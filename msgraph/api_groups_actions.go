/*
Partial Graph API

No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

API version: v1.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package msgraph

import (
	"bytes"
	_context "context"
	_ioutil "io/ioutil"
	_nethttp "net/http"
	_neturl "net/url"
	"strings"
)

// Linger please
var (
	_ _context.Context
)

// GroupsActionsApiService GroupsActionsApi service
type GroupsActionsApiService service

type ApiGroupsGetAvailableExtensionPropertiesRequest struct {
	ctx _context.Context
	ApiService *GroupsActionsApiService
	inlineObject346 *InlineObject346
}

func (r ApiGroupsGetAvailableExtensionPropertiesRequest) InlineObject346(inlineObject346 InlineObject346) ApiGroupsGetAvailableExtensionPropertiesRequest {
	r.inlineObject346 = &inlineObject346
	return r
}

func (r ApiGroupsGetAvailableExtensionPropertiesRequest) Execute() ([]MicrosoftGraphExtensionProperty, *_nethttp.Response, error) {
	return r.ApiService.GroupsGetAvailableExtensionPropertiesExecute(r)
}

/*
GroupsGetAvailableExtensionProperties Invoke action getAvailableExtensionProperties

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGroupsGetAvailableExtensionPropertiesRequest
*/
func (a *GroupsActionsApiService) GroupsGetAvailableExtensionProperties(ctx _context.Context) ApiGroupsGetAvailableExtensionPropertiesRequest {
	return ApiGroupsGetAvailableExtensionPropertiesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []MicrosoftGraphExtensionProperty
func (a *GroupsActionsApiService) GroupsGetAvailableExtensionPropertiesExecute(r ApiGroupsGetAvailableExtensionPropertiesRequest) ([]MicrosoftGraphExtensionProperty, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  []MicrosoftGraphExtensionProperty
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GroupsActionsApiService.GroupsGetAvailableExtensionProperties")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/groups/microsoft.graph.getAvailableExtensionProperties"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject346 == nil {
		return localVarReturnValue, nil, reportError("inlineObject346 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject346
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGroupsGetByIdsRequest struct {
	ctx _context.Context
	ApiService *GroupsActionsApiService
	inlineObject347 *InlineObject347
}

func (r ApiGroupsGetByIdsRequest) InlineObject347(inlineObject347 InlineObject347) ApiGroupsGetByIdsRequest {
	r.inlineObject347 = &inlineObject347
	return r
}

func (r ApiGroupsGetByIdsRequest) Execute() ([]MicrosoftGraphDirectoryObject, *_nethttp.Response, error) {
	return r.ApiService.GroupsGetByIdsExecute(r)
}

/*
GroupsGetByIds Invoke action getByIds

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGroupsGetByIdsRequest
*/
func (a *GroupsActionsApiService) GroupsGetByIds(ctx _context.Context) ApiGroupsGetByIdsRequest {
	return ApiGroupsGetByIdsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []MicrosoftGraphDirectoryObject
func (a *GroupsActionsApiService) GroupsGetByIdsExecute(r ApiGroupsGetByIdsRequest) ([]MicrosoftGraphDirectoryObject, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  []MicrosoftGraphDirectoryObject
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GroupsActionsApiService.GroupsGetByIds")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/groups/microsoft.graph.getByIds"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject347 == nil {
		return localVarReturnValue, nil, reportError("inlineObject347 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject347
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGroupsGroupAddFavoriteRequest struct {
	ctx _context.Context
	ApiService *GroupsActionsApiService
	groupId string
}


func (r ApiGroupsGroupAddFavoriteRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.GroupsGroupAddFavoriteExecute(r)
}

/*
GroupsGroupAddFavorite Invoke action addFavorite

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupId key: id of group
 @return ApiGroupsGroupAddFavoriteRequest
*/
func (a *GroupsActionsApiService) GroupsGroupAddFavorite(ctx _context.Context, groupId string) ApiGroupsGroupAddFavoriteRequest {
	return ApiGroupsGroupAddFavoriteRequest{
		ApiService: a,
		ctx: ctx,
		groupId: groupId,
	}
}

// Execute executes the request
func (a *GroupsActionsApiService) GroupsGroupAddFavoriteExecute(r ApiGroupsGroupAddFavoriteRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GroupsActionsApiService.GroupsGroupAddFavorite")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/groups/{group-id}/microsoft.graph.addFavorite"
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGroupsGroupAssignLicenseRequest struct {
	ctx _context.Context
	ApiService *GroupsActionsApiService
	groupId string
	inlineObject236 *InlineObject236
}

func (r ApiGroupsGroupAssignLicenseRequest) InlineObject236(inlineObject236 InlineObject236) ApiGroupsGroupAssignLicenseRequest {
	r.inlineObject236 = &inlineObject236
	return r
}

func (r ApiGroupsGroupAssignLicenseRequest) Execute() (AnyOfmicrosoftGraphGroup, *_nethttp.Response, error) {
	return r.ApiService.GroupsGroupAssignLicenseExecute(r)
}

/*
GroupsGroupAssignLicense Invoke action assignLicense

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupId key: id of group
 @return ApiGroupsGroupAssignLicenseRequest
*/
func (a *GroupsActionsApiService) GroupsGroupAssignLicense(ctx _context.Context, groupId string) ApiGroupsGroupAssignLicenseRequest {
	return ApiGroupsGroupAssignLicenseRequest{
		ApiService: a,
		ctx: ctx,
		groupId: groupId,
	}
}

// Execute executes the request
//  @return AnyOfmicrosoftGraphGroup
func (a *GroupsActionsApiService) GroupsGroupAssignLicenseExecute(r ApiGroupsGroupAssignLicenseRequest) (AnyOfmicrosoftGraphGroup, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  AnyOfmicrosoftGraphGroup
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GroupsActionsApiService.GroupsGroupAssignLicense")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/groups/{group-id}/microsoft.graph.assignLicense"
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject236 == nil {
		return localVarReturnValue, nil, reportError("inlineObject236 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject236
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGroupsGroupCalendarCalendarViewEventAcceptRequest struct {
	ctx _context.Context
	ApiService *GroupsActionsApiService
	groupId string
	eventId string
	inlineObject157 *InlineObject157
}

func (r ApiGroupsGroupCalendarCalendarViewEventAcceptRequest) InlineObject157(inlineObject157 InlineObject157) ApiGroupsGroupCalendarCalendarViewEventAcceptRequest {
	r.inlineObject157 = &inlineObject157
	return r
}

func (r ApiGroupsGroupCalendarCalendarViewEventAcceptRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.GroupsGroupCalendarCalendarViewEventAcceptExecute(r)
}

/*
GroupsGroupCalendarCalendarViewEventAccept Invoke action accept

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupId key: id of group
 @param eventId key: id of event
 @return ApiGroupsGroupCalendarCalendarViewEventAcceptRequest
*/
func (a *GroupsActionsApiService) GroupsGroupCalendarCalendarViewEventAccept(ctx _context.Context, groupId string, eventId string) ApiGroupsGroupCalendarCalendarViewEventAcceptRequest {
	return ApiGroupsGroupCalendarCalendarViewEventAcceptRequest{
		ApiService: a,
		ctx: ctx,
		groupId: groupId,
		eventId: eventId,
	}
}

// Execute executes the request
func (a *GroupsActionsApiService) GroupsGroupCalendarCalendarViewEventAcceptExecute(r ApiGroupsGroupCalendarCalendarViewEventAcceptRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GroupsActionsApiService.GroupsGroupCalendarCalendarViewEventAccept")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/groups/{group-id}/calendar/calendarView/{event-id}/microsoft.graph.accept"
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject157 == nil {
		return nil, reportError("inlineObject157 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject157
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGroupsGroupCalendarCalendarViewEventAttachmentsCreateUploadSessionRequest struct {
	ctx _context.Context
	ApiService *GroupsActionsApiService
	groupId string
	eventId string
	inlineObject149 *InlineObject149
}

func (r ApiGroupsGroupCalendarCalendarViewEventAttachmentsCreateUploadSessionRequest) InlineObject149(inlineObject149 InlineObject149) ApiGroupsGroupCalendarCalendarViewEventAttachmentsCreateUploadSessionRequest {
	r.inlineObject149 = &inlineObject149
	return r
}

func (r ApiGroupsGroupCalendarCalendarViewEventAttachmentsCreateUploadSessionRequest) Execute() (AnyOfmicrosoftGraphUploadSession, *_nethttp.Response, error) {
	return r.ApiService.GroupsGroupCalendarCalendarViewEventAttachmentsCreateUploadSessionExecute(r)
}

/*
GroupsGroupCalendarCalendarViewEventAttachmentsCreateUploadSession Invoke action createUploadSession

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupId key: id of group
 @param eventId key: id of event
 @return ApiGroupsGroupCalendarCalendarViewEventAttachmentsCreateUploadSessionRequest
*/
func (a *GroupsActionsApiService) GroupsGroupCalendarCalendarViewEventAttachmentsCreateUploadSession(ctx _context.Context, groupId string, eventId string) ApiGroupsGroupCalendarCalendarViewEventAttachmentsCreateUploadSessionRequest {
	return ApiGroupsGroupCalendarCalendarViewEventAttachmentsCreateUploadSessionRequest{
		ApiService: a,
		ctx: ctx,
		groupId: groupId,
		eventId: eventId,
	}
}

// Execute executes the request
//  @return AnyOfmicrosoftGraphUploadSession
func (a *GroupsActionsApiService) GroupsGroupCalendarCalendarViewEventAttachmentsCreateUploadSessionExecute(r ApiGroupsGroupCalendarCalendarViewEventAttachmentsCreateUploadSessionRequest) (AnyOfmicrosoftGraphUploadSession, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  AnyOfmicrosoftGraphUploadSession
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GroupsActionsApiService.GroupsGroupCalendarCalendarViewEventAttachmentsCreateUploadSession")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/groups/{group-id}/calendar/calendarView/{event-id}/attachments/microsoft.graph.createUploadSession"
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject149 == nil {
		return localVarReturnValue, nil, reportError("inlineObject149 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject149
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGroupsGroupCalendarCalendarViewEventCalendarGetScheduleRequest struct {
	ctx _context.Context
	ApiService *GroupsActionsApiService
	groupId string
	eventId string
	inlineObject150 *InlineObject150
}

func (r ApiGroupsGroupCalendarCalendarViewEventCalendarGetScheduleRequest) InlineObject150(inlineObject150 InlineObject150) ApiGroupsGroupCalendarCalendarViewEventCalendarGetScheduleRequest {
	r.inlineObject150 = &inlineObject150
	return r
}

func (r ApiGroupsGroupCalendarCalendarViewEventCalendarGetScheduleRequest) Execute() ([]*AnyOfmicrosoftGraphScheduleInformation, *_nethttp.Response, error) {
	return r.ApiService.GroupsGroupCalendarCalendarViewEventCalendarGetScheduleExecute(r)
}

/*
GroupsGroupCalendarCalendarViewEventCalendarGetSchedule Invoke action getSchedule

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupId key: id of group
 @param eventId key: id of event
 @return ApiGroupsGroupCalendarCalendarViewEventCalendarGetScheduleRequest
*/
func (a *GroupsActionsApiService) GroupsGroupCalendarCalendarViewEventCalendarGetSchedule(ctx _context.Context, groupId string, eventId string) ApiGroupsGroupCalendarCalendarViewEventCalendarGetScheduleRequest {
	return ApiGroupsGroupCalendarCalendarViewEventCalendarGetScheduleRequest{
		ApiService: a,
		ctx: ctx,
		groupId: groupId,
		eventId: eventId,
	}
}

// Execute executes the request
//  @return []*AnyOfmicrosoftGraphScheduleInformation
func (a *GroupsActionsApiService) GroupsGroupCalendarCalendarViewEventCalendarGetScheduleExecute(r ApiGroupsGroupCalendarCalendarViewEventCalendarGetScheduleRequest) ([]*AnyOfmicrosoftGraphScheduleInformation, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  []*AnyOfmicrosoftGraphScheduleInformation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GroupsActionsApiService.GroupsGroupCalendarCalendarViewEventCalendarGetSchedule")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/groups/{group-id}/calendar/calendarView/{event-id}/calendar/microsoft.graph.getSchedule"
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject150 == nil {
		return localVarReturnValue, nil, reportError("inlineObject150 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject150
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGroupsGroupCalendarCalendarViewEventCancelRequest struct {
	ctx _context.Context
	ApiService *GroupsActionsApiService
	groupId string
	eventId string
	inlineObject158 *InlineObject158
}

func (r ApiGroupsGroupCalendarCalendarViewEventCancelRequest) InlineObject158(inlineObject158 InlineObject158) ApiGroupsGroupCalendarCalendarViewEventCancelRequest {
	r.inlineObject158 = &inlineObject158
	return r
}

func (r ApiGroupsGroupCalendarCalendarViewEventCancelRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.GroupsGroupCalendarCalendarViewEventCancelExecute(r)
}

/*
GroupsGroupCalendarCalendarViewEventCancel Invoke action cancel

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupId key: id of group
 @param eventId key: id of event
 @return ApiGroupsGroupCalendarCalendarViewEventCancelRequest
*/
func (a *GroupsActionsApiService) GroupsGroupCalendarCalendarViewEventCancel(ctx _context.Context, groupId string, eventId string) ApiGroupsGroupCalendarCalendarViewEventCancelRequest {
	return ApiGroupsGroupCalendarCalendarViewEventCancelRequest{
		ApiService: a,
		ctx: ctx,
		groupId: groupId,
		eventId: eventId,
	}
}

// Execute executes the request
func (a *GroupsActionsApiService) GroupsGroupCalendarCalendarViewEventCancelExecute(r ApiGroupsGroupCalendarCalendarViewEventCancelRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GroupsActionsApiService.GroupsGroupCalendarCalendarViewEventCancel")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/groups/{group-id}/calendar/calendarView/{event-id}/microsoft.graph.cancel"
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject158 == nil {
		return nil, reportError("inlineObject158 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject158
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGroupsGroupCalendarCalendarViewEventDeclineRequest struct {
	ctx _context.Context
	ApiService *GroupsActionsApiService
	groupId string
	eventId string
	inlineObject159 *InlineObject159
}

func (r ApiGroupsGroupCalendarCalendarViewEventDeclineRequest) InlineObject159(inlineObject159 InlineObject159) ApiGroupsGroupCalendarCalendarViewEventDeclineRequest {
	r.inlineObject159 = &inlineObject159
	return r
}

func (r ApiGroupsGroupCalendarCalendarViewEventDeclineRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.GroupsGroupCalendarCalendarViewEventDeclineExecute(r)
}

/*
GroupsGroupCalendarCalendarViewEventDecline Invoke action decline

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupId key: id of group
 @param eventId key: id of event
 @return ApiGroupsGroupCalendarCalendarViewEventDeclineRequest
*/
func (a *GroupsActionsApiService) GroupsGroupCalendarCalendarViewEventDecline(ctx _context.Context, groupId string, eventId string) ApiGroupsGroupCalendarCalendarViewEventDeclineRequest {
	return ApiGroupsGroupCalendarCalendarViewEventDeclineRequest{
		ApiService: a,
		ctx: ctx,
		groupId: groupId,
		eventId: eventId,
	}
}

// Execute executes the request
func (a *GroupsActionsApiService) GroupsGroupCalendarCalendarViewEventDeclineExecute(r ApiGroupsGroupCalendarCalendarViewEventDeclineRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GroupsActionsApiService.GroupsGroupCalendarCalendarViewEventDecline")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/groups/{group-id}/calendar/calendarView/{event-id}/microsoft.graph.decline"
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject159 == nil {
		return nil, reportError("inlineObject159 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject159
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGroupsGroupCalendarCalendarViewEventDismissReminderRequest struct {
	ctx _context.Context
	ApiService *GroupsActionsApiService
	groupId string
	eventId string
}


func (r ApiGroupsGroupCalendarCalendarViewEventDismissReminderRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.GroupsGroupCalendarCalendarViewEventDismissReminderExecute(r)
}

/*
GroupsGroupCalendarCalendarViewEventDismissReminder Invoke action dismissReminder

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupId key: id of group
 @param eventId key: id of event
 @return ApiGroupsGroupCalendarCalendarViewEventDismissReminderRequest
*/
func (a *GroupsActionsApiService) GroupsGroupCalendarCalendarViewEventDismissReminder(ctx _context.Context, groupId string, eventId string) ApiGroupsGroupCalendarCalendarViewEventDismissReminderRequest {
	return ApiGroupsGroupCalendarCalendarViewEventDismissReminderRequest{
		ApiService: a,
		ctx: ctx,
		groupId: groupId,
		eventId: eventId,
	}
}

// Execute executes the request
func (a *GroupsActionsApiService) GroupsGroupCalendarCalendarViewEventDismissReminderExecute(r ApiGroupsGroupCalendarCalendarViewEventDismissReminderRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GroupsActionsApiService.GroupsGroupCalendarCalendarViewEventDismissReminder")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/groups/{group-id}/calendar/calendarView/{event-id}/microsoft.graph.dismissReminder"
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGroupsGroupCalendarCalendarViewEventForwardRequest struct {
	ctx _context.Context
	ApiService *GroupsActionsApiService
	groupId string
	eventId string
	inlineObject160 *InlineObject160
}

func (r ApiGroupsGroupCalendarCalendarViewEventForwardRequest) InlineObject160(inlineObject160 InlineObject160) ApiGroupsGroupCalendarCalendarViewEventForwardRequest {
	r.inlineObject160 = &inlineObject160
	return r
}

func (r ApiGroupsGroupCalendarCalendarViewEventForwardRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.GroupsGroupCalendarCalendarViewEventForwardExecute(r)
}

/*
GroupsGroupCalendarCalendarViewEventForward Invoke action forward

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupId key: id of group
 @param eventId key: id of event
 @return ApiGroupsGroupCalendarCalendarViewEventForwardRequest
*/
func (a *GroupsActionsApiService) GroupsGroupCalendarCalendarViewEventForward(ctx _context.Context, groupId string, eventId string) ApiGroupsGroupCalendarCalendarViewEventForwardRequest {
	return ApiGroupsGroupCalendarCalendarViewEventForwardRequest{
		ApiService: a,
		ctx: ctx,
		groupId: groupId,
		eventId: eventId,
	}
}

// Execute executes the request
func (a *GroupsActionsApiService) GroupsGroupCalendarCalendarViewEventForwardExecute(r ApiGroupsGroupCalendarCalendarViewEventForwardRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GroupsActionsApiService.GroupsGroupCalendarCalendarViewEventForward")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/groups/{group-id}/calendar/calendarView/{event-id}/microsoft.graph.forward"
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject160 == nil {
		return nil, reportError("inlineObject160 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject160
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGroupsGroupCalendarCalendarViewEventInstancesEventAcceptRequest struct {
	ctx _context.Context
	ApiService *GroupsActionsApiService
	groupId string
	eventId string
	eventId1 string
	inlineObject151 *InlineObject151
}

func (r ApiGroupsGroupCalendarCalendarViewEventInstancesEventAcceptRequest) InlineObject151(inlineObject151 InlineObject151) ApiGroupsGroupCalendarCalendarViewEventInstancesEventAcceptRequest {
	r.inlineObject151 = &inlineObject151
	return r
}

func (r ApiGroupsGroupCalendarCalendarViewEventInstancesEventAcceptRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.GroupsGroupCalendarCalendarViewEventInstancesEventAcceptExecute(r)
}

/*
GroupsGroupCalendarCalendarViewEventInstancesEventAccept Invoke action accept

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupId key: id of group
 @param eventId key: id of event
 @param eventId1 key: id of event
 @return ApiGroupsGroupCalendarCalendarViewEventInstancesEventAcceptRequest
*/
func (a *GroupsActionsApiService) GroupsGroupCalendarCalendarViewEventInstancesEventAccept(ctx _context.Context, groupId string, eventId string, eventId1 string) ApiGroupsGroupCalendarCalendarViewEventInstancesEventAcceptRequest {
	return ApiGroupsGroupCalendarCalendarViewEventInstancesEventAcceptRequest{
		ApiService: a,
		ctx: ctx,
		groupId: groupId,
		eventId: eventId,
		eventId1: eventId1,
	}
}

// Execute executes the request
func (a *GroupsActionsApiService) GroupsGroupCalendarCalendarViewEventInstancesEventAcceptExecute(r ApiGroupsGroupCalendarCalendarViewEventInstancesEventAcceptRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GroupsActionsApiService.GroupsGroupCalendarCalendarViewEventInstancesEventAccept")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/groups/{group-id}/calendar/calendarView/{event-id}/instances/{event-id1}/microsoft.graph.accept"
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id1"+"}", _neturl.PathEscape(parameterToString(r.eventId1, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject151 == nil {
		return nil, reportError("inlineObject151 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject151
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGroupsGroupCalendarCalendarViewEventInstancesEventCancelRequest struct {
	ctx _context.Context
	ApiService *GroupsActionsApiService
	groupId string
	eventId string
	eventId1 string
	inlineObject152 *InlineObject152
}

func (r ApiGroupsGroupCalendarCalendarViewEventInstancesEventCancelRequest) InlineObject152(inlineObject152 InlineObject152) ApiGroupsGroupCalendarCalendarViewEventInstancesEventCancelRequest {
	r.inlineObject152 = &inlineObject152
	return r
}

func (r ApiGroupsGroupCalendarCalendarViewEventInstancesEventCancelRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.GroupsGroupCalendarCalendarViewEventInstancesEventCancelExecute(r)
}

/*
GroupsGroupCalendarCalendarViewEventInstancesEventCancel Invoke action cancel

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupId key: id of group
 @param eventId key: id of event
 @param eventId1 key: id of event
 @return ApiGroupsGroupCalendarCalendarViewEventInstancesEventCancelRequest
*/
func (a *GroupsActionsApiService) GroupsGroupCalendarCalendarViewEventInstancesEventCancel(ctx _context.Context, groupId string, eventId string, eventId1 string) ApiGroupsGroupCalendarCalendarViewEventInstancesEventCancelRequest {
	return ApiGroupsGroupCalendarCalendarViewEventInstancesEventCancelRequest{
		ApiService: a,
		ctx: ctx,
		groupId: groupId,
		eventId: eventId,
		eventId1: eventId1,
	}
}

// Execute executes the request
func (a *GroupsActionsApiService) GroupsGroupCalendarCalendarViewEventInstancesEventCancelExecute(r ApiGroupsGroupCalendarCalendarViewEventInstancesEventCancelRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GroupsActionsApiService.GroupsGroupCalendarCalendarViewEventInstancesEventCancel")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/groups/{group-id}/calendar/calendarView/{event-id}/instances/{event-id1}/microsoft.graph.cancel"
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id1"+"}", _neturl.PathEscape(parameterToString(r.eventId1, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject152 == nil {
		return nil, reportError("inlineObject152 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject152
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGroupsGroupCalendarCalendarViewEventInstancesEventDeclineRequest struct {
	ctx _context.Context
	ApiService *GroupsActionsApiService
	groupId string
	eventId string
	eventId1 string
	inlineObject153 *InlineObject153
}

func (r ApiGroupsGroupCalendarCalendarViewEventInstancesEventDeclineRequest) InlineObject153(inlineObject153 InlineObject153) ApiGroupsGroupCalendarCalendarViewEventInstancesEventDeclineRequest {
	r.inlineObject153 = &inlineObject153
	return r
}

func (r ApiGroupsGroupCalendarCalendarViewEventInstancesEventDeclineRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.GroupsGroupCalendarCalendarViewEventInstancesEventDeclineExecute(r)
}

/*
GroupsGroupCalendarCalendarViewEventInstancesEventDecline Invoke action decline

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupId key: id of group
 @param eventId key: id of event
 @param eventId1 key: id of event
 @return ApiGroupsGroupCalendarCalendarViewEventInstancesEventDeclineRequest
*/
func (a *GroupsActionsApiService) GroupsGroupCalendarCalendarViewEventInstancesEventDecline(ctx _context.Context, groupId string, eventId string, eventId1 string) ApiGroupsGroupCalendarCalendarViewEventInstancesEventDeclineRequest {
	return ApiGroupsGroupCalendarCalendarViewEventInstancesEventDeclineRequest{
		ApiService: a,
		ctx: ctx,
		groupId: groupId,
		eventId: eventId,
		eventId1: eventId1,
	}
}

// Execute executes the request
func (a *GroupsActionsApiService) GroupsGroupCalendarCalendarViewEventInstancesEventDeclineExecute(r ApiGroupsGroupCalendarCalendarViewEventInstancesEventDeclineRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GroupsActionsApiService.GroupsGroupCalendarCalendarViewEventInstancesEventDecline")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/groups/{group-id}/calendar/calendarView/{event-id}/instances/{event-id1}/microsoft.graph.decline"
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id1"+"}", _neturl.PathEscape(parameterToString(r.eventId1, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject153 == nil {
		return nil, reportError("inlineObject153 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject153
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGroupsGroupCalendarCalendarViewEventInstancesEventDismissReminderRequest struct {
	ctx _context.Context
	ApiService *GroupsActionsApiService
	groupId string
	eventId string
	eventId1 string
}


func (r ApiGroupsGroupCalendarCalendarViewEventInstancesEventDismissReminderRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.GroupsGroupCalendarCalendarViewEventInstancesEventDismissReminderExecute(r)
}

/*
GroupsGroupCalendarCalendarViewEventInstancesEventDismissReminder Invoke action dismissReminder

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupId key: id of group
 @param eventId key: id of event
 @param eventId1 key: id of event
 @return ApiGroupsGroupCalendarCalendarViewEventInstancesEventDismissReminderRequest
*/
func (a *GroupsActionsApiService) GroupsGroupCalendarCalendarViewEventInstancesEventDismissReminder(ctx _context.Context, groupId string, eventId string, eventId1 string) ApiGroupsGroupCalendarCalendarViewEventInstancesEventDismissReminderRequest {
	return ApiGroupsGroupCalendarCalendarViewEventInstancesEventDismissReminderRequest{
		ApiService: a,
		ctx: ctx,
		groupId: groupId,
		eventId: eventId,
		eventId1: eventId1,
	}
}

// Execute executes the request
func (a *GroupsActionsApiService) GroupsGroupCalendarCalendarViewEventInstancesEventDismissReminderExecute(r ApiGroupsGroupCalendarCalendarViewEventInstancesEventDismissReminderRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GroupsActionsApiService.GroupsGroupCalendarCalendarViewEventInstancesEventDismissReminder")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/groups/{group-id}/calendar/calendarView/{event-id}/instances/{event-id1}/microsoft.graph.dismissReminder"
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id1"+"}", _neturl.PathEscape(parameterToString(r.eventId1, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGroupsGroupCalendarCalendarViewEventInstancesEventForwardRequest struct {
	ctx _context.Context
	ApiService *GroupsActionsApiService
	groupId string
	eventId string
	eventId1 string
	inlineObject154 *InlineObject154
}

func (r ApiGroupsGroupCalendarCalendarViewEventInstancesEventForwardRequest) InlineObject154(inlineObject154 InlineObject154) ApiGroupsGroupCalendarCalendarViewEventInstancesEventForwardRequest {
	r.inlineObject154 = &inlineObject154
	return r
}

func (r ApiGroupsGroupCalendarCalendarViewEventInstancesEventForwardRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.GroupsGroupCalendarCalendarViewEventInstancesEventForwardExecute(r)
}

/*
GroupsGroupCalendarCalendarViewEventInstancesEventForward Invoke action forward

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupId key: id of group
 @param eventId key: id of event
 @param eventId1 key: id of event
 @return ApiGroupsGroupCalendarCalendarViewEventInstancesEventForwardRequest
*/
func (a *GroupsActionsApiService) GroupsGroupCalendarCalendarViewEventInstancesEventForward(ctx _context.Context, groupId string, eventId string, eventId1 string) ApiGroupsGroupCalendarCalendarViewEventInstancesEventForwardRequest {
	return ApiGroupsGroupCalendarCalendarViewEventInstancesEventForwardRequest{
		ApiService: a,
		ctx: ctx,
		groupId: groupId,
		eventId: eventId,
		eventId1: eventId1,
	}
}

// Execute executes the request
func (a *GroupsActionsApiService) GroupsGroupCalendarCalendarViewEventInstancesEventForwardExecute(r ApiGroupsGroupCalendarCalendarViewEventInstancesEventForwardRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GroupsActionsApiService.GroupsGroupCalendarCalendarViewEventInstancesEventForward")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/groups/{group-id}/calendar/calendarView/{event-id}/instances/{event-id1}/microsoft.graph.forward"
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id1"+"}", _neturl.PathEscape(parameterToString(r.eventId1, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject154 == nil {
		return nil, reportError("inlineObject154 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject154
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGroupsGroupCalendarCalendarViewEventInstancesEventSnoozeReminderRequest struct {
	ctx _context.Context
	ApiService *GroupsActionsApiService
	groupId string
	eventId string
	eventId1 string
	inlineObject155 *InlineObject155
}

func (r ApiGroupsGroupCalendarCalendarViewEventInstancesEventSnoozeReminderRequest) InlineObject155(inlineObject155 InlineObject155) ApiGroupsGroupCalendarCalendarViewEventInstancesEventSnoozeReminderRequest {
	r.inlineObject155 = &inlineObject155
	return r
}

func (r ApiGroupsGroupCalendarCalendarViewEventInstancesEventSnoozeReminderRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.GroupsGroupCalendarCalendarViewEventInstancesEventSnoozeReminderExecute(r)
}

/*
GroupsGroupCalendarCalendarViewEventInstancesEventSnoozeReminder Invoke action snoozeReminder

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupId key: id of group
 @param eventId key: id of event
 @param eventId1 key: id of event
 @return ApiGroupsGroupCalendarCalendarViewEventInstancesEventSnoozeReminderRequest
*/
func (a *GroupsActionsApiService) GroupsGroupCalendarCalendarViewEventInstancesEventSnoozeReminder(ctx _context.Context, groupId string, eventId string, eventId1 string) ApiGroupsGroupCalendarCalendarViewEventInstancesEventSnoozeReminderRequest {
	return ApiGroupsGroupCalendarCalendarViewEventInstancesEventSnoozeReminderRequest{
		ApiService: a,
		ctx: ctx,
		groupId: groupId,
		eventId: eventId,
		eventId1: eventId1,
	}
}

// Execute executes the request
func (a *GroupsActionsApiService) GroupsGroupCalendarCalendarViewEventInstancesEventSnoozeReminderExecute(r ApiGroupsGroupCalendarCalendarViewEventInstancesEventSnoozeReminderRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GroupsActionsApiService.GroupsGroupCalendarCalendarViewEventInstancesEventSnoozeReminder")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/groups/{group-id}/calendar/calendarView/{event-id}/instances/{event-id1}/microsoft.graph.snoozeReminder"
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id1"+"}", _neturl.PathEscape(parameterToString(r.eventId1, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject155 == nil {
		return nil, reportError("inlineObject155 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject155
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGroupsGroupCalendarCalendarViewEventInstancesEventTentativelyAcceptRequest struct {
	ctx _context.Context
	ApiService *GroupsActionsApiService
	groupId string
	eventId string
	eventId1 string
	inlineObject156 *InlineObject156
}

func (r ApiGroupsGroupCalendarCalendarViewEventInstancesEventTentativelyAcceptRequest) InlineObject156(inlineObject156 InlineObject156) ApiGroupsGroupCalendarCalendarViewEventInstancesEventTentativelyAcceptRequest {
	r.inlineObject156 = &inlineObject156
	return r
}

func (r ApiGroupsGroupCalendarCalendarViewEventInstancesEventTentativelyAcceptRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.GroupsGroupCalendarCalendarViewEventInstancesEventTentativelyAcceptExecute(r)
}

/*
GroupsGroupCalendarCalendarViewEventInstancesEventTentativelyAccept Invoke action tentativelyAccept

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupId key: id of group
 @param eventId key: id of event
 @param eventId1 key: id of event
 @return ApiGroupsGroupCalendarCalendarViewEventInstancesEventTentativelyAcceptRequest
*/
func (a *GroupsActionsApiService) GroupsGroupCalendarCalendarViewEventInstancesEventTentativelyAccept(ctx _context.Context, groupId string, eventId string, eventId1 string) ApiGroupsGroupCalendarCalendarViewEventInstancesEventTentativelyAcceptRequest {
	return ApiGroupsGroupCalendarCalendarViewEventInstancesEventTentativelyAcceptRequest{
		ApiService: a,
		ctx: ctx,
		groupId: groupId,
		eventId: eventId,
		eventId1: eventId1,
	}
}

// Execute executes the request
func (a *GroupsActionsApiService) GroupsGroupCalendarCalendarViewEventInstancesEventTentativelyAcceptExecute(r ApiGroupsGroupCalendarCalendarViewEventInstancesEventTentativelyAcceptRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GroupsActionsApiService.GroupsGroupCalendarCalendarViewEventInstancesEventTentativelyAccept")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/groups/{group-id}/calendar/calendarView/{event-id}/instances/{event-id1}/microsoft.graph.tentativelyAccept"
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id1"+"}", _neturl.PathEscape(parameterToString(r.eventId1, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject156 == nil {
		return nil, reportError("inlineObject156 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject156
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGroupsGroupCalendarCalendarViewEventSnoozeReminderRequest struct {
	ctx _context.Context
	ApiService *GroupsActionsApiService
	groupId string
	eventId string
	inlineObject161 *InlineObject161
}

func (r ApiGroupsGroupCalendarCalendarViewEventSnoozeReminderRequest) InlineObject161(inlineObject161 InlineObject161) ApiGroupsGroupCalendarCalendarViewEventSnoozeReminderRequest {
	r.inlineObject161 = &inlineObject161
	return r
}

func (r ApiGroupsGroupCalendarCalendarViewEventSnoozeReminderRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.GroupsGroupCalendarCalendarViewEventSnoozeReminderExecute(r)
}

/*
GroupsGroupCalendarCalendarViewEventSnoozeReminder Invoke action snoozeReminder

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupId key: id of group
 @param eventId key: id of event
 @return ApiGroupsGroupCalendarCalendarViewEventSnoozeReminderRequest
*/
func (a *GroupsActionsApiService) GroupsGroupCalendarCalendarViewEventSnoozeReminder(ctx _context.Context, groupId string, eventId string) ApiGroupsGroupCalendarCalendarViewEventSnoozeReminderRequest {
	return ApiGroupsGroupCalendarCalendarViewEventSnoozeReminderRequest{
		ApiService: a,
		ctx: ctx,
		groupId: groupId,
		eventId: eventId,
	}
}

// Execute executes the request
func (a *GroupsActionsApiService) GroupsGroupCalendarCalendarViewEventSnoozeReminderExecute(r ApiGroupsGroupCalendarCalendarViewEventSnoozeReminderRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GroupsActionsApiService.GroupsGroupCalendarCalendarViewEventSnoozeReminder")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/groups/{group-id}/calendar/calendarView/{event-id}/microsoft.graph.snoozeReminder"
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject161 == nil {
		return nil, reportError("inlineObject161 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject161
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGroupsGroupCalendarCalendarViewEventTentativelyAcceptRequest struct {
	ctx _context.Context
	ApiService *GroupsActionsApiService
	groupId string
	eventId string
	inlineObject162 *InlineObject162
}

func (r ApiGroupsGroupCalendarCalendarViewEventTentativelyAcceptRequest) InlineObject162(inlineObject162 InlineObject162) ApiGroupsGroupCalendarCalendarViewEventTentativelyAcceptRequest {
	r.inlineObject162 = &inlineObject162
	return r
}

func (r ApiGroupsGroupCalendarCalendarViewEventTentativelyAcceptRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.GroupsGroupCalendarCalendarViewEventTentativelyAcceptExecute(r)
}

/*
GroupsGroupCalendarCalendarViewEventTentativelyAccept Invoke action tentativelyAccept

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupId key: id of group
 @param eventId key: id of event
 @return ApiGroupsGroupCalendarCalendarViewEventTentativelyAcceptRequest
*/
func (a *GroupsActionsApiService) GroupsGroupCalendarCalendarViewEventTentativelyAccept(ctx _context.Context, groupId string, eventId string) ApiGroupsGroupCalendarCalendarViewEventTentativelyAcceptRequest {
	return ApiGroupsGroupCalendarCalendarViewEventTentativelyAcceptRequest{
		ApiService: a,
		ctx: ctx,
		groupId: groupId,
		eventId: eventId,
	}
}

// Execute executes the request
func (a *GroupsActionsApiService) GroupsGroupCalendarCalendarViewEventTentativelyAcceptExecute(r ApiGroupsGroupCalendarCalendarViewEventTentativelyAcceptRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GroupsActionsApiService.GroupsGroupCalendarCalendarViewEventTentativelyAccept")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/groups/{group-id}/calendar/calendarView/{event-id}/microsoft.graph.tentativelyAccept"
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject162 == nil {
		return nil, reportError("inlineObject162 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject162
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGroupsGroupCalendarEventsEventAcceptRequest struct {
	ctx _context.Context
	ApiService *GroupsActionsApiService
	groupId string
	eventId string
	inlineObject171 *InlineObject171
}

func (r ApiGroupsGroupCalendarEventsEventAcceptRequest) InlineObject171(inlineObject171 InlineObject171) ApiGroupsGroupCalendarEventsEventAcceptRequest {
	r.inlineObject171 = &inlineObject171
	return r
}

func (r ApiGroupsGroupCalendarEventsEventAcceptRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.GroupsGroupCalendarEventsEventAcceptExecute(r)
}

/*
GroupsGroupCalendarEventsEventAccept Invoke action accept

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupId key: id of group
 @param eventId key: id of event
 @return ApiGroupsGroupCalendarEventsEventAcceptRequest
*/
func (a *GroupsActionsApiService) GroupsGroupCalendarEventsEventAccept(ctx _context.Context, groupId string, eventId string) ApiGroupsGroupCalendarEventsEventAcceptRequest {
	return ApiGroupsGroupCalendarEventsEventAcceptRequest{
		ApiService: a,
		ctx: ctx,
		groupId: groupId,
		eventId: eventId,
	}
}

// Execute executes the request
func (a *GroupsActionsApiService) GroupsGroupCalendarEventsEventAcceptExecute(r ApiGroupsGroupCalendarEventsEventAcceptRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GroupsActionsApiService.GroupsGroupCalendarEventsEventAccept")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/groups/{group-id}/calendar/events/{event-id}/microsoft.graph.accept"
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject171 == nil {
		return nil, reportError("inlineObject171 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject171
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGroupsGroupCalendarEventsEventAttachmentsCreateUploadSessionRequest struct {
	ctx _context.Context
	ApiService *GroupsActionsApiService
	groupId string
	eventId string
	inlineObject163 *InlineObject163
}

func (r ApiGroupsGroupCalendarEventsEventAttachmentsCreateUploadSessionRequest) InlineObject163(inlineObject163 InlineObject163) ApiGroupsGroupCalendarEventsEventAttachmentsCreateUploadSessionRequest {
	r.inlineObject163 = &inlineObject163
	return r
}

func (r ApiGroupsGroupCalendarEventsEventAttachmentsCreateUploadSessionRequest) Execute() (AnyOfmicrosoftGraphUploadSession, *_nethttp.Response, error) {
	return r.ApiService.GroupsGroupCalendarEventsEventAttachmentsCreateUploadSessionExecute(r)
}

/*
GroupsGroupCalendarEventsEventAttachmentsCreateUploadSession Invoke action createUploadSession

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupId key: id of group
 @param eventId key: id of event
 @return ApiGroupsGroupCalendarEventsEventAttachmentsCreateUploadSessionRequest
*/
func (a *GroupsActionsApiService) GroupsGroupCalendarEventsEventAttachmentsCreateUploadSession(ctx _context.Context, groupId string, eventId string) ApiGroupsGroupCalendarEventsEventAttachmentsCreateUploadSessionRequest {
	return ApiGroupsGroupCalendarEventsEventAttachmentsCreateUploadSessionRequest{
		ApiService: a,
		ctx: ctx,
		groupId: groupId,
		eventId: eventId,
	}
}

// Execute executes the request
//  @return AnyOfmicrosoftGraphUploadSession
func (a *GroupsActionsApiService) GroupsGroupCalendarEventsEventAttachmentsCreateUploadSessionExecute(r ApiGroupsGroupCalendarEventsEventAttachmentsCreateUploadSessionRequest) (AnyOfmicrosoftGraphUploadSession, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  AnyOfmicrosoftGraphUploadSession
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GroupsActionsApiService.GroupsGroupCalendarEventsEventAttachmentsCreateUploadSession")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/groups/{group-id}/calendar/events/{event-id}/attachments/microsoft.graph.createUploadSession"
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject163 == nil {
		return localVarReturnValue, nil, reportError("inlineObject163 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject163
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGroupsGroupCalendarEventsEventCalendarGetScheduleRequest struct {
	ctx _context.Context
	ApiService *GroupsActionsApiService
	groupId string
	eventId string
	inlineObject164 *InlineObject164
}

func (r ApiGroupsGroupCalendarEventsEventCalendarGetScheduleRequest) InlineObject164(inlineObject164 InlineObject164) ApiGroupsGroupCalendarEventsEventCalendarGetScheduleRequest {
	r.inlineObject164 = &inlineObject164
	return r
}

func (r ApiGroupsGroupCalendarEventsEventCalendarGetScheduleRequest) Execute() ([]*AnyOfmicrosoftGraphScheduleInformation, *_nethttp.Response, error) {
	return r.ApiService.GroupsGroupCalendarEventsEventCalendarGetScheduleExecute(r)
}

/*
GroupsGroupCalendarEventsEventCalendarGetSchedule Invoke action getSchedule

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupId key: id of group
 @param eventId key: id of event
 @return ApiGroupsGroupCalendarEventsEventCalendarGetScheduleRequest
*/
func (a *GroupsActionsApiService) GroupsGroupCalendarEventsEventCalendarGetSchedule(ctx _context.Context, groupId string, eventId string) ApiGroupsGroupCalendarEventsEventCalendarGetScheduleRequest {
	return ApiGroupsGroupCalendarEventsEventCalendarGetScheduleRequest{
		ApiService: a,
		ctx: ctx,
		groupId: groupId,
		eventId: eventId,
	}
}

// Execute executes the request
//  @return []*AnyOfmicrosoftGraphScheduleInformation
func (a *GroupsActionsApiService) GroupsGroupCalendarEventsEventCalendarGetScheduleExecute(r ApiGroupsGroupCalendarEventsEventCalendarGetScheduleRequest) ([]*AnyOfmicrosoftGraphScheduleInformation, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  []*AnyOfmicrosoftGraphScheduleInformation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GroupsActionsApiService.GroupsGroupCalendarEventsEventCalendarGetSchedule")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/groups/{group-id}/calendar/events/{event-id}/calendar/microsoft.graph.getSchedule"
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject164 == nil {
		return localVarReturnValue, nil, reportError("inlineObject164 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject164
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGroupsGroupCalendarEventsEventCancelRequest struct {
	ctx _context.Context
	ApiService *GroupsActionsApiService
	groupId string
	eventId string
	inlineObject172 *InlineObject172
}

func (r ApiGroupsGroupCalendarEventsEventCancelRequest) InlineObject172(inlineObject172 InlineObject172) ApiGroupsGroupCalendarEventsEventCancelRequest {
	r.inlineObject172 = &inlineObject172
	return r
}

func (r ApiGroupsGroupCalendarEventsEventCancelRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.GroupsGroupCalendarEventsEventCancelExecute(r)
}

/*
GroupsGroupCalendarEventsEventCancel Invoke action cancel

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupId key: id of group
 @param eventId key: id of event
 @return ApiGroupsGroupCalendarEventsEventCancelRequest
*/
func (a *GroupsActionsApiService) GroupsGroupCalendarEventsEventCancel(ctx _context.Context, groupId string, eventId string) ApiGroupsGroupCalendarEventsEventCancelRequest {
	return ApiGroupsGroupCalendarEventsEventCancelRequest{
		ApiService: a,
		ctx: ctx,
		groupId: groupId,
		eventId: eventId,
	}
}

// Execute executes the request
func (a *GroupsActionsApiService) GroupsGroupCalendarEventsEventCancelExecute(r ApiGroupsGroupCalendarEventsEventCancelRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GroupsActionsApiService.GroupsGroupCalendarEventsEventCancel")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/groups/{group-id}/calendar/events/{event-id}/microsoft.graph.cancel"
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject172 == nil {
		return nil, reportError("inlineObject172 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject172
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGroupsGroupCalendarEventsEventDeclineRequest struct {
	ctx _context.Context
	ApiService *GroupsActionsApiService
	groupId string
	eventId string
	inlineObject173 *InlineObject173
}

func (r ApiGroupsGroupCalendarEventsEventDeclineRequest) InlineObject173(inlineObject173 InlineObject173) ApiGroupsGroupCalendarEventsEventDeclineRequest {
	r.inlineObject173 = &inlineObject173
	return r
}

func (r ApiGroupsGroupCalendarEventsEventDeclineRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.GroupsGroupCalendarEventsEventDeclineExecute(r)
}

/*
GroupsGroupCalendarEventsEventDecline Invoke action decline

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupId key: id of group
 @param eventId key: id of event
 @return ApiGroupsGroupCalendarEventsEventDeclineRequest
*/
func (a *GroupsActionsApiService) GroupsGroupCalendarEventsEventDecline(ctx _context.Context, groupId string, eventId string) ApiGroupsGroupCalendarEventsEventDeclineRequest {
	return ApiGroupsGroupCalendarEventsEventDeclineRequest{
		ApiService: a,
		ctx: ctx,
		groupId: groupId,
		eventId: eventId,
	}
}

// Execute executes the request
func (a *GroupsActionsApiService) GroupsGroupCalendarEventsEventDeclineExecute(r ApiGroupsGroupCalendarEventsEventDeclineRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GroupsActionsApiService.GroupsGroupCalendarEventsEventDecline")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/groups/{group-id}/calendar/events/{event-id}/microsoft.graph.decline"
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject173 == nil {
		return nil, reportError("inlineObject173 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject173
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGroupsGroupCalendarEventsEventDismissReminderRequest struct {
	ctx _context.Context
	ApiService *GroupsActionsApiService
	groupId string
	eventId string
}


func (r ApiGroupsGroupCalendarEventsEventDismissReminderRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.GroupsGroupCalendarEventsEventDismissReminderExecute(r)
}

/*
GroupsGroupCalendarEventsEventDismissReminder Invoke action dismissReminder

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupId key: id of group
 @param eventId key: id of event
 @return ApiGroupsGroupCalendarEventsEventDismissReminderRequest
*/
func (a *GroupsActionsApiService) GroupsGroupCalendarEventsEventDismissReminder(ctx _context.Context, groupId string, eventId string) ApiGroupsGroupCalendarEventsEventDismissReminderRequest {
	return ApiGroupsGroupCalendarEventsEventDismissReminderRequest{
		ApiService: a,
		ctx: ctx,
		groupId: groupId,
		eventId: eventId,
	}
}

// Execute executes the request
func (a *GroupsActionsApiService) GroupsGroupCalendarEventsEventDismissReminderExecute(r ApiGroupsGroupCalendarEventsEventDismissReminderRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GroupsActionsApiService.GroupsGroupCalendarEventsEventDismissReminder")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/groups/{group-id}/calendar/events/{event-id}/microsoft.graph.dismissReminder"
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGroupsGroupCalendarEventsEventForwardRequest struct {
	ctx _context.Context
	ApiService *GroupsActionsApiService
	groupId string
	eventId string
	inlineObject174 *InlineObject174
}

func (r ApiGroupsGroupCalendarEventsEventForwardRequest) InlineObject174(inlineObject174 InlineObject174) ApiGroupsGroupCalendarEventsEventForwardRequest {
	r.inlineObject174 = &inlineObject174
	return r
}

func (r ApiGroupsGroupCalendarEventsEventForwardRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.GroupsGroupCalendarEventsEventForwardExecute(r)
}

/*
GroupsGroupCalendarEventsEventForward Invoke action forward

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupId key: id of group
 @param eventId key: id of event
 @return ApiGroupsGroupCalendarEventsEventForwardRequest
*/
func (a *GroupsActionsApiService) GroupsGroupCalendarEventsEventForward(ctx _context.Context, groupId string, eventId string) ApiGroupsGroupCalendarEventsEventForwardRequest {
	return ApiGroupsGroupCalendarEventsEventForwardRequest{
		ApiService: a,
		ctx: ctx,
		groupId: groupId,
		eventId: eventId,
	}
}

// Execute executes the request
func (a *GroupsActionsApiService) GroupsGroupCalendarEventsEventForwardExecute(r ApiGroupsGroupCalendarEventsEventForwardRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GroupsActionsApiService.GroupsGroupCalendarEventsEventForward")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/groups/{group-id}/calendar/events/{event-id}/microsoft.graph.forward"
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject174 == nil {
		return nil, reportError("inlineObject174 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject174
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGroupsGroupCalendarEventsEventInstancesEventAcceptRequest struct {
	ctx _context.Context
	ApiService *GroupsActionsApiService
	groupId string
	eventId string
	eventId1 string
	inlineObject165 *InlineObject165
}

func (r ApiGroupsGroupCalendarEventsEventInstancesEventAcceptRequest) InlineObject165(inlineObject165 InlineObject165) ApiGroupsGroupCalendarEventsEventInstancesEventAcceptRequest {
	r.inlineObject165 = &inlineObject165
	return r
}

func (r ApiGroupsGroupCalendarEventsEventInstancesEventAcceptRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.GroupsGroupCalendarEventsEventInstancesEventAcceptExecute(r)
}

/*
GroupsGroupCalendarEventsEventInstancesEventAccept Invoke action accept

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupId key: id of group
 @param eventId key: id of event
 @param eventId1 key: id of event
 @return ApiGroupsGroupCalendarEventsEventInstancesEventAcceptRequest
*/
func (a *GroupsActionsApiService) GroupsGroupCalendarEventsEventInstancesEventAccept(ctx _context.Context, groupId string, eventId string, eventId1 string) ApiGroupsGroupCalendarEventsEventInstancesEventAcceptRequest {
	return ApiGroupsGroupCalendarEventsEventInstancesEventAcceptRequest{
		ApiService: a,
		ctx: ctx,
		groupId: groupId,
		eventId: eventId,
		eventId1: eventId1,
	}
}

// Execute executes the request
func (a *GroupsActionsApiService) GroupsGroupCalendarEventsEventInstancesEventAcceptExecute(r ApiGroupsGroupCalendarEventsEventInstancesEventAcceptRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GroupsActionsApiService.GroupsGroupCalendarEventsEventInstancesEventAccept")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/groups/{group-id}/calendar/events/{event-id}/instances/{event-id1}/microsoft.graph.accept"
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id1"+"}", _neturl.PathEscape(parameterToString(r.eventId1, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject165 == nil {
		return nil, reportError("inlineObject165 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject165
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGroupsGroupCalendarEventsEventInstancesEventCancelRequest struct {
	ctx _context.Context
	ApiService *GroupsActionsApiService
	groupId string
	eventId string
	eventId1 string
	inlineObject166 *InlineObject166
}

func (r ApiGroupsGroupCalendarEventsEventInstancesEventCancelRequest) InlineObject166(inlineObject166 InlineObject166) ApiGroupsGroupCalendarEventsEventInstancesEventCancelRequest {
	r.inlineObject166 = &inlineObject166
	return r
}

func (r ApiGroupsGroupCalendarEventsEventInstancesEventCancelRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.GroupsGroupCalendarEventsEventInstancesEventCancelExecute(r)
}

/*
GroupsGroupCalendarEventsEventInstancesEventCancel Invoke action cancel

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupId key: id of group
 @param eventId key: id of event
 @param eventId1 key: id of event
 @return ApiGroupsGroupCalendarEventsEventInstancesEventCancelRequest
*/
func (a *GroupsActionsApiService) GroupsGroupCalendarEventsEventInstancesEventCancel(ctx _context.Context, groupId string, eventId string, eventId1 string) ApiGroupsGroupCalendarEventsEventInstancesEventCancelRequest {
	return ApiGroupsGroupCalendarEventsEventInstancesEventCancelRequest{
		ApiService: a,
		ctx: ctx,
		groupId: groupId,
		eventId: eventId,
		eventId1: eventId1,
	}
}

// Execute executes the request
func (a *GroupsActionsApiService) GroupsGroupCalendarEventsEventInstancesEventCancelExecute(r ApiGroupsGroupCalendarEventsEventInstancesEventCancelRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GroupsActionsApiService.GroupsGroupCalendarEventsEventInstancesEventCancel")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/groups/{group-id}/calendar/events/{event-id}/instances/{event-id1}/microsoft.graph.cancel"
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id1"+"}", _neturl.PathEscape(parameterToString(r.eventId1, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject166 == nil {
		return nil, reportError("inlineObject166 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject166
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGroupsGroupCalendarEventsEventInstancesEventDeclineRequest struct {
	ctx _context.Context
	ApiService *GroupsActionsApiService
	groupId string
	eventId string
	eventId1 string
	inlineObject167 *InlineObject167
}

func (r ApiGroupsGroupCalendarEventsEventInstancesEventDeclineRequest) InlineObject167(inlineObject167 InlineObject167) ApiGroupsGroupCalendarEventsEventInstancesEventDeclineRequest {
	r.inlineObject167 = &inlineObject167
	return r
}

func (r ApiGroupsGroupCalendarEventsEventInstancesEventDeclineRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.GroupsGroupCalendarEventsEventInstancesEventDeclineExecute(r)
}

/*
GroupsGroupCalendarEventsEventInstancesEventDecline Invoke action decline

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupId key: id of group
 @param eventId key: id of event
 @param eventId1 key: id of event
 @return ApiGroupsGroupCalendarEventsEventInstancesEventDeclineRequest
*/
func (a *GroupsActionsApiService) GroupsGroupCalendarEventsEventInstancesEventDecline(ctx _context.Context, groupId string, eventId string, eventId1 string) ApiGroupsGroupCalendarEventsEventInstancesEventDeclineRequest {
	return ApiGroupsGroupCalendarEventsEventInstancesEventDeclineRequest{
		ApiService: a,
		ctx: ctx,
		groupId: groupId,
		eventId: eventId,
		eventId1: eventId1,
	}
}

// Execute executes the request
func (a *GroupsActionsApiService) GroupsGroupCalendarEventsEventInstancesEventDeclineExecute(r ApiGroupsGroupCalendarEventsEventInstancesEventDeclineRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GroupsActionsApiService.GroupsGroupCalendarEventsEventInstancesEventDecline")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/groups/{group-id}/calendar/events/{event-id}/instances/{event-id1}/microsoft.graph.decline"
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id1"+"}", _neturl.PathEscape(parameterToString(r.eventId1, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject167 == nil {
		return nil, reportError("inlineObject167 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject167
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGroupsGroupCalendarEventsEventInstancesEventDismissReminderRequest struct {
	ctx _context.Context
	ApiService *GroupsActionsApiService
	groupId string
	eventId string
	eventId1 string
}


func (r ApiGroupsGroupCalendarEventsEventInstancesEventDismissReminderRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.GroupsGroupCalendarEventsEventInstancesEventDismissReminderExecute(r)
}

/*
GroupsGroupCalendarEventsEventInstancesEventDismissReminder Invoke action dismissReminder

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupId key: id of group
 @param eventId key: id of event
 @param eventId1 key: id of event
 @return ApiGroupsGroupCalendarEventsEventInstancesEventDismissReminderRequest
*/
func (a *GroupsActionsApiService) GroupsGroupCalendarEventsEventInstancesEventDismissReminder(ctx _context.Context, groupId string, eventId string, eventId1 string) ApiGroupsGroupCalendarEventsEventInstancesEventDismissReminderRequest {
	return ApiGroupsGroupCalendarEventsEventInstancesEventDismissReminderRequest{
		ApiService: a,
		ctx: ctx,
		groupId: groupId,
		eventId: eventId,
		eventId1: eventId1,
	}
}

// Execute executes the request
func (a *GroupsActionsApiService) GroupsGroupCalendarEventsEventInstancesEventDismissReminderExecute(r ApiGroupsGroupCalendarEventsEventInstancesEventDismissReminderRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GroupsActionsApiService.GroupsGroupCalendarEventsEventInstancesEventDismissReminder")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/groups/{group-id}/calendar/events/{event-id}/instances/{event-id1}/microsoft.graph.dismissReminder"
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id1"+"}", _neturl.PathEscape(parameterToString(r.eventId1, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGroupsGroupCalendarEventsEventInstancesEventForwardRequest struct {
	ctx _context.Context
	ApiService *GroupsActionsApiService
	groupId string
	eventId string
	eventId1 string
	inlineObject168 *InlineObject168
}

func (r ApiGroupsGroupCalendarEventsEventInstancesEventForwardRequest) InlineObject168(inlineObject168 InlineObject168) ApiGroupsGroupCalendarEventsEventInstancesEventForwardRequest {
	r.inlineObject168 = &inlineObject168
	return r
}

func (r ApiGroupsGroupCalendarEventsEventInstancesEventForwardRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.GroupsGroupCalendarEventsEventInstancesEventForwardExecute(r)
}

/*
GroupsGroupCalendarEventsEventInstancesEventForward Invoke action forward

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupId key: id of group
 @param eventId key: id of event
 @param eventId1 key: id of event
 @return ApiGroupsGroupCalendarEventsEventInstancesEventForwardRequest
*/
func (a *GroupsActionsApiService) GroupsGroupCalendarEventsEventInstancesEventForward(ctx _context.Context, groupId string, eventId string, eventId1 string) ApiGroupsGroupCalendarEventsEventInstancesEventForwardRequest {
	return ApiGroupsGroupCalendarEventsEventInstancesEventForwardRequest{
		ApiService: a,
		ctx: ctx,
		groupId: groupId,
		eventId: eventId,
		eventId1: eventId1,
	}
}

// Execute executes the request
func (a *GroupsActionsApiService) GroupsGroupCalendarEventsEventInstancesEventForwardExecute(r ApiGroupsGroupCalendarEventsEventInstancesEventForwardRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GroupsActionsApiService.GroupsGroupCalendarEventsEventInstancesEventForward")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/groups/{group-id}/calendar/events/{event-id}/instances/{event-id1}/microsoft.graph.forward"
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id1"+"}", _neturl.PathEscape(parameterToString(r.eventId1, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject168 == nil {
		return nil, reportError("inlineObject168 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject168
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGroupsGroupCalendarEventsEventInstancesEventSnoozeReminderRequest struct {
	ctx _context.Context
	ApiService *GroupsActionsApiService
	groupId string
	eventId string
	eventId1 string
	inlineObject169 *InlineObject169
}

func (r ApiGroupsGroupCalendarEventsEventInstancesEventSnoozeReminderRequest) InlineObject169(inlineObject169 InlineObject169) ApiGroupsGroupCalendarEventsEventInstancesEventSnoozeReminderRequest {
	r.inlineObject169 = &inlineObject169
	return r
}

func (r ApiGroupsGroupCalendarEventsEventInstancesEventSnoozeReminderRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.GroupsGroupCalendarEventsEventInstancesEventSnoozeReminderExecute(r)
}

/*
GroupsGroupCalendarEventsEventInstancesEventSnoozeReminder Invoke action snoozeReminder

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupId key: id of group
 @param eventId key: id of event
 @param eventId1 key: id of event
 @return ApiGroupsGroupCalendarEventsEventInstancesEventSnoozeReminderRequest
*/
func (a *GroupsActionsApiService) GroupsGroupCalendarEventsEventInstancesEventSnoozeReminder(ctx _context.Context, groupId string, eventId string, eventId1 string) ApiGroupsGroupCalendarEventsEventInstancesEventSnoozeReminderRequest {
	return ApiGroupsGroupCalendarEventsEventInstancesEventSnoozeReminderRequest{
		ApiService: a,
		ctx: ctx,
		groupId: groupId,
		eventId: eventId,
		eventId1: eventId1,
	}
}

// Execute executes the request
func (a *GroupsActionsApiService) GroupsGroupCalendarEventsEventInstancesEventSnoozeReminderExecute(r ApiGroupsGroupCalendarEventsEventInstancesEventSnoozeReminderRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GroupsActionsApiService.GroupsGroupCalendarEventsEventInstancesEventSnoozeReminder")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/groups/{group-id}/calendar/events/{event-id}/instances/{event-id1}/microsoft.graph.snoozeReminder"
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id1"+"}", _neturl.PathEscape(parameterToString(r.eventId1, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject169 == nil {
		return nil, reportError("inlineObject169 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject169
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGroupsGroupCalendarEventsEventInstancesEventTentativelyAcceptRequest struct {
	ctx _context.Context
	ApiService *GroupsActionsApiService
	groupId string
	eventId string
	eventId1 string
	inlineObject170 *InlineObject170
}

func (r ApiGroupsGroupCalendarEventsEventInstancesEventTentativelyAcceptRequest) InlineObject170(inlineObject170 InlineObject170) ApiGroupsGroupCalendarEventsEventInstancesEventTentativelyAcceptRequest {
	r.inlineObject170 = &inlineObject170
	return r
}

func (r ApiGroupsGroupCalendarEventsEventInstancesEventTentativelyAcceptRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.GroupsGroupCalendarEventsEventInstancesEventTentativelyAcceptExecute(r)
}

/*
GroupsGroupCalendarEventsEventInstancesEventTentativelyAccept Invoke action tentativelyAccept

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupId key: id of group
 @param eventId key: id of event
 @param eventId1 key: id of event
 @return ApiGroupsGroupCalendarEventsEventInstancesEventTentativelyAcceptRequest
*/
func (a *GroupsActionsApiService) GroupsGroupCalendarEventsEventInstancesEventTentativelyAccept(ctx _context.Context, groupId string, eventId string, eventId1 string) ApiGroupsGroupCalendarEventsEventInstancesEventTentativelyAcceptRequest {
	return ApiGroupsGroupCalendarEventsEventInstancesEventTentativelyAcceptRequest{
		ApiService: a,
		ctx: ctx,
		groupId: groupId,
		eventId: eventId,
		eventId1: eventId1,
	}
}

// Execute executes the request
func (a *GroupsActionsApiService) GroupsGroupCalendarEventsEventInstancesEventTentativelyAcceptExecute(r ApiGroupsGroupCalendarEventsEventInstancesEventTentativelyAcceptRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GroupsActionsApiService.GroupsGroupCalendarEventsEventInstancesEventTentativelyAccept")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/groups/{group-id}/calendar/events/{event-id}/instances/{event-id1}/microsoft.graph.tentativelyAccept"
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id1"+"}", _neturl.PathEscape(parameterToString(r.eventId1, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject170 == nil {
		return nil, reportError("inlineObject170 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject170
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGroupsGroupCalendarEventsEventSnoozeReminderRequest struct {
	ctx _context.Context
	ApiService *GroupsActionsApiService
	groupId string
	eventId string
	inlineObject175 *InlineObject175
}

func (r ApiGroupsGroupCalendarEventsEventSnoozeReminderRequest) InlineObject175(inlineObject175 InlineObject175) ApiGroupsGroupCalendarEventsEventSnoozeReminderRequest {
	r.inlineObject175 = &inlineObject175
	return r
}

func (r ApiGroupsGroupCalendarEventsEventSnoozeReminderRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.GroupsGroupCalendarEventsEventSnoozeReminderExecute(r)
}

/*
GroupsGroupCalendarEventsEventSnoozeReminder Invoke action snoozeReminder

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupId key: id of group
 @param eventId key: id of event
 @return ApiGroupsGroupCalendarEventsEventSnoozeReminderRequest
*/
func (a *GroupsActionsApiService) GroupsGroupCalendarEventsEventSnoozeReminder(ctx _context.Context, groupId string, eventId string) ApiGroupsGroupCalendarEventsEventSnoozeReminderRequest {
	return ApiGroupsGroupCalendarEventsEventSnoozeReminderRequest{
		ApiService: a,
		ctx: ctx,
		groupId: groupId,
		eventId: eventId,
	}
}

// Execute executes the request
func (a *GroupsActionsApiService) GroupsGroupCalendarEventsEventSnoozeReminderExecute(r ApiGroupsGroupCalendarEventsEventSnoozeReminderRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GroupsActionsApiService.GroupsGroupCalendarEventsEventSnoozeReminder")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/groups/{group-id}/calendar/events/{event-id}/microsoft.graph.snoozeReminder"
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject175 == nil {
		return nil, reportError("inlineObject175 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject175
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGroupsGroupCalendarEventsEventTentativelyAcceptRequest struct {
	ctx _context.Context
	ApiService *GroupsActionsApiService
	groupId string
	eventId string
	inlineObject176 *InlineObject176
}

func (r ApiGroupsGroupCalendarEventsEventTentativelyAcceptRequest) InlineObject176(inlineObject176 InlineObject176) ApiGroupsGroupCalendarEventsEventTentativelyAcceptRequest {
	r.inlineObject176 = &inlineObject176
	return r
}

func (r ApiGroupsGroupCalendarEventsEventTentativelyAcceptRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.GroupsGroupCalendarEventsEventTentativelyAcceptExecute(r)
}

/*
GroupsGroupCalendarEventsEventTentativelyAccept Invoke action tentativelyAccept

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupId key: id of group
 @param eventId key: id of event
 @return ApiGroupsGroupCalendarEventsEventTentativelyAcceptRequest
*/
func (a *GroupsActionsApiService) GroupsGroupCalendarEventsEventTentativelyAccept(ctx _context.Context, groupId string, eventId string) ApiGroupsGroupCalendarEventsEventTentativelyAcceptRequest {
	return ApiGroupsGroupCalendarEventsEventTentativelyAcceptRequest{
		ApiService: a,
		ctx: ctx,
		groupId: groupId,
		eventId: eventId,
	}
}

// Execute executes the request
func (a *GroupsActionsApiService) GroupsGroupCalendarEventsEventTentativelyAcceptExecute(r ApiGroupsGroupCalendarEventsEventTentativelyAcceptRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GroupsActionsApiService.GroupsGroupCalendarEventsEventTentativelyAccept")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/groups/{group-id}/calendar/events/{event-id}/microsoft.graph.tentativelyAccept"
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject176 == nil {
		return nil, reportError("inlineObject176 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject176
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGroupsGroupCalendarGetScheduleRequest struct {
	ctx _context.Context
	ApiService *GroupsActionsApiService
	groupId string
	inlineObject177 *InlineObject177
}

func (r ApiGroupsGroupCalendarGetScheduleRequest) InlineObject177(inlineObject177 InlineObject177) ApiGroupsGroupCalendarGetScheduleRequest {
	r.inlineObject177 = &inlineObject177
	return r
}

func (r ApiGroupsGroupCalendarGetScheduleRequest) Execute() ([]*AnyOfmicrosoftGraphScheduleInformation, *_nethttp.Response, error) {
	return r.ApiService.GroupsGroupCalendarGetScheduleExecute(r)
}

/*
GroupsGroupCalendarGetSchedule Invoke action getSchedule

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupId key: id of group
 @return ApiGroupsGroupCalendarGetScheduleRequest
*/
func (a *GroupsActionsApiService) GroupsGroupCalendarGetSchedule(ctx _context.Context, groupId string) ApiGroupsGroupCalendarGetScheduleRequest {
	return ApiGroupsGroupCalendarGetScheduleRequest{
		ApiService: a,
		ctx: ctx,
		groupId: groupId,
	}
}

// Execute executes the request
//  @return []*AnyOfmicrosoftGraphScheduleInformation
func (a *GroupsActionsApiService) GroupsGroupCalendarGetScheduleExecute(r ApiGroupsGroupCalendarGetScheduleRequest) ([]*AnyOfmicrosoftGraphScheduleInformation, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  []*AnyOfmicrosoftGraphScheduleInformation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GroupsActionsApiService.GroupsGroupCalendarGetSchedule")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/groups/{group-id}/calendar/microsoft.graph.getSchedule"
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject177 == nil {
		return localVarReturnValue, nil, reportError("inlineObject177 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject177
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGroupsGroupCalendarViewEventAcceptRequest struct {
	ctx _context.Context
	ApiService *GroupsActionsApiService
	groupId string
	eventId string
	inlineObject198 *InlineObject198
}

func (r ApiGroupsGroupCalendarViewEventAcceptRequest) InlineObject198(inlineObject198 InlineObject198) ApiGroupsGroupCalendarViewEventAcceptRequest {
	r.inlineObject198 = &inlineObject198
	return r
}

func (r ApiGroupsGroupCalendarViewEventAcceptRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.GroupsGroupCalendarViewEventAcceptExecute(r)
}

/*
GroupsGroupCalendarViewEventAccept Invoke action accept

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupId key: id of group
 @param eventId key: id of event
 @return ApiGroupsGroupCalendarViewEventAcceptRequest
*/
func (a *GroupsActionsApiService) GroupsGroupCalendarViewEventAccept(ctx _context.Context, groupId string, eventId string) ApiGroupsGroupCalendarViewEventAcceptRequest {
	return ApiGroupsGroupCalendarViewEventAcceptRequest{
		ApiService: a,
		ctx: ctx,
		groupId: groupId,
		eventId: eventId,
	}
}

// Execute executes the request
func (a *GroupsActionsApiService) GroupsGroupCalendarViewEventAcceptExecute(r ApiGroupsGroupCalendarViewEventAcceptRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GroupsActionsApiService.GroupsGroupCalendarViewEventAccept")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/groups/{group-id}/calendarView/{event-id}/microsoft.graph.accept"
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject198 == nil {
		return nil, reportError("inlineObject198 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject198
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGroupsGroupCalendarViewEventAttachmentsCreateUploadSessionRequest struct {
	ctx _context.Context
	ApiService *GroupsActionsApiService
	groupId string
	eventId string
	inlineObject178 *InlineObject178
}

func (r ApiGroupsGroupCalendarViewEventAttachmentsCreateUploadSessionRequest) InlineObject178(inlineObject178 InlineObject178) ApiGroupsGroupCalendarViewEventAttachmentsCreateUploadSessionRequest {
	r.inlineObject178 = &inlineObject178
	return r
}

func (r ApiGroupsGroupCalendarViewEventAttachmentsCreateUploadSessionRequest) Execute() (AnyOfmicrosoftGraphUploadSession, *_nethttp.Response, error) {
	return r.ApiService.GroupsGroupCalendarViewEventAttachmentsCreateUploadSessionExecute(r)
}

/*
GroupsGroupCalendarViewEventAttachmentsCreateUploadSession Invoke action createUploadSession

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupId key: id of group
 @param eventId key: id of event
 @return ApiGroupsGroupCalendarViewEventAttachmentsCreateUploadSessionRequest
*/
func (a *GroupsActionsApiService) GroupsGroupCalendarViewEventAttachmentsCreateUploadSession(ctx _context.Context, groupId string, eventId string) ApiGroupsGroupCalendarViewEventAttachmentsCreateUploadSessionRequest {
	return ApiGroupsGroupCalendarViewEventAttachmentsCreateUploadSessionRequest{
		ApiService: a,
		ctx: ctx,
		groupId: groupId,
		eventId: eventId,
	}
}

// Execute executes the request
//  @return AnyOfmicrosoftGraphUploadSession
func (a *GroupsActionsApiService) GroupsGroupCalendarViewEventAttachmentsCreateUploadSessionExecute(r ApiGroupsGroupCalendarViewEventAttachmentsCreateUploadSessionRequest) (AnyOfmicrosoftGraphUploadSession, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  AnyOfmicrosoftGraphUploadSession
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GroupsActionsApiService.GroupsGroupCalendarViewEventAttachmentsCreateUploadSession")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/groups/{group-id}/calendarView/{event-id}/attachments/microsoft.graph.createUploadSession"
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject178 == nil {
		return localVarReturnValue, nil, reportError("inlineObject178 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject178
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGroupsGroupCalendarViewEventCalendarCalendarViewEventAcceptRequest struct {
	ctx _context.Context
	ApiService *GroupsActionsApiService
	groupId string
	eventId string
	eventId1 string
	inlineObject179 *InlineObject179
}

func (r ApiGroupsGroupCalendarViewEventCalendarCalendarViewEventAcceptRequest) InlineObject179(inlineObject179 InlineObject179) ApiGroupsGroupCalendarViewEventCalendarCalendarViewEventAcceptRequest {
	r.inlineObject179 = &inlineObject179
	return r
}

func (r ApiGroupsGroupCalendarViewEventCalendarCalendarViewEventAcceptRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.GroupsGroupCalendarViewEventCalendarCalendarViewEventAcceptExecute(r)
}

/*
GroupsGroupCalendarViewEventCalendarCalendarViewEventAccept Invoke action accept

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupId key: id of group
 @param eventId key: id of event
 @param eventId1 key: id of event
 @return ApiGroupsGroupCalendarViewEventCalendarCalendarViewEventAcceptRequest
*/
func (a *GroupsActionsApiService) GroupsGroupCalendarViewEventCalendarCalendarViewEventAccept(ctx _context.Context, groupId string, eventId string, eventId1 string) ApiGroupsGroupCalendarViewEventCalendarCalendarViewEventAcceptRequest {
	return ApiGroupsGroupCalendarViewEventCalendarCalendarViewEventAcceptRequest{
		ApiService: a,
		ctx: ctx,
		groupId: groupId,
		eventId: eventId,
		eventId1: eventId1,
	}
}

// Execute executes the request
func (a *GroupsActionsApiService) GroupsGroupCalendarViewEventCalendarCalendarViewEventAcceptExecute(r ApiGroupsGroupCalendarViewEventCalendarCalendarViewEventAcceptRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GroupsActionsApiService.GroupsGroupCalendarViewEventCalendarCalendarViewEventAccept")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/groups/{group-id}/calendarView/{event-id}/calendar/calendarView/{event-id1}/microsoft.graph.accept"
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id1"+"}", _neturl.PathEscape(parameterToString(r.eventId1, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject179 == nil {
		return nil, reportError("inlineObject179 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject179
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGroupsGroupCalendarViewEventCalendarCalendarViewEventCancelRequest struct {
	ctx _context.Context
	ApiService *GroupsActionsApiService
	groupId string
	eventId string
	eventId1 string
	inlineObject180 *InlineObject180
}

func (r ApiGroupsGroupCalendarViewEventCalendarCalendarViewEventCancelRequest) InlineObject180(inlineObject180 InlineObject180) ApiGroupsGroupCalendarViewEventCalendarCalendarViewEventCancelRequest {
	r.inlineObject180 = &inlineObject180
	return r
}

func (r ApiGroupsGroupCalendarViewEventCalendarCalendarViewEventCancelRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.GroupsGroupCalendarViewEventCalendarCalendarViewEventCancelExecute(r)
}

/*
GroupsGroupCalendarViewEventCalendarCalendarViewEventCancel Invoke action cancel

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupId key: id of group
 @param eventId key: id of event
 @param eventId1 key: id of event
 @return ApiGroupsGroupCalendarViewEventCalendarCalendarViewEventCancelRequest
*/
func (a *GroupsActionsApiService) GroupsGroupCalendarViewEventCalendarCalendarViewEventCancel(ctx _context.Context, groupId string, eventId string, eventId1 string) ApiGroupsGroupCalendarViewEventCalendarCalendarViewEventCancelRequest {
	return ApiGroupsGroupCalendarViewEventCalendarCalendarViewEventCancelRequest{
		ApiService: a,
		ctx: ctx,
		groupId: groupId,
		eventId: eventId,
		eventId1: eventId1,
	}
}

// Execute executes the request
func (a *GroupsActionsApiService) GroupsGroupCalendarViewEventCalendarCalendarViewEventCancelExecute(r ApiGroupsGroupCalendarViewEventCalendarCalendarViewEventCancelRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GroupsActionsApiService.GroupsGroupCalendarViewEventCalendarCalendarViewEventCancel")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/groups/{group-id}/calendarView/{event-id}/calendar/calendarView/{event-id1}/microsoft.graph.cancel"
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id1"+"}", _neturl.PathEscape(parameterToString(r.eventId1, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject180 == nil {
		return nil, reportError("inlineObject180 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject180
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGroupsGroupCalendarViewEventCalendarCalendarViewEventDeclineRequest struct {
	ctx _context.Context
	ApiService *GroupsActionsApiService
	groupId string
	eventId string
	eventId1 string
	inlineObject181 *InlineObject181
}

func (r ApiGroupsGroupCalendarViewEventCalendarCalendarViewEventDeclineRequest) InlineObject181(inlineObject181 InlineObject181) ApiGroupsGroupCalendarViewEventCalendarCalendarViewEventDeclineRequest {
	r.inlineObject181 = &inlineObject181
	return r
}

func (r ApiGroupsGroupCalendarViewEventCalendarCalendarViewEventDeclineRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.GroupsGroupCalendarViewEventCalendarCalendarViewEventDeclineExecute(r)
}

/*
GroupsGroupCalendarViewEventCalendarCalendarViewEventDecline Invoke action decline

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupId key: id of group
 @param eventId key: id of event
 @param eventId1 key: id of event
 @return ApiGroupsGroupCalendarViewEventCalendarCalendarViewEventDeclineRequest
*/
func (a *GroupsActionsApiService) GroupsGroupCalendarViewEventCalendarCalendarViewEventDecline(ctx _context.Context, groupId string, eventId string, eventId1 string) ApiGroupsGroupCalendarViewEventCalendarCalendarViewEventDeclineRequest {
	return ApiGroupsGroupCalendarViewEventCalendarCalendarViewEventDeclineRequest{
		ApiService: a,
		ctx: ctx,
		groupId: groupId,
		eventId: eventId,
		eventId1: eventId1,
	}
}

// Execute executes the request
func (a *GroupsActionsApiService) GroupsGroupCalendarViewEventCalendarCalendarViewEventDeclineExecute(r ApiGroupsGroupCalendarViewEventCalendarCalendarViewEventDeclineRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GroupsActionsApiService.GroupsGroupCalendarViewEventCalendarCalendarViewEventDecline")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/groups/{group-id}/calendarView/{event-id}/calendar/calendarView/{event-id1}/microsoft.graph.decline"
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id1"+"}", _neturl.PathEscape(parameterToString(r.eventId1, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject181 == nil {
		return nil, reportError("inlineObject181 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject181
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGroupsGroupCalendarViewEventCalendarCalendarViewEventDismissReminderRequest struct {
	ctx _context.Context
	ApiService *GroupsActionsApiService
	groupId string
	eventId string
	eventId1 string
}


func (r ApiGroupsGroupCalendarViewEventCalendarCalendarViewEventDismissReminderRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.GroupsGroupCalendarViewEventCalendarCalendarViewEventDismissReminderExecute(r)
}

/*
GroupsGroupCalendarViewEventCalendarCalendarViewEventDismissReminder Invoke action dismissReminder

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupId key: id of group
 @param eventId key: id of event
 @param eventId1 key: id of event
 @return ApiGroupsGroupCalendarViewEventCalendarCalendarViewEventDismissReminderRequest
*/
func (a *GroupsActionsApiService) GroupsGroupCalendarViewEventCalendarCalendarViewEventDismissReminder(ctx _context.Context, groupId string, eventId string, eventId1 string) ApiGroupsGroupCalendarViewEventCalendarCalendarViewEventDismissReminderRequest {
	return ApiGroupsGroupCalendarViewEventCalendarCalendarViewEventDismissReminderRequest{
		ApiService: a,
		ctx: ctx,
		groupId: groupId,
		eventId: eventId,
		eventId1: eventId1,
	}
}

// Execute executes the request
func (a *GroupsActionsApiService) GroupsGroupCalendarViewEventCalendarCalendarViewEventDismissReminderExecute(r ApiGroupsGroupCalendarViewEventCalendarCalendarViewEventDismissReminderRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GroupsActionsApiService.GroupsGroupCalendarViewEventCalendarCalendarViewEventDismissReminder")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/groups/{group-id}/calendarView/{event-id}/calendar/calendarView/{event-id1}/microsoft.graph.dismissReminder"
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id1"+"}", _neturl.PathEscape(parameterToString(r.eventId1, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGroupsGroupCalendarViewEventCalendarCalendarViewEventForwardRequest struct {
	ctx _context.Context
	ApiService *GroupsActionsApiService
	groupId string
	eventId string
	eventId1 string
	inlineObject182 *InlineObject182
}

func (r ApiGroupsGroupCalendarViewEventCalendarCalendarViewEventForwardRequest) InlineObject182(inlineObject182 InlineObject182) ApiGroupsGroupCalendarViewEventCalendarCalendarViewEventForwardRequest {
	r.inlineObject182 = &inlineObject182
	return r
}

func (r ApiGroupsGroupCalendarViewEventCalendarCalendarViewEventForwardRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.GroupsGroupCalendarViewEventCalendarCalendarViewEventForwardExecute(r)
}

/*
GroupsGroupCalendarViewEventCalendarCalendarViewEventForward Invoke action forward

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupId key: id of group
 @param eventId key: id of event
 @param eventId1 key: id of event
 @return ApiGroupsGroupCalendarViewEventCalendarCalendarViewEventForwardRequest
*/
func (a *GroupsActionsApiService) GroupsGroupCalendarViewEventCalendarCalendarViewEventForward(ctx _context.Context, groupId string, eventId string, eventId1 string) ApiGroupsGroupCalendarViewEventCalendarCalendarViewEventForwardRequest {
	return ApiGroupsGroupCalendarViewEventCalendarCalendarViewEventForwardRequest{
		ApiService: a,
		ctx: ctx,
		groupId: groupId,
		eventId: eventId,
		eventId1: eventId1,
	}
}

// Execute executes the request
func (a *GroupsActionsApiService) GroupsGroupCalendarViewEventCalendarCalendarViewEventForwardExecute(r ApiGroupsGroupCalendarViewEventCalendarCalendarViewEventForwardRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GroupsActionsApiService.GroupsGroupCalendarViewEventCalendarCalendarViewEventForward")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/groups/{group-id}/calendarView/{event-id}/calendar/calendarView/{event-id1}/microsoft.graph.forward"
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id1"+"}", _neturl.PathEscape(parameterToString(r.eventId1, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject182 == nil {
		return nil, reportError("inlineObject182 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject182
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGroupsGroupCalendarViewEventCalendarCalendarViewEventSnoozeReminderRequest struct {
	ctx _context.Context
	ApiService *GroupsActionsApiService
	groupId string
	eventId string
	eventId1 string
	inlineObject183 *InlineObject183
}

func (r ApiGroupsGroupCalendarViewEventCalendarCalendarViewEventSnoozeReminderRequest) InlineObject183(inlineObject183 InlineObject183) ApiGroupsGroupCalendarViewEventCalendarCalendarViewEventSnoozeReminderRequest {
	r.inlineObject183 = &inlineObject183
	return r
}

func (r ApiGroupsGroupCalendarViewEventCalendarCalendarViewEventSnoozeReminderRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.GroupsGroupCalendarViewEventCalendarCalendarViewEventSnoozeReminderExecute(r)
}

/*
GroupsGroupCalendarViewEventCalendarCalendarViewEventSnoozeReminder Invoke action snoozeReminder

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupId key: id of group
 @param eventId key: id of event
 @param eventId1 key: id of event
 @return ApiGroupsGroupCalendarViewEventCalendarCalendarViewEventSnoozeReminderRequest
*/
func (a *GroupsActionsApiService) GroupsGroupCalendarViewEventCalendarCalendarViewEventSnoozeReminder(ctx _context.Context, groupId string, eventId string, eventId1 string) ApiGroupsGroupCalendarViewEventCalendarCalendarViewEventSnoozeReminderRequest {
	return ApiGroupsGroupCalendarViewEventCalendarCalendarViewEventSnoozeReminderRequest{
		ApiService: a,
		ctx: ctx,
		groupId: groupId,
		eventId: eventId,
		eventId1: eventId1,
	}
}

// Execute executes the request
func (a *GroupsActionsApiService) GroupsGroupCalendarViewEventCalendarCalendarViewEventSnoozeReminderExecute(r ApiGroupsGroupCalendarViewEventCalendarCalendarViewEventSnoozeReminderRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GroupsActionsApiService.GroupsGroupCalendarViewEventCalendarCalendarViewEventSnoozeReminder")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/groups/{group-id}/calendarView/{event-id}/calendar/calendarView/{event-id1}/microsoft.graph.snoozeReminder"
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id1"+"}", _neturl.PathEscape(parameterToString(r.eventId1, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject183 == nil {
		return nil, reportError("inlineObject183 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject183
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGroupsGroupCalendarViewEventCalendarCalendarViewEventTentativelyAcceptRequest struct {
	ctx _context.Context
	ApiService *GroupsActionsApiService
	groupId string
	eventId string
	eventId1 string
	inlineObject184 *InlineObject184
}

func (r ApiGroupsGroupCalendarViewEventCalendarCalendarViewEventTentativelyAcceptRequest) InlineObject184(inlineObject184 InlineObject184) ApiGroupsGroupCalendarViewEventCalendarCalendarViewEventTentativelyAcceptRequest {
	r.inlineObject184 = &inlineObject184
	return r
}

func (r ApiGroupsGroupCalendarViewEventCalendarCalendarViewEventTentativelyAcceptRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.GroupsGroupCalendarViewEventCalendarCalendarViewEventTentativelyAcceptExecute(r)
}

/*
GroupsGroupCalendarViewEventCalendarCalendarViewEventTentativelyAccept Invoke action tentativelyAccept

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupId key: id of group
 @param eventId key: id of event
 @param eventId1 key: id of event
 @return ApiGroupsGroupCalendarViewEventCalendarCalendarViewEventTentativelyAcceptRequest
*/
func (a *GroupsActionsApiService) GroupsGroupCalendarViewEventCalendarCalendarViewEventTentativelyAccept(ctx _context.Context, groupId string, eventId string, eventId1 string) ApiGroupsGroupCalendarViewEventCalendarCalendarViewEventTentativelyAcceptRequest {
	return ApiGroupsGroupCalendarViewEventCalendarCalendarViewEventTentativelyAcceptRequest{
		ApiService: a,
		ctx: ctx,
		groupId: groupId,
		eventId: eventId,
		eventId1: eventId1,
	}
}

// Execute executes the request
func (a *GroupsActionsApiService) GroupsGroupCalendarViewEventCalendarCalendarViewEventTentativelyAcceptExecute(r ApiGroupsGroupCalendarViewEventCalendarCalendarViewEventTentativelyAcceptRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GroupsActionsApiService.GroupsGroupCalendarViewEventCalendarCalendarViewEventTentativelyAccept")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/groups/{group-id}/calendarView/{event-id}/calendar/calendarView/{event-id1}/microsoft.graph.tentativelyAccept"
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id1"+"}", _neturl.PathEscape(parameterToString(r.eventId1, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject184 == nil {
		return nil, reportError("inlineObject184 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject184
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGroupsGroupCalendarViewEventCalendarEventsEventAcceptRequest struct {
	ctx _context.Context
	ApiService *GroupsActionsApiService
	groupId string
	eventId string
	eventId1 string
	inlineObject185 *InlineObject185
}

func (r ApiGroupsGroupCalendarViewEventCalendarEventsEventAcceptRequest) InlineObject185(inlineObject185 InlineObject185) ApiGroupsGroupCalendarViewEventCalendarEventsEventAcceptRequest {
	r.inlineObject185 = &inlineObject185
	return r
}

func (r ApiGroupsGroupCalendarViewEventCalendarEventsEventAcceptRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.GroupsGroupCalendarViewEventCalendarEventsEventAcceptExecute(r)
}

/*
GroupsGroupCalendarViewEventCalendarEventsEventAccept Invoke action accept

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupId key: id of group
 @param eventId key: id of event
 @param eventId1 key: id of event
 @return ApiGroupsGroupCalendarViewEventCalendarEventsEventAcceptRequest
*/
func (a *GroupsActionsApiService) GroupsGroupCalendarViewEventCalendarEventsEventAccept(ctx _context.Context, groupId string, eventId string, eventId1 string) ApiGroupsGroupCalendarViewEventCalendarEventsEventAcceptRequest {
	return ApiGroupsGroupCalendarViewEventCalendarEventsEventAcceptRequest{
		ApiService: a,
		ctx: ctx,
		groupId: groupId,
		eventId: eventId,
		eventId1: eventId1,
	}
}

// Execute executes the request
func (a *GroupsActionsApiService) GroupsGroupCalendarViewEventCalendarEventsEventAcceptExecute(r ApiGroupsGroupCalendarViewEventCalendarEventsEventAcceptRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GroupsActionsApiService.GroupsGroupCalendarViewEventCalendarEventsEventAccept")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/groups/{group-id}/calendarView/{event-id}/calendar/events/{event-id1}/microsoft.graph.accept"
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id1"+"}", _neturl.PathEscape(parameterToString(r.eventId1, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject185 == nil {
		return nil, reportError("inlineObject185 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject185
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGroupsGroupCalendarViewEventCalendarEventsEventCancelRequest struct {
	ctx _context.Context
	ApiService *GroupsActionsApiService
	groupId string
	eventId string
	eventId1 string
	inlineObject186 *InlineObject186
}

func (r ApiGroupsGroupCalendarViewEventCalendarEventsEventCancelRequest) InlineObject186(inlineObject186 InlineObject186) ApiGroupsGroupCalendarViewEventCalendarEventsEventCancelRequest {
	r.inlineObject186 = &inlineObject186
	return r
}

func (r ApiGroupsGroupCalendarViewEventCalendarEventsEventCancelRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.GroupsGroupCalendarViewEventCalendarEventsEventCancelExecute(r)
}

/*
GroupsGroupCalendarViewEventCalendarEventsEventCancel Invoke action cancel

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupId key: id of group
 @param eventId key: id of event
 @param eventId1 key: id of event
 @return ApiGroupsGroupCalendarViewEventCalendarEventsEventCancelRequest
*/
func (a *GroupsActionsApiService) GroupsGroupCalendarViewEventCalendarEventsEventCancel(ctx _context.Context, groupId string, eventId string, eventId1 string) ApiGroupsGroupCalendarViewEventCalendarEventsEventCancelRequest {
	return ApiGroupsGroupCalendarViewEventCalendarEventsEventCancelRequest{
		ApiService: a,
		ctx: ctx,
		groupId: groupId,
		eventId: eventId,
		eventId1: eventId1,
	}
}

// Execute executes the request
func (a *GroupsActionsApiService) GroupsGroupCalendarViewEventCalendarEventsEventCancelExecute(r ApiGroupsGroupCalendarViewEventCalendarEventsEventCancelRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GroupsActionsApiService.GroupsGroupCalendarViewEventCalendarEventsEventCancel")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/groups/{group-id}/calendarView/{event-id}/calendar/events/{event-id1}/microsoft.graph.cancel"
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id1"+"}", _neturl.PathEscape(parameterToString(r.eventId1, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject186 == nil {
		return nil, reportError("inlineObject186 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject186
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGroupsGroupCalendarViewEventCalendarEventsEventDeclineRequest struct {
	ctx _context.Context
	ApiService *GroupsActionsApiService
	groupId string
	eventId string
	eventId1 string
	inlineObject187 *InlineObject187
}

func (r ApiGroupsGroupCalendarViewEventCalendarEventsEventDeclineRequest) InlineObject187(inlineObject187 InlineObject187) ApiGroupsGroupCalendarViewEventCalendarEventsEventDeclineRequest {
	r.inlineObject187 = &inlineObject187
	return r
}

func (r ApiGroupsGroupCalendarViewEventCalendarEventsEventDeclineRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.GroupsGroupCalendarViewEventCalendarEventsEventDeclineExecute(r)
}

/*
GroupsGroupCalendarViewEventCalendarEventsEventDecline Invoke action decline

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupId key: id of group
 @param eventId key: id of event
 @param eventId1 key: id of event
 @return ApiGroupsGroupCalendarViewEventCalendarEventsEventDeclineRequest
*/
func (a *GroupsActionsApiService) GroupsGroupCalendarViewEventCalendarEventsEventDecline(ctx _context.Context, groupId string, eventId string, eventId1 string) ApiGroupsGroupCalendarViewEventCalendarEventsEventDeclineRequest {
	return ApiGroupsGroupCalendarViewEventCalendarEventsEventDeclineRequest{
		ApiService: a,
		ctx: ctx,
		groupId: groupId,
		eventId: eventId,
		eventId1: eventId1,
	}
}

// Execute executes the request
func (a *GroupsActionsApiService) GroupsGroupCalendarViewEventCalendarEventsEventDeclineExecute(r ApiGroupsGroupCalendarViewEventCalendarEventsEventDeclineRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GroupsActionsApiService.GroupsGroupCalendarViewEventCalendarEventsEventDecline")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/groups/{group-id}/calendarView/{event-id}/calendar/events/{event-id1}/microsoft.graph.decline"
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id1"+"}", _neturl.PathEscape(parameterToString(r.eventId1, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject187 == nil {
		return nil, reportError("inlineObject187 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject187
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGroupsGroupCalendarViewEventCalendarEventsEventDismissReminderRequest struct {
	ctx _context.Context
	ApiService *GroupsActionsApiService
	groupId string
	eventId string
	eventId1 string
}


func (r ApiGroupsGroupCalendarViewEventCalendarEventsEventDismissReminderRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.GroupsGroupCalendarViewEventCalendarEventsEventDismissReminderExecute(r)
}

/*
GroupsGroupCalendarViewEventCalendarEventsEventDismissReminder Invoke action dismissReminder

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupId key: id of group
 @param eventId key: id of event
 @param eventId1 key: id of event
 @return ApiGroupsGroupCalendarViewEventCalendarEventsEventDismissReminderRequest
*/
func (a *GroupsActionsApiService) GroupsGroupCalendarViewEventCalendarEventsEventDismissReminder(ctx _context.Context, groupId string, eventId string, eventId1 string) ApiGroupsGroupCalendarViewEventCalendarEventsEventDismissReminderRequest {
	return ApiGroupsGroupCalendarViewEventCalendarEventsEventDismissReminderRequest{
		ApiService: a,
		ctx: ctx,
		groupId: groupId,
		eventId: eventId,
		eventId1: eventId1,
	}
}

// Execute executes the request
func (a *GroupsActionsApiService) GroupsGroupCalendarViewEventCalendarEventsEventDismissReminderExecute(r ApiGroupsGroupCalendarViewEventCalendarEventsEventDismissReminderRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GroupsActionsApiService.GroupsGroupCalendarViewEventCalendarEventsEventDismissReminder")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/groups/{group-id}/calendarView/{event-id}/calendar/events/{event-id1}/microsoft.graph.dismissReminder"
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id1"+"}", _neturl.PathEscape(parameterToString(r.eventId1, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGroupsGroupCalendarViewEventCalendarEventsEventForwardRequest struct {
	ctx _context.Context
	ApiService *GroupsActionsApiService
	groupId string
	eventId string
	eventId1 string
	inlineObject188 *InlineObject188
}

func (r ApiGroupsGroupCalendarViewEventCalendarEventsEventForwardRequest) InlineObject188(inlineObject188 InlineObject188) ApiGroupsGroupCalendarViewEventCalendarEventsEventForwardRequest {
	r.inlineObject188 = &inlineObject188
	return r
}

func (r ApiGroupsGroupCalendarViewEventCalendarEventsEventForwardRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.GroupsGroupCalendarViewEventCalendarEventsEventForwardExecute(r)
}

/*
GroupsGroupCalendarViewEventCalendarEventsEventForward Invoke action forward

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupId key: id of group
 @param eventId key: id of event
 @param eventId1 key: id of event
 @return ApiGroupsGroupCalendarViewEventCalendarEventsEventForwardRequest
*/
func (a *GroupsActionsApiService) GroupsGroupCalendarViewEventCalendarEventsEventForward(ctx _context.Context, groupId string, eventId string, eventId1 string) ApiGroupsGroupCalendarViewEventCalendarEventsEventForwardRequest {
	return ApiGroupsGroupCalendarViewEventCalendarEventsEventForwardRequest{
		ApiService: a,
		ctx: ctx,
		groupId: groupId,
		eventId: eventId,
		eventId1: eventId1,
	}
}

// Execute executes the request
func (a *GroupsActionsApiService) GroupsGroupCalendarViewEventCalendarEventsEventForwardExecute(r ApiGroupsGroupCalendarViewEventCalendarEventsEventForwardRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GroupsActionsApiService.GroupsGroupCalendarViewEventCalendarEventsEventForward")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/groups/{group-id}/calendarView/{event-id}/calendar/events/{event-id1}/microsoft.graph.forward"
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id1"+"}", _neturl.PathEscape(parameterToString(r.eventId1, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject188 == nil {
		return nil, reportError("inlineObject188 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject188
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGroupsGroupCalendarViewEventCalendarEventsEventSnoozeReminderRequest struct {
	ctx _context.Context
	ApiService *GroupsActionsApiService
	groupId string
	eventId string
	eventId1 string
	inlineObject189 *InlineObject189
}

func (r ApiGroupsGroupCalendarViewEventCalendarEventsEventSnoozeReminderRequest) InlineObject189(inlineObject189 InlineObject189) ApiGroupsGroupCalendarViewEventCalendarEventsEventSnoozeReminderRequest {
	r.inlineObject189 = &inlineObject189
	return r
}

func (r ApiGroupsGroupCalendarViewEventCalendarEventsEventSnoozeReminderRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.GroupsGroupCalendarViewEventCalendarEventsEventSnoozeReminderExecute(r)
}

/*
GroupsGroupCalendarViewEventCalendarEventsEventSnoozeReminder Invoke action snoozeReminder

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupId key: id of group
 @param eventId key: id of event
 @param eventId1 key: id of event
 @return ApiGroupsGroupCalendarViewEventCalendarEventsEventSnoozeReminderRequest
*/
func (a *GroupsActionsApiService) GroupsGroupCalendarViewEventCalendarEventsEventSnoozeReminder(ctx _context.Context, groupId string, eventId string, eventId1 string) ApiGroupsGroupCalendarViewEventCalendarEventsEventSnoozeReminderRequest {
	return ApiGroupsGroupCalendarViewEventCalendarEventsEventSnoozeReminderRequest{
		ApiService: a,
		ctx: ctx,
		groupId: groupId,
		eventId: eventId,
		eventId1: eventId1,
	}
}

// Execute executes the request
func (a *GroupsActionsApiService) GroupsGroupCalendarViewEventCalendarEventsEventSnoozeReminderExecute(r ApiGroupsGroupCalendarViewEventCalendarEventsEventSnoozeReminderRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GroupsActionsApiService.GroupsGroupCalendarViewEventCalendarEventsEventSnoozeReminder")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/groups/{group-id}/calendarView/{event-id}/calendar/events/{event-id1}/microsoft.graph.snoozeReminder"
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id1"+"}", _neturl.PathEscape(parameterToString(r.eventId1, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject189 == nil {
		return nil, reportError("inlineObject189 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject189
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGroupsGroupCalendarViewEventCalendarEventsEventTentativelyAcceptRequest struct {
	ctx _context.Context
	ApiService *GroupsActionsApiService
	groupId string
	eventId string
	eventId1 string
	inlineObject190 *InlineObject190
}

func (r ApiGroupsGroupCalendarViewEventCalendarEventsEventTentativelyAcceptRequest) InlineObject190(inlineObject190 InlineObject190) ApiGroupsGroupCalendarViewEventCalendarEventsEventTentativelyAcceptRequest {
	r.inlineObject190 = &inlineObject190
	return r
}

func (r ApiGroupsGroupCalendarViewEventCalendarEventsEventTentativelyAcceptRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.GroupsGroupCalendarViewEventCalendarEventsEventTentativelyAcceptExecute(r)
}

/*
GroupsGroupCalendarViewEventCalendarEventsEventTentativelyAccept Invoke action tentativelyAccept

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupId key: id of group
 @param eventId key: id of event
 @param eventId1 key: id of event
 @return ApiGroupsGroupCalendarViewEventCalendarEventsEventTentativelyAcceptRequest
*/
func (a *GroupsActionsApiService) GroupsGroupCalendarViewEventCalendarEventsEventTentativelyAccept(ctx _context.Context, groupId string, eventId string, eventId1 string) ApiGroupsGroupCalendarViewEventCalendarEventsEventTentativelyAcceptRequest {
	return ApiGroupsGroupCalendarViewEventCalendarEventsEventTentativelyAcceptRequest{
		ApiService: a,
		ctx: ctx,
		groupId: groupId,
		eventId: eventId,
		eventId1: eventId1,
	}
}

// Execute executes the request
func (a *GroupsActionsApiService) GroupsGroupCalendarViewEventCalendarEventsEventTentativelyAcceptExecute(r ApiGroupsGroupCalendarViewEventCalendarEventsEventTentativelyAcceptRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GroupsActionsApiService.GroupsGroupCalendarViewEventCalendarEventsEventTentativelyAccept")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/groups/{group-id}/calendarView/{event-id}/calendar/events/{event-id1}/microsoft.graph.tentativelyAccept"
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id1"+"}", _neturl.PathEscape(parameterToString(r.eventId1, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject190 == nil {
		return nil, reportError("inlineObject190 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject190
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGroupsGroupCalendarViewEventCalendarGetScheduleRequest struct {
	ctx _context.Context
	ApiService *GroupsActionsApiService
	groupId string
	eventId string
	inlineObject191 *InlineObject191
}

func (r ApiGroupsGroupCalendarViewEventCalendarGetScheduleRequest) InlineObject191(inlineObject191 InlineObject191) ApiGroupsGroupCalendarViewEventCalendarGetScheduleRequest {
	r.inlineObject191 = &inlineObject191
	return r
}

func (r ApiGroupsGroupCalendarViewEventCalendarGetScheduleRequest) Execute() ([]*AnyOfmicrosoftGraphScheduleInformation, *_nethttp.Response, error) {
	return r.ApiService.GroupsGroupCalendarViewEventCalendarGetScheduleExecute(r)
}

/*
GroupsGroupCalendarViewEventCalendarGetSchedule Invoke action getSchedule

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupId key: id of group
 @param eventId key: id of event
 @return ApiGroupsGroupCalendarViewEventCalendarGetScheduleRequest
*/
func (a *GroupsActionsApiService) GroupsGroupCalendarViewEventCalendarGetSchedule(ctx _context.Context, groupId string, eventId string) ApiGroupsGroupCalendarViewEventCalendarGetScheduleRequest {
	return ApiGroupsGroupCalendarViewEventCalendarGetScheduleRequest{
		ApiService: a,
		ctx: ctx,
		groupId: groupId,
		eventId: eventId,
	}
}

// Execute executes the request
//  @return []*AnyOfmicrosoftGraphScheduleInformation
func (a *GroupsActionsApiService) GroupsGroupCalendarViewEventCalendarGetScheduleExecute(r ApiGroupsGroupCalendarViewEventCalendarGetScheduleRequest) ([]*AnyOfmicrosoftGraphScheduleInformation, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  []*AnyOfmicrosoftGraphScheduleInformation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GroupsActionsApiService.GroupsGroupCalendarViewEventCalendarGetSchedule")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/groups/{group-id}/calendarView/{event-id}/calendar/microsoft.graph.getSchedule"
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject191 == nil {
		return localVarReturnValue, nil, reportError("inlineObject191 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject191
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGroupsGroupCalendarViewEventCancelRequest struct {
	ctx _context.Context
	ApiService *GroupsActionsApiService
	groupId string
	eventId string
	inlineObject199 *InlineObject199
}

func (r ApiGroupsGroupCalendarViewEventCancelRequest) InlineObject199(inlineObject199 InlineObject199) ApiGroupsGroupCalendarViewEventCancelRequest {
	r.inlineObject199 = &inlineObject199
	return r
}

func (r ApiGroupsGroupCalendarViewEventCancelRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.GroupsGroupCalendarViewEventCancelExecute(r)
}

/*
GroupsGroupCalendarViewEventCancel Invoke action cancel

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupId key: id of group
 @param eventId key: id of event
 @return ApiGroupsGroupCalendarViewEventCancelRequest
*/
func (a *GroupsActionsApiService) GroupsGroupCalendarViewEventCancel(ctx _context.Context, groupId string, eventId string) ApiGroupsGroupCalendarViewEventCancelRequest {
	return ApiGroupsGroupCalendarViewEventCancelRequest{
		ApiService: a,
		ctx: ctx,
		groupId: groupId,
		eventId: eventId,
	}
}

// Execute executes the request
func (a *GroupsActionsApiService) GroupsGroupCalendarViewEventCancelExecute(r ApiGroupsGroupCalendarViewEventCancelRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GroupsActionsApiService.GroupsGroupCalendarViewEventCancel")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/groups/{group-id}/calendarView/{event-id}/microsoft.graph.cancel"
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject199 == nil {
		return nil, reportError("inlineObject199 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject199
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGroupsGroupCalendarViewEventDeclineRequest struct {
	ctx _context.Context
	ApiService *GroupsActionsApiService
	groupId string
	eventId string
	inlineObject200 *InlineObject200
}

func (r ApiGroupsGroupCalendarViewEventDeclineRequest) InlineObject200(inlineObject200 InlineObject200) ApiGroupsGroupCalendarViewEventDeclineRequest {
	r.inlineObject200 = &inlineObject200
	return r
}

func (r ApiGroupsGroupCalendarViewEventDeclineRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.GroupsGroupCalendarViewEventDeclineExecute(r)
}

/*
GroupsGroupCalendarViewEventDecline Invoke action decline

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupId key: id of group
 @param eventId key: id of event
 @return ApiGroupsGroupCalendarViewEventDeclineRequest
*/
func (a *GroupsActionsApiService) GroupsGroupCalendarViewEventDecline(ctx _context.Context, groupId string, eventId string) ApiGroupsGroupCalendarViewEventDeclineRequest {
	return ApiGroupsGroupCalendarViewEventDeclineRequest{
		ApiService: a,
		ctx: ctx,
		groupId: groupId,
		eventId: eventId,
	}
}

// Execute executes the request
func (a *GroupsActionsApiService) GroupsGroupCalendarViewEventDeclineExecute(r ApiGroupsGroupCalendarViewEventDeclineRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GroupsActionsApiService.GroupsGroupCalendarViewEventDecline")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/groups/{group-id}/calendarView/{event-id}/microsoft.graph.decline"
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject200 == nil {
		return nil, reportError("inlineObject200 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject200
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGroupsGroupCalendarViewEventDismissReminderRequest struct {
	ctx _context.Context
	ApiService *GroupsActionsApiService
	groupId string
	eventId string
}


func (r ApiGroupsGroupCalendarViewEventDismissReminderRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.GroupsGroupCalendarViewEventDismissReminderExecute(r)
}

/*
GroupsGroupCalendarViewEventDismissReminder Invoke action dismissReminder

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupId key: id of group
 @param eventId key: id of event
 @return ApiGroupsGroupCalendarViewEventDismissReminderRequest
*/
func (a *GroupsActionsApiService) GroupsGroupCalendarViewEventDismissReminder(ctx _context.Context, groupId string, eventId string) ApiGroupsGroupCalendarViewEventDismissReminderRequest {
	return ApiGroupsGroupCalendarViewEventDismissReminderRequest{
		ApiService: a,
		ctx: ctx,
		groupId: groupId,
		eventId: eventId,
	}
}

// Execute executes the request
func (a *GroupsActionsApiService) GroupsGroupCalendarViewEventDismissReminderExecute(r ApiGroupsGroupCalendarViewEventDismissReminderRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GroupsActionsApiService.GroupsGroupCalendarViewEventDismissReminder")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/groups/{group-id}/calendarView/{event-id}/microsoft.graph.dismissReminder"
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGroupsGroupCalendarViewEventForwardRequest struct {
	ctx _context.Context
	ApiService *GroupsActionsApiService
	groupId string
	eventId string
	inlineObject201 *InlineObject201
}

func (r ApiGroupsGroupCalendarViewEventForwardRequest) InlineObject201(inlineObject201 InlineObject201) ApiGroupsGroupCalendarViewEventForwardRequest {
	r.inlineObject201 = &inlineObject201
	return r
}

func (r ApiGroupsGroupCalendarViewEventForwardRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.GroupsGroupCalendarViewEventForwardExecute(r)
}

/*
GroupsGroupCalendarViewEventForward Invoke action forward

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupId key: id of group
 @param eventId key: id of event
 @return ApiGroupsGroupCalendarViewEventForwardRequest
*/
func (a *GroupsActionsApiService) GroupsGroupCalendarViewEventForward(ctx _context.Context, groupId string, eventId string) ApiGroupsGroupCalendarViewEventForwardRequest {
	return ApiGroupsGroupCalendarViewEventForwardRequest{
		ApiService: a,
		ctx: ctx,
		groupId: groupId,
		eventId: eventId,
	}
}

// Execute executes the request
func (a *GroupsActionsApiService) GroupsGroupCalendarViewEventForwardExecute(r ApiGroupsGroupCalendarViewEventForwardRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GroupsActionsApiService.GroupsGroupCalendarViewEventForward")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/groups/{group-id}/calendarView/{event-id}/microsoft.graph.forward"
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject201 == nil {
		return nil, reportError("inlineObject201 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject201
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGroupsGroupCalendarViewEventInstancesEventAcceptRequest struct {
	ctx _context.Context
	ApiService *GroupsActionsApiService
	groupId string
	eventId string
	eventId1 string
	inlineObject192 *InlineObject192
}

func (r ApiGroupsGroupCalendarViewEventInstancesEventAcceptRequest) InlineObject192(inlineObject192 InlineObject192) ApiGroupsGroupCalendarViewEventInstancesEventAcceptRequest {
	r.inlineObject192 = &inlineObject192
	return r
}

func (r ApiGroupsGroupCalendarViewEventInstancesEventAcceptRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.GroupsGroupCalendarViewEventInstancesEventAcceptExecute(r)
}

/*
GroupsGroupCalendarViewEventInstancesEventAccept Invoke action accept

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupId key: id of group
 @param eventId key: id of event
 @param eventId1 key: id of event
 @return ApiGroupsGroupCalendarViewEventInstancesEventAcceptRequest
*/
func (a *GroupsActionsApiService) GroupsGroupCalendarViewEventInstancesEventAccept(ctx _context.Context, groupId string, eventId string, eventId1 string) ApiGroupsGroupCalendarViewEventInstancesEventAcceptRequest {
	return ApiGroupsGroupCalendarViewEventInstancesEventAcceptRequest{
		ApiService: a,
		ctx: ctx,
		groupId: groupId,
		eventId: eventId,
		eventId1: eventId1,
	}
}

// Execute executes the request
func (a *GroupsActionsApiService) GroupsGroupCalendarViewEventInstancesEventAcceptExecute(r ApiGroupsGroupCalendarViewEventInstancesEventAcceptRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GroupsActionsApiService.GroupsGroupCalendarViewEventInstancesEventAccept")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/groups/{group-id}/calendarView/{event-id}/instances/{event-id1}/microsoft.graph.accept"
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id1"+"}", _neturl.PathEscape(parameterToString(r.eventId1, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject192 == nil {
		return nil, reportError("inlineObject192 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject192
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGroupsGroupCalendarViewEventInstancesEventCancelRequest struct {
	ctx _context.Context
	ApiService *GroupsActionsApiService
	groupId string
	eventId string
	eventId1 string
	inlineObject193 *InlineObject193
}

func (r ApiGroupsGroupCalendarViewEventInstancesEventCancelRequest) InlineObject193(inlineObject193 InlineObject193) ApiGroupsGroupCalendarViewEventInstancesEventCancelRequest {
	r.inlineObject193 = &inlineObject193
	return r
}

func (r ApiGroupsGroupCalendarViewEventInstancesEventCancelRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.GroupsGroupCalendarViewEventInstancesEventCancelExecute(r)
}

/*
GroupsGroupCalendarViewEventInstancesEventCancel Invoke action cancel

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupId key: id of group
 @param eventId key: id of event
 @param eventId1 key: id of event
 @return ApiGroupsGroupCalendarViewEventInstancesEventCancelRequest
*/
func (a *GroupsActionsApiService) GroupsGroupCalendarViewEventInstancesEventCancel(ctx _context.Context, groupId string, eventId string, eventId1 string) ApiGroupsGroupCalendarViewEventInstancesEventCancelRequest {
	return ApiGroupsGroupCalendarViewEventInstancesEventCancelRequest{
		ApiService: a,
		ctx: ctx,
		groupId: groupId,
		eventId: eventId,
		eventId1: eventId1,
	}
}

// Execute executes the request
func (a *GroupsActionsApiService) GroupsGroupCalendarViewEventInstancesEventCancelExecute(r ApiGroupsGroupCalendarViewEventInstancesEventCancelRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GroupsActionsApiService.GroupsGroupCalendarViewEventInstancesEventCancel")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/groups/{group-id}/calendarView/{event-id}/instances/{event-id1}/microsoft.graph.cancel"
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id1"+"}", _neturl.PathEscape(parameterToString(r.eventId1, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject193 == nil {
		return nil, reportError("inlineObject193 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject193
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGroupsGroupCalendarViewEventInstancesEventDeclineRequest struct {
	ctx _context.Context
	ApiService *GroupsActionsApiService
	groupId string
	eventId string
	eventId1 string
	inlineObject194 *InlineObject194
}

func (r ApiGroupsGroupCalendarViewEventInstancesEventDeclineRequest) InlineObject194(inlineObject194 InlineObject194) ApiGroupsGroupCalendarViewEventInstancesEventDeclineRequest {
	r.inlineObject194 = &inlineObject194
	return r
}

func (r ApiGroupsGroupCalendarViewEventInstancesEventDeclineRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.GroupsGroupCalendarViewEventInstancesEventDeclineExecute(r)
}

/*
GroupsGroupCalendarViewEventInstancesEventDecline Invoke action decline

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupId key: id of group
 @param eventId key: id of event
 @param eventId1 key: id of event
 @return ApiGroupsGroupCalendarViewEventInstancesEventDeclineRequest
*/
func (a *GroupsActionsApiService) GroupsGroupCalendarViewEventInstancesEventDecline(ctx _context.Context, groupId string, eventId string, eventId1 string) ApiGroupsGroupCalendarViewEventInstancesEventDeclineRequest {
	return ApiGroupsGroupCalendarViewEventInstancesEventDeclineRequest{
		ApiService: a,
		ctx: ctx,
		groupId: groupId,
		eventId: eventId,
		eventId1: eventId1,
	}
}

// Execute executes the request
func (a *GroupsActionsApiService) GroupsGroupCalendarViewEventInstancesEventDeclineExecute(r ApiGroupsGroupCalendarViewEventInstancesEventDeclineRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GroupsActionsApiService.GroupsGroupCalendarViewEventInstancesEventDecline")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/groups/{group-id}/calendarView/{event-id}/instances/{event-id1}/microsoft.graph.decline"
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id1"+"}", _neturl.PathEscape(parameterToString(r.eventId1, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject194 == nil {
		return nil, reportError("inlineObject194 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject194
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGroupsGroupCalendarViewEventInstancesEventDismissReminderRequest struct {
	ctx _context.Context
	ApiService *GroupsActionsApiService
	groupId string
	eventId string
	eventId1 string
}


func (r ApiGroupsGroupCalendarViewEventInstancesEventDismissReminderRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.GroupsGroupCalendarViewEventInstancesEventDismissReminderExecute(r)
}

/*
GroupsGroupCalendarViewEventInstancesEventDismissReminder Invoke action dismissReminder

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupId key: id of group
 @param eventId key: id of event
 @param eventId1 key: id of event
 @return ApiGroupsGroupCalendarViewEventInstancesEventDismissReminderRequest
*/
func (a *GroupsActionsApiService) GroupsGroupCalendarViewEventInstancesEventDismissReminder(ctx _context.Context, groupId string, eventId string, eventId1 string) ApiGroupsGroupCalendarViewEventInstancesEventDismissReminderRequest {
	return ApiGroupsGroupCalendarViewEventInstancesEventDismissReminderRequest{
		ApiService: a,
		ctx: ctx,
		groupId: groupId,
		eventId: eventId,
		eventId1: eventId1,
	}
}

// Execute executes the request
func (a *GroupsActionsApiService) GroupsGroupCalendarViewEventInstancesEventDismissReminderExecute(r ApiGroupsGroupCalendarViewEventInstancesEventDismissReminderRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GroupsActionsApiService.GroupsGroupCalendarViewEventInstancesEventDismissReminder")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/groups/{group-id}/calendarView/{event-id}/instances/{event-id1}/microsoft.graph.dismissReminder"
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id1"+"}", _neturl.PathEscape(parameterToString(r.eventId1, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGroupsGroupCalendarViewEventInstancesEventForwardRequest struct {
	ctx _context.Context
	ApiService *GroupsActionsApiService
	groupId string
	eventId string
	eventId1 string
	inlineObject195 *InlineObject195
}

func (r ApiGroupsGroupCalendarViewEventInstancesEventForwardRequest) InlineObject195(inlineObject195 InlineObject195) ApiGroupsGroupCalendarViewEventInstancesEventForwardRequest {
	r.inlineObject195 = &inlineObject195
	return r
}

func (r ApiGroupsGroupCalendarViewEventInstancesEventForwardRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.GroupsGroupCalendarViewEventInstancesEventForwardExecute(r)
}

/*
GroupsGroupCalendarViewEventInstancesEventForward Invoke action forward

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupId key: id of group
 @param eventId key: id of event
 @param eventId1 key: id of event
 @return ApiGroupsGroupCalendarViewEventInstancesEventForwardRequest
*/
func (a *GroupsActionsApiService) GroupsGroupCalendarViewEventInstancesEventForward(ctx _context.Context, groupId string, eventId string, eventId1 string) ApiGroupsGroupCalendarViewEventInstancesEventForwardRequest {
	return ApiGroupsGroupCalendarViewEventInstancesEventForwardRequest{
		ApiService: a,
		ctx: ctx,
		groupId: groupId,
		eventId: eventId,
		eventId1: eventId1,
	}
}

// Execute executes the request
func (a *GroupsActionsApiService) GroupsGroupCalendarViewEventInstancesEventForwardExecute(r ApiGroupsGroupCalendarViewEventInstancesEventForwardRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GroupsActionsApiService.GroupsGroupCalendarViewEventInstancesEventForward")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/groups/{group-id}/calendarView/{event-id}/instances/{event-id1}/microsoft.graph.forward"
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id1"+"}", _neturl.PathEscape(parameterToString(r.eventId1, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject195 == nil {
		return nil, reportError("inlineObject195 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject195
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGroupsGroupCalendarViewEventInstancesEventSnoozeReminderRequest struct {
	ctx _context.Context
	ApiService *GroupsActionsApiService
	groupId string
	eventId string
	eventId1 string
	inlineObject196 *InlineObject196
}

func (r ApiGroupsGroupCalendarViewEventInstancesEventSnoozeReminderRequest) InlineObject196(inlineObject196 InlineObject196) ApiGroupsGroupCalendarViewEventInstancesEventSnoozeReminderRequest {
	r.inlineObject196 = &inlineObject196
	return r
}

func (r ApiGroupsGroupCalendarViewEventInstancesEventSnoozeReminderRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.GroupsGroupCalendarViewEventInstancesEventSnoozeReminderExecute(r)
}

/*
GroupsGroupCalendarViewEventInstancesEventSnoozeReminder Invoke action snoozeReminder

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupId key: id of group
 @param eventId key: id of event
 @param eventId1 key: id of event
 @return ApiGroupsGroupCalendarViewEventInstancesEventSnoozeReminderRequest
*/
func (a *GroupsActionsApiService) GroupsGroupCalendarViewEventInstancesEventSnoozeReminder(ctx _context.Context, groupId string, eventId string, eventId1 string) ApiGroupsGroupCalendarViewEventInstancesEventSnoozeReminderRequest {
	return ApiGroupsGroupCalendarViewEventInstancesEventSnoozeReminderRequest{
		ApiService: a,
		ctx: ctx,
		groupId: groupId,
		eventId: eventId,
		eventId1: eventId1,
	}
}

// Execute executes the request
func (a *GroupsActionsApiService) GroupsGroupCalendarViewEventInstancesEventSnoozeReminderExecute(r ApiGroupsGroupCalendarViewEventInstancesEventSnoozeReminderRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GroupsActionsApiService.GroupsGroupCalendarViewEventInstancesEventSnoozeReminder")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/groups/{group-id}/calendarView/{event-id}/instances/{event-id1}/microsoft.graph.snoozeReminder"
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id1"+"}", _neturl.PathEscape(parameterToString(r.eventId1, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject196 == nil {
		return nil, reportError("inlineObject196 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject196
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGroupsGroupCalendarViewEventInstancesEventTentativelyAcceptRequest struct {
	ctx _context.Context
	ApiService *GroupsActionsApiService
	groupId string
	eventId string
	eventId1 string
	inlineObject197 *InlineObject197
}

func (r ApiGroupsGroupCalendarViewEventInstancesEventTentativelyAcceptRequest) InlineObject197(inlineObject197 InlineObject197) ApiGroupsGroupCalendarViewEventInstancesEventTentativelyAcceptRequest {
	r.inlineObject197 = &inlineObject197
	return r
}

func (r ApiGroupsGroupCalendarViewEventInstancesEventTentativelyAcceptRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.GroupsGroupCalendarViewEventInstancesEventTentativelyAcceptExecute(r)
}

/*
GroupsGroupCalendarViewEventInstancesEventTentativelyAccept Invoke action tentativelyAccept

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupId key: id of group
 @param eventId key: id of event
 @param eventId1 key: id of event
 @return ApiGroupsGroupCalendarViewEventInstancesEventTentativelyAcceptRequest
*/
func (a *GroupsActionsApiService) GroupsGroupCalendarViewEventInstancesEventTentativelyAccept(ctx _context.Context, groupId string, eventId string, eventId1 string) ApiGroupsGroupCalendarViewEventInstancesEventTentativelyAcceptRequest {
	return ApiGroupsGroupCalendarViewEventInstancesEventTentativelyAcceptRequest{
		ApiService: a,
		ctx: ctx,
		groupId: groupId,
		eventId: eventId,
		eventId1: eventId1,
	}
}

// Execute executes the request
func (a *GroupsActionsApiService) GroupsGroupCalendarViewEventInstancesEventTentativelyAcceptExecute(r ApiGroupsGroupCalendarViewEventInstancesEventTentativelyAcceptRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GroupsActionsApiService.GroupsGroupCalendarViewEventInstancesEventTentativelyAccept")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/groups/{group-id}/calendarView/{event-id}/instances/{event-id1}/microsoft.graph.tentativelyAccept"
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id1"+"}", _neturl.PathEscape(parameterToString(r.eventId1, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject197 == nil {
		return nil, reportError("inlineObject197 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject197
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGroupsGroupCalendarViewEventSnoozeReminderRequest struct {
	ctx _context.Context
	ApiService *GroupsActionsApiService
	groupId string
	eventId string
	inlineObject202 *InlineObject202
}

func (r ApiGroupsGroupCalendarViewEventSnoozeReminderRequest) InlineObject202(inlineObject202 InlineObject202) ApiGroupsGroupCalendarViewEventSnoozeReminderRequest {
	r.inlineObject202 = &inlineObject202
	return r
}

func (r ApiGroupsGroupCalendarViewEventSnoozeReminderRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.GroupsGroupCalendarViewEventSnoozeReminderExecute(r)
}

/*
GroupsGroupCalendarViewEventSnoozeReminder Invoke action snoozeReminder

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupId key: id of group
 @param eventId key: id of event
 @return ApiGroupsGroupCalendarViewEventSnoozeReminderRequest
*/
func (a *GroupsActionsApiService) GroupsGroupCalendarViewEventSnoozeReminder(ctx _context.Context, groupId string, eventId string) ApiGroupsGroupCalendarViewEventSnoozeReminderRequest {
	return ApiGroupsGroupCalendarViewEventSnoozeReminderRequest{
		ApiService: a,
		ctx: ctx,
		groupId: groupId,
		eventId: eventId,
	}
}

// Execute executes the request
func (a *GroupsActionsApiService) GroupsGroupCalendarViewEventSnoozeReminderExecute(r ApiGroupsGroupCalendarViewEventSnoozeReminderRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GroupsActionsApiService.GroupsGroupCalendarViewEventSnoozeReminder")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/groups/{group-id}/calendarView/{event-id}/microsoft.graph.snoozeReminder"
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject202 == nil {
		return nil, reportError("inlineObject202 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject202
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGroupsGroupCalendarViewEventTentativelyAcceptRequest struct {
	ctx _context.Context
	ApiService *GroupsActionsApiService
	groupId string
	eventId string
	inlineObject203 *InlineObject203
}

func (r ApiGroupsGroupCalendarViewEventTentativelyAcceptRequest) InlineObject203(inlineObject203 InlineObject203) ApiGroupsGroupCalendarViewEventTentativelyAcceptRequest {
	r.inlineObject203 = &inlineObject203
	return r
}

func (r ApiGroupsGroupCalendarViewEventTentativelyAcceptRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.GroupsGroupCalendarViewEventTentativelyAcceptExecute(r)
}

/*
GroupsGroupCalendarViewEventTentativelyAccept Invoke action tentativelyAccept

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupId key: id of group
 @param eventId key: id of event
 @return ApiGroupsGroupCalendarViewEventTentativelyAcceptRequest
*/
func (a *GroupsActionsApiService) GroupsGroupCalendarViewEventTentativelyAccept(ctx _context.Context, groupId string, eventId string) ApiGroupsGroupCalendarViewEventTentativelyAcceptRequest {
	return ApiGroupsGroupCalendarViewEventTentativelyAcceptRequest{
		ApiService: a,
		ctx: ctx,
		groupId: groupId,
		eventId: eventId,
	}
}

// Execute executes the request
func (a *GroupsActionsApiService) GroupsGroupCalendarViewEventTentativelyAcceptExecute(r ApiGroupsGroupCalendarViewEventTentativelyAcceptRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GroupsActionsApiService.GroupsGroupCalendarViewEventTentativelyAccept")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/groups/{group-id}/calendarView/{event-id}/microsoft.graph.tentativelyAccept"
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject203 == nil {
		return nil, reportError("inlineObject203 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject203
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGroupsGroupCheckGrantedPermissionsForAppRequest struct {
	ctx _context.Context
	ApiService *GroupsActionsApiService
	groupId string
}


func (r ApiGroupsGroupCheckGrantedPermissionsForAppRequest) Execute() ([]*AnyOfmicrosoftGraphResourceSpecificPermissionGrant, *_nethttp.Response, error) {
	return r.ApiService.GroupsGroupCheckGrantedPermissionsForAppExecute(r)
}

/*
GroupsGroupCheckGrantedPermissionsForApp Invoke action checkGrantedPermissionsForApp

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupId key: id of group
 @return ApiGroupsGroupCheckGrantedPermissionsForAppRequest
*/
func (a *GroupsActionsApiService) GroupsGroupCheckGrantedPermissionsForApp(ctx _context.Context, groupId string) ApiGroupsGroupCheckGrantedPermissionsForAppRequest {
	return ApiGroupsGroupCheckGrantedPermissionsForAppRequest{
		ApiService: a,
		ctx: ctx,
		groupId: groupId,
	}
}

// Execute executes the request
//  @return []*AnyOfmicrosoftGraphResourceSpecificPermissionGrant
func (a *GroupsActionsApiService) GroupsGroupCheckGrantedPermissionsForAppExecute(r ApiGroupsGroupCheckGrantedPermissionsForAppRequest) ([]*AnyOfmicrosoftGraphResourceSpecificPermissionGrant, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  []*AnyOfmicrosoftGraphResourceSpecificPermissionGrant
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GroupsActionsApiService.GroupsGroupCheckGrantedPermissionsForApp")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/groups/{group-id}/microsoft.graph.checkGrantedPermissionsForApp"
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGroupsGroupCheckMemberGroupsRequest struct {
	ctx _context.Context
	ApiService *GroupsActionsApiService
	groupId string
	inlineObject237 *InlineObject237
}

func (r ApiGroupsGroupCheckMemberGroupsRequest) InlineObject237(inlineObject237 InlineObject237) ApiGroupsGroupCheckMemberGroupsRequest {
	r.inlineObject237 = &inlineObject237
	return r
}

func (r ApiGroupsGroupCheckMemberGroupsRequest) Execute() ([]string, *_nethttp.Response, error) {
	return r.ApiService.GroupsGroupCheckMemberGroupsExecute(r)
}

/*
GroupsGroupCheckMemberGroups Invoke action checkMemberGroups

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupId key: id of group
 @return ApiGroupsGroupCheckMemberGroupsRequest
*/
func (a *GroupsActionsApiService) GroupsGroupCheckMemberGroups(ctx _context.Context, groupId string) ApiGroupsGroupCheckMemberGroupsRequest {
	return ApiGroupsGroupCheckMemberGroupsRequest{
		ApiService: a,
		ctx: ctx,
		groupId: groupId,
	}
}

// Execute executes the request
//  @return []string
func (a *GroupsActionsApiService) GroupsGroupCheckMemberGroupsExecute(r ApiGroupsGroupCheckMemberGroupsRequest) ([]string, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  []string
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GroupsActionsApiService.GroupsGroupCheckMemberGroups")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/groups/{group-id}/microsoft.graph.checkMemberGroups"
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject237 == nil {
		return localVarReturnValue, nil, reportError("inlineObject237 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject237
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGroupsGroupCheckMemberObjectsRequest struct {
	ctx _context.Context
	ApiService *GroupsActionsApiService
	groupId string
	inlineObject238 *InlineObject238
}

func (r ApiGroupsGroupCheckMemberObjectsRequest) InlineObject238(inlineObject238 InlineObject238) ApiGroupsGroupCheckMemberObjectsRequest {
	r.inlineObject238 = &inlineObject238
	return r
}

func (r ApiGroupsGroupCheckMemberObjectsRequest) Execute() ([]string, *_nethttp.Response, error) {
	return r.ApiService.GroupsGroupCheckMemberObjectsExecute(r)
}

/*
GroupsGroupCheckMemberObjects Invoke action checkMemberObjects

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupId key: id of group
 @return ApiGroupsGroupCheckMemberObjectsRequest
*/
func (a *GroupsActionsApiService) GroupsGroupCheckMemberObjects(ctx _context.Context, groupId string) ApiGroupsGroupCheckMemberObjectsRequest {
	return ApiGroupsGroupCheckMemberObjectsRequest{
		ApiService: a,
		ctx: ctx,
		groupId: groupId,
	}
}

// Execute executes the request
//  @return []string
func (a *GroupsActionsApiService) GroupsGroupCheckMemberObjectsExecute(r ApiGroupsGroupCheckMemberObjectsRequest) ([]string, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  []string
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GroupsActionsApiService.GroupsGroupCheckMemberObjects")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/groups/{group-id}/microsoft.graph.checkMemberObjects"
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject238 == nil {
		return localVarReturnValue, nil, reportError("inlineObject238 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject238
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGroupsGroupConversationsConversationThreadsConversationThreadPostsPostAttachmentsCreateUploadSessionRequest struct {
	ctx _context.Context
	ApiService *GroupsActionsApiService
	groupId string
	conversationId string
	conversationThreadId string
	postId string
	inlineObject205 *InlineObject205
}

func (r ApiGroupsGroupConversationsConversationThreadsConversationThreadPostsPostAttachmentsCreateUploadSessionRequest) InlineObject205(inlineObject205 InlineObject205) ApiGroupsGroupConversationsConversationThreadsConversationThreadPostsPostAttachmentsCreateUploadSessionRequest {
	r.inlineObject205 = &inlineObject205
	return r
}

func (r ApiGroupsGroupConversationsConversationThreadsConversationThreadPostsPostAttachmentsCreateUploadSessionRequest) Execute() (AnyOfmicrosoftGraphUploadSession, *_nethttp.Response, error) {
	return r.ApiService.GroupsGroupConversationsConversationThreadsConversationThreadPostsPostAttachmentsCreateUploadSessionExecute(r)
}

/*
GroupsGroupConversationsConversationThreadsConversationThreadPostsPostAttachmentsCreateUploadSession Invoke action createUploadSession

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupId key: id of group
 @param conversationId key: id of conversation
 @param conversationThreadId key: id of conversationThread
 @param postId key: id of post
 @return ApiGroupsGroupConversationsConversationThreadsConversationThreadPostsPostAttachmentsCreateUploadSessionRequest
*/
func (a *GroupsActionsApiService) GroupsGroupConversationsConversationThreadsConversationThreadPostsPostAttachmentsCreateUploadSession(ctx _context.Context, groupId string, conversationId string, conversationThreadId string, postId string) ApiGroupsGroupConversationsConversationThreadsConversationThreadPostsPostAttachmentsCreateUploadSessionRequest {
	return ApiGroupsGroupConversationsConversationThreadsConversationThreadPostsPostAttachmentsCreateUploadSessionRequest{
		ApiService: a,
		ctx: ctx,
		groupId: groupId,
		conversationId: conversationId,
		conversationThreadId: conversationThreadId,
		postId: postId,
	}
}

// Execute executes the request
//  @return AnyOfmicrosoftGraphUploadSession
func (a *GroupsActionsApiService) GroupsGroupConversationsConversationThreadsConversationThreadPostsPostAttachmentsCreateUploadSessionExecute(r ApiGroupsGroupConversationsConversationThreadsConversationThreadPostsPostAttachmentsCreateUploadSessionRequest) (AnyOfmicrosoftGraphUploadSession, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  AnyOfmicrosoftGraphUploadSession
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GroupsActionsApiService.GroupsGroupConversationsConversationThreadsConversationThreadPostsPostAttachmentsCreateUploadSession")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/groups/{group-id}/conversations/{conversation-id}/threads/{conversationThread-id}/posts/{post-id}/attachments/microsoft.graph.createUploadSession"
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"conversation-id"+"}", _neturl.PathEscape(parameterToString(r.conversationId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"conversationThread-id"+"}", _neturl.PathEscape(parameterToString(r.conversationThreadId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"post-id"+"}", _neturl.PathEscape(parameterToString(r.postId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject205 == nil {
		return localVarReturnValue, nil, reportError("inlineObject205 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject205
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGroupsGroupConversationsConversationThreadsConversationThreadPostsPostForwardRequest struct {
	ctx _context.Context
	ApiService *GroupsActionsApiService
	groupId string
	conversationId string
	conversationThreadId string
	postId string
	inlineObject208 *InlineObject208
}

func (r ApiGroupsGroupConversationsConversationThreadsConversationThreadPostsPostForwardRequest) InlineObject208(inlineObject208 InlineObject208) ApiGroupsGroupConversationsConversationThreadsConversationThreadPostsPostForwardRequest {
	r.inlineObject208 = &inlineObject208
	return r
}

func (r ApiGroupsGroupConversationsConversationThreadsConversationThreadPostsPostForwardRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.GroupsGroupConversationsConversationThreadsConversationThreadPostsPostForwardExecute(r)
}

/*
GroupsGroupConversationsConversationThreadsConversationThreadPostsPostForward Invoke action forward

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupId key: id of group
 @param conversationId key: id of conversation
 @param conversationThreadId key: id of conversationThread
 @param postId key: id of post
 @return ApiGroupsGroupConversationsConversationThreadsConversationThreadPostsPostForwardRequest
*/
func (a *GroupsActionsApiService) GroupsGroupConversationsConversationThreadsConversationThreadPostsPostForward(ctx _context.Context, groupId string, conversationId string, conversationThreadId string, postId string) ApiGroupsGroupConversationsConversationThreadsConversationThreadPostsPostForwardRequest {
	return ApiGroupsGroupConversationsConversationThreadsConversationThreadPostsPostForwardRequest{
		ApiService: a,
		ctx: ctx,
		groupId: groupId,
		conversationId: conversationId,
		conversationThreadId: conversationThreadId,
		postId: postId,
	}
}

// Execute executes the request
func (a *GroupsActionsApiService) GroupsGroupConversationsConversationThreadsConversationThreadPostsPostForwardExecute(r ApiGroupsGroupConversationsConversationThreadsConversationThreadPostsPostForwardRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GroupsActionsApiService.GroupsGroupConversationsConversationThreadsConversationThreadPostsPostForward")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/groups/{group-id}/conversations/{conversation-id}/threads/{conversationThread-id}/posts/{post-id}/microsoft.graph.forward"
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"conversation-id"+"}", _neturl.PathEscape(parameterToString(r.conversationId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"conversationThread-id"+"}", _neturl.PathEscape(parameterToString(r.conversationThreadId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"post-id"+"}", _neturl.PathEscape(parameterToString(r.postId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject208 == nil {
		return nil, reportError("inlineObject208 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject208
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGroupsGroupConversationsConversationThreadsConversationThreadPostsPostInReplyToForwardRequest struct {
	ctx _context.Context
	ApiService *GroupsActionsApiService
	groupId string
	conversationId string
	conversationThreadId string
	postId string
	inlineObject206 *InlineObject206
}

func (r ApiGroupsGroupConversationsConversationThreadsConversationThreadPostsPostInReplyToForwardRequest) InlineObject206(inlineObject206 InlineObject206) ApiGroupsGroupConversationsConversationThreadsConversationThreadPostsPostInReplyToForwardRequest {
	r.inlineObject206 = &inlineObject206
	return r
}

func (r ApiGroupsGroupConversationsConversationThreadsConversationThreadPostsPostInReplyToForwardRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.GroupsGroupConversationsConversationThreadsConversationThreadPostsPostInReplyToForwardExecute(r)
}

/*
GroupsGroupConversationsConversationThreadsConversationThreadPostsPostInReplyToForward Invoke action forward

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupId key: id of group
 @param conversationId key: id of conversation
 @param conversationThreadId key: id of conversationThread
 @param postId key: id of post
 @return ApiGroupsGroupConversationsConversationThreadsConversationThreadPostsPostInReplyToForwardRequest
*/
func (a *GroupsActionsApiService) GroupsGroupConversationsConversationThreadsConversationThreadPostsPostInReplyToForward(ctx _context.Context, groupId string, conversationId string, conversationThreadId string, postId string) ApiGroupsGroupConversationsConversationThreadsConversationThreadPostsPostInReplyToForwardRequest {
	return ApiGroupsGroupConversationsConversationThreadsConversationThreadPostsPostInReplyToForwardRequest{
		ApiService: a,
		ctx: ctx,
		groupId: groupId,
		conversationId: conversationId,
		conversationThreadId: conversationThreadId,
		postId: postId,
	}
}

// Execute executes the request
func (a *GroupsActionsApiService) GroupsGroupConversationsConversationThreadsConversationThreadPostsPostInReplyToForwardExecute(r ApiGroupsGroupConversationsConversationThreadsConversationThreadPostsPostInReplyToForwardRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GroupsActionsApiService.GroupsGroupConversationsConversationThreadsConversationThreadPostsPostInReplyToForward")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/groups/{group-id}/conversations/{conversation-id}/threads/{conversationThread-id}/posts/{post-id}/inReplyTo/microsoft.graph.forward"
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"conversation-id"+"}", _neturl.PathEscape(parameterToString(r.conversationId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"conversationThread-id"+"}", _neturl.PathEscape(parameterToString(r.conversationThreadId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"post-id"+"}", _neturl.PathEscape(parameterToString(r.postId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject206 == nil {
		return nil, reportError("inlineObject206 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject206
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGroupsGroupConversationsConversationThreadsConversationThreadPostsPostInReplyToReplyRequest struct {
	ctx _context.Context
	ApiService *GroupsActionsApiService
	groupId string
	conversationId string
	conversationThreadId string
	postId string
	inlineObject207 *InlineObject207
}

func (r ApiGroupsGroupConversationsConversationThreadsConversationThreadPostsPostInReplyToReplyRequest) InlineObject207(inlineObject207 InlineObject207) ApiGroupsGroupConversationsConversationThreadsConversationThreadPostsPostInReplyToReplyRequest {
	r.inlineObject207 = &inlineObject207
	return r
}

func (r ApiGroupsGroupConversationsConversationThreadsConversationThreadPostsPostInReplyToReplyRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.GroupsGroupConversationsConversationThreadsConversationThreadPostsPostInReplyToReplyExecute(r)
}

/*
GroupsGroupConversationsConversationThreadsConversationThreadPostsPostInReplyToReply Invoke action reply

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupId key: id of group
 @param conversationId key: id of conversation
 @param conversationThreadId key: id of conversationThread
 @param postId key: id of post
 @return ApiGroupsGroupConversationsConversationThreadsConversationThreadPostsPostInReplyToReplyRequest
*/
func (a *GroupsActionsApiService) GroupsGroupConversationsConversationThreadsConversationThreadPostsPostInReplyToReply(ctx _context.Context, groupId string, conversationId string, conversationThreadId string, postId string) ApiGroupsGroupConversationsConversationThreadsConversationThreadPostsPostInReplyToReplyRequest {
	return ApiGroupsGroupConversationsConversationThreadsConversationThreadPostsPostInReplyToReplyRequest{
		ApiService: a,
		ctx: ctx,
		groupId: groupId,
		conversationId: conversationId,
		conversationThreadId: conversationThreadId,
		postId: postId,
	}
}

// Execute executes the request
func (a *GroupsActionsApiService) GroupsGroupConversationsConversationThreadsConversationThreadPostsPostInReplyToReplyExecute(r ApiGroupsGroupConversationsConversationThreadsConversationThreadPostsPostInReplyToReplyRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GroupsActionsApiService.GroupsGroupConversationsConversationThreadsConversationThreadPostsPostInReplyToReply")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/groups/{group-id}/conversations/{conversation-id}/threads/{conversationThread-id}/posts/{post-id}/inReplyTo/microsoft.graph.reply"
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"conversation-id"+"}", _neturl.PathEscape(parameterToString(r.conversationId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"conversationThread-id"+"}", _neturl.PathEscape(parameterToString(r.conversationThreadId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"post-id"+"}", _neturl.PathEscape(parameterToString(r.postId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject207 == nil {
		return nil, reportError("inlineObject207 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject207
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGroupsGroupConversationsConversationThreadsConversationThreadPostsPostReplyRequest struct {
	ctx _context.Context
	ApiService *GroupsActionsApiService
	groupId string
	conversationId string
	conversationThreadId string
	postId string
	inlineObject209 *InlineObject209
}

func (r ApiGroupsGroupConversationsConversationThreadsConversationThreadPostsPostReplyRequest) InlineObject209(inlineObject209 InlineObject209) ApiGroupsGroupConversationsConversationThreadsConversationThreadPostsPostReplyRequest {
	r.inlineObject209 = &inlineObject209
	return r
}

func (r ApiGroupsGroupConversationsConversationThreadsConversationThreadPostsPostReplyRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.GroupsGroupConversationsConversationThreadsConversationThreadPostsPostReplyExecute(r)
}

/*
GroupsGroupConversationsConversationThreadsConversationThreadPostsPostReply Invoke action reply

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupId key: id of group
 @param conversationId key: id of conversation
 @param conversationThreadId key: id of conversationThread
 @param postId key: id of post
 @return ApiGroupsGroupConversationsConversationThreadsConversationThreadPostsPostReplyRequest
*/
func (a *GroupsActionsApiService) GroupsGroupConversationsConversationThreadsConversationThreadPostsPostReply(ctx _context.Context, groupId string, conversationId string, conversationThreadId string, postId string) ApiGroupsGroupConversationsConversationThreadsConversationThreadPostsPostReplyRequest {
	return ApiGroupsGroupConversationsConversationThreadsConversationThreadPostsPostReplyRequest{
		ApiService: a,
		ctx: ctx,
		groupId: groupId,
		conversationId: conversationId,
		conversationThreadId: conversationThreadId,
		postId: postId,
	}
}

// Execute executes the request
func (a *GroupsActionsApiService) GroupsGroupConversationsConversationThreadsConversationThreadPostsPostReplyExecute(r ApiGroupsGroupConversationsConversationThreadsConversationThreadPostsPostReplyRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GroupsActionsApiService.GroupsGroupConversationsConversationThreadsConversationThreadPostsPostReply")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/groups/{group-id}/conversations/{conversation-id}/threads/{conversationThread-id}/posts/{post-id}/microsoft.graph.reply"
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"conversation-id"+"}", _neturl.PathEscape(parameterToString(r.conversationId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"conversationThread-id"+"}", _neturl.PathEscape(parameterToString(r.conversationThreadId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"post-id"+"}", _neturl.PathEscape(parameterToString(r.postId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject209 == nil {
		return nil, reportError("inlineObject209 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject209
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGroupsGroupConversationsConversationThreadsConversationThreadReplyRequest struct {
	ctx _context.Context
	ApiService *GroupsActionsApiService
	groupId string
	conversationId string
	conversationThreadId string
	inlineObject204 *InlineObject204
}

func (r ApiGroupsGroupConversationsConversationThreadsConversationThreadReplyRequest) InlineObject204(inlineObject204 InlineObject204) ApiGroupsGroupConversationsConversationThreadsConversationThreadReplyRequest {
	r.inlineObject204 = &inlineObject204
	return r
}

func (r ApiGroupsGroupConversationsConversationThreadsConversationThreadReplyRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.GroupsGroupConversationsConversationThreadsConversationThreadReplyExecute(r)
}

/*
GroupsGroupConversationsConversationThreadsConversationThreadReply Invoke action reply

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupId key: id of group
 @param conversationId key: id of conversation
 @param conversationThreadId key: id of conversationThread
 @return ApiGroupsGroupConversationsConversationThreadsConversationThreadReplyRequest
*/
func (a *GroupsActionsApiService) GroupsGroupConversationsConversationThreadsConversationThreadReply(ctx _context.Context, groupId string, conversationId string, conversationThreadId string) ApiGroupsGroupConversationsConversationThreadsConversationThreadReplyRequest {
	return ApiGroupsGroupConversationsConversationThreadsConversationThreadReplyRequest{
		ApiService: a,
		ctx: ctx,
		groupId: groupId,
		conversationId: conversationId,
		conversationThreadId: conversationThreadId,
	}
}

// Execute executes the request
func (a *GroupsActionsApiService) GroupsGroupConversationsConversationThreadsConversationThreadReplyExecute(r ApiGroupsGroupConversationsConversationThreadsConversationThreadReplyRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GroupsActionsApiService.GroupsGroupConversationsConversationThreadsConversationThreadReply")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/groups/{group-id}/conversations/{conversation-id}/threads/{conversationThread-id}/microsoft.graph.reply"
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"conversation-id"+"}", _neturl.PathEscape(parameterToString(r.conversationId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"conversationThread-id"+"}", _neturl.PathEscape(parameterToString(r.conversationThreadId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject204 == nil {
		return nil, reportError("inlineObject204 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject204
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGroupsGroupEventsEventAcceptRequest struct {
	ctx _context.Context
	ApiService *GroupsActionsApiService
	groupId string
	eventId string
	inlineObject230 *InlineObject230
}

func (r ApiGroupsGroupEventsEventAcceptRequest) InlineObject230(inlineObject230 InlineObject230) ApiGroupsGroupEventsEventAcceptRequest {
	r.inlineObject230 = &inlineObject230
	return r
}

func (r ApiGroupsGroupEventsEventAcceptRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.GroupsGroupEventsEventAcceptExecute(r)
}

/*
GroupsGroupEventsEventAccept Invoke action accept

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupId key: id of group
 @param eventId key: id of event
 @return ApiGroupsGroupEventsEventAcceptRequest
*/
func (a *GroupsActionsApiService) GroupsGroupEventsEventAccept(ctx _context.Context, groupId string, eventId string) ApiGroupsGroupEventsEventAcceptRequest {
	return ApiGroupsGroupEventsEventAcceptRequest{
		ApiService: a,
		ctx: ctx,
		groupId: groupId,
		eventId: eventId,
	}
}

// Execute executes the request
func (a *GroupsActionsApiService) GroupsGroupEventsEventAcceptExecute(r ApiGroupsGroupEventsEventAcceptRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GroupsActionsApiService.GroupsGroupEventsEventAccept")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/groups/{group-id}/events/{event-id}/microsoft.graph.accept"
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject230 == nil {
		return nil, reportError("inlineObject230 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject230
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGroupsGroupEventsEventAttachmentsCreateUploadSessionRequest struct {
	ctx _context.Context
	ApiService *GroupsActionsApiService
	groupId string
	eventId string
	inlineObject210 *InlineObject210
}

func (r ApiGroupsGroupEventsEventAttachmentsCreateUploadSessionRequest) InlineObject210(inlineObject210 InlineObject210) ApiGroupsGroupEventsEventAttachmentsCreateUploadSessionRequest {
	r.inlineObject210 = &inlineObject210
	return r
}

func (r ApiGroupsGroupEventsEventAttachmentsCreateUploadSessionRequest) Execute() (AnyOfmicrosoftGraphUploadSession, *_nethttp.Response, error) {
	return r.ApiService.GroupsGroupEventsEventAttachmentsCreateUploadSessionExecute(r)
}

/*
GroupsGroupEventsEventAttachmentsCreateUploadSession Invoke action createUploadSession

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupId key: id of group
 @param eventId key: id of event
 @return ApiGroupsGroupEventsEventAttachmentsCreateUploadSessionRequest
*/
func (a *GroupsActionsApiService) GroupsGroupEventsEventAttachmentsCreateUploadSession(ctx _context.Context, groupId string, eventId string) ApiGroupsGroupEventsEventAttachmentsCreateUploadSessionRequest {
	return ApiGroupsGroupEventsEventAttachmentsCreateUploadSessionRequest{
		ApiService: a,
		ctx: ctx,
		groupId: groupId,
		eventId: eventId,
	}
}

// Execute executes the request
//  @return AnyOfmicrosoftGraphUploadSession
func (a *GroupsActionsApiService) GroupsGroupEventsEventAttachmentsCreateUploadSessionExecute(r ApiGroupsGroupEventsEventAttachmentsCreateUploadSessionRequest) (AnyOfmicrosoftGraphUploadSession, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  AnyOfmicrosoftGraphUploadSession
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GroupsActionsApiService.GroupsGroupEventsEventAttachmentsCreateUploadSession")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/groups/{group-id}/events/{event-id}/attachments/microsoft.graph.createUploadSession"
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject210 == nil {
		return localVarReturnValue, nil, reportError("inlineObject210 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject210
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGroupsGroupEventsEventCalendarCalendarViewEventAcceptRequest struct {
	ctx _context.Context
	ApiService *GroupsActionsApiService
	groupId string
	eventId string
	eventId1 string
	inlineObject211 *InlineObject211
}

func (r ApiGroupsGroupEventsEventCalendarCalendarViewEventAcceptRequest) InlineObject211(inlineObject211 InlineObject211) ApiGroupsGroupEventsEventCalendarCalendarViewEventAcceptRequest {
	r.inlineObject211 = &inlineObject211
	return r
}

func (r ApiGroupsGroupEventsEventCalendarCalendarViewEventAcceptRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.GroupsGroupEventsEventCalendarCalendarViewEventAcceptExecute(r)
}

/*
GroupsGroupEventsEventCalendarCalendarViewEventAccept Invoke action accept

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupId key: id of group
 @param eventId key: id of event
 @param eventId1 key: id of event
 @return ApiGroupsGroupEventsEventCalendarCalendarViewEventAcceptRequest
*/
func (a *GroupsActionsApiService) GroupsGroupEventsEventCalendarCalendarViewEventAccept(ctx _context.Context, groupId string, eventId string, eventId1 string) ApiGroupsGroupEventsEventCalendarCalendarViewEventAcceptRequest {
	return ApiGroupsGroupEventsEventCalendarCalendarViewEventAcceptRequest{
		ApiService: a,
		ctx: ctx,
		groupId: groupId,
		eventId: eventId,
		eventId1: eventId1,
	}
}

// Execute executes the request
func (a *GroupsActionsApiService) GroupsGroupEventsEventCalendarCalendarViewEventAcceptExecute(r ApiGroupsGroupEventsEventCalendarCalendarViewEventAcceptRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GroupsActionsApiService.GroupsGroupEventsEventCalendarCalendarViewEventAccept")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/groups/{group-id}/events/{event-id}/calendar/calendarView/{event-id1}/microsoft.graph.accept"
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id1"+"}", _neturl.PathEscape(parameterToString(r.eventId1, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject211 == nil {
		return nil, reportError("inlineObject211 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject211
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGroupsGroupEventsEventCalendarCalendarViewEventCancelRequest struct {
	ctx _context.Context
	ApiService *GroupsActionsApiService
	groupId string
	eventId string
	eventId1 string
	inlineObject212 *InlineObject212
}

func (r ApiGroupsGroupEventsEventCalendarCalendarViewEventCancelRequest) InlineObject212(inlineObject212 InlineObject212) ApiGroupsGroupEventsEventCalendarCalendarViewEventCancelRequest {
	r.inlineObject212 = &inlineObject212
	return r
}

func (r ApiGroupsGroupEventsEventCalendarCalendarViewEventCancelRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.GroupsGroupEventsEventCalendarCalendarViewEventCancelExecute(r)
}

/*
GroupsGroupEventsEventCalendarCalendarViewEventCancel Invoke action cancel

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupId key: id of group
 @param eventId key: id of event
 @param eventId1 key: id of event
 @return ApiGroupsGroupEventsEventCalendarCalendarViewEventCancelRequest
*/
func (a *GroupsActionsApiService) GroupsGroupEventsEventCalendarCalendarViewEventCancel(ctx _context.Context, groupId string, eventId string, eventId1 string) ApiGroupsGroupEventsEventCalendarCalendarViewEventCancelRequest {
	return ApiGroupsGroupEventsEventCalendarCalendarViewEventCancelRequest{
		ApiService: a,
		ctx: ctx,
		groupId: groupId,
		eventId: eventId,
		eventId1: eventId1,
	}
}

// Execute executes the request
func (a *GroupsActionsApiService) GroupsGroupEventsEventCalendarCalendarViewEventCancelExecute(r ApiGroupsGroupEventsEventCalendarCalendarViewEventCancelRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GroupsActionsApiService.GroupsGroupEventsEventCalendarCalendarViewEventCancel")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/groups/{group-id}/events/{event-id}/calendar/calendarView/{event-id1}/microsoft.graph.cancel"
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id1"+"}", _neturl.PathEscape(parameterToString(r.eventId1, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject212 == nil {
		return nil, reportError("inlineObject212 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject212
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGroupsGroupEventsEventCalendarCalendarViewEventDeclineRequest struct {
	ctx _context.Context
	ApiService *GroupsActionsApiService
	groupId string
	eventId string
	eventId1 string
	inlineObject213 *InlineObject213
}

func (r ApiGroupsGroupEventsEventCalendarCalendarViewEventDeclineRequest) InlineObject213(inlineObject213 InlineObject213) ApiGroupsGroupEventsEventCalendarCalendarViewEventDeclineRequest {
	r.inlineObject213 = &inlineObject213
	return r
}

func (r ApiGroupsGroupEventsEventCalendarCalendarViewEventDeclineRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.GroupsGroupEventsEventCalendarCalendarViewEventDeclineExecute(r)
}

/*
GroupsGroupEventsEventCalendarCalendarViewEventDecline Invoke action decline

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupId key: id of group
 @param eventId key: id of event
 @param eventId1 key: id of event
 @return ApiGroupsGroupEventsEventCalendarCalendarViewEventDeclineRequest
*/
func (a *GroupsActionsApiService) GroupsGroupEventsEventCalendarCalendarViewEventDecline(ctx _context.Context, groupId string, eventId string, eventId1 string) ApiGroupsGroupEventsEventCalendarCalendarViewEventDeclineRequest {
	return ApiGroupsGroupEventsEventCalendarCalendarViewEventDeclineRequest{
		ApiService: a,
		ctx: ctx,
		groupId: groupId,
		eventId: eventId,
		eventId1: eventId1,
	}
}

// Execute executes the request
func (a *GroupsActionsApiService) GroupsGroupEventsEventCalendarCalendarViewEventDeclineExecute(r ApiGroupsGroupEventsEventCalendarCalendarViewEventDeclineRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GroupsActionsApiService.GroupsGroupEventsEventCalendarCalendarViewEventDecline")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/groups/{group-id}/events/{event-id}/calendar/calendarView/{event-id1}/microsoft.graph.decline"
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id1"+"}", _neturl.PathEscape(parameterToString(r.eventId1, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject213 == nil {
		return nil, reportError("inlineObject213 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject213
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGroupsGroupEventsEventCalendarCalendarViewEventDismissReminderRequest struct {
	ctx _context.Context
	ApiService *GroupsActionsApiService
	groupId string
	eventId string
	eventId1 string
}


func (r ApiGroupsGroupEventsEventCalendarCalendarViewEventDismissReminderRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.GroupsGroupEventsEventCalendarCalendarViewEventDismissReminderExecute(r)
}

/*
GroupsGroupEventsEventCalendarCalendarViewEventDismissReminder Invoke action dismissReminder

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupId key: id of group
 @param eventId key: id of event
 @param eventId1 key: id of event
 @return ApiGroupsGroupEventsEventCalendarCalendarViewEventDismissReminderRequest
*/
func (a *GroupsActionsApiService) GroupsGroupEventsEventCalendarCalendarViewEventDismissReminder(ctx _context.Context, groupId string, eventId string, eventId1 string) ApiGroupsGroupEventsEventCalendarCalendarViewEventDismissReminderRequest {
	return ApiGroupsGroupEventsEventCalendarCalendarViewEventDismissReminderRequest{
		ApiService: a,
		ctx: ctx,
		groupId: groupId,
		eventId: eventId,
		eventId1: eventId1,
	}
}

// Execute executes the request
func (a *GroupsActionsApiService) GroupsGroupEventsEventCalendarCalendarViewEventDismissReminderExecute(r ApiGroupsGroupEventsEventCalendarCalendarViewEventDismissReminderRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GroupsActionsApiService.GroupsGroupEventsEventCalendarCalendarViewEventDismissReminder")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/groups/{group-id}/events/{event-id}/calendar/calendarView/{event-id1}/microsoft.graph.dismissReminder"
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id1"+"}", _neturl.PathEscape(parameterToString(r.eventId1, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGroupsGroupEventsEventCalendarCalendarViewEventForwardRequest struct {
	ctx _context.Context
	ApiService *GroupsActionsApiService
	groupId string
	eventId string
	eventId1 string
	inlineObject214 *InlineObject214
}

func (r ApiGroupsGroupEventsEventCalendarCalendarViewEventForwardRequest) InlineObject214(inlineObject214 InlineObject214) ApiGroupsGroupEventsEventCalendarCalendarViewEventForwardRequest {
	r.inlineObject214 = &inlineObject214
	return r
}

func (r ApiGroupsGroupEventsEventCalendarCalendarViewEventForwardRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.GroupsGroupEventsEventCalendarCalendarViewEventForwardExecute(r)
}

/*
GroupsGroupEventsEventCalendarCalendarViewEventForward Invoke action forward

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupId key: id of group
 @param eventId key: id of event
 @param eventId1 key: id of event
 @return ApiGroupsGroupEventsEventCalendarCalendarViewEventForwardRequest
*/
func (a *GroupsActionsApiService) GroupsGroupEventsEventCalendarCalendarViewEventForward(ctx _context.Context, groupId string, eventId string, eventId1 string) ApiGroupsGroupEventsEventCalendarCalendarViewEventForwardRequest {
	return ApiGroupsGroupEventsEventCalendarCalendarViewEventForwardRequest{
		ApiService: a,
		ctx: ctx,
		groupId: groupId,
		eventId: eventId,
		eventId1: eventId1,
	}
}

// Execute executes the request
func (a *GroupsActionsApiService) GroupsGroupEventsEventCalendarCalendarViewEventForwardExecute(r ApiGroupsGroupEventsEventCalendarCalendarViewEventForwardRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GroupsActionsApiService.GroupsGroupEventsEventCalendarCalendarViewEventForward")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/groups/{group-id}/events/{event-id}/calendar/calendarView/{event-id1}/microsoft.graph.forward"
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id1"+"}", _neturl.PathEscape(parameterToString(r.eventId1, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject214 == nil {
		return nil, reportError("inlineObject214 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject214
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGroupsGroupEventsEventCalendarCalendarViewEventSnoozeReminderRequest struct {
	ctx _context.Context
	ApiService *GroupsActionsApiService
	groupId string
	eventId string
	eventId1 string
	inlineObject215 *InlineObject215
}

func (r ApiGroupsGroupEventsEventCalendarCalendarViewEventSnoozeReminderRequest) InlineObject215(inlineObject215 InlineObject215) ApiGroupsGroupEventsEventCalendarCalendarViewEventSnoozeReminderRequest {
	r.inlineObject215 = &inlineObject215
	return r
}

func (r ApiGroupsGroupEventsEventCalendarCalendarViewEventSnoozeReminderRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.GroupsGroupEventsEventCalendarCalendarViewEventSnoozeReminderExecute(r)
}

/*
GroupsGroupEventsEventCalendarCalendarViewEventSnoozeReminder Invoke action snoozeReminder

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupId key: id of group
 @param eventId key: id of event
 @param eventId1 key: id of event
 @return ApiGroupsGroupEventsEventCalendarCalendarViewEventSnoozeReminderRequest
*/
func (a *GroupsActionsApiService) GroupsGroupEventsEventCalendarCalendarViewEventSnoozeReminder(ctx _context.Context, groupId string, eventId string, eventId1 string) ApiGroupsGroupEventsEventCalendarCalendarViewEventSnoozeReminderRequest {
	return ApiGroupsGroupEventsEventCalendarCalendarViewEventSnoozeReminderRequest{
		ApiService: a,
		ctx: ctx,
		groupId: groupId,
		eventId: eventId,
		eventId1: eventId1,
	}
}

// Execute executes the request
func (a *GroupsActionsApiService) GroupsGroupEventsEventCalendarCalendarViewEventSnoozeReminderExecute(r ApiGroupsGroupEventsEventCalendarCalendarViewEventSnoozeReminderRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GroupsActionsApiService.GroupsGroupEventsEventCalendarCalendarViewEventSnoozeReminder")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/groups/{group-id}/events/{event-id}/calendar/calendarView/{event-id1}/microsoft.graph.snoozeReminder"
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id1"+"}", _neturl.PathEscape(parameterToString(r.eventId1, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject215 == nil {
		return nil, reportError("inlineObject215 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject215
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGroupsGroupEventsEventCalendarCalendarViewEventTentativelyAcceptRequest struct {
	ctx _context.Context
	ApiService *GroupsActionsApiService
	groupId string
	eventId string
	eventId1 string
	inlineObject216 *InlineObject216
}

func (r ApiGroupsGroupEventsEventCalendarCalendarViewEventTentativelyAcceptRequest) InlineObject216(inlineObject216 InlineObject216) ApiGroupsGroupEventsEventCalendarCalendarViewEventTentativelyAcceptRequest {
	r.inlineObject216 = &inlineObject216
	return r
}

func (r ApiGroupsGroupEventsEventCalendarCalendarViewEventTentativelyAcceptRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.GroupsGroupEventsEventCalendarCalendarViewEventTentativelyAcceptExecute(r)
}

/*
GroupsGroupEventsEventCalendarCalendarViewEventTentativelyAccept Invoke action tentativelyAccept

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupId key: id of group
 @param eventId key: id of event
 @param eventId1 key: id of event
 @return ApiGroupsGroupEventsEventCalendarCalendarViewEventTentativelyAcceptRequest
*/
func (a *GroupsActionsApiService) GroupsGroupEventsEventCalendarCalendarViewEventTentativelyAccept(ctx _context.Context, groupId string, eventId string, eventId1 string) ApiGroupsGroupEventsEventCalendarCalendarViewEventTentativelyAcceptRequest {
	return ApiGroupsGroupEventsEventCalendarCalendarViewEventTentativelyAcceptRequest{
		ApiService: a,
		ctx: ctx,
		groupId: groupId,
		eventId: eventId,
		eventId1: eventId1,
	}
}

// Execute executes the request
func (a *GroupsActionsApiService) GroupsGroupEventsEventCalendarCalendarViewEventTentativelyAcceptExecute(r ApiGroupsGroupEventsEventCalendarCalendarViewEventTentativelyAcceptRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GroupsActionsApiService.GroupsGroupEventsEventCalendarCalendarViewEventTentativelyAccept")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/groups/{group-id}/events/{event-id}/calendar/calendarView/{event-id1}/microsoft.graph.tentativelyAccept"
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id1"+"}", _neturl.PathEscape(parameterToString(r.eventId1, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject216 == nil {
		return nil, reportError("inlineObject216 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject216
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGroupsGroupEventsEventCalendarEventsEventAcceptRequest struct {
	ctx _context.Context
	ApiService *GroupsActionsApiService
	groupId string
	eventId string
	eventId1 string
	inlineObject217 *InlineObject217
}

func (r ApiGroupsGroupEventsEventCalendarEventsEventAcceptRequest) InlineObject217(inlineObject217 InlineObject217) ApiGroupsGroupEventsEventCalendarEventsEventAcceptRequest {
	r.inlineObject217 = &inlineObject217
	return r
}

func (r ApiGroupsGroupEventsEventCalendarEventsEventAcceptRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.GroupsGroupEventsEventCalendarEventsEventAcceptExecute(r)
}

/*
GroupsGroupEventsEventCalendarEventsEventAccept Invoke action accept

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupId key: id of group
 @param eventId key: id of event
 @param eventId1 key: id of event
 @return ApiGroupsGroupEventsEventCalendarEventsEventAcceptRequest
*/
func (a *GroupsActionsApiService) GroupsGroupEventsEventCalendarEventsEventAccept(ctx _context.Context, groupId string, eventId string, eventId1 string) ApiGroupsGroupEventsEventCalendarEventsEventAcceptRequest {
	return ApiGroupsGroupEventsEventCalendarEventsEventAcceptRequest{
		ApiService: a,
		ctx: ctx,
		groupId: groupId,
		eventId: eventId,
		eventId1: eventId1,
	}
}

// Execute executes the request
func (a *GroupsActionsApiService) GroupsGroupEventsEventCalendarEventsEventAcceptExecute(r ApiGroupsGroupEventsEventCalendarEventsEventAcceptRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GroupsActionsApiService.GroupsGroupEventsEventCalendarEventsEventAccept")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/groups/{group-id}/events/{event-id}/calendar/events/{event-id1}/microsoft.graph.accept"
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id1"+"}", _neturl.PathEscape(parameterToString(r.eventId1, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject217 == nil {
		return nil, reportError("inlineObject217 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject217
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGroupsGroupEventsEventCalendarEventsEventCancelRequest struct {
	ctx _context.Context
	ApiService *GroupsActionsApiService
	groupId string
	eventId string
	eventId1 string
	inlineObject218 *InlineObject218
}

func (r ApiGroupsGroupEventsEventCalendarEventsEventCancelRequest) InlineObject218(inlineObject218 InlineObject218) ApiGroupsGroupEventsEventCalendarEventsEventCancelRequest {
	r.inlineObject218 = &inlineObject218
	return r
}

func (r ApiGroupsGroupEventsEventCalendarEventsEventCancelRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.GroupsGroupEventsEventCalendarEventsEventCancelExecute(r)
}

/*
GroupsGroupEventsEventCalendarEventsEventCancel Invoke action cancel

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupId key: id of group
 @param eventId key: id of event
 @param eventId1 key: id of event
 @return ApiGroupsGroupEventsEventCalendarEventsEventCancelRequest
*/
func (a *GroupsActionsApiService) GroupsGroupEventsEventCalendarEventsEventCancel(ctx _context.Context, groupId string, eventId string, eventId1 string) ApiGroupsGroupEventsEventCalendarEventsEventCancelRequest {
	return ApiGroupsGroupEventsEventCalendarEventsEventCancelRequest{
		ApiService: a,
		ctx: ctx,
		groupId: groupId,
		eventId: eventId,
		eventId1: eventId1,
	}
}

// Execute executes the request
func (a *GroupsActionsApiService) GroupsGroupEventsEventCalendarEventsEventCancelExecute(r ApiGroupsGroupEventsEventCalendarEventsEventCancelRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GroupsActionsApiService.GroupsGroupEventsEventCalendarEventsEventCancel")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/groups/{group-id}/events/{event-id}/calendar/events/{event-id1}/microsoft.graph.cancel"
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id1"+"}", _neturl.PathEscape(parameterToString(r.eventId1, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject218 == nil {
		return nil, reportError("inlineObject218 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject218
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGroupsGroupEventsEventCalendarEventsEventDeclineRequest struct {
	ctx _context.Context
	ApiService *GroupsActionsApiService
	groupId string
	eventId string
	eventId1 string
	inlineObject219 *InlineObject219
}

func (r ApiGroupsGroupEventsEventCalendarEventsEventDeclineRequest) InlineObject219(inlineObject219 InlineObject219) ApiGroupsGroupEventsEventCalendarEventsEventDeclineRequest {
	r.inlineObject219 = &inlineObject219
	return r
}

func (r ApiGroupsGroupEventsEventCalendarEventsEventDeclineRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.GroupsGroupEventsEventCalendarEventsEventDeclineExecute(r)
}

/*
GroupsGroupEventsEventCalendarEventsEventDecline Invoke action decline

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupId key: id of group
 @param eventId key: id of event
 @param eventId1 key: id of event
 @return ApiGroupsGroupEventsEventCalendarEventsEventDeclineRequest
*/
func (a *GroupsActionsApiService) GroupsGroupEventsEventCalendarEventsEventDecline(ctx _context.Context, groupId string, eventId string, eventId1 string) ApiGroupsGroupEventsEventCalendarEventsEventDeclineRequest {
	return ApiGroupsGroupEventsEventCalendarEventsEventDeclineRequest{
		ApiService: a,
		ctx: ctx,
		groupId: groupId,
		eventId: eventId,
		eventId1: eventId1,
	}
}

// Execute executes the request
func (a *GroupsActionsApiService) GroupsGroupEventsEventCalendarEventsEventDeclineExecute(r ApiGroupsGroupEventsEventCalendarEventsEventDeclineRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GroupsActionsApiService.GroupsGroupEventsEventCalendarEventsEventDecline")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/groups/{group-id}/events/{event-id}/calendar/events/{event-id1}/microsoft.graph.decline"
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id1"+"}", _neturl.PathEscape(parameterToString(r.eventId1, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject219 == nil {
		return nil, reportError("inlineObject219 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject219
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGroupsGroupEventsEventCalendarEventsEventDismissReminderRequest struct {
	ctx _context.Context
	ApiService *GroupsActionsApiService
	groupId string
	eventId string
	eventId1 string
}


func (r ApiGroupsGroupEventsEventCalendarEventsEventDismissReminderRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.GroupsGroupEventsEventCalendarEventsEventDismissReminderExecute(r)
}

/*
GroupsGroupEventsEventCalendarEventsEventDismissReminder Invoke action dismissReminder

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupId key: id of group
 @param eventId key: id of event
 @param eventId1 key: id of event
 @return ApiGroupsGroupEventsEventCalendarEventsEventDismissReminderRequest
*/
func (a *GroupsActionsApiService) GroupsGroupEventsEventCalendarEventsEventDismissReminder(ctx _context.Context, groupId string, eventId string, eventId1 string) ApiGroupsGroupEventsEventCalendarEventsEventDismissReminderRequest {
	return ApiGroupsGroupEventsEventCalendarEventsEventDismissReminderRequest{
		ApiService: a,
		ctx: ctx,
		groupId: groupId,
		eventId: eventId,
		eventId1: eventId1,
	}
}

// Execute executes the request
func (a *GroupsActionsApiService) GroupsGroupEventsEventCalendarEventsEventDismissReminderExecute(r ApiGroupsGroupEventsEventCalendarEventsEventDismissReminderRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GroupsActionsApiService.GroupsGroupEventsEventCalendarEventsEventDismissReminder")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/groups/{group-id}/events/{event-id}/calendar/events/{event-id1}/microsoft.graph.dismissReminder"
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id1"+"}", _neturl.PathEscape(parameterToString(r.eventId1, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGroupsGroupEventsEventCalendarEventsEventForwardRequest struct {
	ctx _context.Context
	ApiService *GroupsActionsApiService
	groupId string
	eventId string
	eventId1 string
	inlineObject220 *InlineObject220
}

func (r ApiGroupsGroupEventsEventCalendarEventsEventForwardRequest) InlineObject220(inlineObject220 InlineObject220) ApiGroupsGroupEventsEventCalendarEventsEventForwardRequest {
	r.inlineObject220 = &inlineObject220
	return r
}

func (r ApiGroupsGroupEventsEventCalendarEventsEventForwardRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.GroupsGroupEventsEventCalendarEventsEventForwardExecute(r)
}

/*
GroupsGroupEventsEventCalendarEventsEventForward Invoke action forward

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupId key: id of group
 @param eventId key: id of event
 @param eventId1 key: id of event
 @return ApiGroupsGroupEventsEventCalendarEventsEventForwardRequest
*/
func (a *GroupsActionsApiService) GroupsGroupEventsEventCalendarEventsEventForward(ctx _context.Context, groupId string, eventId string, eventId1 string) ApiGroupsGroupEventsEventCalendarEventsEventForwardRequest {
	return ApiGroupsGroupEventsEventCalendarEventsEventForwardRequest{
		ApiService: a,
		ctx: ctx,
		groupId: groupId,
		eventId: eventId,
		eventId1: eventId1,
	}
}

// Execute executes the request
func (a *GroupsActionsApiService) GroupsGroupEventsEventCalendarEventsEventForwardExecute(r ApiGroupsGroupEventsEventCalendarEventsEventForwardRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GroupsActionsApiService.GroupsGroupEventsEventCalendarEventsEventForward")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/groups/{group-id}/events/{event-id}/calendar/events/{event-id1}/microsoft.graph.forward"
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id1"+"}", _neturl.PathEscape(parameterToString(r.eventId1, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject220 == nil {
		return nil, reportError("inlineObject220 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject220
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGroupsGroupEventsEventCalendarEventsEventSnoozeReminderRequest struct {
	ctx _context.Context
	ApiService *GroupsActionsApiService
	groupId string
	eventId string
	eventId1 string
	inlineObject221 *InlineObject221
}

func (r ApiGroupsGroupEventsEventCalendarEventsEventSnoozeReminderRequest) InlineObject221(inlineObject221 InlineObject221) ApiGroupsGroupEventsEventCalendarEventsEventSnoozeReminderRequest {
	r.inlineObject221 = &inlineObject221
	return r
}

func (r ApiGroupsGroupEventsEventCalendarEventsEventSnoozeReminderRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.GroupsGroupEventsEventCalendarEventsEventSnoozeReminderExecute(r)
}

/*
GroupsGroupEventsEventCalendarEventsEventSnoozeReminder Invoke action snoozeReminder

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupId key: id of group
 @param eventId key: id of event
 @param eventId1 key: id of event
 @return ApiGroupsGroupEventsEventCalendarEventsEventSnoozeReminderRequest
*/
func (a *GroupsActionsApiService) GroupsGroupEventsEventCalendarEventsEventSnoozeReminder(ctx _context.Context, groupId string, eventId string, eventId1 string) ApiGroupsGroupEventsEventCalendarEventsEventSnoozeReminderRequest {
	return ApiGroupsGroupEventsEventCalendarEventsEventSnoozeReminderRequest{
		ApiService: a,
		ctx: ctx,
		groupId: groupId,
		eventId: eventId,
		eventId1: eventId1,
	}
}

// Execute executes the request
func (a *GroupsActionsApiService) GroupsGroupEventsEventCalendarEventsEventSnoozeReminderExecute(r ApiGroupsGroupEventsEventCalendarEventsEventSnoozeReminderRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GroupsActionsApiService.GroupsGroupEventsEventCalendarEventsEventSnoozeReminder")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/groups/{group-id}/events/{event-id}/calendar/events/{event-id1}/microsoft.graph.snoozeReminder"
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id1"+"}", _neturl.PathEscape(parameterToString(r.eventId1, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject221 == nil {
		return nil, reportError("inlineObject221 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject221
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGroupsGroupEventsEventCalendarEventsEventTentativelyAcceptRequest struct {
	ctx _context.Context
	ApiService *GroupsActionsApiService
	groupId string
	eventId string
	eventId1 string
	inlineObject222 *InlineObject222
}

func (r ApiGroupsGroupEventsEventCalendarEventsEventTentativelyAcceptRequest) InlineObject222(inlineObject222 InlineObject222) ApiGroupsGroupEventsEventCalendarEventsEventTentativelyAcceptRequest {
	r.inlineObject222 = &inlineObject222
	return r
}

func (r ApiGroupsGroupEventsEventCalendarEventsEventTentativelyAcceptRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.GroupsGroupEventsEventCalendarEventsEventTentativelyAcceptExecute(r)
}

/*
GroupsGroupEventsEventCalendarEventsEventTentativelyAccept Invoke action tentativelyAccept

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupId key: id of group
 @param eventId key: id of event
 @param eventId1 key: id of event
 @return ApiGroupsGroupEventsEventCalendarEventsEventTentativelyAcceptRequest
*/
func (a *GroupsActionsApiService) GroupsGroupEventsEventCalendarEventsEventTentativelyAccept(ctx _context.Context, groupId string, eventId string, eventId1 string) ApiGroupsGroupEventsEventCalendarEventsEventTentativelyAcceptRequest {
	return ApiGroupsGroupEventsEventCalendarEventsEventTentativelyAcceptRequest{
		ApiService: a,
		ctx: ctx,
		groupId: groupId,
		eventId: eventId,
		eventId1: eventId1,
	}
}

// Execute executes the request
func (a *GroupsActionsApiService) GroupsGroupEventsEventCalendarEventsEventTentativelyAcceptExecute(r ApiGroupsGroupEventsEventCalendarEventsEventTentativelyAcceptRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GroupsActionsApiService.GroupsGroupEventsEventCalendarEventsEventTentativelyAccept")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/groups/{group-id}/events/{event-id}/calendar/events/{event-id1}/microsoft.graph.tentativelyAccept"
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id1"+"}", _neturl.PathEscape(parameterToString(r.eventId1, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject222 == nil {
		return nil, reportError("inlineObject222 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject222
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGroupsGroupEventsEventCalendarGetScheduleRequest struct {
	ctx _context.Context
	ApiService *GroupsActionsApiService
	groupId string
	eventId string
	inlineObject223 *InlineObject223
}

func (r ApiGroupsGroupEventsEventCalendarGetScheduleRequest) InlineObject223(inlineObject223 InlineObject223) ApiGroupsGroupEventsEventCalendarGetScheduleRequest {
	r.inlineObject223 = &inlineObject223
	return r
}

func (r ApiGroupsGroupEventsEventCalendarGetScheduleRequest) Execute() ([]*AnyOfmicrosoftGraphScheduleInformation, *_nethttp.Response, error) {
	return r.ApiService.GroupsGroupEventsEventCalendarGetScheduleExecute(r)
}

/*
GroupsGroupEventsEventCalendarGetSchedule Invoke action getSchedule

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupId key: id of group
 @param eventId key: id of event
 @return ApiGroupsGroupEventsEventCalendarGetScheduleRequest
*/
func (a *GroupsActionsApiService) GroupsGroupEventsEventCalendarGetSchedule(ctx _context.Context, groupId string, eventId string) ApiGroupsGroupEventsEventCalendarGetScheduleRequest {
	return ApiGroupsGroupEventsEventCalendarGetScheduleRequest{
		ApiService: a,
		ctx: ctx,
		groupId: groupId,
		eventId: eventId,
	}
}

// Execute executes the request
//  @return []*AnyOfmicrosoftGraphScheduleInformation
func (a *GroupsActionsApiService) GroupsGroupEventsEventCalendarGetScheduleExecute(r ApiGroupsGroupEventsEventCalendarGetScheduleRequest) ([]*AnyOfmicrosoftGraphScheduleInformation, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  []*AnyOfmicrosoftGraphScheduleInformation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GroupsActionsApiService.GroupsGroupEventsEventCalendarGetSchedule")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/groups/{group-id}/events/{event-id}/calendar/microsoft.graph.getSchedule"
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject223 == nil {
		return localVarReturnValue, nil, reportError("inlineObject223 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject223
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGroupsGroupEventsEventCancelRequest struct {
	ctx _context.Context
	ApiService *GroupsActionsApiService
	groupId string
	eventId string
	inlineObject231 *InlineObject231
}

func (r ApiGroupsGroupEventsEventCancelRequest) InlineObject231(inlineObject231 InlineObject231) ApiGroupsGroupEventsEventCancelRequest {
	r.inlineObject231 = &inlineObject231
	return r
}

func (r ApiGroupsGroupEventsEventCancelRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.GroupsGroupEventsEventCancelExecute(r)
}

/*
GroupsGroupEventsEventCancel Invoke action cancel

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupId key: id of group
 @param eventId key: id of event
 @return ApiGroupsGroupEventsEventCancelRequest
*/
func (a *GroupsActionsApiService) GroupsGroupEventsEventCancel(ctx _context.Context, groupId string, eventId string) ApiGroupsGroupEventsEventCancelRequest {
	return ApiGroupsGroupEventsEventCancelRequest{
		ApiService: a,
		ctx: ctx,
		groupId: groupId,
		eventId: eventId,
	}
}

// Execute executes the request
func (a *GroupsActionsApiService) GroupsGroupEventsEventCancelExecute(r ApiGroupsGroupEventsEventCancelRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GroupsActionsApiService.GroupsGroupEventsEventCancel")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/groups/{group-id}/events/{event-id}/microsoft.graph.cancel"
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject231 == nil {
		return nil, reportError("inlineObject231 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject231
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGroupsGroupEventsEventDeclineRequest struct {
	ctx _context.Context
	ApiService *GroupsActionsApiService
	groupId string
	eventId string
	inlineObject232 *InlineObject232
}

func (r ApiGroupsGroupEventsEventDeclineRequest) InlineObject232(inlineObject232 InlineObject232) ApiGroupsGroupEventsEventDeclineRequest {
	r.inlineObject232 = &inlineObject232
	return r
}

func (r ApiGroupsGroupEventsEventDeclineRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.GroupsGroupEventsEventDeclineExecute(r)
}

/*
GroupsGroupEventsEventDecline Invoke action decline

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupId key: id of group
 @param eventId key: id of event
 @return ApiGroupsGroupEventsEventDeclineRequest
*/
func (a *GroupsActionsApiService) GroupsGroupEventsEventDecline(ctx _context.Context, groupId string, eventId string) ApiGroupsGroupEventsEventDeclineRequest {
	return ApiGroupsGroupEventsEventDeclineRequest{
		ApiService: a,
		ctx: ctx,
		groupId: groupId,
		eventId: eventId,
	}
}

// Execute executes the request
func (a *GroupsActionsApiService) GroupsGroupEventsEventDeclineExecute(r ApiGroupsGroupEventsEventDeclineRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GroupsActionsApiService.GroupsGroupEventsEventDecline")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/groups/{group-id}/events/{event-id}/microsoft.graph.decline"
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject232 == nil {
		return nil, reportError("inlineObject232 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject232
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGroupsGroupEventsEventDismissReminderRequest struct {
	ctx _context.Context
	ApiService *GroupsActionsApiService
	groupId string
	eventId string
}


func (r ApiGroupsGroupEventsEventDismissReminderRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.GroupsGroupEventsEventDismissReminderExecute(r)
}

/*
GroupsGroupEventsEventDismissReminder Invoke action dismissReminder

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupId key: id of group
 @param eventId key: id of event
 @return ApiGroupsGroupEventsEventDismissReminderRequest
*/
func (a *GroupsActionsApiService) GroupsGroupEventsEventDismissReminder(ctx _context.Context, groupId string, eventId string) ApiGroupsGroupEventsEventDismissReminderRequest {
	return ApiGroupsGroupEventsEventDismissReminderRequest{
		ApiService: a,
		ctx: ctx,
		groupId: groupId,
		eventId: eventId,
	}
}

// Execute executes the request
func (a *GroupsActionsApiService) GroupsGroupEventsEventDismissReminderExecute(r ApiGroupsGroupEventsEventDismissReminderRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GroupsActionsApiService.GroupsGroupEventsEventDismissReminder")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/groups/{group-id}/events/{event-id}/microsoft.graph.dismissReminder"
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGroupsGroupEventsEventForwardRequest struct {
	ctx _context.Context
	ApiService *GroupsActionsApiService
	groupId string
	eventId string
	inlineObject233 *InlineObject233
}

func (r ApiGroupsGroupEventsEventForwardRequest) InlineObject233(inlineObject233 InlineObject233) ApiGroupsGroupEventsEventForwardRequest {
	r.inlineObject233 = &inlineObject233
	return r
}

func (r ApiGroupsGroupEventsEventForwardRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.GroupsGroupEventsEventForwardExecute(r)
}

/*
GroupsGroupEventsEventForward Invoke action forward

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupId key: id of group
 @param eventId key: id of event
 @return ApiGroupsGroupEventsEventForwardRequest
*/
func (a *GroupsActionsApiService) GroupsGroupEventsEventForward(ctx _context.Context, groupId string, eventId string) ApiGroupsGroupEventsEventForwardRequest {
	return ApiGroupsGroupEventsEventForwardRequest{
		ApiService: a,
		ctx: ctx,
		groupId: groupId,
		eventId: eventId,
	}
}

// Execute executes the request
func (a *GroupsActionsApiService) GroupsGroupEventsEventForwardExecute(r ApiGroupsGroupEventsEventForwardRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GroupsActionsApiService.GroupsGroupEventsEventForward")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/groups/{group-id}/events/{event-id}/microsoft.graph.forward"
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject233 == nil {
		return nil, reportError("inlineObject233 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject233
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGroupsGroupEventsEventInstancesEventAcceptRequest struct {
	ctx _context.Context
	ApiService *GroupsActionsApiService
	groupId string
	eventId string
	eventId1 string
	inlineObject224 *InlineObject224
}

func (r ApiGroupsGroupEventsEventInstancesEventAcceptRequest) InlineObject224(inlineObject224 InlineObject224) ApiGroupsGroupEventsEventInstancesEventAcceptRequest {
	r.inlineObject224 = &inlineObject224
	return r
}

func (r ApiGroupsGroupEventsEventInstancesEventAcceptRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.GroupsGroupEventsEventInstancesEventAcceptExecute(r)
}

/*
GroupsGroupEventsEventInstancesEventAccept Invoke action accept

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupId key: id of group
 @param eventId key: id of event
 @param eventId1 key: id of event
 @return ApiGroupsGroupEventsEventInstancesEventAcceptRequest
*/
func (a *GroupsActionsApiService) GroupsGroupEventsEventInstancesEventAccept(ctx _context.Context, groupId string, eventId string, eventId1 string) ApiGroupsGroupEventsEventInstancesEventAcceptRequest {
	return ApiGroupsGroupEventsEventInstancesEventAcceptRequest{
		ApiService: a,
		ctx: ctx,
		groupId: groupId,
		eventId: eventId,
		eventId1: eventId1,
	}
}

// Execute executes the request
func (a *GroupsActionsApiService) GroupsGroupEventsEventInstancesEventAcceptExecute(r ApiGroupsGroupEventsEventInstancesEventAcceptRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GroupsActionsApiService.GroupsGroupEventsEventInstancesEventAccept")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/groups/{group-id}/events/{event-id}/instances/{event-id1}/microsoft.graph.accept"
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id1"+"}", _neturl.PathEscape(parameterToString(r.eventId1, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject224 == nil {
		return nil, reportError("inlineObject224 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject224
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGroupsGroupEventsEventInstancesEventCancelRequest struct {
	ctx _context.Context
	ApiService *GroupsActionsApiService
	groupId string
	eventId string
	eventId1 string
	inlineObject225 *InlineObject225
}

func (r ApiGroupsGroupEventsEventInstancesEventCancelRequest) InlineObject225(inlineObject225 InlineObject225) ApiGroupsGroupEventsEventInstancesEventCancelRequest {
	r.inlineObject225 = &inlineObject225
	return r
}

func (r ApiGroupsGroupEventsEventInstancesEventCancelRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.GroupsGroupEventsEventInstancesEventCancelExecute(r)
}

/*
GroupsGroupEventsEventInstancesEventCancel Invoke action cancel

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupId key: id of group
 @param eventId key: id of event
 @param eventId1 key: id of event
 @return ApiGroupsGroupEventsEventInstancesEventCancelRequest
*/
func (a *GroupsActionsApiService) GroupsGroupEventsEventInstancesEventCancel(ctx _context.Context, groupId string, eventId string, eventId1 string) ApiGroupsGroupEventsEventInstancesEventCancelRequest {
	return ApiGroupsGroupEventsEventInstancesEventCancelRequest{
		ApiService: a,
		ctx: ctx,
		groupId: groupId,
		eventId: eventId,
		eventId1: eventId1,
	}
}

// Execute executes the request
func (a *GroupsActionsApiService) GroupsGroupEventsEventInstancesEventCancelExecute(r ApiGroupsGroupEventsEventInstancesEventCancelRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GroupsActionsApiService.GroupsGroupEventsEventInstancesEventCancel")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/groups/{group-id}/events/{event-id}/instances/{event-id1}/microsoft.graph.cancel"
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id1"+"}", _neturl.PathEscape(parameterToString(r.eventId1, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject225 == nil {
		return nil, reportError("inlineObject225 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject225
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGroupsGroupEventsEventInstancesEventDeclineRequest struct {
	ctx _context.Context
	ApiService *GroupsActionsApiService
	groupId string
	eventId string
	eventId1 string
	inlineObject226 *InlineObject226
}

func (r ApiGroupsGroupEventsEventInstancesEventDeclineRequest) InlineObject226(inlineObject226 InlineObject226) ApiGroupsGroupEventsEventInstancesEventDeclineRequest {
	r.inlineObject226 = &inlineObject226
	return r
}

func (r ApiGroupsGroupEventsEventInstancesEventDeclineRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.GroupsGroupEventsEventInstancesEventDeclineExecute(r)
}

/*
GroupsGroupEventsEventInstancesEventDecline Invoke action decline

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupId key: id of group
 @param eventId key: id of event
 @param eventId1 key: id of event
 @return ApiGroupsGroupEventsEventInstancesEventDeclineRequest
*/
func (a *GroupsActionsApiService) GroupsGroupEventsEventInstancesEventDecline(ctx _context.Context, groupId string, eventId string, eventId1 string) ApiGroupsGroupEventsEventInstancesEventDeclineRequest {
	return ApiGroupsGroupEventsEventInstancesEventDeclineRequest{
		ApiService: a,
		ctx: ctx,
		groupId: groupId,
		eventId: eventId,
		eventId1: eventId1,
	}
}

// Execute executes the request
func (a *GroupsActionsApiService) GroupsGroupEventsEventInstancesEventDeclineExecute(r ApiGroupsGroupEventsEventInstancesEventDeclineRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GroupsActionsApiService.GroupsGroupEventsEventInstancesEventDecline")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/groups/{group-id}/events/{event-id}/instances/{event-id1}/microsoft.graph.decline"
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id1"+"}", _neturl.PathEscape(parameterToString(r.eventId1, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject226 == nil {
		return nil, reportError("inlineObject226 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject226
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGroupsGroupEventsEventInstancesEventDismissReminderRequest struct {
	ctx _context.Context
	ApiService *GroupsActionsApiService
	groupId string
	eventId string
	eventId1 string
}


func (r ApiGroupsGroupEventsEventInstancesEventDismissReminderRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.GroupsGroupEventsEventInstancesEventDismissReminderExecute(r)
}

/*
GroupsGroupEventsEventInstancesEventDismissReminder Invoke action dismissReminder

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupId key: id of group
 @param eventId key: id of event
 @param eventId1 key: id of event
 @return ApiGroupsGroupEventsEventInstancesEventDismissReminderRequest
*/
func (a *GroupsActionsApiService) GroupsGroupEventsEventInstancesEventDismissReminder(ctx _context.Context, groupId string, eventId string, eventId1 string) ApiGroupsGroupEventsEventInstancesEventDismissReminderRequest {
	return ApiGroupsGroupEventsEventInstancesEventDismissReminderRequest{
		ApiService: a,
		ctx: ctx,
		groupId: groupId,
		eventId: eventId,
		eventId1: eventId1,
	}
}

// Execute executes the request
func (a *GroupsActionsApiService) GroupsGroupEventsEventInstancesEventDismissReminderExecute(r ApiGroupsGroupEventsEventInstancesEventDismissReminderRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GroupsActionsApiService.GroupsGroupEventsEventInstancesEventDismissReminder")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/groups/{group-id}/events/{event-id}/instances/{event-id1}/microsoft.graph.dismissReminder"
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id1"+"}", _neturl.PathEscape(parameterToString(r.eventId1, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGroupsGroupEventsEventInstancesEventForwardRequest struct {
	ctx _context.Context
	ApiService *GroupsActionsApiService
	groupId string
	eventId string
	eventId1 string
	inlineObject227 *InlineObject227
}

func (r ApiGroupsGroupEventsEventInstancesEventForwardRequest) InlineObject227(inlineObject227 InlineObject227) ApiGroupsGroupEventsEventInstancesEventForwardRequest {
	r.inlineObject227 = &inlineObject227
	return r
}

func (r ApiGroupsGroupEventsEventInstancesEventForwardRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.GroupsGroupEventsEventInstancesEventForwardExecute(r)
}

/*
GroupsGroupEventsEventInstancesEventForward Invoke action forward

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupId key: id of group
 @param eventId key: id of event
 @param eventId1 key: id of event
 @return ApiGroupsGroupEventsEventInstancesEventForwardRequest
*/
func (a *GroupsActionsApiService) GroupsGroupEventsEventInstancesEventForward(ctx _context.Context, groupId string, eventId string, eventId1 string) ApiGroupsGroupEventsEventInstancesEventForwardRequest {
	return ApiGroupsGroupEventsEventInstancesEventForwardRequest{
		ApiService: a,
		ctx: ctx,
		groupId: groupId,
		eventId: eventId,
		eventId1: eventId1,
	}
}

// Execute executes the request
func (a *GroupsActionsApiService) GroupsGroupEventsEventInstancesEventForwardExecute(r ApiGroupsGroupEventsEventInstancesEventForwardRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GroupsActionsApiService.GroupsGroupEventsEventInstancesEventForward")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/groups/{group-id}/events/{event-id}/instances/{event-id1}/microsoft.graph.forward"
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id1"+"}", _neturl.PathEscape(parameterToString(r.eventId1, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject227 == nil {
		return nil, reportError("inlineObject227 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject227
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGroupsGroupEventsEventInstancesEventSnoozeReminderRequest struct {
	ctx _context.Context
	ApiService *GroupsActionsApiService
	groupId string
	eventId string
	eventId1 string
	inlineObject228 *InlineObject228
}

func (r ApiGroupsGroupEventsEventInstancesEventSnoozeReminderRequest) InlineObject228(inlineObject228 InlineObject228) ApiGroupsGroupEventsEventInstancesEventSnoozeReminderRequest {
	r.inlineObject228 = &inlineObject228
	return r
}

func (r ApiGroupsGroupEventsEventInstancesEventSnoozeReminderRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.GroupsGroupEventsEventInstancesEventSnoozeReminderExecute(r)
}

/*
GroupsGroupEventsEventInstancesEventSnoozeReminder Invoke action snoozeReminder

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupId key: id of group
 @param eventId key: id of event
 @param eventId1 key: id of event
 @return ApiGroupsGroupEventsEventInstancesEventSnoozeReminderRequest
*/
func (a *GroupsActionsApiService) GroupsGroupEventsEventInstancesEventSnoozeReminder(ctx _context.Context, groupId string, eventId string, eventId1 string) ApiGroupsGroupEventsEventInstancesEventSnoozeReminderRequest {
	return ApiGroupsGroupEventsEventInstancesEventSnoozeReminderRequest{
		ApiService: a,
		ctx: ctx,
		groupId: groupId,
		eventId: eventId,
		eventId1: eventId1,
	}
}

// Execute executes the request
func (a *GroupsActionsApiService) GroupsGroupEventsEventInstancesEventSnoozeReminderExecute(r ApiGroupsGroupEventsEventInstancesEventSnoozeReminderRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GroupsActionsApiService.GroupsGroupEventsEventInstancesEventSnoozeReminder")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/groups/{group-id}/events/{event-id}/instances/{event-id1}/microsoft.graph.snoozeReminder"
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id1"+"}", _neturl.PathEscape(parameterToString(r.eventId1, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject228 == nil {
		return nil, reportError("inlineObject228 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject228
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGroupsGroupEventsEventInstancesEventTentativelyAcceptRequest struct {
	ctx _context.Context
	ApiService *GroupsActionsApiService
	groupId string
	eventId string
	eventId1 string
	inlineObject229 *InlineObject229
}

func (r ApiGroupsGroupEventsEventInstancesEventTentativelyAcceptRequest) InlineObject229(inlineObject229 InlineObject229) ApiGroupsGroupEventsEventInstancesEventTentativelyAcceptRequest {
	r.inlineObject229 = &inlineObject229
	return r
}

func (r ApiGroupsGroupEventsEventInstancesEventTentativelyAcceptRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.GroupsGroupEventsEventInstancesEventTentativelyAcceptExecute(r)
}

/*
GroupsGroupEventsEventInstancesEventTentativelyAccept Invoke action tentativelyAccept

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupId key: id of group
 @param eventId key: id of event
 @param eventId1 key: id of event
 @return ApiGroupsGroupEventsEventInstancesEventTentativelyAcceptRequest
*/
func (a *GroupsActionsApiService) GroupsGroupEventsEventInstancesEventTentativelyAccept(ctx _context.Context, groupId string, eventId string, eventId1 string) ApiGroupsGroupEventsEventInstancesEventTentativelyAcceptRequest {
	return ApiGroupsGroupEventsEventInstancesEventTentativelyAcceptRequest{
		ApiService: a,
		ctx: ctx,
		groupId: groupId,
		eventId: eventId,
		eventId1: eventId1,
	}
}

// Execute executes the request
func (a *GroupsActionsApiService) GroupsGroupEventsEventInstancesEventTentativelyAcceptExecute(r ApiGroupsGroupEventsEventInstancesEventTentativelyAcceptRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GroupsActionsApiService.GroupsGroupEventsEventInstancesEventTentativelyAccept")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/groups/{group-id}/events/{event-id}/instances/{event-id1}/microsoft.graph.tentativelyAccept"
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id1"+"}", _neturl.PathEscape(parameterToString(r.eventId1, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject229 == nil {
		return nil, reportError("inlineObject229 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject229
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGroupsGroupEventsEventSnoozeReminderRequest struct {
	ctx _context.Context
	ApiService *GroupsActionsApiService
	groupId string
	eventId string
	inlineObject234 *InlineObject234
}

func (r ApiGroupsGroupEventsEventSnoozeReminderRequest) InlineObject234(inlineObject234 InlineObject234) ApiGroupsGroupEventsEventSnoozeReminderRequest {
	r.inlineObject234 = &inlineObject234
	return r
}

func (r ApiGroupsGroupEventsEventSnoozeReminderRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.GroupsGroupEventsEventSnoozeReminderExecute(r)
}

/*
GroupsGroupEventsEventSnoozeReminder Invoke action snoozeReminder

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupId key: id of group
 @param eventId key: id of event
 @return ApiGroupsGroupEventsEventSnoozeReminderRequest
*/
func (a *GroupsActionsApiService) GroupsGroupEventsEventSnoozeReminder(ctx _context.Context, groupId string, eventId string) ApiGroupsGroupEventsEventSnoozeReminderRequest {
	return ApiGroupsGroupEventsEventSnoozeReminderRequest{
		ApiService: a,
		ctx: ctx,
		groupId: groupId,
		eventId: eventId,
	}
}

// Execute executes the request
func (a *GroupsActionsApiService) GroupsGroupEventsEventSnoozeReminderExecute(r ApiGroupsGroupEventsEventSnoozeReminderRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GroupsActionsApiService.GroupsGroupEventsEventSnoozeReminder")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/groups/{group-id}/events/{event-id}/microsoft.graph.snoozeReminder"
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject234 == nil {
		return nil, reportError("inlineObject234 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject234
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGroupsGroupEventsEventTentativelyAcceptRequest struct {
	ctx _context.Context
	ApiService *GroupsActionsApiService
	groupId string
	eventId string
	inlineObject235 *InlineObject235
}

func (r ApiGroupsGroupEventsEventTentativelyAcceptRequest) InlineObject235(inlineObject235 InlineObject235) ApiGroupsGroupEventsEventTentativelyAcceptRequest {
	r.inlineObject235 = &inlineObject235
	return r
}

func (r ApiGroupsGroupEventsEventTentativelyAcceptRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.GroupsGroupEventsEventTentativelyAcceptExecute(r)
}

/*
GroupsGroupEventsEventTentativelyAccept Invoke action tentativelyAccept

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupId key: id of group
 @param eventId key: id of event
 @return ApiGroupsGroupEventsEventTentativelyAcceptRequest
*/
func (a *GroupsActionsApiService) GroupsGroupEventsEventTentativelyAccept(ctx _context.Context, groupId string, eventId string) ApiGroupsGroupEventsEventTentativelyAcceptRequest {
	return ApiGroupsGroupEventsEventTentativelyAcceptRequest{
		ApiService: a,
		ctx: ctx,
		groupId: groupId,
		eventId: eventId,
	}
}

// Execute executes the request
func (a *GroupsActionsApiService) GroupsGroupEventsEventTentativelyAcceptExecute(r ApiGroupsGroupEventsEventTentativelyAcceptRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GroupsActionsApiService.GroupsGroupEventsEventTentativelyAccept")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/groups/{group-id}/events/{event-id}/microsoft.graph.tentativelyAccept"
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject235 == nil {
		return nil, reportError("inlineObject235 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject235
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGroupsGroupGetMemberGroupsRequest struct {
	ctx _context.Context
	ApiService *GroupsActionsApiService
	groupId string
	inlineObject239 *InlineObject239
}

func (r ApiGroupsGroupGetMemberGroupsRequest) InlineObject239(inlineObject239 InlineObject239) ApiGroupsGroupGetMemberGroupsRequest {
	r.inlineObject239 = &inlineObject239
	return r
}

func (r ApiGroupsGroupGetMemberGroupsRequest) Execute() ([]string, *_nethttp.Response, error) {
	return r.ApiService.GroupsGroupGetMemberGroupsExecute(r)
}

/*
GroupsGroupGetMemberGroups Invoke action getMemberGroups

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupId key: id of group
 @return ApiGroupsGroupGetMemberGroupsRequest
*/
func (a *GroupsActionsApiService) GroupsGroupGetMemberGroups(ctx _context.Context, groupId string) ApiGroupsGroupGetMemberGroupsRequest {
	return ApiGroupsGroupGetMemberGroupsRequest{
		ApiService: a,
		ctx: ctx,
		groupId: groupId,
	}
}

// Execute executes the request
//  @return []string
func (a *GroupsActionsApiService) GroupsGroupGetMemberGroupsExecute(r ApiGroupsGroupGetMemberGroupsRequest) ([]string, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  []string
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GroupsActionsApiService.GroupsGroupGetMemberGroups")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/groups/{group-id}/microsoft.graph.getMemberGroups"
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject239 == nil {
		return localVarReturnValue, nil, reportError("inlineObject239 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject239
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGroupsGroupGetMemberObjectsRequest struct {
	ctx _context.Context
	ApiService *GroupsActionsApiService
	groupId string
	inlineObject240 *InlineObject240
}

func (r ApiGroupsGroupGetMemberObjectsRequest) InlineObject240(inlineObject240 InlineObject240) ApiGroupsGroupGetMemberObjectsRequest {
	r.inlineObject240 = &inlineObject240
	return r
}

func (r ApiGroupsGroupGetMemberObjectsRequest) Execute() ([]string, *_nethttp.Response, error) {
	return r.ApiService.GroupsGroupGetMemberObjectsExecute(r)
}

/*
GroupsGroupGetMemberObjects Invoke action getMemberObjects

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupId key: id of group
 @return ApiGroupsGroupGetMemberObjectsRequest
*/
func (a *GroupsActionsApiService) GroupsGroupGetMemberObjects(ctx _context.Context, groupId string) ApiGroupsGroupGetMemberObjectsRequest {
	return ApiGroupsGroupGetMemberObjectsRequest{
		ApiService: a,
		ctx: ctx,
		groupId: groupId,
	}
}

// Execute executes the request
//  @return []string
func (a *GroupsActionsApiService) GroupsGroupGetMemberObjectsExecute(r ApiGroupsGroupGetMemberObjectsRequest) ([]string, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  []string
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GroupsActionsApiService.GroupsGroupGetMemberObjects")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/groups/{group-id}/microsoft.graph.getMemberObjects"
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject240 == nil {
		return localVarReturnValue, nil, reportError("inlineObject240 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject240
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGroupsGroupOnenoteNotebooksGetNotebookFromWebUrlRequest struct {
	ctx _context.Context
	ApiService *GroupsActionsApiService
	groupId string
	inlineObject263 *InlineObject263
}

func (r ApiGroupsGroupOnenoteNotebooksGetNotebookFromWebUrlRequest) InlineObject263(inlineObject263 InlineObject263) ApiGroupsGroupOnenoteNotebooksGetNotebookFromWebUrlRequest {
	r.inlineObject263 = &inlineObject263
	return r
}

func (r ApiGroupsGroupOnenoteNotebooksGetNotebookFromWebUrlRequest) Execute() (AnyOfmicrosoftGraphCopyNotebookModel, *_nethttp.Response, error) {
	return r.ApiService.GroupsGroupOnenoteNotebooksGetNotebookFromWebUrlExecute(r)
}

/*
GroupsGroupOnenoteNotebooksGetNotebookFromWebUrl Invoke action getNotebookFromWebUrl

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupId key: id of group
 @return ApiGroupsGroupOnenoteNotebooksGetNotebookFromWebUrlRequest
*/
func (a *GroupsActionsApiService) GroupsGroupOnenoteNotebooksGetNotebookFromWebUrl(ctx _context.Context, groupId string) ApiGroupsGroupOnenoteNotebooksGetNotebookFromWebUrlRequest {
	return ApiGroupsGroupOnenoteNotebooksGetNotebookFromWebUrlRequest{
		ApiService: a,
		ctx: ctx,
		groupId: groupId,
	}
}

// Execute executes the request
//  @return AnyOfmicrosoftGraphCopyNotebookModel
func (a *GroupsActionsApiService) GroupsGroupOnenoteNotebooksGetNotebookFromWebUrlExecute(r ApiGroupsGroupOnenoteNotebooksGetNotebookFromWebUrlRequest) (AnyOfmicrosoftGraphCopyNotebookModel, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  AnyOfmicrosoftGraphCopyNotebookModel
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GroupsActionsApiService.GroupsGroupOnenoteNotebooksGetNotebookFromWebUrl")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/groups/{group-id}/onenote/notebooks/microsoft.graph.getNotebookFromWebUrl"
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject263 == nil {
		return localVarReturnValue, nil, reportError("inlineObject263 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject263
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGroupsGroupOnenoteNotebooksNotebookCopyNotebookRequest struct {
	ctx _context.Context
	ApiService *GroupsActionsApiService
	groupId string
	notebookId string
	inlineObject242 *InlineObject242
}

func (r ApiGroupsGroupOnenoteNotebooksNotebookCopyNotebookRequest) InlineObject242(inlineObject242 InlineObject242) ApiGroupsGroupOnenoteNotebooksNotebookCopyNotebookRequest {
	r.inlineObject242 = &inlineObject242
	return r
}

func (r ApiGroupsGroupOnenoteNotebooksNotebookCopyNotebookRequest) Execute() (AnyOfmicrosoftGraphOnenoteOperation, *_nethttp.Response, error) {
	return r.ApiService.GroupsGroupOnenoteNotebooksNotebookCopyNotebookExecute(r)
}

/*
GroupsGroupOnenoteNotebooksNotebookCopyNotebook Invoke action copyNotebook

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupId key: id of group
 @param notebookId key: id of notebook
 @return ApiGroupsGroupOnenoteNotebooksNotebookCopyNotebookRequest
*/
func (a *GroupsActionsApiService) GroupsGroupOnenoteNotebooksNotebookCopyNotebook(ctx _context.Context, groupId string, notebookId string) ApiGroupsGroupOnenoteNotebooksNotebookCopyNotebookRequest {
	return ApiGroupsGroupOnenoteNotebooksNotebookCopyNotebookRequest{
		ApiService: a,
		ctx: ctx,
		groupId: groupId,
		notebookId: notebookId,
	}
}

// Execute executes the request
//  @return AnyOfmicrosoftGraphOnenoteOperation
func (a *GroupsActionsApiService) GroupsGroupOnenoteNotebooksNotebookCopyNotebookExecute(r ApiGroupsGroupOnenoteNotebooksNotebookCopyNotebookRequest) (AnyOfmicrosoftGraphOnenoteOperation, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  AnyOfmicrosoftGraphOnenoteOperation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GroupsActionsApiService.GroupsGroupOnenoteNotebooksNotebookCopyNotebook")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/groups/{group-id}/onenote/notebooks/{notebook-id}/microsoft.graph.copyNotebook"
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"notebook-id"+"}", _neturl.PathEscape(parameterToString(r.notebookId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject242 == nil {
		return localVarReturnValue, nil, reportError("inlineObject242 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject242
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGroupsGroupOnenoteNotebooksNotebookSectionGroupsSectionGroupParentNotebookCopyNotebookRequest struct {
	ctx _context.Context
	ApiService *GroupsActionsApiService
	groupId string
	notebookId string
	sectionGroupId string
	inlineObject243 *InlineObject243
}

func (r ApiGroupsGroupOnenoteNotebooksNotebookSectionGroupsSectionGroupParentNotebookCopyNotebookRequest) InlineObject243(inlineObject243 InlineObject243) ApiGroupsGroupOnenoteNotebooksNotebookSectionGroupsSectionGroupParentNotebookCopyNotebookRequest {
	r.inlineObject243 = &inlineObject243
	return r
}

func (r ApiGroupsGroupOnenoteNotebooksNotebookSectionGroupsSectionGroupParentNotebookCopyNotebookRequest) Execute() (AnyOfmicrosoftGraphOnenoteOperation, *_nethttp.Response, error) {
	return r.ApiService.GroupsGroupOnenoteNotebooksNotebookSectionGroupsSectionGroupParentNotebookCopyNotebookExecute(r)
}

/*
GroupsGroupOnenoteNotebooksNotebookSectionGroupsSectionGroupParentNotebookCopyNotebook Invoke action copyNotebook

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupId key: id of group
 @param notebookId key: id of notebook
 @param sectionGroupId key: id of sectionGroup
 @return ApiGroupsGroupOnenoteNotebooksNotebookSectionGroupsSectionGroupParentNotebookCopyNotebookRequest
*/
func (a *GroupsActionsApiService) GroupsGroupOnenoteNotebooksNotebookSectionGroupsSectionGroupParentNotebookCopyNotebook(ctx _context.Context, groupId string, notebookId string, sectionGroupId string) ApiGroupsGroupOnenoteNotebooksNotebookSectionGroupsSectionGroupParentNotebookCopyNotebookRequest {
	return ApiGroupsGroupOnenoteNotebooksNotebookSectionGroupsSectionGroupParentNotebookCopyNotebookRequest{
		ApiService: a,
		ctx: ctx,
		groupId: groupId,
		notebookId: notebookId,
		sectionGroupId: sectionGroupId,
	}
}

// Execute executes the request
//  @return AnyOfmicrosoftGraphOnenoteOperation
func (a *GroupsActionsApiService) GroupsGroupOnenoteNotebooksNotebookSectionGroupsSectionGroupParentNotebookCopyNotebookExecute(r ApiGroupsGroupOnenoteNotebooksNotebookSectionGroupsSectionGroupParentNotebookCopyNotebookRequest) (AnyOfmicrosoftGraphOnenoteOperation, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  AnyOfmicrosoftGraphOnenoteOperation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GroupsActionsApiService.GroupsGroupOnenoteNotebooksNotebookSectionGroupsSectionGroupParentNotebookCopyNotebook")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/groups/{group-id}/onenote/notebooks/{notebook-id}/sectionGroups/{sectionGroup-id}/parentNotebook/microsoft.graph.copyNotebook"
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"notebook-id"+"}", _neturl.PathEscape(parameterToString(r.notebookId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"sectionGroup-id"+"}", _neturl.PathEscape(parameterToString(r.sectionGroupId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject243 == nil {
		return localVarReturnValue, nil, reportError("inlineObject243 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject243
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGroupsGroupOnenoteNotebooksNotebookSectionGroupsSectionGroupSectionsOnenoteSectionCopyToNotebookRequest struct {
	ctx _context.Context
	ApiService *GroupsActionsApiService
	groupId string
	notebookId string
	sectionGroupId string
	onenoteSectionId string
	inlineObject244 *InlineObject244
}

func (r ApiGroupsGroupOnenoteNotebooksNotebookSectionGroupsSectionGroupSectionsOnenoteSectionCopyToNotebookRequest) InlineObject244(inlineObject244 InlineObject244) ApiGroupsGroupOnenoteNotebooksNotebookSectionGroupsSectionGroupSectionsOnenoteSectionCopyToNotebookRequest {
	r.inlineObject244 = &inlineObject244
	return r
}

func (r ApiGroupsGroupOnenoteNotebooksNotebookSectionGroupsSectionGroupSectionsOnenoteSectionCopyToNotebookRequest) Execute() (AnyOfmicrosoftGraphOnenoteOperation, *_nethttp.Response, error) {
	return r.ApiService.GroupsGroupOnenoteNotebooksNotebookSectionGroupsSectionGroupSectionsOnenoteSectionCopyToNotebookExecute(r)
}

/*
GroupsGroupOnenoteNotebooksNotebookSectionGroupsSectionGroupSectionsOnenoteSectionCopyToNotebook Invoke action copyToNotebook

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupId key: id of group
 @param notebookId key: id of notebook
 @param sectionGroupId key: id of sectionGroup
 @param onenoteSectionId key: id of onenoteSection
 @return ApiGroupsGroupOnenoteNotebooksNotebookSectionGroupsSectionGroupSectionsOnenoteSectionCopyToNotebookRequest
*/
func (a *GroupsActionsApiService) GroupsGroupOnenoteNotebooksNotebookSectionGroupsSectionGroupSectionsOnenoteSectionCopyToNotebook(ctx _context.Context, groupId string, notebookId string, sectionGroupId string, onenoteSectionId string) ApiGroupsGroupOnenoteNotebooksNotebookSectionGroupsSectionGroupSectionsOnenoteSectionCopyToNotebookRequest {
	return ApiGroupsGroupOnenoteNotebooksNotebookSectionGroupsSectionGroupSectionsOnenoteSectionCopyToNotebookRequest{
		ApiService: a,
		ctx: ctx,
		groupId: groupId,
		notebookId: notebookId,
		sectionGroupId: sectionGroupId,
		onenoteSectionId: onenoteSectionId,
	}
}

// Execute executes the request
//  @return AnyOfmicrosoftGraphOnenoteOperation
func (a *GroupsActionsApiService) GroupsGroupOnenoteNotebooksNotebookSectionGroupsSectionGroupSectionsOnenoteSectionCopyToNotebookExecute(r ApiGroupsGroupOnenoteNotebooksNotebookSectionGroupsSectionGroupSectionsOnenoteSectionCopyToNotebookRequest) (AnyOfmicrosoftGraphOnenoteOperation, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  AnyOfmicrosoftGraphOnenoteOperation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GroupsActionsApiService.GroupsGroupOnenoteNotebooksNotebookSectionGroupsSectionGroupSectionsOnenoteSectionCopyToNotebook")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/groups/{group-id}/onenote/notebooks/{notebook-id}/sectionGroups/{sectionGroup-id}/sections/{onenoteSection-id}/microsoft.graph.copyToNotebook"
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"notebook-id"+"}", _neturl.PathEscape(parameterToString(r.notebookId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"sectionGroup-id"+"}", _neturl.PathEscape(parameterToString(r.sectionGroupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"onenoteSection-id"+"}", _neturl.PathEscape(parameterToString(r.onenoteSectionId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject244 == nil {
		return localVarReturnValue, nil, reportError("inlineObject244 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject244
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGroupsGroupOnenoteNotebooksNotebookSectionGroupsSectionGroupSectionsOnenoteSectionCopyToSectionGroupRequest struct {
	ctx _context.Context
	ApiService *GroupsActionsApiService
	groupId string
	notebookId string
	sectionGroupId string
	onenoteSectionId string
	inlineObject245 *InlineObject245
}

func (r ApiGroupsGroupOnenoteNotebooksNotebookSectionGroupsSectionGroupSectionsOnenoteSectionCopyToSectionGroupRequest) InlineObject245(inlineObject245 InlineObject245) ApiGroupsGroupOnenoteNotebooksNotebookSectionGroupsSectionGroupSectionsOnenoteSectionCopyToSectionGroupRequest {
	r.inlineObject245 = &inlineObject245
	return r
}

func (r ApiGroupsGroupOnenoteNotebooksNotebookSectionGroupsSectionGroupSectionsOnenoteSectionCopyToSectionGroupRequest) Execute() (AnyOfmicrosoftGraphOnenoteOperation, *_nethttp.Response, error) {
	return r.ApiService.GroupsGroupOnenoteNotebooksNotebookSectionGroupsSectionGroupSectionsOnenoteSectionCopyToSectionGroupExecute(r)
}

/*
GroupsGroupOnenoteNotebooksNotebookSectionGroupsSectionGroupSectionsOnenoteSectionCopyToSectionGroup Invoke action copyToSectionGroup

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupId key: id of group
 @param notebookId key: id of notebook
 @param sectionGroupId key: id of sectionGroup
 @param onenoteSectionId key: id of onenoteSection
 @return ApiGroupsGroupOnenoteNotebooksNotebookSectionGroupsSectionGroupSectionsOnenoteSectionCopyToSectionGroupRequest
*/
func (a *GroupsActionsApiService) GroupsGroupOnenoteNotebooksNotebookSectionGroupsSectionGroupSectionsOnenoteSectionCopyToSectionGroup(ctx _context.Context, groupId string, notebookId string, sectionGroupId string, onenoteSectionId string) ApiGroupsGroupOnenoteNotebooksNotebookSectionGroupsSectionGroupSectionsOnenoteSectionCopyToSectionGroupRequest {
	return ApiGroupsGroupOnenoteNotebooksNotebookSectionGroupsSectionGroupSectionsOnenoteSectionCopyToSectionGroupRequest{
		ApiService: a,
		ctx: ctx,
		groupId: groupId,
		notebookId: notebookId,
		sectionGroupId: sectionGroupId,
		onenoteSectionId: onenoteSectionId,
	}
}

// Execute executes the request
//  @return AnyOfmicrosoftGraphOnenoteOperation
func (a *GroupsActionsApiService) GroupsGroupOnenoteNotebooksNotebookSectionGroupsSectionGroupSectionsOnenoteSectionCopyToSectionGroupExecute(r ApiGroupsGroupOnenoteNotebooksNotebookSectionGroupsSectionGroupSectionsOnenoteSectionCopyToSectionGroupRequest) (AnyOfmicrosoftGraphOnenoteOperation, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  AnyOfmicrosoftGraphOnenoteOperation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GroupsActionsApiService.GroupsGroupOnenoteNotebooksNotebookSectionGroupsSectionGroupSectionsOnenoteSectionCopyToSectionGroup")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/groups/{group-id}/onenote/notebooks/{notebook-id}/sectionGroups/{sectionGroup-id}/sections/{onenoteSection-id}/microsoft.graph.copyToSectionGroup"
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"notebook-id"+"}", _neturl.PathEscape(parameterToString(r.notebookId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"sectionGroup-id"+"}", _neturl.PathEscape(parameterToString(r.sectionGroupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"onenoteSection-id"+"}", _neturl.PathEscape(parameterToString(r.onenoteSectionId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject245 == nil {
		return localVarReturnValue, nil, reportError("inlineObject245 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject245
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGroupsGroupOnenoteNotebooksNotebookSectionGroupsSectionGroupSectionsOnenoteSectionPagesOnenotePageCopyToSectionRequest struct {
	ctx _context.Context
	ApiService *GroupsActionsApiService
	groupId string
	notebookId string
	sectionGroupId string
	onenoteSectionId string
	onenotePageId string
	inlineObject246 *InlineObject246
}

func (r ApiGroupsGroupOnenoteNotebooksNotebookSectionGroupsSectionGroupSectionsOnenoteSectionPagesOnenotePageCopyToSectionRequest) InlineObject246(inlineObject246 InlineObject246) ApiGroupsGroupOnenoteNotebooksNotebookSectionGroupsSectionGroupSectionsOnenoteSectionPagesOnenotePageCopyToSectionRequest {
	r.inlineObject246 = &inlineObject246
	return r
}

func (r ApiGroupsGroupOnenoteNotebooksNotebookSectionGroupsSectionGroupSectionsOnenoteSectionPagesOnenotePageCopyToSectionRequest) Execute() (AnyOfmicrosoftGraphOnenoteOperation, *_nethttp.Response, error) {
	return r.ApiService.GroupsGroupOnenoteNotebooksNotebookSectionGroupsSectionGroupSectionsOnenoteSectionPagesOnenotePageCopyToSectionExecute(r)
}

/*
GroupsGroupOnenoteNotebooksNotebookSectionGroupsSectionGroupSectionsOnenoteSectionPagesOnenotePageCopyToSection Invoke action copyToSection

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupId key: id of group
 @param notebookId key: id of notebook
 @param sectionGroupId key: id of sectionGroup
 @param onenoteSectionId key: id of onenoteSection
 @param onenotePageId key: id of onenotePage
 @return ApiGroupsGroupOnenoteNotebooksNotebookSectionGroupsSectionGroupSectionsOnenoteSectionPagesOnenotePageCopyToSectionRequest
*/
func (a *GroupsActionsApiService) GroupsGroupOnenoteNotebooksNotebookSectionGroupsSectionGroupSectionsOnenoteSectionPagesOnenotePageCopyToSection(ctx _context.Context, groupId string, notebookId string, sectionGroupId string, onenoteSectionId string, onenotePageId string) ApiGroupsGroupOnenoteNotebooksNotebookSectionGroupsSectionGroupSectionsOnenoteSectionPagesOnenotePageCopyToSectionRequest {
	return ApiGroupsGroupOnenoteNotebooksNotebookSectionGroupsSectionGroupSectionsOnenoteSectionPagesOnenotePageCopyToSectionRequest{
		ApiService: a,
		ctx: ctx,
		groupId: groupId,
		notebookId: notebookId,
		sectionGroupId: sectionGroupId,
		onenoteSectionId: onenoteSectionId,
		onenotePageId: onenotePageId,
	}
}

// Execute executes the request
//  @return AnyOfmicrosoftGraphOnenoteOperation
func (a *GroupsActionsApiService) GroupsGroupOnenoteNotebooksNotebookSectionGroupsSectionGroupSectionsOnenoteSectionPagesOnenotePageCopyToSectionExecute(r ApiGroupsGroupOnenoteNotebooksNotebookSectionGroupsSectionGroupSectionsOnenoteSectionPagesOnenotePageCopyToSectionRequest) (AnyOfmicrosoftGraphOnenoteOperation, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  AnyOfmicrosoftGraphOnenoteOperation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GroupsActionsApiService.GroupsGroupOnenoteNotebooksNotebookSectionGroupsSectionGroupSectionsOnenoteSectionPagesOnenotePageCopyToSection")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/groups/{group-id}/onenote/notebooks/{notebook-id}/sectionGroups/{sectionGroup-id}/sections/{onenoteSection-id}/pages/{onenotePage-id}/microsoft.graph.copyToSection"
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"notebook-id"+"}", _neturl.PathEscape(parameterToString(r.notebookId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"sectionGroup-id"+"}", _neturl.PathEscape(parameterToString(r.sectionGroupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"onenoteSection-id"+"}", _neturl.PathEscape(parameterToString(r.onenoteSectionId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"onenotePage-id"+"}", _neturl.PathEscape(parameterToString(r.onenotePageId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject246 == nil {
		return localVarReturnValue, nil, reportError("inlineObject246 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject246
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGroupsGroupOnenoteNotebooksNotebookSectionGroupsSectionGroupSectionsOnenoteSectionPagesOnenotePageOnenotePatchContentRequest struct {
	ctx _context.Context
	ApiService *GroupsActionsApiService
	groupId string
	notebookId string
	sectionGroupId string
	onenoteSectionId string
	onenotePageId string
	inlineObject247 *InlineObject247
}

func (r ApiGroupsGroupOnenoteNotebooksNotebookSectionGroupsSectionGroupSectionsOnenoteSectionPagesOnenotePageOnenotePatchContentRequest) InlineObject247(inlineObject247 InlineObject247) ApiGroupsGroupOnenoteNotebooksNotebookSectionGroupsSectionGroupSectionsOnenoteSectionPagesOnenotePageOnenotePatchContentRequest {
	r.inlineObject247 = &inlineObject247
	return r
}

func (r ApiGroupsGroupOnenoteNotebooksNotebookSectionGroupsSectionGroupSectionsOnenoteSectionPagesOnenotePageOnenotePatchContentRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.GroupsGroupOnenoteNotebooksNotebookSectionGroupsSectionGroupSectionsOnenoteSectionPagesOnenotePageOnenotePatchContentExecute(r)
}

/*
GroupsGroupOnenoteNotebooksNotebookSectionGroupsSectionGroupSectionsOnenoteSectionPagesOnenotePageOnenotePatchContent Invoke action onenotePatchContent

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupId key: id of group
 @param notebookId key: id of notebook
 @param sectionGroupId key: id of sectionGroup
 @param onenoteSectionId key: id of onenoteSection
 @param onenotePageId key: id of onenotePage
 @return ApiGroupsGroupOnenoteNotebooksNotebookSectionGroupsSectionGroupSectionsOnenoteSectionPagesOnenotePageOnenotePatchContentRequest
*/
func (a *GroupsActionsApiService) GroupsGroupOnenoteNotebooksNotebookSectionGroupsSectionGroupSectionsOnenoteSectionPagesOnenotePageOnenotePatchContent(ctx _context.Context, groupId string, notebookId string, sectionGroupId string, onenoteSectionId string, onenotePageId string) ApiGroupsGroupOnenoteNotebooksNotebookSectionGroupsSectionGroupSectionsOnenoteSectionPagesOnenotePageOnenotePatchContentRequest {
	return ApiGroupsGroupOnenoteNotebooksNotebookSectionGroupsSectionGroupSectionsOnenoteSectionPagesOnenotePageOnenotePatchContentRequest{
		ApiService: a,
		ctx: ctx,
		groupId: groupId,
		notebookId: notebookId,
		sectionGroupId: sectionGroupId,
		onenoteSectionId: onenoteSectionId,
		onenotePageId: onenotePageId,
	}
}

// Execute executes the request
func (a *GroupsActionsApiService) GroupsGroupOnenoteNotebooksNotebookSectionGroupsSectionGroupSectionsOnenoteSectionPagesOnenotePageOnenotePatchContentExecute(r ApiGroupsGroupOnenoteNotebooksNotebookSectionGroupsSectionGroupSectionsOnenoteSectionPagesOnenotePageOnenotePatchContentRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GroupsActionsApiService.GroupsGroupOnenoteNotebooksNotebookSectionGroupsSectionGroupSectionsOnenoteSectionPagesOnenotePageOnenotePatchContent")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/groups/{group-id}/onenote/notebooks/{notebook-id}/sectionGroups/{sectionGroup-id}/sections/{onenoteSection-id}/pages/{onenotePage-id}/microsoft.graph.onenotePatchContent"
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"notebook-id"+"}", _neturl.PathEscape(parameterToString(r.notebookId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"sectionGroup-id"+"}", _neturl.PathEscape(parameterToString(r.sectionGroupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"onenoteSection-id"+"}", _neturl.PathEscape(parameterToString(r.onenoteSectionId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"onenotePage-id"+"}", _neturl.PathEscape(parameterToString(r.onenotePageId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject247 == nil {
		return nil, reportError("inlineObject247 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject247
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGroupsGroupOnenoteNotebooksNotebookSectionGroupsSectionGroupSectionsOnenoteSectionPagesOnenotePageParentNotebookCopyNotebookRequest struct {
	ctx _context.Context
	ApiService *GroupsActionsApiService
	groupId string
	notebookId string
	sectionGroupId string
	onenoteSectionId string
	onenotePageId string
	inlineObject248 *InlineObject248
}

func (r ApiGroupsGroupOnenoteNotebooksNotebookSectionGroupsSectionGroupSectionsOnenoteSectionPagesOnenotePageParentNotebookCopyNotebookRequest) InlineObject248(inlineObject248 InlineObject248) ApiGroupsGroupOnenoteNotebooksNotebookSectionGroupsSectionGroupSectionsOnenoteSectionPagesOnenotePageParentNotebookCopyNotebookRequest {
	r.inlineObject248 = &inlineObject248
	return r
}

func (r ApiGroupsGroupOnenoteNotebooksNotebookSectionGroupsSectionGroupSectionsOnenoteSectionPagesOnenotePageParentNotebookCopyNotebookRequest) Execute() (AnyOfmicrosoftGraphOnenoteOperation, *_nethttp.Response, error) {
	return r.ApiService.GroupsGroupOnenoteNotebooksNotebookSectionGroupsSectionGroupSectionsOnenoteSectionPagesOnenotePageParentNotebookCopyNotebookExecute(r)
}

/*
GroupsGroupOnenoteNotebooksNotebookSectionGroupsSectionGroupSectionsOnenoteSectionPagesOnenotePageParentNotebookCopyNotebook Invoke action copyNotebook

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupId key: id of group
 @param notebookId key: id of notebook
 @param sectionGroupId key: id of sectionGroup
 @param onenoteSectionId key: id of onenoteSection
 @param onenotePageId key: id of onenotePage
 @return ApiGroupsGroupOnenoteNotebooksNotebookSectionGroupsSectionGroupSectionsOnenoteSectionPagesOnenotePageParentNotebookCopyNotebookRequest
*/
func (a *GroupsActionsApiService) GroupsGroupOnenoteNotebooksNotebookSectionGroupsSectionGroupSectionsOnenoteSectionPagesOnenotePageParentNotebookCopyNotebook(ctx _context.Context, groupId string, notebookId string, sectionGroupId string, onenoteSectionId string, onenotePageId string) ApiGroupsGroupOnenoteNotebooksNotebookSectionGroupsSectionGroupSectionsOnenoteSectionPagesOnenotePageParentNotebookCopyNotebookRequest {
	return ApiGroupsGroupOnenoteNotebooksNotebookSectionGroupsSectionGroupSectionsOnenoteSectionPagesOnenotePageParentNotebookCopyNotebookRequest{
		ApiService: a,
		ctx: ctx,
		groupId: groupId,
		notebookId: notebookId,
		sectionGroupId: sectionGroupId,
		onenoteSectionId: onenoteSectionId,
		onenotePageId: onenotePageId,
	}
}

// Execute executes the request
//  @return AnyOfmicrosoftGraphOnenoteOperation
func (a *GroupsActionsApiService) GroupsGroupOnenoteNotebooksNotebookSectionGroupsSectionGroupSectionsOnenoteSectionPagesOnenotePageParentNotebookCopyNotebookExecute(r ApiGroupsGroupOnenoteNotebooksNotebookSectionGroupsSectionGroupSectionsOnenoteSectionPagesOnenotePageParentNotebookCopyNotebookRequest) (AnyOfmicrosoftGraphOnenoteOperation, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  AnyOfmicrosoftGraphOnenoteOperation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GroupsActionsApiService.GroupsGroupOnenoteNotebooksNotebookSectionGroupsSectionGroupSectionsOnenoteSectionPagesOnenotePageParentNotebookCopyNotebook")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/groups/{group-id}/onenote/notebooks/{notebook-id}/sectionGroups/{sectionGroup-id}/sections/{onenoteSection-id}/pages/{onenotePage-id}/parentNotebook/microsoft.graph.copyNotebook"
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"notebook-id"+"}", _neturl.PathEscape(parameterToString(r.notebookId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"sectionGroup-id"+"}", _neturl.PathEscape(parameterToString(r.sectionGroupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"onenoteSection-id"+"}", _neturl.PathEscape(parameterToString(r.onenoteSectionId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"onenotePage-id"+"}", _neturl.PathEscape(parameterToString(r.onenotePageId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject248 == nil {
		return localVarReturnValue, nil, reportError("inlineObject248 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject248
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGroupsGroupOnenoteNotebooksNotebookSectionGroupsSectionGroupSectionsOnenoteSectionPagesOnenotePageParentSectionCopyToNotebookRequest struct {
	ctx _context.Context
	ApiService *GroupsActionsApiService
	groupId string
	notebookId string
	sectionGroupId string
	onenoteSectionId string
	onenotePageId string
	inlineObject249 *InlineObject249
}

func (r ApiGroupsGroupOnenoteNotebooksNotebookSectionGroupsSectionGroupSectionsOnenoteSectionPagesOnenotePageParentSectionCopyToNotebookRequest) InlineObject249(inlineObject249 InlineObject249) ApiGroupsGroupOnenoteNotebooksNotebookSectionGroupsSectionGroupSectionsOnenoteSectionPagesOnenotePageParentSectionCopyToNotebookRequest {
	r.inlineObject249 = &inlineObject249
	return r
}

func (r ApiGroupsGroupOnenoteNotebooksNotebookSectionGroupsSectionGroupSectionsOnenoteSectionPagesOnenotePageParentSectionCopyToNotebookRequest) Execute() (AnyOfmicrosoftGraphOnenoteOperation, *_nethttp.Response, error) {
	return r.ApiService.GroupsGroupOnenoteNotebooksNotebookSectionGroupsSectionGroupSectionsOnenoteSectionPagesOnenotePageParentSectionCopyToNotebookExecute(r)
}

/*
GroupsGroupOnenoteNotebooksNotebookSectionGroupsSectionGroupSectionsOnenoteSectionPagesOnenotePageParentSectionCopyToNotebook Invoke action copyToNotebook

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupId key: id of group
 @param notebookId key: id of notebook
 @param sectionGroupId key: id of sectionGroup
 @param onenoteSectionId key: id of onenoteSection
 @param onenotePageId key: id of onenotePage
 @return ApiGroupsGroupOnenoteNotebooksNotebookSectionGroupsSectionGroupSectionsOnenoteSectionPagesOnenotePageParentSectionCopyToNotebookRequest
*/
func (a *GroupsActionsApiService) GroupsGroupOnenoteNotebooksNotebookSectionGroupsSectionGroupSectionsOnenoteSectionPagesOnenotePageParentSectionCopyToNotebook(ctx _context.Context, groupId string, notebookId string, sectionGroupId string, onenoteSectionId string, onenotePageId string) ApiGroupsGroupOnenoteNotebooksNotebookSectionGroupsSectionGroupSectionsOnenoteSectionPagesOnenotePageParentSectionCopyToNotebookRequest {
	return ApiGroupsGroupOnenoteNotebooksNotebookSectionGroupsSectionGroupSectionsOnenoteSectionPagesOnenotePageParentSectionCopyToNotebookRequest{
		ApiService: a,
		ctx: ctx,
		groupId: groupId,
		notebookId: notebookId,
		sectionGroupId: sectionGroupId,
		onenoteSectionId: onenoteSectionId,
		onenotePageId: onenotePageId,
	}
}

// Execute executes the request
//  @return AnyOfmicrosoftGraphOnenoteOperation
func (a *GroupsActionsApiService) GroupsGroupOnenoteNotebooksNotebookSectionGroupsSectionGroupSectionsOnenoteSectionPagesOnenotePageParentSectionCopyToNotebookExecute(r ApiGroupsGroupOnenoteNotebooksNotebookSectionGroupsSectionGroupSectionsOnenoteSectionPagesOnenotePageParentSectionCopyToNotebookRequest) (AnyOfmicrosoftGraphOnenoteOperation, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  AnyOfmicrosoftGraphOnenoteOperation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GroupsActionsApiService.GroupsGroupOnenoteNotebooksNotebookSectionGroupsSectionGroupSectionsOnenoteSectionPagesOnenotePageParentSectionCopyToNotebook")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/groups/{group-id}/onenote/notebooks/{notebook-id}/sectionGroups/{sectionGroup-id}/sections/{onenoteSection-id}/pages/{onenotePage-id}/parentSection/microsoft.graph.copyToNotebook"
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"notebook-id"+"}", _neturl.PathEscape(parameterToString(r.notebookId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"sectionGroup-id"+"}", _neturl.PathEscape(parameterToString(r.sectionGroupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"onenoteSection-id"+"}", _neturl.PathEscape(parameterToString(r.onenoteSectionId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"onenotePage-id"+"}", _neturl.PathEscape(parameterToString(r.onenotePageId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject249 == nil {
		return localVarReturnValue, nil, reportError("inlineObject249 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject249
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGroupsGroupOnenoteNotebooksNotebookSectionGroupsSectionGroupSectionsOnenoteSectionPagesOnenotePageParentSectionCopyToSectionGroupRequest struct {
	ctx _context.Context
	ApiService *GroupsActionsApiService
	groupId string
	notebookId string
	sectionGroupId string
	onenoteSectionId string
	onenotePageId string
	inlineObject250 *InlineObject250
}

func (r ApiGroupsGroupOnenoteNotebooksNotebookSectionGroupsSectionGroupSectionsOnenoteSectionPagesOnenotePageParentSectionCopyToSectionGroupRequest) InlineObject250(inlineObject250 InlineObject250) ApiGroupsGroupOnenoteNotebooksNotebookSectionGroupsSectionGroupSectionsOnenoteSectionPagesOnenotePageParentSectionCopyToSectionGroupRequest {
	r.inlineObject250 = &inlineObject250
	return r
}

func (r ApiGroupsGroupOnenoteNotebooksNotebookSectionGroupsSectionGroupSectionsOnenoteSectionPagesOnenotePageParentSectionCopyToSectionGroupRequest) Execute() (AnyOfmicrosoftGraphOnenoteOperation, *_nethttp.Response, error) {
	return r.ApiService.GroupsGroupOnenoteNotebooksNotebookSectionGroupsSectionGroupSectionsOnenoteSectionPagesOnenotePageParentSectionCopyToSectionGroupExecute(r)
}

/*
GroupsGroupOnenoteNotebooksNotebookSectionGroupsSectionGroupSectionsOnenoteSectionPagesOnenotePageParentSectionCopyToSectionGroup Invoke action copyToSectionGroup

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupId key: id of group
 @param notebookId key: id of notebook
 @param sectionGroupId key: id of sectionGroup
 @param onenoteSectionId key: id of onenoteSection
 @param onenotePageId key: id of onenotePage
 @return ApiGroupsGroupOnenoteNotebooksNotebookSectionGroupsSectionGroupSectionsOnenoteSectionPagesOnenotePageParentSectionCopyToSectionGroupRequest
*/
func (a *GroupsActionsApiService) GroupsGroupOnenoteNotebooksNotebookSectionGroupsSectionGroupSectionsOnenoteSectionPagesOnenotePageParentSectionCopyToSectionGroup(ctx _context.Context, groupId string, notebookId string, sectionGroupId string, onenoteSectionId string, onenotePageId string) ApiGroupsGroupOnenoteNotebooksNotebookSectionGroupsSectionGroupSectionsOnenoteSectionPagesOnenotePageParentSectionCopyToSectionGroupRequest {
	return ApiGroupsGroupOnenoteNotebooksNotebookSectionGroupsSectionGroupSectionsOnenoteSectionPagesOnenotePageParentSectionCopyToSectionGroupRequest{
		ApiService: a,
		ctx: ctx,
		groupId: groupId,
		notebookId: notebookId,
		sectionGroupId: sectionGroupId,
		onenoteSectionId: onenoteSectionId,
		onenotePageId: onenotePageId,
	}
}

// Execute executes the request
//  @return AnyOfmicrosoftGraphOnenoteOperation
func (a *GroupsActionsApiService) GroupsGroupOnenoteNotebooksNotebookSectionGroupsSectionGroupSectionsOnenoteSectionPagesOnenotePageParentSectionCopyToSectionGroupExecute(r ApiGroupsGroupOnenoteNotebooksNotebookSectionGroupsSectionGroupSectionsOnenoteSectionPagesOnenotePageParentSectionCopyToSectionGroupRequest) (AnyOfmicrosoftGraphOnenoteOperation, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  AnyOfmicrosoftGraphOnenoteOperation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GroupsActionsApiService.GroupsGroupOnenoteNotebooksNotebookSectionGroupsSectionGroupSectionsOnenoteSectionPagesOnenotePageParentSectionCopyToSectionGroup")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/groups/{group-id}/onenote/notebooks/{notebook-id}/sectionGroups/{sectionGroup-id}/sections/{onenoteSection-id}/pages/{onenotePage-id}/parentSection/microsoft.graph.copyToSectionGroup"
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"notebook-id"+"}", _neturl.PathEscape(parameterToString(r.notebookId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"sectionGroup-id"+"}", _neturl.PathEscape(parameterToString(r.sectionGroupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"onenoteSection-id"+"}", _neturl.PathEscape(parameterToString(r.onenoteSectionId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"onenotePage-id"+"}", _neturl.PathEscape(parameterToString(r.onenotePageId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject250 == nil {
		return localVarReturnValue, nil, reportError("inlineObject250 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject250
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGroupsGroupOnenoteNotebooksNotebookSectionGroupsSectionGroupSectionsOnenoteSectionParentNotebookCopyNotebookRequest struct {
	ctx _context.Context
	ApiService *GroupsActionsApiService
	groupId string
	notebookId string
	sectionGroupId string
	onenoteSectionId string
	inlineObject251 *InlineObject251
}

func (r ApiGroupsGroupOnenoteNotebooksNotebookSectionGroupsSectionGroupSectionsOnenoteSectionParentNotebookCopyNotebookRequest) InlineObject251(inlineObject251 InlineObject251) ApiGroupsGroupOnenoteNotebooksNotebookSectionGroupsSectionGroupSectionsOnenoteSectionParentNotebookCopyNotebookRequest {
	r.inlineObject251 = &inlineObject251
	return r
}

func (r ApiGroupsGroupOnenoteNotebooksNotebookSectionGroupsSectionGroupSectionsOnenoteSectionParentNotebookCopyNotebookRequest) Execute() (AnyOfmicrosoftGraphOnenoteOperation, *_nethttp.Response, error) {
	return r.ApiService.GroupsGroupOnenoteNotebooksNotebookSectionGroupsSectionGroupSectionsOnenoteSectionParentNotebookCopyNotebookExecute(r)
}

/*
GroupsGroupOnenoteNotebooksNotebookSectionGroupsSectionGroupSectionsOnenoteSectionParentNotebookCopyNotebook Invoke action copyNotebook

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupId key: id of group
 @param notebookId key: id of notebook
 @param sectionGroupId key: id of sectionGroup
 @param onenoteSectionId key: id of onenoteSection
 @return ApiGroupsGroupOnenoteNotebooksNotebookSectionGroupsSectionGroupSectionsOnenoteSectionParentNotebookCopyNotebookRequest
*/
func (a *GroupsActionsApiService) GroupsGroupOnenoteNotebooksNotebookSectionGroupsSectionGroupSectionsOnenoteSectionParentNotebookCopyNotebook(ctx _context.Context, groupId string, notebookId string, sectionGroupId string, onenoteSectionId string) ApiGroupsGroupOnenoteNotebooksNotebookSectionGroupsSectionGroupSectionsOnenoteSectionParentNotebookCopyNotebookRequest {
	return ApiGroupsGroupOnenoteNotebooksNotebookSectionGroupsSectionGroupSectionsOnenoteSectionParentNotebookCopyNotebookRequest{
		ApiService: a,
		ctx: ctx,
		groupId: groupId,
		notebookId: notebookId,
		sectionGroupId: sectionGroupId,
		onenoteSectionId: onenoteSectionId,
	}
}

// Execute executes the request
//  @return AnyOfmicrosoftGraphOnenoteOperation
func (a *GroupsActionsApiService) GroupsGroupOnenoteNotebooksNotebookSectionGroupsSectionGroupSectionsOnenoteSectionParentNotebookCopyNotebookExecute(r ApiGroupsGroupOnenoteNotebooksNotebookSectionGroupsSectionGroupSectionsOnenoteSectionParentNotebookCopyNotebookRequest) (AnyOfmicrosoftGraphOnenoteOperation, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  AnyOfmicrosoftGraphOnenoteOperation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GroupsActionsApiService.GroupsGroupOnenoteNotebooksNotebookSectionGroupsSectionGroupSectionsOnenoteSectionParentNotebookCopyNotebook")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/groups/{group-id}/onenote/notebooks/{notebook-id}/sectionGroups/{sectionGroup-id}/sections/{onenoteSection-id}/parentNotebook/microsoft.graph.copyNotebook"
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"notebook-id"+"}", _neturl.PathEscape(parameterToString(r.notebookId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"sectionGroup-id"+"}", _neturl.PathEscape(parameterToString(r.sectionGroupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"onenoteSection-id"+"}", _neturl.PathEscape(parameterToString(r.onenoteSectionId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject251 == nil {
		return localVarReturnValue, nil, reportError("inlineObject251 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject251
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGroupsGroupOnenoteNotebooksNotebookSectionsOnenoteSectionCopyToNotebookRequest struct {
	ctx _context.Context
	ApiService *GroupsActionsApiService
	groupId string
	notebookId string
	onenoteSectionId string
	inlineObject252 *InlineObject252
}

func (r ApiGroupsGroupOnenoteNotebooksNotebookSectionsOnenoteSectionCopyToNotebookRequest) InlineObject252(inlineObject252 InlineObject252) ApiGroupsGroupOnenoteNotebooksNotebookSectionsOnenoteSectionCopyToNotebookRequest {
	r.inlineObject252 = &inlineObject252
	return r
}

func (r ApiGroupsGroupOnenoteNotebooksNotebookSectionsOnenoteSectionCopyToNotebookRequest) Execute() (AnyOfmicrosoftGraphOnenoteOperation, *_nethttp.Response, error) {
	return r.ApiService.GroupsGroupOnenoteNotebooksNotebookSectionsOnenoteSectionCopyToNotebookExecute(r)
}

/*
GroupsGroupOnenoteNotebooksNotebookSectionsOnenoteSectionCopyToNotebook Invoke action copyToNotebook

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupId key: id of group
 @param notebookId key: id of notebook
 @param onenoteSectionId key: id of onenoteSection
 @return ApiGroupsGroupOnenoteNotebooksNotebookSectionsOnenoteSectionCopyToNotebookRequest
*/
func (a *GroupsActionsApiService) GroupsGroupOnenoteNotebooksNotebookSectionsOnenoteSectionCopyToNotebook(ctx _context.Context, groupId string, notebookId string, onenoteSectionId string) ApiGroupsGroupOnenoteNotebooksNotebookSectionsOnenoteSectionCopyToNotebookRequest {
	return ApiGroupsGroupOnenoteNotebooksNotebookSectionsOnenoteSectionCopyToNotebookRequest{
		ApiService: a,
		ctx: ctx,
		groupId: groupId,
		notebookId: notebookId,
		onenoteSectionId: onenoteSectionId,
	}
}

// Execute executes the request
//  @return AnyOfmicrosoftGraphOnenoteOperation
func (a *GroupsActionsApiService) GroupsGroupOnenoteNotebooksNotebookSectionsOnenoteSectionCopyToNotebookExecute(r ApiGroupsGroupOnenoteNotebooksNotebookSectionsOnenoteSectionCopyToNotebookRequest) (AnyOfmicrosoftGraphOnenoteOperation, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  AnyOfmicrosoftGraphOnenoteOperation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GroupsActionsApiService.GroupsGroupOnenoteNotebooksNotebookSectionsOnenoteSectionCopyToNotebook")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/groups/{group-id}/onenote/notebooks/{notebook-id}/sections/{onenoteSection-id}/microsoft.graph.copyToNotebook"
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"notebook-id"+"}", _neturl.PathEscape(parameterToString(r.notebookId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"onenoteSection-id"+"}", _neturl.PathEscape(parameterToString(r.onenoteSectionId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject252 == nil {
		return localVarReturnValue, nil, reportError("inlineObject252 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject252
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGroupsGroupOnenoteNotebooksNotebookSectionsOnenoteSectionCopyToSectionGroupRequest struct {
	ctx _context.Context
	ApiService *GroupsActionsApiService
	groupId string
	notebookId string
	onenoteSectionId string
	inlineObject253 *InlineObject253
}

func (r ApiGroupsGroupOnenoteNotebooksNotebookSectionsOnenoteSectionCopyToSectionGroupRequest) InlineObject253(inlineObject253 InlineObject253) ApiGroupsGroupOnenoteNotebooksNotebookSectionsOnenoteSectionCopyToSectionGroupRequest {
	r.inlineObject253 = &inlineObject253
	return r
}

func (r ApiGroupsGroupOnenoteNotebooksNotebookSectionsOnenoteSectionCopyToSectionGroupRequest) Execute() (AnyOfmicrosoftGraphOnenoteOperation, *_nethttp.Response, error) {
	return r.ApiService.GroupsGroupOnenoteNotebooksNotebookSectionsOnenoteSectionCopyToSectionGroupExecute(r)
}

/*
GroupsGroupOnenoteNotebooksNotebookSectionsOnenoteSectionCopyToSectionGroup Invoke action copyToSectionGroup

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupId key: id of group
 @param notebookId key: id of notebook
 @param onenoteSectionId key: id of onenoteSection
 @return ApiGroupsGroupOnenoteNotebooksNotebookSectionsOnenoteSectionCopyToSectionGroupRequest
*/
func (a *GroupsActionsApiService) GroupsGroupOnenoteNotebooksNotebookSectionsOnenoteSectionCopyToSectionGroup(ctx _context.Context, groupId string, notebookId string, onenoteSectionId string) ApiGroupsGroupOnenoteNotebooksNotebookSectionsOnenoteSectionCopyToSectionGroupRequest {
	return ApiGroupsGroupOnenoteNotebooksNotebookSectionsOnenoteSectionCopyToSectionGroupRequest{
		ApiService: a,
		ctx: ctx,
		groupId: groupId,
		notebookId: notebookId,
		onenoteSectionId: onenoteSectionId,
	}
}

// Execute executes the request
//  @return AnyOfmicrosoftGraphOnenoteOperation
func (a *GroupsActionsApiService) GroupsGroupOnenoteNotebooksNotebookSectionsOnenoteSectionCopyToSectionGroupExecute(r ApiGroupsGroupOnenoteNotebooksNotebookSectionsOnenoteSectionCopyToSectionGroupRequest) (AnyOfmicrosoftGraphOnenoteOperation, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  AnyOfmicrosoftGraphOnenoteOperation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GroupsActionsApiService.GroupsGroupOnenoteNotebooksNotebookSectionsOnenoteSectionCopyToSectionGroup")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/groups/{group-id}/onenote/notebooks/{notebook-id}/sections/{onenoteSection-id}/microsoft.graph.copyToSectionGroup"
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"notebook-id"+"}", _neturl.PathEscape(parameterToString(r.notebookId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"onenoteSection-id"+"}", _neturl.PathEscape(parameterToString(r.onenoteSectionId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject253 == nil {
		return localVarReturnValue, nil, reportError("inlineObject253 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject253
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGroupsGroupOnenoteNotebooksNotebookSectionsOnenoteSectionPagesOnenotePageCopyToSectionRequest struct {
	ctx _context.Context
	ApiService *GroupsActionsApiService
	groupId string
	notebookId string
	onenoteSectionId string
	onenotePageId string
	inlineObject254 *InlineObject254
}

func (r ApiGroupsGroupOnenoteNotebooksNotebookSectionsOnenoteSectionPagesOnenotePageCopyToSectionRequest) InlineObject254(inlineObject254 InlineObject254) ApiGroupsGroupOnenoteNotebooksNotebookSectionsOnenoteSectionPagesOnenotePageCopyToSectionRequest {
	r.inlineObject254 = &inlineObject254
	return r
}

func (r ApiGroupsGroupOnenoteNotebooksNotebookSectionsOnenoteSectionPagesOnenotePageCopyToSectionRequest) Execute() (AnyOfmicrosoftGraphOnenoteOperation, *_nethttp.Response, error) {
	return r.ApiService.GroupsGroupOnenoteNotebooksNotebookSectionsOnenoteSectionPagesOnenotePageCopyToSectionExecute(r)
}

/*
GroupsGroupOnenoteNotebooksNotebookSectionsOnenoteSectionPagesOnenotePageCopyToSection Invoke action copyToSection

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupId key: id of group
 @param notebookId key: id of notebook
 @param onenoteSectionId key: id of onenoteSection
 @param onenotePageId key: id of onenotePage
 @return ApiGroupsGroupOnenoteNotebooksNotebookSectionsOnenoteSectionPagesOnenotePageCopyToSectionRequest
*/
func (a *GroupsActionsApiService) GroupsGroupOnenoteNotebooksNotebookSectionsOnenoteSectionPagesOnenotePageCopyToSection(ctx _context.Context, groupId string, notebookId string, onenoteSectionId string, onenotePageId string) ApiGroupsGroupOnenoteNotebooksNotebookSectionsOnenoteSectionPagesOnenotePageCopyToSectionRequest {
	return ApiGroupsGroupOnenoteNotebooksNotebookSectionsOnenoteSectionPagesOnenotePageCopyToSectionRequest{
		ApiService: a,
		ctx: ctx,
		groupId: groupId,
		notebookId: notebookId,
		onenoteSectionId: onenoteSectionId,
		onenotePageId: onenotePageId,
	}
}

// Execute executes the request
//  @return AnyOfmicrosoftGraphOnenoteOperation
func (a *GroupsActionsApiService) GroupsGroupOnenoteNotebooksNotebookSectionsOnenoteSectionPagesOnenotePageCopyToSectionExecute(r ApiGroupsGroupOnenoteNotebooksNotebookSectionsOnenoteSectionPagesOnenotePageCopyToSectionRequest) (AnyOfmicrosoftGraphOnenoteOperation, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  AnyOfmicrosoftGraphOnenoteOperation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GroupsActionsApiService.GroupsGroupOnenoteNotebooksNotebookSectionsOnenoteSectionPagesOnenotePageCopyToSection")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/groups/{group-id}/onenote/notebooks/{notebook-id}/sections/{onenoteSection-id}/pages/{onenotePage-id}/microsoft.graph.copyToSection"
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"notebook-id"+"}", _neturl.PathEscape(parameterToString(r.notebookId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"onenoteSection-id"+"}", _neturl.PathEscape(parameterToString(r.onenoteSectionId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"onenotePage-id"+"}", _neturl.PathEscape(parameterToString(r.onenotePageId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject254 == nil {
		return localVarReturnValue, nil, reportError("inlineObject254 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject254
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGroupsGroupOnenoteNotebooksNotebookSectionsOnenoteSectionPagesOnenotePageOnenotePatchContentRequest struct {
	ctx _context.Context
	ApiService *GroupsActionsApiService
	groupId string
	notebookId string
	onenoteSectionId string
	onenotePageId string
	inlineObject255 *InlineObject255
}

func (r ApiGroupsGroupOnenoteNotebooksNotebookSectionsOnenoteSectionPagesOnenotePageOnenotePatchContentRequest) InlineObject255(inlineObject255 InlineObject255) ApiGroupsGroupOnenoteNotebooksNotebookSectionsOnenoteSectionPagesOnenotePageOnenotePatchContentRequest {
	r.inlineObject255 = &inlineObject255
	return r
}

func (r ApiGroupsGroupOnenoteNotebooksNotebookSectionsOnenoteSectionPagesOnenotePageOnenotePatchContentRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.GroupsGroupOnenoteNotebooksNotebookSectionsOnenoteSectionPagesOnenotePageOnenotePatchContentExecute(r)
}

/*
GroupsGroupOnenoteNotebooksNotebookSectionsOnenoteSectionPagesOnenotePageOnenotePatchContent Invoke action onenotePatchContent

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupId key: id of group
 @param notebookId key: id of notebook
 @param onenoteSectionId key: id of onenoteSection
 @param onenotePageId key: id of onenotePage
 @return ApiGroupsGroupOnenoteNotebooksNotebookSectionsOnenoteSectionPagesOnenotePageOnenotePatchContentRequest
*/
func (a *GroupsActionsApiService) GroupsGroupOnenoteNotebooksNotebookSectionsOnenoteSectionPagesOnenotePageOnenotePatchContent(ctx _context.Context, groupId string, notebookId string, onenoteSectionId string, onenotePageId string) ApiGroupsGroupOnenoteNotebooksNotebookSectionsOnenoteSectionPagesOnenotePageOnenotePatchContentRequest {
	return ApiGroupsGroupOnenoteNotebooksNotebookSectionsOnenoteSectionPagesOnenotePageOnenotePatchContentRequest{
		ApiService: a,
		ctx: ctx,
		groupId: groupId,
		notebookId: notebookId,
		onenoteSectionId: onenoteSectionId,
		onenotePageId: onenotePageId,
	}
}

// Execute executes the request
func (a *GroupsActionsApiService) GroupsGroupOnenoteNotebooksNotebookSectionsOnenoteSectionPagesOnenotePageOnenotePatchContentExecute(r ApiGroupsGroupOnenoteNotebooksNotebookSectionsOnenoteSectionPagesOnenotePageOnenotePatchContentRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GroupsActionsApiService.GroupsGroupOnenoteNotebooksNotebookSectionsOnenoteSectionPagesOnenotePageOnenotePatchContent")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/groups/{group-id}/onenote/notebooks/{notebook-id}/sections/{onenoteSection-id}/pages/{onenotePage-id}/microsoft.graph.onenotePatchContent"
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"notebook-id"+"}", _neturl.PathEscape(parameterToString(r.notebookId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"onenoteSection-id"+"}", _neturl.PathEscape(parameterToString(r.onenoteSectionId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"onenotePage-id"+"}", _neturl.PathEscape(parameterToString(r.onenotePageId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject255 == nil {
		return nil, reportError("inlineObject255 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject255
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGroupsGroupOnenoteNotebooksNotebookSectionsOnenoteSectionPagesOnenotePageParentNotebookCopyNotebookRequest struct {
	ctx _context.Context
	ApiService *GroupsActionsApiService
	groupId string
	notebookId string
	onenoteSectionId string
	onenotePageId string
	inlineObject256 *InlineObject256
}

func (r ApiGroupsGroupOnenoteNotebooksNotebookSectionsOnenoteSectionPagesOnenotePageParentNotebookCopyNotebookRequest) InlineObject256(inlineObject256 InlineObject256) ApiGroupsGroupOnenoteNotebooksNotebookSectionsOnenoteSectionPagesOnenotePageParentNotebookCopyNotebookRequest {
	r.inlineObject256 = &inlineObject256
	return r
}

func (r ApiGroupsGroupOnenoteNotebooksNotebookSectionsOnenoteSectionPagesOnenotePageParentNotebookCopyNotebookRequest) Execute() (AnyOfmicrosoftGraphOnenoteOperation, *_nethttp.Response, error) {
	return r.ApiService.GroupsGroupOnenoteNotebooksNotebookSectionsOnenoteSectionPagesOnenotePageParentNotebookCopyNotebookExecute(r)
}

/*
GroupsGroupOnenoteNotebooksNotebookSectionsOnenoteSectionPagesOnenotePageParentNotebookCopyNotebook Invoke action copyNotebook

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupId key: id of group
 @param notebookId key: id of notebook
 @param onenoteSectionId key: id of onenoteSection
 @param onenotePageId key: id of onenotePage
 @return ApiGroupsGroupOnenoteNotebooksNotebookSectionsOnenoteSectionPagesOnenotePageParentNotebookCopyNotebookRequest
*/
func (a *GroupsActionsApiService) GroupsGroupOnenoteNotebooksNotebookSectionsOnenoteSectionPagesOnenotePageParentNotebookCopyNotebook(ctx _context.Context, groupId string, notebookId string, onenoteSectionId string, onenotePageId string) ApiGroupsGroupOnenoteNotebooksNotebookSectionsOnenoteSectionPagesOnenotePageParentNotebookCopyNotebookRequest {
	return ApiGroupsGroupOnenoteNotebooksNotebookSectionsOnenoteSectionPagesOnenotePageParentNotebookCopyNotebookRequest{
		ApiService: a,
		ctx: ctx,
		groupId: groupId,
		notebookId: notebookId,
		onenoteSectionId: onenoteSectionId,
		onenotePageId: onenotePageId,
	}
}

// Execute executes the request
//  @return AnyOfmicrosoftGraphOnenoteOperation
func (a *GroupsActionsApiService) GroupsGroupOnenoteNotebooksNotebookSectionsOnenoteSectionPagesOnenotePageParentNotebookCopyNotebookExecute(r ApiGroupsGroupOnenoteNotebooksNotebookSectionsOnenoteSectionPagesOnenotePageParentNotebookCopyNotebookRequest) (AnyOfmicrosoftGraphOnenoteOperation, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  AnyOfmicrosoftGraphOnenoteOperation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GroupsActionsApiService.GroupsGroupOnenoteNotebooksNotebookSectionsOnenoteSectionPagesOnenotePageParentNotebookCopyNotebook")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/groups/{group-id}/onenote/notebooks/{notebook-id}/sections/{onenoteSection-id}/pages/{onenotePage-id}/parentNotebook/microsoft.graph.copyNotebook"
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"notebook-id"+"}", _neturl.PathEscape(parameterToString(r.notebookId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"onenoteSection-id"+"}", _neturl.PathEscape(parameterToString(r.onenoteSectionId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"onenotePage-id"+"}", _neturl.PathEscape(parameterToString(r.onenotePageId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject256 == nil {
		return localVarReturnValue, nil, reportError("inlineObject256 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject256
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGroupsGroupOnenoteNotebooksNotebookSectionsOnenoteSectionPagesOnenotePageParentSectionCopyToNotebookRequest struct {
	ctx _context.Context
	ApiService *GroupsActionsApiService
	groupId string
	notebookId string
	onenoteSectionId string
	onenotePageId string
	inlineObject257 *InlineObject257
}

func (r ApiGroupsGroupOnenoteNotebooksNotebookSectionsOnenoteSectionPagesOnenotePageParentSectionCopyToNotebookRequest) InlineObject257(inlineObject257 InlineObject257) ApiGroupsGroupOnenoteNotebooksNotebookSectionsOnenoteSectionPagesOnenotePageParentSectionCopyToNotebookRequest {
	r.inlineObject257 = &inlineObject257
	return r
}

func (r ApiGroupsGroupOnenoteNotebooksNotebookSectionsOnenoteSectionPagesOnenotePageParentSectionCopyToNotebookRequest) Execute() (AnyOfmicrosoftGraphOnenoteOperation, *_nethttp.Response, error) {
	return r.ApiService.GroupsGroupOnenoteNotebooksNotebookSectionsOnenoteSectionPagesOnenotePageParentSectionCopyToNotebookExecute(r)
}

/*
GroupsGroupOnenoteNotebooksNotebookSectionsOnenoteSectionPagesOnenotePageParentSectionCopyToNotebook Invoke action copyToNotebook

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupId key: id of group
 @param notebookId key: id of notebook
 @param onenoteSectionId key: id of onenoteSection
 @param onenotePageId key: id of onenotePage
 @return ApiGroupsGroupOnenoteNotebooksNotebookSectionsOnenoteSectionPagesOnenotePageParentSectionCopyToNotebookRequest
*/
func (a *GroupsActionsApiService) GroupsGroupOnenoteNotebooksNotebookSectionsOnenoteSectionPagesOnenotePageParentSectionCopyToNotebook(ctx _context.Context, groupId string, notebookId string, onenoteSectionId string, onenotePageId string) ApiGroupsGroupOnenoteNotebooksNotebookSectionsOnenoteSectionPagesOnenotePageParentSectionCopyToNotebookRequest {
	return ApiGroupsGroupOnenoteNotebooksNotebookSectionsOnenoteSectionPagesOnenotePageParentSectionCopyToNotebookRequest{
		ApiService: a,
		ctx: ctx,
		groupId: groupId,
		notebookId: notebookId,
		onenoteSectionId: onenoteSectionId,
		onenotePageId: onenotePageId,
	}
}

// Execute executes the request
//  @return AnyOfmicrosoftGraphOnenoteOperation
func (a *GroupsActionsApiService) GroupsGroupOnenoteNotebooksNotebookSectionsOnenoteSectionPagesOnenotePageParentSectionCopyToNotebookExecute(r ApiGroupsGroupOnenoteNotebooksNotebookSectionsOnenoteSectionPagesOnenotePageParentSectionCopyToNotebookRequest) (AnyOfmicrosoftGraphOnenoteOperation, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  AnyOfmicrosoftGraphOnenoteOperation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GroupsActionsApiService.GroupsGroupOnenoteNotebooksNotebookSectionsOnenoteSectionPagesOnenotePageParentSectionCopyToNotebook")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/groups/{group-id}/onenote/notebooks/{notebook-id}/sections/{onenoteSection-id}/pages/{onenotePage-id}/parentSection/microsoft.graph.copyToNotebook"
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"notebook-id"+"}", _neturl.PathEscape(parameterToString(r.notebookId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"onenoteSection-id"+"}", _neturl.PathEscape(parameterToString(r.onenoteSectionId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"onenotePage-id"+"}", _neturl.PathEscape(parameterToString(r.onenotePageId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject257 == nil {
		return localVarReturnValue, nil, reportError("inlineObject257 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject257
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGroupsGroupOnenoteNotebooksNotebookSectionsOnenoteSectionPagesOnenotePageParentSectionCopyToSectionGroupRequest struct {
	ctx _context.Context
	ApiService *GroupsActionsApiService
	groupId string
	notebookId string
	onenoteSectionId string
	onenotePageId string
	inlineObject258 *InlineObject258
}

func (r ApiGroupsGroupOnenoteNotebooksNotebookSectionsOnenoteSectionPagesOnenotePageParentSectionCopyToSectionGroupRequest) InlineObject258(inlineObject258 InlineObject258) ApiGroupsGroupOnenoteNotebooksNotebookSectionsOnenoteSectionPagesOnenotePageParentSectionCopyToSectionGroupRequest {
	r.inlineObject258 = &inlineObject258
	return r
}

func (r ApiGroupsGroupOnenoteNotebooksNotebookSectionsOnenoteSectionPagesOnenotePageParentSectionCopyToSectionGroupRequest) Execute() (AnyOfmicrosoftGraphOnenoteOperation, *_nethttp.Response, error) {
	return r.ApiService.GroupsGroupOnenoteNotebooksNotebookSectionsOnenoteSectionPagesOnenotePageParentSectionCopyToSectionGroupExecute(r)
}

/*
GroupsGroupOnenoteNotebooksNotebookSectionsOnenoteSectionPagesOnenotePageParentSectionCopyToSectionGroup Invoke action copyToSectionGroup

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupId key: id of group
 @param notebookId key: id of notebook
 @param onenoteSectionId key: id of onenoteSection
 @param onenotePageId key: id of onenotePage
 @return ApiGroupsGroupOnenoteNotebooksNotebookSectionsOnenoteSectionPagesOnenotePageParentSectionCopyToSectionGroupRequest
*/
func (a *GroupsActionsApiService) GroupsGroupOnenoteNotebooksNotebookSectionsOnenoteSectionPagesOnenotePageParentSectionCopyToSectionGroup(ctx _context.Context, groupId string, notebookId string, onenoteSectionId string, onenotePageId string) ApiGroupsGroupOnenoteNotebooksNotebookSectionsOnenoteSectionPagesOnenotePageParentSectionCopyToSectionGroupRequest {
	return ApiGroupsGroupOnenoteNotebooksNotebookSectionsOnenoteSectionPagesOnenotePageParentSectionCopyToSectionGroupRequest{
		ApiService: a,
		ctx: ctx,
		groupId: groupId,
		notebookId: notebookId,
		onenoteSectionId: onenoteSectionId,
		onenotePageId: onenotePageId,
	}
}

// Execute executes the request
//  @return AnyOfmicrosoftGraphOnenoteOperation
func (a *GroupsActionsApiService) GroupsGroupOnenoteNotebooksNotebookSectionsOnenoteSectionPagesOnenotePageParentSectionCopyToSectionGroupExecute(r ApiGroupsGroupOnenoteNotebooksNotebookSectionsOnenoteSectionPagesOnenotePageParentSectionCopyToSectionGroupRequest) (AnyOfmicrosoftGraphOnenoteOperation, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  AnyOfmicrosoftGraphOnenoteOperation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GroupsActionsApiService.GroupsGroupOnenoteNotebooksNotebookSectionsOnenoteSectionPagesOnenotePageParentSectionCopyToSectionGroup")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/groups/{group-id}/onenote/notebooks/{notebook-id}/sections/{onenoteSection-id}/pages/{onenotePage-id}/parentSection/microsoft.graph.copyToSectionGroup"
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"notebook-id"+"}", _neturl.PathEscape(parameterToString(r.notebookId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"onenoteSection-id"+"}", _neturl.PathEscape(parameterToString(r.onenoteSectionId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"onenotePage-id"+"}", _neturl.PathEscape(parameterToString(r.onenotePageId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject258 == nil {
		return localVarReturnValue, nil, reportError("inlineObject258 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject258
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGroupsGroupOnenoteNotebooksNotebookSectionsOnenoteSectionParentNotebookCopyNotebookRequest struct {
	ctx _context.Context
	ApiService *GroupsActionsApiService
	groupId string
	notebookId string
	onenoteSectionId string
	inlineObject259 *InlineObject259
}

func (r ApiGroupsGroupOnenoteNotebooksNotebookSectionsOnenoteSectionParentNotebookCopyNotebookRequest) InlineObject259(inlineObject259 InlineObject259) ApiGroupsGroupOnenoteNotebooksNotebookSectionsOnenoteSectionParentNotebookCopyNotebookRequest {
	r.inlineObject259 = &inlineObject259
	return r
}

func (r ApiGroupsGroupOnenoteNotebooksNotebookSectionsOnenoteSectionParentNotebookCopyNotebookRequest) Execute() (AnyOfmicrosoftGraphOnenoteOperation, *_nethttp.Response, error) {
	return r.ApiService.GroupsGroupOnenoteNotebooksNotebookSectionsOnenoteSectionParentNotebookCopyNotebookExecute(r)
}

/*
GroupsGroupOnenoteNotebooksNotebookSectionsOnenoteSectionParentNotebookCopyNotebook Invoke action copyNotebook

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupId key: id of group
 @param notebookId key: id of notebook
 @param onenoteSectionId key: id of onenoteSection
 @return ApiGroupsGroupOnenoteNotebooksNotebookSectionsOnenoteSectionParentNotebookCopyNotebookRequest
*/
func (a *GroupsActionsApiService) GroupsGroupOnenoteNotebooksNotebookSectionsOnenoteSectionParentNotebookCopyNotebook(ctx _context.Context, groupId string, notebookId string, onenoteSectionId string) ApiGroupsGroupOnenoteNotebooksNotebookSectionsOnenoteSectionParentNotebookCopyNotebookRequest {
	return ApiGroupsGroupOnenoteNotebooksNotebookSectionsOnenoteSectionParentNotebookCopyNotebookRequest{
		ApiService: a,
		ctx: ctx,
		groupId: groupId,
		notebookId: notebookId,
		onenoteSectionId: onenoteSectionId,
	}
}

// Execute executes the request
//  @return AnyOfmicrosoftGraphOnenoteOperation
func (a *GroupsActionsApiService) GroupsGroupOnenoteNotebooksNotebookSectionsOnenoteSectionParentNotebookCopyNotebookExecute(r ApiGroupsGroupOnenoteNotebooksNotebookSectionsOnenoteSectionParentNotebookCopyNotebookRequest) (AnyOfmicrosoftGraphOnenoteOperation, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  AnyOfmicrosoftGraphOnenoteOperation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GroupsActionsApiService.GroupsGroupOnenoteNotebooksNotebookSectionsOnenoteSectionParentNotebookCopyNotebook")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/groups/{group-id}/onenote/notebooks/{notebook-id}/sections/{onenoteSection-id}/parentNotebook/microsoft.graph.copyNotebook"
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"notebook-id"+"}", _neturl.PathEscape(parameterToString(r.notebookId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"onenoteSection-id"+"}", _neturl.PathEscape(parameterToString(r.onenoteSectionId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject259 == nil {
		return localVarReturnValue, nil, reportError("inlineObject259 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject259
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGroupsGroupOnenoteNotebooksNotebookSectionsOnenoteSectionParentSectionGroupParentNotebookCopyNotebookRequest struct {
	ctx _context.Context
	ApiService *GroupsActionsApiService
	groupId string
	notebookId string
	onenoteSectionId string
	inlineObject260 *InlineObject260
}

func (r ApiGroupsGroupOnenoteNotebooksNotebookSectionsOnenoteSectionParentSectionGroupParentNotebookCopyNotebookRequest) InlineObject260(inlineObject260 InlineObject260) ApiGroupsGroupOnenoteNotebooksNotebookSectionsOnenoteSectionParentSectionGroupParentNotebookCopyNotebookRequest {
	r.inlineObject260 = &inlineObject260
	return r
}

func (r ApiGroupsGroupOnenoteNotebooksNotebookSectionsOnenoteSectionParentSectionGroupParentNotebookCopyNotebookRequest) Execute() (AnyOfmicrosoftGraphOnenoteOperation, *_nethttp.Response, error) {
	return r.ApiService.GroupsGroupOnenoteNotebooksNotebookSectionsOnenoteSectionParentSectionGroupParentNotebookCopyNotebookExecute(r)
}

/*
GroupsGroupOnenoteNotebooksNotebookSectionsOnenoteSectionParentSectionGroupParentNotebookCopyNotebook Invoke action copyNotebook

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupId key: id of group
 @param notebookId key: id of notebook
 @param onenoteSectionId key: id of onenoteSection
 @return ApiGroupsGroupOnenoteNotebooksNotebookSectionsOnenoteSectionParentSectionGroupParentNotebookCopyNotebookRequest
*/
func (a *GroupsActionsApiService) GroupsGroupOnenoteNotebooksNotebookSectionsOnenoteSectionParentSectionGroupParentNotebookCopyNotebook(ctx _context.Context, groupId string, notebookId string, onenoteSectionId string) ApiGroupsGroupOnenoteNotebooksNotebookSectionsOnenoteSectionParentSectionGroupParentNotebookCopyNotebookRequest {
	return ApiGroupsGroupOnenoteNotebooksNotebookSectionsOnenoteSectionParentSectionGroupParentNotebookCopyNotebookRequest{
		ApiService: a,
		ctx: ctx,
		groupId: groupId,
		notebookId: notebookId,
		onenoteSectionId: onenoteSectionId,
	}
}

// Execute executes the request
//  @return AnyOfmicrosoftGraphOnenoteOperation
func (a *GroupsActionsApiService) GroupsGroupOnenoteNotebooksNotebookSectionsOnenoteSectionParentSectionGroupParentNotebookCopyNotebookExecute(r ApiGroupsGroupOnenoteNotebooksNotebookSectionsOnenoteSectionParentSectionGroupParentNotebookCopyNotebookRequest) (AnyOfmicrosoftGraphOnenoteOperation, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  AnyOfmicrosoftGraphOnenoteOperation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GroupsActionsApiService.GroupsGroupOnenoteNotebooksNotebookSectionsOnenoteSectionParentSectionGroupParentNotebookCopyNotebook")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/groups/{group-id}/onenote/notebooks/{notebook-id}/sections/{onenoteSection-id}/parentSectionGroup/parentNotebook/microsoft.graph.copyNotebook"
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"notebook-id"+"}", _neturl.PathEscape(parameterToString(r.notebookId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"onenoteSection-id"+"}", _neturl.PathEscape(parameterToString(r.onenoteSectionId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject260 == nil {
		return localVarReturnValue, nil, reportError("inlineObject260 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject260
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGroupsGroupOnenoteNotebooksNotebookSectionsOnenoteSectionParentSectionGroupSectionsOnenoteSectionCopyToNotebookRequest struct {
	ctx _context.Context
	ApiService *GroupsActionsApiService
	groupId string
	notebookId string
	onenoteSectionId string
	onenoteSectionId1 string
	inlineObject261 *InlineObject261
}

func (r ApiGroupsGroupOnenoteNotebooksNotebookSectionsOnenoteSectionParentSectionGroupSectionsOnenoteSectionCopyToNotebookRequest) InlineObject261(inlineObject261 InlineObject261) ApiGroupsGroupOnenoteNotebooksNotebookSectionsOnenoteSectionParentSectionGroupSectionsOnenoteSectionCopyToNotebookRequest {
	r.inlineObject261 = &inlineObject261
	return r
}

func (r ApiGroupsGroupOnenoteNotebooksNotebookSectionsOnenoteSectionParentSectionGroupSectionsOnenoteSectionCopyToNotebookRequest) Execute() (AnyOfmicrosoftGraphOnenoteOperation, *_nethttp.Response, error) {
	return r.ApiService.GroupsGroupOnenoteNotebooksNotebookSectionsOnenoteSectionParentSectionGroupSectionsOnenoteSectionCopyToNotebookExecute(r)
}

/*
GroupsGroupOnenoteNotebooksNotebookSectionsOnenoteSectionParentSectionGroupSectionsOnenoteSectionCopyToNotebook Invoke action copyToNotebook

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupId key: id of group
 @param notebookId key: id of notebook
 @param onenoteSectionId key: id of onenoteSection
 @param onenoteSectionId1 key: id of onenoteSection
 @return ApiGroupsGroupOnenoteNotebooksNotebookSectionsOnenoteSectionParentSectionGroupSectionsOnenoteSectionCopyToNotebookRequest
*/
func (a *GroupsActionsApiService) GroupsGroupOnenoteNotebooksNotebookSectionsOnenoteSectionParentSectionGroupSectionsOnenoteSectionCopyToNotebook(ctx _context.Context, groupId string, notebookId string, onenoteSectionId string, onenoteSectionId1 string) ApiGroupsGroupOnenoteNotebooksNotebookSectionsOnenoteSectionParentSectionGroupSectionsOnenoteSectionCopyToNotebookRequest {
	return ApiGroupsGroupOnenoteNotebooksNotebookSectionsOnenoteSectionParentSectionGroupSectionsOnenoteSectionCopyToNotebookRequest{
		ApiService: a,
		ctx: ctx,
		groupId: groupId,
		notebookId: notebookId,
		onenoteSectionId: onenoteSectionId,
		onenoteSectionId1: onenoteSectionId1,
	}
}

// Execute executes the request
//  @return AnyOfmicrosoftGraphOnenoteOperation
func (a *GroupsActionsApiService) GroupsGroupOnenoteNotebooksNotebookSectionsOnenoteSectionParentSectionGroupSectionsOnenoteSectionCopyToNotebookExecute(r ApiGroupsGroupOnenoteNotebooksNotebookSectionsOnenoteSectionParentSectionGroupSectionsOnenoteSectionCopyToNotebookRequest) (AnyOfmicrosoftGraphOnenoteOperation, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  AnyOfmicrosoftGraphOnenoteOperation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GroupsActionsApiService.GroupsGroupOnenoteNotebooksNotebookSectionsOnenoteSectionParentSectionGroupSectionsOnenoteSectionCopyToNotebook")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/groups/{group-id}/onenote/notebooks/{notebook-id}/sections/{onenoteSection-id}/parentSectionGroup/sections/{onenoteSection-id1}/microsoft.graph.copyToNotebook"
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"notebook-id"+"}", _neturl.PathEscape(parameterToString(r.notebookId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"onenoteSection-id"+"}", _neturl.PathEscape(parameterToString(r.onenoteSectionId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"onenoteSection-id1"+"}", _neturl.PathEscape(parameterToString(r.onenoteSectionId1, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject261 == nil {
		return localVarReturnValue, nil, reportError("inlineObject261 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject261
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGroupsGroupOnenoteNotebooksNotebookSectionsOnenoteSectionParentSectionGroupSectionsOnenoteSectionCopyToSectionGroupRequest struct {
	ctx _context.Context
	ApiService *GroupsActionsApiService
	groupId string
	notebookId string
	onenoteSectionId string
	onenoteSectionId1 string
	inlineObject262 *InlineObject262
}

func (r ApiGroupsGroupOnenoteNotebooksNotebookSectionsOnenoteSectionParentSectionGroupSectionsOnenoteSectionCopyToSectionGroupRequest) InlineObject262(inlineObject262 InlineObject262) ApiGroupsGroupOnenoteNotebooksNotebookSectionsOnenoteSectionParentSectionGroupSectionsOnenoteSectionCopyToSectionGroupRequest {
	r.inlineObject262 = &inlineObject262
	return r
}

func (r ApiGroupsGroupOnenoteNotebooksNotebookSectionsOnenoteSectionParentSectionGroupSectionsOnenoteSectionCopyToSectionGroupRequest) Execute() (AnyOfmicrosoftGraphOnenoteOperation, *_nethttp.Response, error) {
	return r.ApiService.GroupsGroupOnenoteNotebooksNotebookSectionsOnenoteSectionParentSectionGroupSectionsOnenoteSectionCopyToSectionGroupExecute(r)
}

/*
GroupsGroupOnenoteNotebooksNotebookSectionsOnenoteSectionParentSectionGroupSectionsOnenoteSectionCopyToSectionGroup Invoke action copyToSectionGroup

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupId key: id of group
 @param notebookId key: id of notebook
 @param onenoteSectionId key: id of onenoteSection
 @param onenoteSectionId1 key: id of onenoteSection
 @return ApiGroupsGroupOnenoteNotebooksNotebookSectionsOnenoteSectionParentSectionGroupSectionsOnenoteSectionCopyToSectionGroupRequest
*/
func (a *GroupsActionsApiService) GroupsGroupOnenoteNotebooksNotebookSectionsOnenoteSectionParentSectionGroupSectionsOnenoteSectionCopyToSectionGroup(ctx _context.Context, groupId string, notebookId string, onenoteSectionId string, onenoteSectionId1 string) ApiGroupsGroupOnenoteNotebooksNotebookSectionsOnenoteSectionParentSectionGroupSectionsOnenoteSectionCopyToSectionGroupRequest {
	return ApiGroupsGroupOnenoteNotebooksNotebookSectionsOnenoteSectionParentSectionGroupSectionsOnenoteSectionCopyToSectionGroupRequest{
		ApiService: a,
		ctx: ctx,
		groupId: groupId,
		notebookId: notebookId,
		onenoteSectionId: onenoteSectionId,
		onenoteSectionId1: onenoteSectionId1,
	}
}

// Execute executes the request
//  @return AnyOfmicrosoftGraphOnenoteOperation
func (a *GroupsActionsApiService) GroupsGroupOnenoteNotebooksNotebookSectionsOnenoteSectionParentSectionGroupSectionsOnenoteSectionCopyToSectionGroupExecute(r ApiGroupsGroupOnenoteNotebooksNotebookSectionsOnenoteSectionParentSectionGroupSectionsOnenoteSectionCopyToSectionGroupRequest) (AnyOfmicrosoftGraphOnenoteOperation, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  AnyOfmicrosoftGraphOnenoteOperation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GroupsActionsApiService.GroupsGroupOnenoteNotebooksNotebookSectionsOnenoteSectionParentSectionGroupSectionsOnenoteSectionCopyToSectionGroup")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/groups/{group-id}/onenote/notebooks/{notebook-id}/sections/{onenoteSection-id}/parentSectionGroup/sections/{onenoteSection-id1}/microsoft.graph.copyToSectionGroup"
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"notebook-id"+"}", _neturl.PathEscape(parameterToString(r.notebookId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"onenoteSection-id"+"}", _neturl.PathEscape(parameterToString(r.onenoteSectionId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"onenoteSection-id1"+"}", _neturl.PathEscape(parameterToString(r.onenoteSectionId1, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject262 == nil {
		return localVarReturnValue, nil, reportError("inlineObject262 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject262
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGroupsGroupOnenotePagesOnenotePageCopyToSectionRequest struct {
	ctx _context.Context
	ApiService *GroupsActionsApiService
	groupId string
	onenotePageId string
	inlineObject264 *InlineObject264
}

func (r ApiGroupsGroupOnenotePagesOnenotePageCopyToSectionRequest) InlineObject264(inlineObject264 InlineObject264) ApiGroupsGroupOnenotePagesOnenotePageCopyToSectionRequest {
	r.inlineObject264 = &inlineObject264
	return r
}

func (r ApiGroupsGroupOnenotePagesOnenotePageCopyToSectionRequest) Execute() (AnyOfmicrosoftGraphOnenoteOperation, *_nethttp.Response, error) {
	return r.ApiService.GroupsGroupOnenotePagesOnenotePageCopyToSectionExecute(r)
}

/*
GroupsGroupOnenotePagesOnenotePageCopyToSection Invoke action copyToSection

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupId key: id of group
 @param onenotePageId key: id of onenotePage
 @return ApiGroupsGroupOnenotePagesOnenotePageCopyToSectionRequest
*/
func (a *GroupsActionsApiService) GroupsGroupOnenotePagesOnenotePageCopyToSection(ctx _context.Context, groupId string, onenotePageId string) ApiGroupsGroupOnenotePagesOnenotePageCopyToSectionRequest {
	return ApiGroupsGroupOnenotePagesOnenotePageCopyToSectionRequest{
		ApiService: a,
		ctx: ctx,
		groupId: groupId,
		onenotePageId: onenotePageId,
	}
}

// Execute executes the request
//  @return AnyOfmicrosoftGraphOnenoteOperation
func (a *GroupsActionsApiService) GroupsGroupOnenotePagesOnenotePageCopyToSectionExecute(r ApiGroupsGroupOnenotePagesOnenotePageCopyToSectionRequest) (AnyOfmicrosoftGraphOnenoteOperation, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  AnyOfmicrosoftGraphOnenoteOperation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GroupsActionsApiService.GroupsGroupOnenotePagesOnenotePageCopyToSection")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/groups/{group-id}/onenote/pages/{onenotePage-id}/microsoft.graph.copyToSection"
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"onenotePage-id"+"}", _neturl.PathEscape(parameterToString(r.onenotePageId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject264 == nil {
		return localVarReturnValue, nil, reportError("inlineObject264 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject264
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGroupsGroupOnenotePagesOnenotePageOnenotePatchContentRequest struct {
	ctx _context.Context
	ApiService *GroupsActionsApiService
	groupId string
	onenotePageId string
	inlineObject265 *InlineObject265
}

func (r ApiGroupsGroupOnenotePagesOnenotePageOnenotePatchContentRequest) InlineObject265(inlineObject265 InlineObject265) ApiGroupsGroupOnenotePagesOnenotePageOnenotePatchContentRequest {
	r.inlineObject265 = &inlineObject265
	return r
}

func (r ApiGroupsGroupOnenotePagesOnenotePageOnenotePatchContentRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.GroupsGroupOnenotePagesOnenotePageOnenotePatchContentExecute(r)
}

/*
GroupsGroupOnenotePagesOnenotePageOnenotePatchContent Invoke action onenotePatchContent

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupId key: id of group
 @param onenotePageId key: id of onenotePage
 @return ApiGroupsGroupOnenotePagesOnenotePageOnenotePatchContentRequest
*/
func (a *GroupsActionsApiService) GroupsGroupOnenotePagesOnenotePageOnenotePatchContent(ctx _context.Context, groupId string, onenotePageId string) ApiGroupsGroupOnenotePagesOnenotePageOnenotePatchContentRequest {
	return ApiGroupsGroupOnenotePagesOnenotePageOnenotePatchContentRequest{
		ApiService: a,
		ctx: ctx,
		groupId: groupId,
		onenotePageId: onenotePageId,
	}
}

// Execute executes the request
func (a *GroupsActionsApiService) GroupsGroupOnenotePagesOnenotePageOnenotePatchContentExecute(r ApiGroupsGroupOnenotePagesOnenotePageOnenotePatchContentRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GroupsActionsApiService.GroupsGroupOnenotePagesOnenotePageOnenotePatchContent")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/groups/{group-id}/onenote/pages/{onenotePage-id}/microsoft.graph.onenotePatchContent"
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"onenotePage-id"+"}", _neturl.PathEscape(parameterToString(r.onenotePageId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject265 == nil {
		return nil, reportError("inlineObject265 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject265
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGroupsGroupOnenotePagesOnenotePageParentNotebookCopyNotebookRequest struct {
	ctx _context.Context
	ApiService *GroupsActionsApiService
	groupId string
	onenotePageId string
	inlineObject266 *InlineObject266
}

func (r ApiGroupsGroupOnenotePagesOnenotePageParentNotebookCopyNotebookRequest) InlineObject266(inlineObject266 InlineObject266) ApiGroupsGroupOnenotePagesOnenotePageParentNotebookCopyNotebookRequest {
	r.inlineObject266 = &inlineObject266
	return r
}

func (r ApiGroupsGroupOnenotePagesOnenotePageParentNotebookCopyNotebookRequest) Execute() (AnyOfmicrosoftGraphOnenoteOperation, *_nethttp.Response, error) {
	return r.ApiService.GroupsGroupOnenotePagesOnenotePageParentNotebookCopyNotebookExecute(r)
}

/*
GroupsGroupOnenotePagesOnenotePageParentNotebookCopyNotebook Invoke action copyNotebook

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupId key: id of group
 @param onenotePageId key: id of onenotePage
 @return ApiGroupsGroupOnenotePagesOnenotePageParentNotebookCopyNotebookRequest
*/
func (a *GroupsActionsApiService) GroupsGroupOnenotePagesOnenotePageParentNotebookCopyNotebook(ctx _context.Context, groupId string, onenotePageId string) ApiGroupsGroupOnenotePagesOnenotePageParentNotebookCopyNotebookRequest {
	return ApiGroupsGroupOnenotePagesOnenotePageParentNotebookCopyNotebookRequest{
		ApiService: a,
		ctx: ctx,
		groupId: groupId,
		onenotePageId: onenotePageId,
	}
}

// Execute executes the request
//  @return AnyOfmicrosoftGraphOnenoteOperation
func (a *GroupsActionsApiService) GroupsGroupOnenotePagesOnenotePageParentNotebookCopyNotebookExecute(r ApiGroupsGroupOnenotePagesOnenotePageParentNotebookCopyNotebookRequest) (AnyOfmicrosoftGraphOnenoteOperation, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  AnyOfmicrosoftGraphOnenoteOperation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GroupsActionsApiService.GroupsGroupOnenotePagesOnenotePageParentNotebookCopyNotebook")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/groups/{group-id}/onenote/pages/{onenotePage-id}/parentNotebook/microsoft.graph.copyNotebook"
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"onenotePage-id"+"}", _neturl.PathEscape(parameterToString(r.onenotePageId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject266 == nil {
		return localVarReturnValue, nil, reportError("inlineObject266 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject266
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGroupsGroupOnenotePagesOnenotePageParentNotebookSectionGroupsSectionGroupParentNotebookCopyNotebookRequest struct {
	ctx _context.Context
	ApiService *GroupsActionsApiService
	groupId string
	onenotePageId string
	sectionGroupId string
	inlineObject267 *InlineObject267
}

func (r ApiGroupsGroupOnenotePagesOnenotePageParentNotebookSectionGroupsSectionGroupParentNotebookCopyNotebookRequest) InlineObject267(inlineObject267 InlineObject267) ApiGroupsGroupOnenotePagesOnenotePageParentNotebookSectionGroupsSectionGroupParentNotebookCopyNotebookRequest {
	r.inlineObject267 = &inlineObject267
	return r
}

func (r ApiGroupsGroupOnenotePagesOnenotePageParentNotebookSectionGroupsSectionGroupParentNotebookCopyNotebookRequest) Execute() (AnyOfmicrosoftGraphOnenoteOperation, *_nethttp.Response, error) {
	return r.ApiService.GroupsGroupOnenotePagesOnenotePageParentNotebookSectionGroupsSectionGroupParentNotebookCopyNotebookExecute(r)
}

/*
GroupsGroupOnenotePagesOnenotePageParentNotebookSectionGroupsSectionGroupParentNotebookCopyNotebook Invoke action copyNotebook

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupId key: id of group
 @param onenotePageId key: id of onenotePage
 @param sectionGroupId key: id of sectionGroup
 @return ApiGroupsGroupOnenotePagesOnenotePageParentNotebookSectionGroupsSectionGroupParentNotebookCopyNotebookRequest
*/
func (a *GroupsActionsApiService) GroupsGroupOnenotePagesOnenotePageParentNotebookSectionGroupsSectionGroupParentNotebookCopyNotebook(ctx _context.Context, groupId string, onenotePageId string, sectionGroupId string) ApiGroupsGroupOnenotePagesOnenotePageParentNotebookSectionGroupsSectionGroupParentNotebookCopyNotebookRequest {
	return ApiGroupsGroupOnenotePagesOnenotePageParentNotebookSectionGroupsSectionGroupParentNotebookCopyNotebookRequest{
		ApiService: a,
		ctx: ctx,
		groupId: groupId,
		onenotePageId: onenotePageId,
		sectionGroupId: sectionGroupId,
	}
}

// Execute executes the request
//  @return AnyOfmicrosoftGraphOnenoteOperation
func (a *GroupsActionsApiService) GroupsGroupOnenotePagesOnenotePageParentNotebookSectionGroupsSectionGroupParentNotebookCopyNotebookExecute(r ApiGroupsGroupOnenotePagesOnenotePageParentNotebookSectionGroupsSectionGroupParentNotebookCopyNotebookRequest) (AnyOfmicrosoftGraphOnenoteOperation, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  AnyOfmicrosoftGraphOnenoteOperation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GroupsActionsApiService.GroupsGroupOnenotePagesOnenotePageParentNotebookSectionGroupsSectionGroupParentNotebookCopyNotebook")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/groups/{group-id}/onenote/pages/{onenotePage-id}/parentNotebook/sectionGroups/{sectionGroup-id}/parentNotebook/microsoft.graph.copyNotebook"
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"onenotePage-id"+"}", _neturl.PathEscape(parameterToString(r.onenotePageId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"sectionGroup-id"+"}", _neturl.PathEscape(parameterToString(r.sectionGroupId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject267 == nil {
		return localVarReturnValue, nil, reportError("inlineObject267 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject267
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGroupsGroupOnenotePagesOnenotePageParentNotebookSectionGroupsSectionGroupSectionsOnenoteSectionCopyToNotebookRequest struct {
	ctx _context.Context
	ApiService *GroupsActionsApiService
	groupId string
	onenotePageId string
	sectionGroupId string
	onenoteSectionId string
	inlineObject268 *InlineObject268
}

func (r ApiGroupsGroupOnenotePagesOnenotePageParentNotebookSectionGroupsSectionGroupSectionsOnenoteSectionCopyToNotebookRequest) InlineObject268(inlineObject268 InlineObject268) ApiGroupsGroupOnenotePagesOnenotePageParentNotebookSectionGroupsSectionGroupSectionsOnenoteSectionCopyToNotebookRequest {
	r.inlineObject268 = &inlineObject268
	return r
}

func (r ApiGroupsGroupOnenotePagesOnenotePageParentNotebookSectionGroupsSectionGroupSectionsOnenoteSectionCopyToNotebookRequest) Execute() (AnyOfmicrosoftGraphOnenoteOperation, *_nethttp.Response, error) {
	return r.ApiService.GroupsGroupOnenotePagesOnenotePageParentNotebookSectionGroupsSectionGroupSectionsOnenoteSectionCopyToNotebookExecute(r)
}

/*
GroupsGroupOnenotePagesOnenotePageParentNotebookSectionGroupsSectionGroupSectionsOnenoteSectionCopyToNotebook Invoke action copyToNotebook

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupId key: id of group
 @param onenotePageId key: id of onenotePage
 @param sectionGroupId key: id of sectionGroup
 @param onenoteSectionId key: id of onenoteSection
 @return ApiGroupsGroupOnenotePagesOnenotePageParentNotebookSectionGroupsSectionGroupSectionsOnenoteSectionCopyToNotebookRequest
*/
func (a *GroupsActionsApiService) GroupsGroupOnenotePagesOnenotePageParentNotebookSectionGroupsSectionGroupSectionsOnenoteSectionCopyToNotebook(ctx _context.Context, groupId string, onenotePageId string, sectionGroupId string, onenoteSectionId string) ApiGroupsGroupOnenotePagesOnenotePageParentNotebookSectionGroupsSectionGroupSectionsOnenoteSectionCopyToNotebookRequest {
	return ApiGroupsGroupOnenotePagesOnenotePageParentNotebookSectionGroupsSectionGroupSectionsOnenoteSectionCopyToNotebookRequest{
		ApiService: a,
		ctx: ctx,
		groupId: groupId,
		onenotePageId: onenotePageId,
		sectionGroupId: sectionGroupId,
		onenoteSectionId: onenoteSectionId,
	}
}

// Execute executes the request
//  @return AnyOfmicrosoftGraphOnenoteOperation
func (a *GroupsActionsApiService) GroupsGroupOnenotePagesOnenotePageParentNotebookSectionGroupsSectionGroupSectionsOnenoteSectionCopyToNotebookExecute(r ApiGroupsGroupOnenotePagesOnenotePageParentNotebookSectionGroupsSectionGroupSectionsOnenoteSectionCopyToNotebookRequest) (AnyOfmicrosoftGraphOnenoteOperation, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  AnyOfmicrosoftGraphOnenoteOperation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GroupsActionsApiService.GroupsGroupOnenotePagesOnenotePageParentNotebookSectionGroupsSectionGroupSectionsOnenoteSectionCopyToNotebook")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/groups/{group-id}/onenote/pages/{onenotePage-id}/parentNotebook/sectionGroups/{sectionGroup-id}/sections/{onenoteSection-id}/microsoft.graph.copyToNotebook"
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"onenotePage-id"+"}", _neturl.PathEscape(parameterToString(r.onenotePageId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"sectionGroup-id"+"}", _neturl.PathEscape(parameterToString(r.sectionGroupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"onenoteSection-id"+"}", _neturl.PathEscape(parameterToString(r.onenoteSectionId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject268 == nil {
		return localVarReturnValue, nil, reportError("inlineObject268 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject268
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGroupsGroupOnenotePagesOnenotePageParentNotebookSectionGroupsSectionGroupSectionsOnenoteSectionCopyToSectionGroupRequest struct {
	ctx _context.Context
	ApiService *GroupsActionsApiService
	groupId string
	onenotePageId string
	sectionGroupId string
	onenoteSectionId string
	inlineObject269 *InlineObject269
}

func (r ApiGroupsGroupOnenotePagesOnenotePageParentNotebookSectionGroupsSectionGroupSectionsOnenoteSectionCopyToSectionGroupRequest) InlineObject269(inlineObject269 InlineObject269) ApiGroupsGroupOnenotePagesOnenotePageParentNotebookSectionGroupsSectionGroupSectionsOnenoteSectionCopyToSectionGroupRequest {
	r.inlineObject269 = &inlineObject269
	return r
}

func (r ApiGroupsGroupOnenotePagesOnenotePageParentNotebookSectionGroupsSectionGroupSectionsOnenoteSectionCopyToSectionGroupRequest) Execute() (AnyOfmicrosoftGraphOnenoteOperation, *_nethttp.Response, error) {
	return r.ApiService.GroupsGroupOnenotePagesOnenotePageParentNotebookSectionGroupsSectionGroupSectionsOnenoteSectionCopyToSectionGroupExecute(r)
}

/*
GroupsGroupOnenotePagesOnenotePageParentNotebookSectionGroupsSectionGroupSectionsOnenoteSectionCopyToSectionGroup Invoke action copyToSectionGroup

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupId key: id of group
 @param onenotePageId key: id of onenotePage
 @param sectionGroupId key: id of sectionGroup
 @param onenoteSectionId key: id of onenoteSection
 @return ApiGroupsGroupOnenotePagesOnenotePageParentNotebookSectionGroupsSectionGroupSectionsOnenoteSectionCopyToSectionGroupRequest
*/
func (a *GroupsActionsApiService) GroupsGroupOnenotePagesOnenotePageParentNotebookSectionGroupsSectionGroupSectionsOnenoteSectionCopyToSectionGroup(ctx _context.Context, groupId string, onenotePageId string, sectionGroupId string, onenoteSectionId string) ApiGroupsGroupOnenotePagesOnenotePageParentNotebookSectionGroupsSectionGroupSectionsOnenoteSectionCopyToSectionGroupRequest {
	return ApiGroupsGroupOnenotePagesOnenotePageParentNotebookSectionGroupsSectionGroupSectionsOnenoteSectionCopyToSectionGroupRequest{
		ApiService: a,
		ctx: ctx,
		groupId: groupId,
		onenotePageId: onenotePageId,
		sectionGroupId: sectionGroupId,
		onenoteSectionId: onenoteSectionId,
	}
}

// Execute executes the request
//  @return AnyOfmicrosoftGraphOnenoteOperation
func (a *GroupsActionsApiService) GroupsGroupOnenotePagesOnenotePageParentNotebookSectionGroupsSectionGroupSectionsOnenoteSectionCopyToSectionGroupExecute(r ApiGroupsGroupOnenotePagesOnenotePageParentNotebookSectionGroupsSectionGroupSectionsOnenoteSectionCopyToSectionGroupRequest) (AnyOfmicrosoftGraphOnenoteOperation, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  AnyOfmicrosoftGraphOnenoteOperation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GroupsActionsApiService.GroupsGroupOnenotePagesOnenotePageParentNotebookSectionGroupsSectionGroupSectionsOnenoteSectionCopyToSectionGroup")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/groups/{group-id}/onenote/pages/{onenotePage-id}/parentNotebook/sectionGroups/{sectionGroup-id}/sections/{onenoteSection-id}/microsoft.graph.copyToSectionGroup"
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"onenotePage-id"+"}", _neturl.PathEscape(parameterToString(r.onenotePageId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"sectionGroup-id"+"}", _neturl.PathEscape(parameterToString(r.sectionGroupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"onenoteSection-id"+"}", _neturl.PathEscape(parameterToString(r.onenoteSectionId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject269 == nil {
		return localVarReturnValue, nil, reportError("inlineObject269 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject269
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGroupsGroupOnenotePagesOnenotePageParentNotebookSectionGroupsSectionGroupSectionsOnenoteSectionPagesOnenotePageCopyToSectionRequest struct {
	ctx _context.Context
	ApiService *GroupsActionsApiService
	groupId string
	onenotePageId string
	sectionGroupId string
	onenoteSectionId string
	onenotePageId1 string
	inlineObject270 *InlineObject270
}

func (r ApiGroupsGroupOnenotePagesOnenotePageParentNotebookSectionGroupsSectionGroupSectionsOnenoteSectionPagesOnenotePageCopyToSectionRequest) InlineObject270(inlineObject270 InlineObject270) ApiGroupsGroupOnenotePagesOnenotePageParentNotebookSectionGroupsSectionGroupSectionsOnenoteSectionPagesOnenotePageCopyToSectionRequest {
	r.inlineObject270 = &inlineObject270
	return r
}

func (r ApiGroupsGroupOnenotePagesOnenotePageParentNotebookSectionGroupsSectionGroupSectionsOnenoteSectionPagesOnenotePageCopyToSectionRequest) Execute() (AnyOfmicrosoftGraphOnenoteOperation, *_nethttp.Response, error) {
	return r.ApiService.GroupsGroupOnenotePagesOnenotePageParentNotebookSectionGroupsSectionGroupSectionsOnenoteSectionPagesOnenotePageCopyToSectionExecute(r)
}

/*
GroupsGroupOnenotePagesOnenotePageParentNotebookSectionGroupsSectionGroupSectionsOnenoteSectionPagesOnenotePageCopyToSection Invoke action copyToSection

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupId key: id of group
 @param onenotePageId key: id of onenotePage
 @param sectionGroupId key: id of sectionGroup
 @param onenoteSectionId key: id of onenoteSection
 @param onenotePageId1 key: id of onenotePage
 @return ApiGroupsGroupOnenotePagesOnenotePageParentNotebookSectionGroupsSectionGroupSectionsOnenoteSectionPagesOnenotePageCopyToSectionRequest
*/
func (a *GroupsActionsApiService) GroupsGroupOnenotePagesOnenotePageParentNotebookSectionGroupsSectionGroupSectionsOnenoteSectionPagesOnenotePageCopyToSection(ctx _context.Context, groupId string, onenotePageId string, sectionGroupId string, onenoteSectionId string, onenotePageId1 string) ApiGroupsGroupOnenotePagesOnenotePageParentNotebookSectionGroupsSectionGroupSectionsOnenoteSectionPagesOnenotePageCopyToSectionRequest {
	return ApiGroupsGroupOnenotePagesOnenotePageParentNotebookSectionGroupsSectionGroupSectionsOnenoteSectionPagesOnenotePageCopyToSectionRequest{
		ApiService: a,
		ctx: ctx,
		groupId: groupId,
		onenotePageId: onenotePageId,
		sectionGroupId: sectionGroupId,
		onenoteSectionId: onenoteSectionId,
		onenotePageId1: onenotePageId1,
	}
}

// Execute executes the request
//  @return AnyOfmicrosoftGraphOnenoteOperation
func (a *GroupsActionsApiService) GroupsGroupOnenotePagesOnenotePageParentNotebookSectionGroupsSectionGroupSectionsOnenoteSectionPagesOnenotePageCopyToSectionExecute(r ApiGroupsGroupOnenotePagesOnenotePageParentNotebookSectionGroupsSectionGroupSectionsOnenoteSectionPagesOnenotePageCopyToSectionRequest) (AnyOfmicrosoftGraphOnenoteOperation, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  AnyOfmicrosoftGraphOnenoteOperation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GroupsActionsApiService.GroupsGroupOnenotePagesOnenotePageParentNotebookSectionGroupsSectionGroupSectionsOnenoteSectionPagesOnenotePageCopyToSection")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/groups/{group-id}/onenote/pages/{onenotePage-id}/parentNotebook/sectionGroups/{sectionGroup-id}/sections/{onenoteSection-id}/pages/{onenotePage-id1}/microsoft.graph.copyToSection"
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"onenotePage-id"+"}", _neturl.PathEscape(parameterToString(r.onenotePageId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"sectionGroup-id"+"}", _neturl.PathEscape(parameterToString(r.sectionGroupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"onenoteSection-id"+"}", _neturl.PathEscape(parameterToString(r.onenoteSectionId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"onenotePage-id1"+"}", _neturl.PathEscape(parameterToString(r.onenotePageId1, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject270 == nil {
		return localVarReturnValue, nil, reportError("inlineObject270 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject270
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGroupsGroupOnenotePagesOnenotePageParentNotebookSectionGroupsSectionGroupSectionsOnenoteSectionPagesOnenotePageOnenotePatchContentRequest struct {
	ctx _context.Context
	ApiService *GroupsActionsApiService
	groupId string
	onenotePageId string
	sectionGroupId string
	onenoteSectionId string
	onenotePageId1 string
	inlineObject271 *InlineObject271
}

func (r ApiGroupsGroupOnenotePagesOnenotePageParentNotebookSectionGroupsSectionGroupSectionsOnenoteSectionPagesOnenotePageOnenotePatchContentRequest) InlineObject271(inlineObject271 InlineObject271) ApiGroupsGroupOnenotePagesOnenotePageParentNotebookSectionGroupsSectionGroupSectionsOnenoteSectionPagesOnenotePageOnenotePatchContentRequest {
	r.inlineObject271 = &inlineObject271
	return r
}

func (r ApiGroupsGroupOnenotePagesOnenotePageParentNotebookSectionGroupsSectionGroupSectionsOnenoteSectionPagesOnenotePageOnenotePatchContentRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.GroupsGroupOnenotePagesOnenotePageParentNotebookSectionGroupsSectionGroupSectionsOnenoteSectionPagesOnenotePageOnenotePatchContentExecute(r)
}

/*
GroupsGroupOnenotePagesOnenotePageParentNotebookSectionGroupsSectionGroupSectionsOnenoteSectionPagesOnenotePageOnenotePatchContent Invoke action onenotePatchContent

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupId key: id of group
 @param onenotePageId key: id of onenotePage
 @param sectionGroupId key: id of sectionGroup
 @param onenoteSectionId key: id of onenoteSection
 @param onenotePageId1 key: id of onenotePage
 @return ApiGroupsGroupOnenotePagesOnenotePageParentNotebookSectionGroupsSectionGroupSectionsOnenoteSectionPagesOnenotePageOnenotePatchContentRequest
*/
func (a *GroupsActionsApiService) GroupsGroupOnenotePagesOnenotePageParentNotebookSectionGroupsSectionGroupSectionsOnenoteSectionPagesOnenotePageOnenotePatchContent(ctx _context.Context, groupId string, onenotePageId string, sectionGroupId string, onenoteSectionId string, onenotePageId1 string) ApiGroupsGroupOnenotePagesOnenotePageParentNotebookSectionGroupsSectionGroupSectionsOnenoteSectionPagesOnenotePageOnenotePatchContentRequest {
	return ApiGroupsGroupOnenotePagesOnenotePageParentNotebookSectionGroupsSectionGroupSectionsOnenoteSectionPagesOnenotePageOnenotePatchContentRequest{
		ApiService: a,
		ctx: ctx,
		groupId: groupId,
		onenotePageId: onenotePageId,
		sectionGroupId: sectionGroupId,
		onenoteSectionId: onenoteSectionId,
		onenotePageId1: onenotePageId1,
	}
}

// Execute executes the request
func (a *GroupsActionsApiService) GroupsGroupOnenotePagesOnenotePageParentNotebookSectionGroupsSectionGroupSectionsOnenoteSectionPagesOnenotePageOnenotePatchContentExecute(r ApiGroupsGroupOnenotePagesOnenotePageParentNotebookSectionGroupsSectionGroupSectionsOnenoteSectionPagesOnenotePageOnenotePatchContentRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GroupsActionsApiService.GroupsGroupOnenotePagesOnenotePageParentNotebookSectionGroupsSectionGroupSectionsOnenoteSectionPagesOnenotePageOnenotePatchContent")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/groups/{group-id}/onenote/pages/{onenotePage-id}/parentNotebook/sectionGroups/{sectionGroup-id}/sections/{onenoteSection-id}/pages/{onenotePage-id1}/microsoft.graph.onenotePatchContent"
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"onenotePage-id"+"}", _neturl.PathEscape(parameterToString(r.onenotePageId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"sectionGroup-id"+"}", _neturl.PathEscape(parameterToString(r.sectionGroupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"onenoteSection-id"+"}", _neturl.PathEscape(parameterToString(r.onenoteSectionId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"onenotePage-id1"+"}", _neturl.PathEscape(parameterToString(r.onenotePageId1, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject271 == nil {
		return nil, reportError("inlineObject271 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject271
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGroupsGroupOnenotePagesOnenotePageParentNotebookSectionGroupsSectionGroupSectionsOnenoteSectionParentNotebookCopyNotebookRequest struct {
	ctx _context.Context
	ApiService *GroupsActionsApiService
	groupId string
	onenotePageId string
	sectionGroupId string
	onenoteSectionId string
	inlineObject272 *InlineObject272
}

func (r ApiGroupsGroupOnenotePagesOnenotePageParentNotebookSectionGroupsSectionGroupSectionsOnenoteSectionParentNotebookCopyNotebookRequest) InlineObject272(inlineObject272 InlineObject272) ApiGroupsGroupOnenotePagesOnenotePageParentNotebookSectionGroupsSectionGroupSectionsOnenoteSectionParentNotebookCopyNotebookRequest {
	r.inlineObject272 = &inlineObject272
	return r
}

func (r ApiGroupsGroupOnenotePagesOnenotePageParentNotebookSectionGroupsSectionGroupSectionsOnenoteSectionParentNotebookCopyNotebookRequest) Execute() (AnyOfmicrosoftGraphOnenoteOperation, *_nethttp.Response, error) {
	return r.ApiService.GroupsGroupOnenotePagesOnenotePageParentNotebookSectionGroupsSectionGroupSectionsOnenoteSectionParentNotebookCopyNotebookExecute(r)
}

/*
GroupsGroupOnenotePagesOnenotePageParentNotebookSectionGroupsSectionGroupSectionsOnenoteSectionParentNotebookCopyNotebook Invoke action copyNotebook

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupId key: id of group
 @param onenotePageId key: id of onenotePage
 @param sectionGroupId key: id of sectionGroup
 @param onenoteSectionId key: id of onenoteSection
 @return ApiGroupsGroupOnenotePagesOnenotePageParentNotebookSectionGroupsSectionGroupSectionsOnenoteSectionParentNotebookCopyNotebookRequest
*/
func (a *GroupsActionsApiService) GroupsGroupOnenotePagesOnenotePageParentNotebookSectionGroupsSectionGroupSectionsOnenoteSectionParentNotebookCopyNotebook(ctx _context.Context, groupId string, onenotePageId string, sectionGroupId string, onenoteSectionId string) ApiGroupsGroupOnenotePagesOnenotePageParentNotebookSectionGroupsSectionGroupSectionsOnenoteSectionParentNotebookCopyNotebookRequest {
	return ApiGroupsGroupOnenotePagesOnenotePageParentNotebookSectionGroupsSectionGroupSectionsOnenoteSectionParentNotebookCopyNotebookRequest{
		ApiService: a,
		ctx: ctx,
		groupId: groupId,
		onenotePageId: onenotePageId,
		sectionGroupId: sectionGroupId,
		onenoteSectionId: onenoteSectionId,
	}
}

// Execute executes the request
//  @return AnyOfmicrosoftGraphOnenoteOperation
func (a *GroupsActionsApiService) GroupsGroupOnenotePagesOnenotePageParentNotebookSectionGroupsSectionGroupSectionsOnenoteSectionParentNotebookCopyNotebookExecute(r ApiGroupsGroupOnenotePagesOnenotePageParentNotebookSectionGroupsSectionGroupSectionsOnenoteSectionParentNotebookCopyNotebookRequest) (AnyOfmicrosoftGraphOnenoteOperation, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  AnyOfmicrosoftGraphOnenoteOperation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GroupsActionsApiService.GroupsGroupOnenotePagesOnenotePageParentNotebookSectionGroupsSectionGroupSectionsOnenoteSectionParentNotebookCopyNotebook")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/groups/{group-id}/onenote/pages/{onenotePage-id}/parentNotebook/sectionGroups/{sectionGroup-id}/sections/{onenoteSection-id}/parentNotebook/microsoft.graph.copyNotebook"
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"onenotePage-id"+"}", _neturl.PathEscape(parameterToString(r.onenotePageId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"sectionGroup-id"+"}", _neturl.PathEscape(parameterToString(r.sectionGroupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"onenoteSection-id"+"}", _neturl.PathEscape(parameterToString(r.onenoteSectionId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject272 == nil {
		return localVarReturnValue, nil, reportError("inlineObject272 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject272
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGroupsGroupOnenotePagesOnenotePageParentNotebookSectionsOnenoteSectionCopyToNotebookRequest struct {
	ctx _context.Context
	ApiService *GroupsActionsApiService
	groupId string
	onenotePageId string
	onenoteSectionId string
	inlineObject273 *InlineObject273
}

func (r ApiGroupsGroupOnenotePagesOnenotePageParentNotebookSectionsOnenoteSectionCopyToNotebookRequest) InlineObject273(inlineObject273 InlineObject273) ApiGroupsGroupOnenotePagesOnenotePageParentNotebookSectionsOnenoteSectionCopyToNotebookRequest {
	r.inlineObject273 = &inlineObject273
	return r
}

func (r ApiGroupsGroupOnenotePagesOnenotePageParentNotebookSectionsOnenoteSectionCopyToNotebookRequest) Execute() (AnyOfmicrosoftGraphOnenoteOperation, *_nethttp.Response, error) {
	return r.ApiService.GroupsGroupOnenotePagesOnenotePageParentNotebookSectionsOnenoteSectionCopyToNotebookExecute(r)
}

/*
GroupsGroupOnenotePagesOnenotePageParentNotebookSectionsOnenoteSectionCopyToNotebook Invoke action copyToNotebook

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupId key: id of group
 @param onenotePageId key: id of onenotePage
 @param onenoteSectionId key: id of onenoteSection
 @return ApiGroupsGroupOnenotePagesOnenotePageParentNotebookSectionsOnenoteSectionCopyToNotebookRequest
*/
func (a *GroupsActionsApiService) GroupsGroupOnenotePagesOnenotePageParentNotebookSectionsOnenoteSectionCopyToNotebook(ctx _context.Context, groupId string, onenotePageId string, onenoteSectionId string) ApiGroupsGroupOnenotePagesOnenotePageParentNotebookSectionsOnenoteSectionCopyToNotebookRequest {
	return ApiGroupsGroupOnenotePagesOnenotePageParentNotebookSectionsOnenoteSectionCopyToNotebookRequest{
		ApiService: a,
		ctx: ctx,
		groupId: groupId,
		onenotePageId: onenotePageId,
		onenoteSectionId: onenoteSectionId,
	}
}

// Execute executes the request
//  @return AnyOfmicrosoftGraphOnenoteOperation
func (a *GroupsActionsApiService) GroupsGroupOnenotePagesOnenotePageParentNotebookSectionsOnenoteSectionCopyToNotebookExecute(r ApiGroupsGroupOnenotePagesOnenotePageParentNotebookSectionsOnenoteSectionCopyToNotebookRequest) (AnyOfmicrosoftGraphOnenoteOperation, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  AnyOfmicrosoftGraphOnenoteOperation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GroupsActionsApiService.GroupsGroupOnenotePagesOnenotePageParentNotebookSectionsOnenoteSectionCopyToNotebook")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/groups/{group-id}/onenote/pages/{onenotePage-id}/parentNotebook/sections/{onenoteSection-id}/microsoft.graph.copyToNotebook"
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"onenotePage-id"+"}", _neturl.PathEscape(parameterToString(r.onenotePageId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"onenoteSection-id"+"}", _neturl.PathEscape(parameterToString(r.onenoteSectionId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject273 == nil {
		return localVarReturnValue, nil, reportError("inlineObject273 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject273
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGroupsGroupOnenotePagesOnenotePageParentNotebookSectionsOnenoteSectionCopyToSectionGroupRequest struct {
	ctx _context.Context
	ApiService *GroupsActionsApiService
	groupId string
	onenotePageId string
	onenoteSectionId string
	inlineObject274 *InlineObject274
}

func (r ApiGroupsGroupOnenotePagesOnenotePageParentNotebookSectionsOnenoteSectionCopyToSectionGroupRequest) InlineObject274(inlineObject274 InlineObject274) ApiGroupsGroupOnenotePagesOnenotePageParentNotebookSectionsOnenoteSectionCopyToSectionGroupRequest {
	r.inlineObject274 = &inlineObject274
	return r
}

func (r ApiGroupsGroupOnenotePagesOnenotePageParentNotebookSectionsOnenoteSectionCopyToSectionGroupRequest) Execute() (AnyOfmicrosoftGraphOnenoteOperation, *_nethttp.Response, error) {
	return r.ApiService.GroupsGroupOnenotePagesOnenotePageParentNotebookSectionsOnenoteSectionCopyToSectionGroupExecute(r)
}

/*
GroupsGroupOnenotePagesOnenotePageParentNotebookSectionsOnenoteSectionCopyToSectionGroup Invoke action copyToSectionGroup

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupId key: id of group
 @param onenotePageId key: id of onenotePage
 @param onenoteSectionId key: id of onenoteSection
 @return ApiGroupsGroupOnenotePagesOnenotePageParentNotebookSectionsOnenoteSectionCopyToSectionGroupRequest
*/
func (a *GroupsActionsApiService) GroupsGroupOnenotePagesOnenotePageParentNotebookSectionsOnenoteSectionCopyToSectionGroup(ctx _context.Context, groupId string, onenotePageId string, onenoteSectionId string) ApiGroupsGroupOnenotePagesOnenotePageParentNotebookSectionsOnenoteSectionCopyToSectionGroupRequest {
	return ApiGroupsGroupOnenotePagesOnenotePageParentNotebookSectionsOnenoteSectionCopyToSectionGroupRequest{
		ApiService: a,
		ctx: ctx,
		groupId: groupId,
		onenotePageId: onenotePageId,
		onenoteSectionId: onenoteSectionId,
	}
}

// Execute executes the request
//  @return AnyOfmicrosoftGraphOnenoteOperation
func (a *GroupsActionsApiService) GroupsGroupOnenotePagesOnenotePageParentNotebookSectionsOnenoteSectionCopyToSectionGroupExecute(r ApiGroupsGroupOnenotePagesOnenotePageParentNotebookSectionsOnenoteSectionCopyToSectionGroupRequest) (AnyOfmicrosoftGraphOnenoteOperation, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  AnyOfmicrosoftGraphOnenoteOperation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GroupsActionsApiService.GroupsGroupOnenotePagesOnenotePageParentNotebookSectionsOnenoteSectionCopyToSectionGroup")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/groups/{group-id}/onenote/pages/{onenotePage-id}/parentNotebook/sections/{onenoteSection-id}/microsoft.graph.copyToSectionGroup"
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"onenotePage-id"+"}", _neturl.PathEscape(parameterToString(r.onenotePageId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"onenoteSection-id"+"}", _neturl.PathEscape(parameterToString(r.onenoteSectionId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject274 == nil {
		return localVarReturnValue, nil, reportError("inlineObject274 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject274
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGroupsGroupOnenotePagesOnenotePageParentNotebookSectionsOnenoteSectionPagesOnenotePageCopyToSectionRequest struct {
	ctx _context.Context
	ApiService *GroupsActionsApiService
	groupId string
	onenotePageId string
	onenoteSectionId string
	onenotePageId1 string
	inlineObject275 *InlineObject275
}

func (r ApiGroupsGroupOnenotePagesOnenotePageParentNotebookSectionsOnenoteSectionPagesOnenotePageCopyToSectionRequest) InlineObject275(inlineObject275 InlineObject275) ApiGroupsGroupOnenotePagesOnenotePageParentNotebookSectionsOnenoteSectionPagesOnenotePageCopyToSectionRequest {
	r.inlineObject275 = &inlineObject275
	return r
}

func (r ApiGroupsGroupOnenotePagesOnenotePageParentNotebookSectionsOnenoteSectionPagesOnenotePageCopyToSectionRequest) Execute() (AnyOfmicrosoftGraphOnenoteOperation, *_nethttp.Response, error) {
	return r.ApiService.GroupsGroupOnenotePagesOnenotePageParentNotebookSectionsOnenoteSectionPagesOnenotePageCopyToSectionExecute(r)
}

/*
GroupsGroupOnenotePagesOnenotePageParentNotebookSectionsOnenoteSectionPagesOnenotePageCopyToSection Invoke action copyToSection

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupId key: id of group
 @param onenotePageId key: id of onenotePage
 @param onenoteSectionId key: id of onenoteSection
 @param onenotePageId1 key: id of onenotePage
 @return ApiGroupsGroupOnenotePagesOnenotePageParentNotebookSectionsOnenoteSectionPagesOnenotePageCopyToSectionRequest
*/
func (a *GroupsActionsApiService) GroupsGroupOnenotePagesOnenotePageParentNotebookSectionsOnenoteSectionPagesOnenotePageCopyToSection(ctx _context.Context, groupId string, onenotePageId string, onenoteSectionId string, onenotePageId1 string) ApiGroupsGroupOnenotePagesOnenotePageParentNotebookSectionsOnenoteSectionPagesOnenotePageCopyToSectionRequest {
	return ApiGroupsGroupOnenotePagesOnenotePageParentNotebookSectionsOnenoteSectionPagesOnenotePageCopyToSectionRequest{
		ApiService: a,
		ctx: ctx,
		groupId: groupId,
		onenotePageId: onenotePageId,
		onenoteSectionId: onenoteSectionId,
		onenotePageId1: onenotePageId1,
	}
}

// Execute executes the request
//  @return AnyOfmicrosoftGraphOnenoteOperation
func (a *GroupsActionsApiService) GroupsGroupOnenotePagesOnenotePageParentNotebookSectionsOnenoteSectionPagesOnenotePageCopyToSectionExecute(r ApiGroupsGroupOnenotePagesOnenotePageParentNotebookSectionsOnenoteSectionPagesOnenotePageCopyToSectionRequest) (AnyOfmicrosoftGraphOnenoteOperation, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  AnyOfmicrosoftGraphOnenoteOperation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GroupsActionsApiService.GroupsGroupOnenotePagesOnenotePageParentNotebookSectionsOnenoteSectionPagesOnenotePageCopyToSection")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/groups/{group-id}/onenote/pages/{onenotePage-id}/parentNotebook/sections/{onenoteSection-id}/pages/{onenotePage-id1}/microsoft.graph.copyToSection"
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"onenotePage-id"+"}", _neturl.PathEscape(parameterToString(r.onenotePageId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"onenoteSection-id"+"}", _neturl.PathEscape(parameterToString(r.onenoteSectionId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"onenotePage-id1"+"}", _neturl.PathEscape(parameterToString(r.onenotePageId1, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject275 == nil {
		return localVarReturnValue, nil, reportError("inlineObject275 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject275
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGroupsGroupOnenotePagesOnenotePageParentNotebookSectionsOnenoteSectionPagesOnenotePageOnenotePatchContentRequest struct {
	ctx _context.Context
	ApiService *GroupsActionsApiService
	groupId string
	onenotePageId string
	onenoteSectionId string
	onenotePageId1 string
	inlineObject276 *InlineObject276
}

func (r ApiGroupsGroupOnenotePagesOnenotePageParentNotebookSectionsOnenoteSectionPagesOnenotePageOnenotePatchContentRequest) InlineObject276(inlineObject276 InlineObject276) ApiGroupsGroupOnenotePagesOnenotePageParentNotebookSectionsOnenoteSectionPagesOnenotePageOnenotePatchContentRequest {
	r.inlineObject276 = &inlineObject276
	return r
}

func (r ApiGroupsGroupOnenotePagesOnenotePageParentNotebookSectionsOnenoteSectionPagesOnenotePageOnenotePatchContentRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.GroupsGroupOnenotePagesOnenotePageParentNotebookSectionsOnenoteSectionPagesOnenotePageOnenotePatchContentExecute(r)
}

/*
GroupsGroupOnenotePagesOnenotePageParentNotebookSectionsOnenoteSectionPagesOnenotePageOnenotePatchContent Invoke action onenotePatchContent

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupId key: id of group
 @param onenotePageId key: id of onenotePage
 @param onenoteSectionId key: id of onenoteSection
 @param onenotePageId1 key: id of onenotePage
 @return ApiGroupsGroupOnenotePagesOnenotePageParentNotebookSectionsOnenoteSectionPagesOnenotePageOnenotePatchContentRequest
*/
func (a *GroupsActionsApiService) GroupsGroupOnenotePagesOnenotePageParentNotebookSectionsOnenoteSectionPagesOnenotePageOnenotePatchContent(ctx _context.Context, groupId string, onenotePageId string, onenoteSectionId string, onenotePageId1 string) ApiGroupsGroupOnenotePagesOnenotePageParentNotebookSectionsOnenoteSectionPagesOnenotePageOnenotePatchContentRequest {
	return ApiGroupsGroupOnenotePagesOnenotePageParentNotebookSectionsOnenoteSectionPagesOnenotePageOnenotePatchContentRequest{
		ApiService: a,
		ctx: ctx,
		groupId: groupId,
		onenotePageId: onenotePageId,
		onenoteSectionId: onenoteSectionId,
		onenotePageId1: onenotePageId1,
	}
}

// Execute executes the request
func (a *GroupsActionsApiService) GroupsGroupOnenotePagesOnenotePageParentNotebookSectionsOnenoteSectionPagesOnenotePageOnenotePatchContentExecute(r ApiGroupsGroupOnenotePagesOnenotePageParentNotebookSectionsOnenoteSectionPagesOnenotePageOnenotePatchContentRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GroupsActionsApiService.GroupsGroupOnenotePagesOnenotePageParentNotebookSectionsOnenoteSectionPagesOnenotePageOnenotePatchContent")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/groups/{group-id}/onenote/pages/{onenotePage-id}/parentNotebook/sections/{onenoteSection-id}/pages/{onenotePage-id1}/microsoft.graph.onenotePatchContent"
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"onenotePage-id"+"}", _neturl.PathEscape(parameterToString(r.onenotePageId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"onenoteSection-id"+"}", _neturl.PathEscape(parameterToString(r.onenoteSectionId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"onenotePage-id1"+"}", _neturl.PathEscape(parameterToString(r.onenotePageId1, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject276 == nil {
		return nil, reportError("inlineObject276 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject276
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGroupsGroupOnenotePagesOnenotePageParentNotebookSectionsOnenoteSectionParentNotebookCopyNotebookRequest struct {
	ctx _context.Context
	ApiService *GroupsActionsApiService
	groupId string
	onenotePageId string
	onenoteSectionId string
	inlineObject277 *InlineObject277
}

func (r ApiGroupsGroupOnenotePagesOnenotePageParentNotebookSectionsOnenoteSectionParentNotebookCopyNotebookRequest) InlineObject277(inlineObject277 InlineObject277) ApiGroupsGroupOnenotePagesOnenotePageParentNotebookSectionsOnenoteSectionParentNotebookCopyNotebookRequest {
	r.inlineObject277 = &inlineObject277
	return r
}

func (r ApiGroupsGroupOnenotePagesOnenotePageParentNotebookSectionsOnenoteSectionParentNotebookCopyNotebookRequest) Execute() (AnyOfmicrosoftGraphOnenoteOperation, *_nethttp.Response, error) {
	return r.ApiService.GroupsGroupOnenotePagesOnenotePageParentNotebookSectionsOnenoteSectionParentNotebookCopyNotebookExecute(r)
}

/*
GroupsGroupOnenotePagesOnenotePageParentNotebookSectionsOnenoteSectionParentNotebookCopyNotebook Invoke action copyNotebook

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupId key: id of group
 @param onenotePageId key: id of onenotePage
 @param onenoteSectionId key: id of onenoteSection
 @return ApiGroupsGroupOnenotePagesOnenotePageParentNotebookSectionsOnenoteSectionParentNotebookCopyNotebookRequest
*/
func (a *GroupsActionsApiService) GroupsGroupOnenotePagesOnenotePageParentNotebookSectionsOnenoteSectionParentNotebookCopyNotebook(ctx _context.Context, groupId string, onenotePageId string, onenoteSectionId string) ApiGroupsGroupOnenotePagesOnenotePageParentNotebookSectionsOnenoteSectionParentNotebookCopyNotebookRequest {
	return ApiGroupsGroupOnenotePagesOnenotePageParentNotebookSectionsOnenoteSectionParentNotebookCopyNotebookRequest{
		ApiService: a,
		ctx: ctx,
		groupId: groupId,
		onenotePageId: onenotePageId,
		onenoteSectionId: onenoteSectionId,
	}
}

// Execute executes the request
//  @return AnyOfmicrosoftGraphOnenoteOperation
func (a *GroupsActionsApiService) GroupsGroupOnenotePagesOnenotePageParentNotebookSectionsOnenoteSectionParentNotebookCopyNotebookExecute(r ApiGroupsGroupOnenotePagesOnenotePageParentNotebookSectionsOnenoteSectionParentNotebookCopyNotebookRequest) (AnyOfmicrosoftGraphOnenoteOperation, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  AnyOfmicrosoftGraphOnenoteOperation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GroupsActionsApiService.GroupsGroupOnenotePagesOnenotePageParentNotebookSectionsOnenoteSectionParentNotebookCopyNotebook")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/groups/{group-id}/onenote/pages/{onenotePage-id}/parentNotebook/sections/{onenoteSection-id}/parentNotebook/microsoft.graph.copyNotebook"
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"onenotePage-id"+"}", _neturl.PathEscape(parameterToString(r.onenotePageId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"onenoteSection-id"+"}", _neturl.PathEscape(parameterToString(r.onenoteSectionId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject277 == nil {
		return localVarReturnValue, nil, reportError("inlineObject277 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject277
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGroupsGroupOnenotePagesOnenotePageParentNotebookSectionsOnenoteSectionParentSectionGroupParentNotebookCopyNotebookRequest struct {
	ctx _context.Context
	ApiService *GroupsActionsApiService
	groupId string
	onenotePageId string
	onenoteSectionId string
	inlineObject278 *InlineObject278
}

func (r ApiGroupsGroupOnenotePagesOnenotePageParentNotebookSectionsOnenoteSectionParentSectionGroupParentNotebookCopyNotebookRequest) InlineObject278(inlineObject278 InlineObject278) ApiGroupsGroupOnenotePagesOnenotePageParentNotebookSectionsOnenoteSectionParentSectionGroupParentNotebookCopyNotebookRequest {
	r.inlineObject278 = &inlineObject278
	return r
}

func (r ApiGroupsGroupOnenotePagesOnenotePageParentNotebookSectionsOnenoteSectionParentSectionGroupParentNotebookCopyNotebookRequest) Execute() (AnyOfmicrosoftGraphOnenoteOperation, *_nethttp.Response, error) {
	return r.ApiService.GroupsGroupOnenotePagesOnenotePageParentNotebookSectionsOnenoteSectionParentSectionGroupParentNotebookCopyNotebookExecute(r)
}

/*
GroupsGroupOnenotePagesOnenotePageParentNotebookSectionsOnenoteSectionParentSectionGroupParentNotebookCopyNotebook Invoke action copyNotebook

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupId key: id of group
 @param onenotePageId key: id of onenotePage
 @param onenoteSectionId key: id of onenoteSection
 @return ApiGroupsGroupOnenotePagesOnenotePageParentNotebookSectionsOnenoteSectionParentSectionGroupParentNotebookCopyNotebookRequest
*/
func (a *GroupsActionsApiService) GroupsGroupOnenotePagesOnenotePageParentNotebookSectionsOnenoteSectionParentSectionGroupParentNotebookCopyNotebook(ctx _context.Context, groupId string, onenotePageId string, onenoteSectionId string) ApiGroupsGroupOnenotePagesOnenotePageParentNotebookSectionsOnenoteSectionParentSectionGroupParentNotebookCopyNotebookRequest {
	return ApiGroupsGroupOnenotePagesOnenotePageParentNotebookSectionsOnenoteSectionParentSectionGroupParentNotebookCopyNotebookRequest{
		ApiService: a,
		ctx: ctx,
		groupId: groupId,
		onenotePageId: onenotePageId,
		onenoteSectionId: onenoteSectionId,
	}
}

// Execute executes the request
//  @return AnyOfmicrosoftGraphOnenoteOperation
func (a *GroupsActionsApiService) GroupsGroupOnenotePagesOnenotePageParentNotebookSectionsOnenoteSectionParentSectionGroupParentNotebookCopyNotebookExecute(r ApiGroupsGroupOnenotePagesOnenotePageParentNotebookSectionsOnenoteSectionParentSectionGroupParentNotebookCopyNotebookRequest) (AnyOfmicrosoftGraphOnenoteOperation, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  AnyOfmicrosoftGraphOnenoteOperation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GroupsActionsApiService.GroupsGroupOnenotePagesOnenotePageParentNotebookSectionsOnenoteSectionParentSectionGroupParentNotebookCopyNotebook")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/groups/{group-id}/onenote/pages/{onenotePage-id}/parentNotebook/sections/{onenoteSection-id}/parentSectionGroup/parentNotebook/microsoft.graph.copyNotebook"
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"onenotePage-id"+"}", _neturl.PathEscape(parameterToString(r.onenotePageId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"onenoteSection-id"+"}", _neturl.PathEscape(parameterToString(r.onenoteSectionId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject278 == nil {
		return localVarReturnValue, nil, reportError("inlineObject278 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject278
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGroupsGroupOnenotePagesOnenotePageParentNotebookSectionsOnenoteSectionParentSectionGroupSectionsOnenoteSectionCopyToNotebookRequest struct {
	ctx _context.Context
	ApiService *GroupsActionsApiService
	groupId string
	onenotePageId string
	onenoteSectionId string
	onenoteSectionId1 string
	inlineObject279 *InlineObject279
}

func (r ApiGroupsGroupOnenotePagesOnenotePageParentNotebookSectionsOnenoteSectionParentSectionGroupSectionsOnenoteSectionCopyToNotebookRequest) InlineObject279(inlineObject279 InlineObject279) ApiGroupsGroupOnenotePagesOnenotePageParentNotebookSectionsOnenoteSectionParentSectionGroupSectionsOnenoteSectionCopyToNotebookRequest {
	r.inlineObject279 = &inlineObject279
	return r
}

func (r ApiGroupsGroupOnenotePagesOnenotePageParentNotebookSectionsOnenoteSectionParentSectionGroupSectionsOnenoteSectionCopyToNotebookRequest) Execute() (AnyOfmicrosoftGraphOnenoteOperation, *_nethttp.Response, error) {
	return r.ApiService.GroupsGroupOnenotePagesOnenotePageParentNotebookSectionsOnenoteSectionParentSectionGroupSectionsOnenoteSectionCopyToNotebookExecute(r)
}

/*
GroupsGroupOnenotePagesOnenotePageParentNotebookSectionsOnenoteSectionParentSectionGroupSectionsOnenoteSectionCopyToNotebook Invoke action copyToNotebook

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupId key: id of group
 @param onenotePageId key: id of onenotePage
 @param onenoteSectionId key: id of onenoteSection
 @param onenoteSectionId1 key: id of onenoteSection
 @return ApiGroupsGroupOnenotePagesOnenotePageParentNotebookSectionsOnenoteSectionParentSectionGroupSectionsOnenoteSectionCopyToNotebookRequest
*/
func (a *GroupsActionsApiService) GroupsGroupOnenotePagesOnenotePageParentNotebookSectionsOnenoteSectionParentSectionGroupSectionsOnenoteSectionCopyToNotebook(ctx _context.Context, groupId string, onenotePageId string, onenoteSectionId string, onenoteSectionId1 string) ApiGroupsGroupOnenotePagesOnenotePageParentNotebookSectionsOnenoteSectionParentSectionGroupSectionsOnenoteSectionCopyToNotebookRequest {
	return ApiGroupsGroupOnenotePagesOnenotePageParentNotebookSectionsOnenoteSectionParentSectionGroupSectionsOnenoteSectionCopyToNotebookRequest{
		ApiService: a,
		ctx: ctx,
		groupId: groupId,
		onenotePageId: onenotePageId,
		onenoteSectionId: onenoteSectionId,
		onenoteSectionId1: onenoteSectionId1,
	}
}

// Execute executes the request
//  @return AnyOfmicrosoftGraphOnenoteOperation
func (a *GroupsActionsApiService) GroupsGroupOnenotePagesOnenotePageParentNotebookSectionsOnenoteSectionParentSectionGroupSectionsOnenoteSectionCopyToNotebookExecute(r ApiGroupsGroupOnenotePagesOnenotePageParentNotebookSectionsOnenoteSectionParentSectionGroupSectionsOnenoteSectionCopyToNotebookRequest) (AnyOfmicrosoftGraphOnenoteOperation, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  AnyOfmicrosoftGraphOnenoteOperation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GroupsActionsApiService.GroupsGroupOnenotePagesOnenotePageParentNotebookSectionsOnenoteSectionParentSectionGroupSectionsOnenoteSectionCopyToNotebook")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/groups/{group-id}/onenote/pages/{onenotePage-id}/parentNotebook/sections/{onenoteSection-id}/parentSectionGroup/sections/{onenoteSection-id1}/microsoft.graph.copyToNotebook"
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"onenotePage-id"+"}", _neturl.PathEscape(parameterToString(r.onenotePageId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"onenoteSection-id"+"}", _neturl.PathEscape(parameterToString(r.onenoteSectionId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"onenoteSection-id1"+"}", _neturl.PathEscape(parameterToString(r.onenoteSectionId1, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject279 == nil {
		return localVarReturnValue, nil, reportError("inlineObject279 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject279
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGroupsGroupOnenotePagesOnenotePageParentNotebookSectionsOnenoteSectionParentSectionGroupSectionsOnenoteSectionCopyToSectionGroupRequest struct {
	ctx _context.Context
	ApiService *GroupsActionsApiService
	groupId string
	onenotePageId string
	onenoteSectionId string
	onenoteSectionId1 string
	inlineObject280 *InlineObject280
}

func (r ApiGroupsGroupOnenotePagesOnenotePageParentNotebookSectionsOnenoteSectionParentSectionGroupSectionsOnenoteSectionCopyToSectionGroupRequest) InlineObject280(inlineObject280 InlineObject280) ApiGroupsGroupOnenotePagesOnenotePageParentNotebookSectionsOnenoteSectionParentSectionGroupSectionsOnenoteSectionCopyToSectionGroupRequest {
	r.inlineObject280 = &inlineObject280
	return r
}

func (r ApiGroupsGroupOnenotePagesOnenotePageParentNotebookSectionsOnenoteSectionParentSectionGroupSectionsOnenoteSectionCopyToSectionGroupRequest) Execute() (AnyOfmicrosoftGraphOnenoteOperation, *_nethttp.Response, error) {
	return r.ApiService.GroupsGroupOnenotePagesOnenotePageParentNotebookSectionsOnenoteSectionParentSectionGroupSectionsOnenoteSectionCopyToSectionGroupExecute(r)
}

/*
GroupsGroupOnenotePagesOnenotePageParentNotebookSectionsOnenoteSectionParentSectionGroupSectionsOnenoteSectionCopyToSectionGroup Invoke action copyToSectionGroup

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupId key: id of group
 @param onenotePageId key: id of onenotePage
 @param onenoteSectionId key: id of onenoteSection
 @param onenoteSectionId1 key: id of onenoteSection
 @return ApiGroupsGroupOnenotePagesOnenotePageParentNotebookSectionsOnenoteSectionParentSectionGroupSectionsOnenoteSectionCopyToSectionGroupRequest
*/
func (a *GroupsActionsApiService) GroupsGroupOnenotePagesOnenotePageParentNotebookSectionsOnenoteSectionParentSectionGroupSectionsOnenoteSectionCopyToSectionGroup(ctx _context.Context, groupId string, onenotePageId string, onenoteSectionId string, onenoteSectionId1 string) ApiGroupsGroupOnenotePagesOnenotePageParentNotebookSectionsOnenoteSectionParentSectionGroupSectionsOnenoteSectionCopyToSectionGroupRequest {
	return ApiGroupsGroupOnenotePagesOnenotePageParentNotebookSectionsOnenoteSectionParentSectionGroupSectionsOnenoteSectionCopyToSectionGroupRequest{
		ApiService: a,
		ctx: ctx,
		groupId: groupId,
		onenotePageId: onenotePageId,
		onenoteSectionId: onenoteSectionId,
		onenoteSectionId1: onenoteSectionId1,
	}
}

// Execute executes the request
//  @return AnyOfmicrosoftGraphOnenoteOperation
func (a *GroupsActionsApiService) GroupsGroupOnenotePagesOnenotePageParentNotebookSectionsOnenoteSectionParentSectionGroupSectionsOnenoteSectionCopyToSectionGroupExecute(r ApiGroupsGroupOnenotePagesOnenotePageParentNotebookSectionsOnenoteSectionParentSectionGroupSectionsOnenoteSectionCopyToSectionGroupRequest) (AnyOfmicrosoftGraphOnenoteOperation, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  AnyOfmicrosoftGraphOnenoteOperation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GroupsActionsApiService.GroupsGroupOnenotePagesOnenotePageParentNotebookSectionsOnenoteSectionParentSectionGroupSectionsOnenoteSectionCopyToSectionGroup")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/groups/{group-id}/onenote/pages/{onenotePage-id}/parentNotebook/sections/{onenoteSection-id}/parentSectionGroup/sections/{onenoteSection-id1}/microsoft.graph.copyToSectionGroup"
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"onenotePage-id"+"}", _neturl.PathEscape(parameterToString(r.onenotePageId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"onenoteSection-id"+"}", _neturl.PathEscape(parameterToString(r.onenoteSectionId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"onenoteSection-id1"+"}", _neturl.PathEscape(parameterToString(r.onenoteSectionId1, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject280 == nil {
		return localVarReturnValue, nil, reportError("inlineObject280 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject280
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGroupsGroupOnenotePagesOnenotePageParentSectionCopyToNotebookRequest struct {
	ctx _context.Context
	ApiService *GroupsActionsApiService
	groupId string
	onenotePageId string
	inlineObject281 *InlineObject281
}

func (r ApiGroupsGroupOnenotePagesOnenotePageParentSectionCopyToNotebookRequest) InlineObject281(inlineObject281 InlineObject281) ApiGroupsGroupOnenotePagesOnenotePageParentSectionCopyToNotebookRequest {
	r.inlineObject281 = &inlineObject281
	return r
}

func (r ApiGroupsGroupOnenotePagesOnenotePageParentSectionCopyToNotebookRequest) Execute() (AnyOfmicrosoftGraphOnenoteOperation, *_nethttp.Response, error) {
	return r.ApiService.GroupsGroupOnenotePagesOnenotePageParentSectionCopyToNotebookExecute(r)
}

/*
GroupsGroupOnenotePagesOnenotePageParentSectionCopyToNotebook Invoke action copyToNotebook

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupId key: id of group
 @param onenotePageId key: id of onenotePage
 @return ApiGroupsGroupOnenotePagesOnenotePageParentSectionCopyToNotebookRequest
*/
func (a *GroupsActionsApiService) GroupsGroupOnenotePagesOnenotePageParentSectionCopyToNotebook(ctx _context.Context, groupId string, onenotePageId string) ApiGroupsGroupOnenotePagesOnenotePageParentSectionCopyToNotebookRequest {
	return ApiGroupsGroupOnenotePagesOnenotePageParentSectionCopyToNotebookRequest{
		ApiService: a,
		ctx: ctx,
		groupId: groupId,
		onenotePageId: onenotePageId,
	}
}

// Execute executes the request
//  @return AnyOfmicrosoftGraphOnenoteOperation
func (a *GroupsActionsApiService) GroupsGroupOnenotePagesOnenotePageParentSectionCopyToNotebookExecute(r ApiGroupsGroupOnenotePagesOnenotePageParentSectionCopyToNotebookRequest) (AnyOfmicrosoftGraphOnenoteOperation, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  AnyOfmicrosoftGraphOnenoteOperation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GroupsActionsApiService.GroupsGroupOnenotePagesOnenotePageParentSectionCopyToNotebook")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/groups/{group-id}/onenote/pages/{onenotePage-id}/parentSection/microsoft.graph.copyToNotebook"
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"onenotePage-id"+"}", _neturl.PathEscape(parameterToString(r.onenotePageId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject281 == nil {
		return localVarReturnValue, nil, reportError("inlineObject281 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject281
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGroupsGroupOnenotePagesOnenotePageParentSectionCopyToSectionGroupRequest struct {
	ctx _context.Context
	ApiService *GroupsActionsApiService
	groupId string
	onenotePageId string
	inlineObject282 *InlineObject282
}

func (r ApiGroupsGroupOnenotePagesOnenotePageParentSectionCopyToSectionGroupRequest) InlineObject282(inlineObject282 InlineObject282) ApiGroupsGroupOnenotePagesOnenotePageParentSectionCopyToSectionGroupRequest {
	r.inlineObject282 = &inlineObject282
	return r
}

func (r ApiGroupsGroupOnenotePagesOnenotePageParentSectionCopyToSectionGroupRequest) Execute() (AnyOfmicrosoftGraphOnenoteOperation, *_nethttp.Response, error) {
	return r.ApiService.GroupsGroupOnenotePagesOnenotePageParentSectionCopyToSectionGroupExecute(r)
}

/*
GroupsGroupOnenotePagesOnenotePageParentSectionCopyToSectionGroup Invoke action copyToSectionGroup

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupId key: id of group
 @param onenotePageId key: id of onenotePage
 @return ApiGroupsGroupOnenotePagesOnenotePageParentSectionCopyToSectionGroupRequest
*/
func (a *GroupsActionsApiService) GroupsGroupOnenotePagesOnenotePageParentSectionCopyToSectionGroup(ctx _context.Context, groupId string, onenotePageId string) ApiGroupsGroupOnenotePagesOnenotePageParentSectionCopyToSectionGroupRequest {
	return ApiGroupsGroupOnenotePagesOnenotePageParentSectionCopyToSectionGroupRequest{
		ApiService: a,
		ctx: ctx,
		groupId: groupId,
		onenotePageId: onenotePageId,
	}
}

// Execute executes the request
//  @return AnyOfmicrosoftGraphOnenoteOperation
func (a *GroupsActionsApiService) GroupsGroupOnenotePagesOnenotePageParentSectionCopyToSectionGroupExecute(r ApiGroupsGroupOnenotePagesOnenotePageParentSectionCopyToSectionGroupRequest) (AnyOfmicrosoftGraphOnenoteOperation, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  AnyOfmicrosoftGraphOnenoteOperation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GroupsActionsApiService.GroupsGroupOnenotePagesOnenotePageParentSectionCopyToSectionGroup")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/groups/{group-id}/onenote/pages/{onenotePage-id}/parentSection/microsoft.graph.copyToSectionGroup"
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"onenotePage-id"+"}", _neturl.PathEscape(parameterToString(r.onenotePageId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject282 == nil {
		return localVarReturnValue, nil, reportError("inlineObject282 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject282
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGroupsGroupOnenotePagesOnenotePageParentSectionPagesOnenotePageCopyToSectionRequest struct {
	ctx _context.Context
	ApiService *GroupsActionsApiService
	groupId string
	onenotePageId string
	onenotePageId1 string
	inlineObject283 *InlineObject283
}

func (r ApiGroupsGroupOnenotePagesOnenotePageParentSectionPagesOnenotePageCopyToSectionRequest) InlineObject283(inlineObject283 InlineObject283) ApiGroupsGroupOnenotePagesOnenotePageParentSectionPagesOnenotePageCopyToSectionRequest {
	r.inlineObject283 = &inlineObject283
	return r
}

func (r ApiGroupsGroupOnenotePagesOnenotePageParentSectionPagesOnenotePageCopyToSectionRequest) Execute() (AnyOfmicrosoftGraphOnenoteOperation, *_nethttp.Response, error) {
	return r.ApiService.GroupsGroupOnenotePagesOnenotePageParentSectionPagesOnenotePageCopyToSectionExecute(r)
}

/*
GroupsGroupOnenotePagesOnenotePageParentSectionPagesOnenotePageCopyToSection Invoke action copyToSection

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupId key: id of group
 @param onenotePageId key: id of onenotePage
 @param onenotePageId1 key: id of onenotePage
 @return ApiGroupsGroupOnenotePagesOnenotePageParentSectionPagesOnenotePageCopyToSectionRequest
*/
func (a *GroupsActionsApiService) GroupsGroupOnenotePagesOnenotePageParentSectionPagesOnenotePageCopyToSection(ctx _context.Context, groupId string, onenotePageId string, onenotePageId1 string) ApiGroupsGroupOnenotePagesOnenotePageParentSectionPagesOnenotePageCopyToSectionRequest {
	return ApiGroupsGroupOnenotePagesOnenotePageParentSectionPagesOnenotePageCopyToSectionRequest{
		ApiService: a,
		ctx: ctx,
		groupId: groupId,
		onenotePageId: onenotePageId,
		onenotePageId1: onenotePageId1,
	}
}

// Execute executes the request
//  @return AnyOfmicrosoftGraphOnenoteOperation
func (a *GroupsActionsApiService) GroupsGroupOnenotePagesOnenotePageParentSectionPagesOnenotePageCopyToSectionExecute(r ApiGroupsGroupOnenotePagesOnenotePageParentSectionPagesOnenotePageCopyToSectionRequest) (AnyOfmicrosoftGraphOnenoteOperation, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  AnyOfmicrosoftGraphOnenoteOperation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GroupsActionsApiService.GroupsGroupOnenotePagesOnenotePageParentSectionPagesOnenotePageCopyToSection")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/groups/{group-id}/onenote/pages/{onenotePage-id}/parentSection/pages/{onenotePage-id1}/microsoft.graph.copyToSection"
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"onenotePage-id"+"}", _neturl.PathEscape(parameterToString(r.onenotePageId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"onenotePage-id1"+"}", _neturl.PathEscape(parameterToString(r.onenotePageId1, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject283 == nil {
		return localVarReturnValue, nil, reportError("inlineObject283 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject283
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGroupsGroupOnenotePagesOnenotePageParentSectionPagesOnenotePageOnenotePatchContentRequest struct {
	ctx _context.Context
	ApiService *GroupsActionsApiService
	groupId string
	onenotePageId string
	onenotePageId1 string
	inlineObject284 *InlineObject284
}

func (r ApiGroupsGroupOnenotePagesOnenotePageParentSectionPagesOnenotePageOnenotePatchContentRequest) InlineObject284(inlineObject284 InlineObject284) ApiGroupsGroupOnenotePagesOnenotePageParentSectionPagesOnenotePageOnenotePatchContentRequest {
	r.inlineObject284 = &inlineObject284
	return r
}

func (r ApiGroupsGroupOnenotePagesOnenotePageParentSectionPagesOnenotePageOnenotePatchContentRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.GroupsGroupOnenotePagesOnenotePageParentSectionPagesOnenotePageOnenotePatchContentExecute(r)
}

/*
GroupsGroupOnenotePagesOnenotePageParentSectionPagesOnenotePageOnenotePatchContent Invoke action onenotePatchContent

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupId key: id of group
 @param onenotePageId key: id of onenotePage
 @param onenotePageId1 key: id of onenotePage
 @return ApiGroupsGroupOnenotePagesOnenotePageParentSectionPagesOnenotePageOnenotePatchContentRequest
*/
func (a *GroupsActionsApiService) GroupsGroupOnenotePagesOnenotePageParentSectionPagesOnenotePageOnenotePatchContent(ctx _context.Context, groupId string, onenotePageId string, onenotePageId1 string) ApiGroupsGroupOnenotePagesOnenotePageParentSectionPagesOnenotePageOnenotePatchContentRequest {
	return ApiGroupsGroupOnenotePagesOnenotePageParentSectionPagesOnenotePageOnenotePatchContentRequest{
		ApiService: a,
		ctx: ctx,
		groupId: groupId,
		onenotePageId: onenotePageId,
		onenotePageId1: onenotePageId1,
	}
}

// Execute executes the request
func (a *GroupsActionsApiService) GroupsGroupOnenotePagesOnenotePageParentSectionPagesOnenotePageOnenotePatchContentExecute(r ApiGroupsGroupOnenotePagesOnenotePageParentSectionPagesOnenotePageOnenotePatchContentRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GroupsActionsApiService.GroupsGroupOnenotePagesOnenotePageParentSectionPagesOnenotePageOnenotePatchContent")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/groups/{group-id}/onenote/pages/{onenotePage-id}/parentSection/pages/{onenotePage-id1}/microsoft.graph.onenotePatchContent"
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"onenotePage-id"+"}", _neturl.PathEscape(parameterToString(r.onenotePageId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"onenotePage-id1"+"}", _neturl.PathEscape(parameterToString(r.onenotePageId1, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject284 == nil {
		return nil, reportError("inlineObject284 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject284
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGroupsGroupOnenotePagesOnenotePageParentSectionParentNotebookCopyNotebookRequest struct {
	ctx _context.Context
	ApiService *GroupsActionsApiService
	groupId string
	onenotePageId string
	inlineObject285 *InlineObject285
}

func (r ApiGroupsGroupOnenotePagesOnenotePageParentSectionParentNotebookCopyNotebookRequest) InlineObject285(inlineObject285 InlineObject285) ApiGroupsGroupOnenotePagesOnenotePageParentSectionParentNotebookCopyNotebookRequest {
	r.inlineObject285 = &inlineObject285
	return r
}

func (r ApiGroupsGroupOnenotePagesOnenotePageParentSectionParentNotebookCopyNotebookRequest) Execute() (AnyOfmicrosoftGraphOnenoteOperation, *_nethttp.Response, error) {
	return r.ApiService.GroupsGroupOnenotePagesOnenotePageParentSectionParentNotebookCopyNotebookExecute(r)
}

/*
GroupsGroupOnenotePagesOnenotePageParentSectionParentNotebookCopyNotebook Invoke action copyNotebook

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupId key: id of group
 @param onenotePageId key: id of onenotePage
 @return ApiGroupsGroupOnenotePagesOnenotePageParentSectionParentNotebookCopyNotebookRequest
*/
func (a *GroupsActionsApiService) GroupsGroupOnenotePagesOnenotePageParentSectionParentNotebookCopyNotebook(ctx _context.Context, groupId string, onenotePageId string) ApiGroupsGroupOnenotePagesOnenotePageParentSectionParentNotebookCopyNotebookRequest {
	return ApiGroupsGroupOnenotePagesOnenotePageParentSectionParentNotebookCopyNotebookRequest{
		ApiService: a,
		ctx: ctx,
		groupId: groupId,
		onenotePageId: onenotePageId,
	}
}

// Execute executes the request
//  @return AnyOfmicrosoftGraphOnenoteOperation
func (a *GroupsActionsApiService) GroupsGroupOnenotePagesOnenotePageParentSectionParentNotebookCopyNotebookExecute(r ApiGroupsGroupOnenotePagesOnenotePageParentSectionParentNotebookCopyNotebookRequest) (AnyOfmicrosoftGraphOnenoteOperation, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  AnyOfmicrosoftGraphOnenoteOperation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GroupsActionsApiService.GroupsGroupOnenotePagesOnenotePageParentSectionParentNotebookCopyNotebook")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/groups/{group-id}/onenote/pages/{onenotePage-id}/parentSection/parentNotebook/microsoft.graph.copyNotebook"
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"onenotePage-id"+"}", _neturl.PathEscape(parameterToString(r.onenotePageId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject285 == nil {
		return localVarReturnValue, nil, reportError("inlineObject285 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject285
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGroupsGroupOnenotePagesOnenotePageParentSectionParentNotebookSectionGroupsSectionGroupParentNotebookCopyNotebookRequest struct {
	ctx _context.Context
	ApiService *GroupsActionsApiService
	groupId string
	onenotePageId string
	sectionGroupId string
	inlineObject286 *InlineObject286
}

func (r ApiGroupsGroupOnenotePagesOnenotePageParentSectionParentNotebookSectionGroupsSectionGroupParentNotebookCopyNotebookRequest) InlineObject286(inlineObject286 InlineObject286) ApiGroupsGroupOnenotePagesOnenotePageParentSectionParentNotebookSectionGroupsSectionGroupParentNotebookCopyNotebookRequest {
	r.inlineObject286 = &inlineObject286
	return r
}

func (r ApiGroupsGroupOnenotePagesOnenotePageParentSectionParentNotebookSectionGroupsSectionGroupParentNotebookCopyNotebookRequest) Execute() (AnyOfmicrosoftGraphOnenoteOperation, *_nethttp.Response, error) {
	return r.ApiService.GroupsGroupOnenotePagesOnenotePageParentSectionParentNotebookSectionGroupsSectionGroupParentNotebookCopyNotebookExecute(r)
}

/*
GroupsGroupOnenotePagesOnenotePageParentSectionParentNotebookSectionGroupsSectionGroupParentNotebookCopyNotebook Invoke action copyNotebook

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupId key: id of group
 @param onenotePageId key: id of onenotePage
 @param sectionGroupId key: id of sectionGroup
 @return ApiGroupsGroupOnenotePagesOnenotePageParentSectionParentNotebookSectionGroupsSectionGroupParentNotebookCopyNotebookRequest
*/
func (a *GroupsActionsApiService) GroupsGroupOnenotePagesOnenotePageParentSectionParentNotebookSectionGroupsSectionGroupParentNotebookCopyNotebook(ctx _context.Context, groupId string, onenotePageId string, sectionGroupId string) ApiGroupsGroupOnenotePagesOnenotePageParentSectionParentNotebookSectionGroupsSectionGroupParentNotebookCopyNotebookRequest {
	return ApiGroupsGroupOnenotePagesOnenotePageParentSectionParentNotebookSectionGroupsSectionGroupParentNotebookCopyNotebookRequest{
		ApiService: a,
		ctx: ctx,
		groupId: groupId,
		onenotePageId: onenotePageId,
		sectionGroupId: sectionGroupId,
	}
}

// Execute executes the request
//  @return AnyOfmicrosoftGraphOnenoteOperation
func (a *GroupsActionsApiService) GroupsGroupOnenotePagesOnenotePageParentSectionParentNotebookSectionGroupsSectionGroupParentNotebookCopyNotebookExecute(r ApiGroupsGroupOnenotePagesOnenotePageParentSectionParentNotebookSectionGroupsSectionGroupParentNotebookCopyNotebookRequest) (AnyOfmicrosoftGraphOnenoteOperation, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  AnyOfmicrosoftGraphOnenoteOperation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GroupsActionsApiService.GroupsGroupOnenotePagesOnenotePageParentSectionParentNotebookSectionGroupsSectionGroupParentNotebookCopyNotebook")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/groups/{group-id}/onenote/pages/{onenotePage-id}/parentSection/parentNotebook/sectionGroups/{sectionGroup-id}/parentNotebook/microsoft.graph.copyNotebook"
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"onenotePage-id"+"}", _neturl.PathEscape(parameterToString(r.onenotePageId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"sectionGroup-id"+"}", _neturl.PathEscape(parameterToString(r.sectionGroupId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject286 == nil {
		return localVarReturnValue, nil, reportError("inlineObject286 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject286
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGroupsGroupOnenotePagesOnenotePageParentSectionParentNotebookSectionGroupsSectionGroupSectionsOnenoteSectionCopyToNotebookRequest struct {
	ctx _context.Context
	ApiService *GroupsActionsApiService
	groupId string
	onenotePageId string
	sectionGroupId string
	onenoteSectionId string
	inlineObject287 *InlineObject287
}

func (r ApiGroupsGroupOnenotePagesOnenotePageParentSectionParentNotebookSectionGroupsSectionGroupSectionsOnenoteSectionCopyToNotebookRequest) InlineObject287(inlineObject287 InlineObject287) ApiGroupsGroupOnenotePagesOnenotePageParentSectionParentNotebookSectionGroupsSectionGroupSectionsOnenoteSectionCopyToNotebookRequest {
	r.inlineObject287 = &inlineObject287
	return r
}

func (r ApiGroupsGroupOnenotePagesOnenotePageParentSectionParentNotebookSectionGroupsSectionGroupSectionsOnenoteSectionCopyToNotebookRequest) Execute() (AnyOfmicrosoftGraphOnenoteOperation, *_nethttp.Response, error) {
	return r.ApiService.GroupsGroupOnenotePagesOnenotePageParentSectionParentNotebookSectionGroupsSectionGroupSectionsOnenoteSectionCopyToNotebookExecute(r)
}

/*
GroupsGroupOnenotePagesOnenotePageParentSectionParentNotebookSectionGroupsSectionGroupSectionsOnenoteSectionCopyToNotebook Invoke action copyToNotebook

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupId key: id of group
 @param onenotePageId key: id of onenotePage
 @param sectionGroupId key: id of sectionGroup
 @param onenoteSectionId key: id of onenoteSection
 @return ApiGroupsGroupOnenotePagesOnenotePageParentSectionParentNotebookSectionGroupsSectionGroupSectionsOnenoteSectionCopyToNotebookRequest
*/
func (a *GroupsActionsApiService) GroupsGroupOnenotePagesOnenotePageParentSectionParentNotebookSectionGroupsSectionGroupSectionsOnenoteSectionCopyToNotebook(ctx _context.Context, groupId string, onenotePageId string, sectionGroupId string, onenoteSectionId string) ApiGroupsGroupOnenotePagesOnenotePageParentSectionParentNotebookSectionGroupsSectionGroupSectionsOnenoteSectionCopyToNotebookRequest {
	return ApiGroupsGroupOnenotePagesOnenotePageParentSectionParentNotebookSectionGroupsSectionGroupSectionsOnenoteSectionCopyToNotebookRequest{
		ApiService: a,
		ctx: ctx,
		groupId: groupId,
		onenotePageId: onenotePageId,
		sectionGroupId: sectionGroupId,
		onenoteSectionId: onenoteSectionId,
	}
}

// Execute executes the request
//  @return AnyOfmicrosoftGraphOnenoteOperation
func (a *GroupsActionsApiService) GroupsGroupOnenotePagesOnenotePageParentSectionParentNotebookSectionGroupsSectionGroupSectionsOnenoteSectionCopyToNotebookExecute(r ApiGroupsGroupOnenotePagesOnenotePageParentSectionParentNotebookSectionGroupsSectionGroupSectionsOnenoteSectionCopyToNotebookRequest) (AnyOfmicrosoftGraphOnenoteOperation, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  AnyOfmicrosoftGraphOnenoteOperation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GroupsActionsApiService.GroupsGroupOnenotePagesOnenotePageParentSectionParentNotebookSectionGroupsSectionGroupSectionsOnenoteSectionCopyToNotebook")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/groups/{group-id}/onenote/pages/{onenotePage-id}/parentSection/parentNotebook/sectionGroups/{sectionGroup-id}/sections/{onenoteSection-id}/microsoft.graph.copyToNotebook"
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"onenotePage-id"+"}", _neturl.PathEscape(parameterToString(r.onenotePageId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"sectionGroup-id"+"}", _neturl.PathEscape(parameterToString(r.sectionGroupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"onenoteSection-id"+"}", _neturl.PathEscape(parameterToString(r.onenoteSectionId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject287 == nil {
		return localVarReturnValue, nil, reportError("inlineObject287 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject287
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGroupsGroupOnenotePagesOnenotePageParentSectionParentNotebookSectionGroupsSectionGroupSectionsOnenoteSectionCopyToSectionGroupRequest struct {
	ctx _context.Context
	ApiService *GroupsActionsApiService
	groupId string
	onenotePageId string
	sectionGroupId string
	onenoteSectionId string
	inlineObject288 *InlineObject288
}

func (r ApiGroupsGroupOnenotePagesOnenotePageParentSectionParentNotebookSectionGroupsSectionGroupSectionsOnenoteSectionCopyToSectionGroupRequest) InlineObject288(inlineObject288 InlineObject288) ApiGroupsGroupOnenotePagesOnenotePageParentSectionParentNotebookSectionGroupsSectionGroupSectionsOnenoteSectionCopyToSectionGroupRequest {
	r.inlineObject288 = &inlineObject288
	return r
}

func (r ApiGroupsGroupOnenotePagesOnenotePageParentSectionParentNotebookSectionGroupsSectionGroupSectionsOnenoteSectionCopyToSectionGroupRequest) Execute() (AnyOfmicrosoftGraphOnenoteOperation, *_nethttp.Response, error) {
	return r.ApiService.GroupsGroupOnenotePagesOnenotePageParentSectionParentNotebookSectionGroupsSectionGroupSectionsOnenoteSectionCopyToSectionGroupExecute(r)
}

/*
GroupsGroupOnenotePagesOnenotePageParentSectionParentNotebookSectionGroupsSectionGroupSectionsOnenoteSectionCopyToSectionGroup Invoke action copyToSectionGroup

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupId key: id of group
 @param onenotePageId key: id of onenotePage
 @param sectionGroupId key: id of sectionGroup
 @param onenoteSectionId key: id of onenoteSection
 @return ApiGroupsGroupOnenotePagesOnenotePageParentSectionParentNotebookSectionGroupsSectionGroupSectionsOnenoteSectionCopyToSectionGroupRequest
*/
func (a *GroupsActionsApiService) GroupsGroupOnenotePagesOnenotePageParentSectionParentNotebookSectionGroupsSectionGroupSectionsOnenoteSectionCopyToSectionGroup(ctx _context.Context, groupId string, onenotePageId string, sectionGroupId string, onenoteSectionId string) ApiGroupsGroupOnenotePagesOnenotePageParentSectionParentNotebookSectionGroupsSectionGroupSectionsOnenoteSectionCopyToSectionGroupRequest {
	return ApiGroupsGroupOnenotePagesOnenotePageParentSectionParentNotebookSectionGroupsSectionGroupSectionsOnenoteSectionCopyToSectionGroupRequest{
		ApiService: a,
		ctx: ctx,
		groupId: groupId,
		onenotePageId: onenotePageId,
		sectionGroupId: sectionGroupId,
		onenoteSectionId: onenoteSectionId,
	}
}

// Execute executes the request
//  @return AnyOfmicrosoftGraphOnenoteOperation
func (a *GroupsActionsApiService) GroupsGroupOnenotePagesOnenotePageParentSectionParentNotebookSectionGroupsSectionGroupSectionsOnenoteSectionCopyToSectionGroupExecute(r ApiGroupsGroupOnenotePagesOnenotePageParentSectionParentNotebookSectionGroupsSectionGroupSectionsOnenoteSectionCopyToSectionGroupRequest) (AnyOfmicrosoftGraphOnenoteOperation, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  AnyOfmicrosoftGraphOnenoteOperation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GroupsActionsApiService.GroupsGroupOnenotePagesOnenotePageParentSectionParentNotebookSectionGroupsSectionGroupSectionsOnenoteSectionCopyToSectionGroup")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/groups/{group-id}/onenote/pages/{onenotePage-id}/parentSection/parentNotebook/sectionGroups/{sectionGroup-id}/sections/{onenoteSection-id}/microsoft.graph.copyToSectionGroup"
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"onenotePage-id"+"}", _neturl.PathEscape(parameterToString(r.onenotePageId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"sectionGroup-id"+"}", _neturl.PathEscape(parameterToString(r.sectionGroupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"onenoteSection-id"+"}", _neturl.PathEscape(parameterToString(r.onenoteSectionId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject288 == nil {
		return localVarReturnValue, nil, reportError("inlineObject288 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject288
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGroupsGroupOnenotePagesOnenotePageParentSectionParentNotebookSectionsOnenoteSectionCopyToNotebookRequest struct {
	ctx _context.Context
	ApiService *GroupsActionsApiService
	groupId string
	onenotePageId string
	onenoteSectionId string
	inlineObject289 *InlineObject289
}

func (r ApiGroupsGroupOnenotePagesOnenotePageParentSectionParentNotebookSectionsOnenoteSectionCopyToNotebookRequest) InlineObject289(inlineObject289 InlineObject289) ApiGroupsGroupOnenotePagesOnenotePageParentSectionParentNotebookSectionsOnenoteSectionCopyToNotebookRequest {
	r.inlineObject289 = &inlineObject289
	return r
}

func (r ApiGroupsGroupOnenotePagesOnenotePageParentSectionParentNotebookSectionsOnenoteSectionCopyToNotebookRequest) Execute() (AnyOfmicrosoftGraphOnenoteOperation, *_nethttp.Response, error) {
	return r.ApiService.GroupsGroupOnenotePagesOnenotePageParentSectionParentNotebookSectionsOnenoteSectionCopyToNotebookExecute(r)
}

/*
GroupsGroupOnenotePagesOnenotePageParentSectionParentNotebookSectionsOnenoteSectionCopyToNotebook Invoke action copyToNotebook

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupId key: id of group
 @param onenotePageId key: id of onenotePage
 @param onenoteSectionId key: id of onenoteSection
 @return ApiGroupsGroupOnenotePagesOnenotePageParentSectionParentNotebookSectionsOnenoteSectionCopyToNotebookRequest
*/
func (a *GroupsActionsApiService) GroupsGroupOnenotePagesOnenotePageParentSectionParentNotebookSectionsOnenoteSectionCopyToNotebook(ctx _context.Context, groupId string, onenotePageId string, onenoteSectionId string) ApiGroupsGroupOnenotePagesOnenotePageParentSectionParentNotebookSectionsOnenoteSectionCopyToNotebookRequest {
	return ApiGroupsGroupOnenotePagesOnenotePageParentSectionParentNotebookSectionsOnenoteSectionCopyToNotebookRequest{
		ApiService: a,
		ctx: ctx,
		groupId: groupId,
		onenotePageId: onenotePageId,
		onenoteSectionId: onenoteSectionId,
	}
}

// Execute executes the request
//  @return AnyOfmicrosoftGraphOnenoteOperation
func (a *GroupsActionsApiService) GroupsGroupOnenotePagesOnenotePageParentSectionParentNotebookSectionsOnenoteSectionCopyToNotebookExecute(r ApiGroupsGroupOnenotePagesOnenotePageParentSectionParentNotebookSectionsOnenoteSectionCopyToNotebookRequest) (AnyOfmicrosoftGraphOnenoteOperation, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  AnyOfmicrosoftGraphOnenoteOperation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GroupsActionsApiService.GroupsGroupOnenotePagesOnenotePageParentSectionParentNotebookSectionsOnenoteSectionCopyToNotebook")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/groups/{group-id}/onenote/pages/{onenotePage-id}/parentSection/parentNotebook/sections/{onenoteSection-id}/microsoft.graph.copyToNotebook"
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"onenotePage-id"+"}", _neturl.PathEscape(parameterToString(r.onenotePageId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"onenoteSection-id"+"}", _neturl.PathEscape(parameterToString(r.onenoteSectionId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject289 == nil {
		return localVarReturnValue, nil, reportError("inlineObject289 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject289
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGroupsGroupOnenotePagesOnenotePageParentSectionParentNotebookSectionsOnenoteSectionCopyToSectionGroupRequest struct {
	ctx _context.Context
	ApiService *GroupsActionsApiService
	groupId string
	onenotePageId string
	onenoteSectionId string
	inlineObject290 *InlineObject290
}

func (r ApiGroupsGroupOnenotePagesOnenotePageParentSectionParentNotebookSectionsOnenoteSectionCopyToSectionGroupRequest) InlineObject290(inlineObject290 InlineObject290) ApiGroupsGroupOnenotePagesOnenotePageParentSectionParentNotebookSectionsOnenoteSectionCopyToSectionGroupRequest {
	r.inlineObject290 = &inlineObject290
	return r
}

func (r ApiGroupsGroupOnenotePagesOnenotePageParentSectionParentNotebookSectionsOnenoteSectionCopyToSectionGroupRequest) Execute() (AnyOfmicrosoftGraphOnenoteOperation, *_nethttp.Response, error) {
	return r.ApiService.GroupsGroupOnenotePagesOnenotePageParentSectionParentNotebookSectionsOnenoteSectionCopyToSectionGroupExecute(r)
}

/*
GroupsGroupOnenotePagesOnenotePageParentSectionParentNotebookSectionsOnenoteSectionCopyToSectionGroup Invoke action copyToSectionGroup

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupId key: id of group
 @param onenotePageId key: id of onenotePage
 @param onenoteSectionId key: id of onenoteSection
 @return ApiGroupsGroupOnenotePagesOnenotePageParentSectionParentNotebookSectionsOnenoteSectionCopyToSectionGroupRequest
*/
func (a *GroupsActionsApiService) GroupsGroupOnenotePagesOnenotePageParentSectionParentNotebookSectionsOnenoteSectionCopyToSectionGroup(ctx _context.Context, groupId string, onenotePageId string, onenoteSectionId string) ApiGroupsGroupOnenotePagesOnenotePageParentSectionParentNotebookSectionsOnenoteSectionCopyToSectionGroupRequest {
	return ApiGroupsGroupOnenotePagesOnenotePageParentSectionParentNotebookSectionsOnenoteSectionCopyToSectionGroupRequest{
		ApiService: a,
		ctx: ctx,
		groupId: groupId,
		onenotePageId: onenotePageId,
		onenoteSectionId: onenoteSectionId,
	}
}

// Execute executes the request
//  @return AnyOfmicrosoftGraphOnenoteOperation
func (a *GroupsActionsApiService) GroupsGroupOnenotePagesOnenotePageParentSectionParentNotebookSectionsOnenoteSectionCopyToSectionGroupExecute(r ApiGroupsGroupOnenotePagesOnenotePageParentSectionParentNotebookSectionsOnenoteSectionCopyToSectionGroupRequest) (AnyOfmicrosoftGraphOnenoteOperation, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  AnyOfmicrosoftGraphOnenoteOperation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GroupsActionsApiService.GroupsGroupOnenotePagesOnenotePageParentSectionParentNotebookSectionsOnenoteSectionCopyToSectionGroup")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/groups/{group-id}/onenote/pages/{onenotePage-id}/parentSection/parentNotebook/sections/{onenoteSection-id}/microsoft.graph.copyToSectionGroup"
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"onenotePage-id"+"}", _neturl.PathEscape(parameterToString(r.onenotePageId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"onenoteSection-id"+"}", _neturl.PathEscape(parameterToString(r.onenoteSectionId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject290 == nil {
		return localVarReturnValue, nil, reportError("inlineObject290 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject290
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGroupsGroupOnenotePagesOnenotePageParentSectionParentSectionGroupParentNotebookCopyNotebookRequest struct {
	ctx _context.Context
	ApiService *GroupsActionsApiService
	groupId string
	onenotePageId string
	inlineObject291 *InlineObject291
}

func (r ApiGroupsGroupOnenotePagesOnenotePageParentSectionParentSectionGroupParentNotebookCopyNotebookRequest) InlineObject291(inlineObject291 InlineObject291) ApiGroupsGroupOnenotePagesOnenotePageParentSectionParentSectionGroupParentNotebookCopyNotebookRequest {
	r.inlineObject291 = &inlineObject291
	return r
}

func (r ApiGroupsGroupOnenotePagesOnenotePageParentSectionParentSectionGroupParentNotebookCopyNotebookRequest) Execute() (AnyOfmicrosoftGraphOnenoteOperation, *_nethttp.Response, error) {
	return r.ApiService.GroupsGroupOnenotePagesOnenotePageParentSectionParentSectionGroupParentNotebookCopyNotebookExecute(r)
}

/*
GroupsGroupOnenotePagesOnenotePageParentSectionParentSectionGroupParentNotebookCopyNotebook Invoke action copyNotebook

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupId key: id of group
 @param onenotePageId key: id of onenotePage
 @return ApiGroupsGroupOnenotePagesOnenotePageParentSectionParentSectionGroupParentNotebookCopyNotebookRequest
*/
func (a *GroupsActionsApiService) GroupsGroupOnenotePagesOnenotePageParentSectionParentSectionGroupParentNotebookCopyNotebook(ctx _context.Context, groupId string, onenotePageId string) ApiGroupsGroupOnenotePagesOnenotePageParentSectionParentSectionGroupParentNotebookCopyNotebookRequest {
	return ApiGroupsGroupOnenotePagesOnenotePageParentSectionParentSectionGroupParentNotebookCopyNotebookRequest{
		ApiService: a,
		ctx: ctx,
		groupId: groupId,
		onenotePageId: onenotePageId,
	}
}

// Execute executes the request
//  @return AnyOfmicrosoftGraphOnenoteOperation
func (a *GroupsActionsApiService) GroupsGroupOnenotePagesOnenotePageParentSectionParentSectionGroupParentNotebookCopyNotebookExecute(r ApiGroupsGroupOnenotePagesOnenotePageParentSectionParentSectionGroupParentNotebookCopyNotebookRequest) (AnyOfmicrosoftGraphOnenoteOperation, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  AnyOfmicrosoftGraphOnenoteOperation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GroupsActionsApiService.GroupsGroupOnenotePagesOnenotePageParentSectionParentSectionGroupParentNotebookCopyNotebook")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/groups/{group-id}/onenote/pages/{onenotePage-id}/parentSection/parentSectionGroup/parentNotebook/microsoft.graph.copyNotebook"
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"onenotePage-id"+"}", _neturl.PathEscape(parameterToString(r.onenotePageId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject291 == nil {
		return localVarReturnValue, nil, reportError("inlineObject291 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject291
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGroupsGroupOnenotePagesOnenotePageParentSectionParentSectionGroupParentNotebookSectionsOnenoteSectionCopyToNotebookRequest struct {
	ctx _context.Context
	ApiService *GroupsActionsApiService
	groupId string
	onenotePageId string
	onenoteSectionId string
	inlineObject292 *InlineObject292
}

func (r ApiGroupsGroupOnenotePagesOnenotePageParentSectionParentSectionGroupParentNotebookSectionsOnenoteSectionCopyToNotebookRequest) InlineObject292(inlineObject292 InlineObject292) ApiGroupsGroupOnenotePagesOnenotePageParentSectionParentSectionGroupParentNotebookSectionsOnenoteSectionCopyToNotebookRequest {
	r.inlineObject292 = &inlineObject292
	return r
}

func (r ApiGroupsGroupOnenotePagesOnenotePageParentSectionParentSectionGroupParentNotebookSectionsOnenoteSectionCopyToNotebookRequest) Execute() (AnyOfmicrosoftGraphOnenoteOperation, *_nethttp.Response, error) {
	return r.ApiService.GroupsGroupOnenotePagesOnenotePageParentSectionParentSectionGroupParentNotebookSectionsOnenoteSectionCopyToNotebookExecute(r)
}

/*
GroupsGroupOnenotePagesOnenotePageParentSectionParentSectionGroupParentNotebookSectionsOnenoteSectionCopyToNotebook Invoke action copyToNotebook

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupId key: id of group
 @param onenotePageId key: id of onenotePage
 @param onenoteSectionId key: id of onenoteSection
 @return ApiGroupsGroupOnenotePagesOnenotePageParentSectionParentSectionGroupParentNotebookSectionsOnenoteSectionCopyToNotebookRequest
*/
func (a *GroupsActionsApiService) GroupsGroupOnenotePagesOnenotePageParentSectionParentSectionGroupParentNotebookSectionsOnenoteSectionCopyToNotebook(ctx _context.Context, groupId string, onenotePageId string, onenoteSectionId string) ApiGroupsGroupOnenotePagesOnenotePageParentSectionParentSectionGroupParentNotebookSectionsOnenoteSectionCopyToNotebookRequest {
	return ApiGroupsGroupOnenotePagesOnenotePageParentSectionParentSectionGroupParentNotebookSectionsOnenoteSectionCopyToNotebookRequest{
		ApiService: a,
		ctx: ctx,
		groupId: groupId,
		onenotePageId: onenotePageId,
		onenoteSectionId: onenoteSectionId,
	}
}

// Execute executes the request
//  @return AnyOfmicrosoftGraphOnenoteOperation
func (a *GroupsActionsApiService) GroupsGroupOnenotePagesOnenotePageParentSectionParentSectionGroupParentNotebookSectionsOnenoteSectionCopyToNotebookExecute(r ApiGroupsGroupOnenotePagesOnenotePageParentSectionParentSectionGroupParentNotebookSectionsOnenoteSectionCopyToNotebookRequest) (AnyOfmicrosoftGraphOnenoteOperation, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  AnyOfmicrosoftGraphOnenoteOperation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GroupsActionsApiService.GroupsGroupOnenotePagesOnenotePageParentSectionParentSectionGroupParentNotebookSectionsOnenoteSectionCopyToNotebook")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/groups/{group-id}/onenote/pages/{onenotePage-id}/parentSection/parentSectionGroup/parentNotebook/sections/{onenoteSection-id}/microsoft.graph.copyToNotebook"
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"onenotePage-id"+"}", _neturl.PathEscape(parameterToString(r.onenotePageId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"onenoteSection-id"+"}", _neturl.PathEscape(parameterToString(r.onenoteSectionId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject292 == nil {
		return localVarReturnValue, nil, reportError("inlineObject292 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject292
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGroupsGroupOnenotePagesOnenotePageParentSectionParentSectionGroupParentNotebookSectionsOnenoteSectionCopyToSectionGroupRequest struct {
	ctx _context.Context
	ApiService *GroupsActionsApiService
	groupId string
	onenotePageId string
	onenoteSectionId string
	inlineObject293 *InlineObject293
}

func (r ApiGroupsGroupOnenotePagesOnenotePageParentSectionParentSectionGroupParentNotebookSectionsOnenoteSectionCopyToSectionGroupRequest) InlineObject293(inlineObject293 InlineObject293) ApiGroupsGroupOnenotePagesOnenotePageParentSectionParentSectionGroupParentNotebookSectionsOnenoteSectionCopyToSectionGroupRequest {
	r.inlineObject293 = &inlineObject293
	return r
}

func (r ApiGroupsGroupOnenotePagesOnenotePageParentSectionParentSectionGroupParentNotebookSectionsOnenoteSectionCopyToSectionGroupRequest) Execute() (AnyOfmicrosoftGraphOnenoteOperation, *_nethttp.Response, error) {
	return r.ApiService.GroupsGroupOnenotePagesOnenotePageParentSectionParentSectionGroupParentNotebookSectionsOnenoteSectionCopyToSectionGroupExecute(r)
}

/*
GroupsGroupOnenotePagesOnenotePageParentSectionParentSectionGroupParentNotebookSectionsOnenoteSectionCopyToSectionGroup Invoke action copyToSectionGroup

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupId key: id of group
 @param onenotePageId key: id of onenotePage
 @param onenoteSectionId key: id of onenoteSection
 @return ApiGroupsGroupOnenotePagesOnenotePageParentSectionParentSectionGroupParentNotebookSectionsOnenoteSectionCopyToSectionGroupRequest
*/
func (a *GroupsActionsApiService) GroupsGroupOnenotePagesOnenotePageParentSectionParentSectionGroupParentNotebookSectionsOnenoteSectionCopyToSectionGroup(ctx _context.Context, groupId string, onenotePageId string, onenoteSectionId string) ApiGroupsGroupOnenotePagesOnenotePageParentSectionParentSectionGroupParentNotebookSectionsOnenoteSectionCopyToSectionGroupRequest {
	return ApiGroupsGroupOnenotePagesOnenotePageParentSectionParentSectionGroupParentNotebookSectionsOnenoteSectionCopyToSectionGroupRequest{
		ApiService: a,
		ctx: ctx,
		groupId: groupId,
		onenotePageId: onenotePageId,
		onenoteSectionId: onenoteSectionId,
	}
}

// Execute executes the request
//  @return AnyOfmicrosoftGraphOnenoteOperation
func (a *GroupsActionsApiService) GroupsGroupOnenotePagesOnenotePageParentSectionParentSectionGroupParentNotebookSectionsOnenoteSectionCopyToSectionGroupExecute(r ApiGroupsGroupOnenotePagesOnenotePageParentSectionParentSectionGroupParentNotebookSectionsOnenoteSectionCopyToSectionGroupRequest) (AnyOfmicrosoftGraphOnenoteOperation, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  AnyOfmicrosoftGraphOnenoteOperation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GroupsActionsApiService.GroupsGroupOnenotePagesOnenotePageParentSectionParentSectionGroupParentNotebookSectionsOnenoteSectionCopyToSectionGroup")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/groups/{group-id}/onenote/pages/{onenotePage-id}/parentSection/parentSectionGroup/parentNotebook/sections/{onenoteSection-id}/microsoft.graph.copyToSectionGroup"
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"onenotePage-id"+"}", _neturl.PathEscape(parameterToString(r.onenotePageId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"onenoteSection-id"+"}", _neturl.PathEscape(parameterToString(r.onenoteSectionId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject293 == nil {
		return localVarReturnValue, nil, reportError("inlineObject293 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject293
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGroupsGroupOnenotePagesOnenotePageParentSectionParentSectionGroupSectionsOnenoteSectionCopyToNotebookRequest struct {
	ctx _context.Context
	ApiService *GroupsActionsApiService
	groupId string
	onenotePageId string
	onenoteSectionId string
	inlineObject294 *InlineObject294
}

func (r ApiGroupsGroupOnenotePagesOnenotePageParentSectionParentSectionGroupSectionsOnenoteSectionCopyToNotebookRequest) InlineObject294(inlineObject294 InlineObject294) ApiGroupsGroupOnenotePagesOnenotePageParentSectionParentSectionGroupSectionsOnenoteSectionCopyToNotebookRequest {
	r.inlineObject294 = &inlineObject294
	return r
}

func (r ApiGroupsGroupOnenotePagesOnenotePageParentSectionParentSectionGroupSectionsOnenoteSectionCopyToNotebookRequest) Execute() (AnyOfmicrosoftGraphOnenoteOperation, *_nethttp.Response, error) {
	return r.ApiService.GroupsGroupOnenotePagesOnenotePageParentSectionParentSectionGroupSectionsOnenoteSectionCopyToNotebookExecute(r)
}

/*
GroupsGroupOnenotePagesOnenotePageParentSectionParentSectionGroupSectionsOnenoteSectionCopyToNotebook Invoke action copyToNotebook

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupId key: id of group
 @param onenotePageId key: id of onenotePage
 @param onenoteSectionId key: id of onenoteSection
 @return ApiGroupsGroupOnenotePagesOnenotePageParentSectionParentSectionGroupSectionsOnenoteSectionCopyToNotebookRequest
*/
func (a *GroupsActionsApiService) GroupsGroupOnenotePagesOnenotePageParentSectionParentSectionGroupSectionsOnenoteSectionCopyToNotebook(ctx _context.Context, groupId string, onenotePageId string, onenoteSectionId string) ApiGroupsGroupOnenotePagesOnenotePageParentSectionParentSectionGroupSectionsOnenoteSectionCopyToNotebookRequest {
	return ApiGroupsGroupOnenotePagesOnenotePageParentSectionParentSectionGroupSectionsOnenoteSectionCopyToNotebookRequest{
		ApiService: a,
		ctx: ctx,
		groupId: groupId,
		onenotePageId: onenotePageId,
		onenoteSectionId: onenoteSectionId,
	}
}

// Execute executes the request
//  @return AnyOfmicrosoftGraphOnenoteOperation
func (a *GroupsActionsApiService) GroupsGroupOnenotePagesOnenotePageParentSectionParentSectionGroupSectionsOnenoteSectionCopyToNotebookExecute(r ApiGroupsGroupOnenotePagesOnenotePageParentSectionParentSectionGroupSectionsOnenoteSectionCopyToNotebookRequest) (AnyOfmicrosoftGraphOnenoteOperation, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  AnyOfmicrosoftGraphOnenoteOperation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GroupsActionsApiService.GroupsGroupOnenotePagesOnenotePageParentSectionParentSectionGroupSectionsOnenoteSectionCopyToNotebook")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/groups/{group-id}/onenote/pages/{onenotePage-id}/parentSection/parentSectionGroup/sections/{onenoteSection-id}/microsoft.graph.copyToNotebook"
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"onenotePage-id"+"}", _neturl.PathEscape(parameterToString(r.onenotePageId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"onenoteSection-id"+"}", _neturl.PathEscape(parameterToString(r.onenoteSectionId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject294 == nil {
		return localVarReturnValue, nil, reportError("inlineObject294 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject294
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGroupsGroupOnenotePagesOnenotePageParentSectionParentSectionGroupSectionsOnenoteSectionCopyToSectionGroupRequest struct {
	ctx _context.Context
	ApiService *GroupsActionsApiService
	groupId string
	onenotePageId string
	onenoteSectionId string
	inlineObject295 *InlineObject295
}

func (r ApiGroupsGroupOnenotePagesOnenotePageParentSectionParentSectionGroupSectionsOnenoteSectionCopyToSectionGroupRequest) InlineObject295(inlineObject295 InlineObject295) ApiGroupsGroupOnenotePagesOnenotePageParentSectionParentSectionGroupSectionsOnenoteSectionCopyToSectionGroupRequest {
	r.inlineObject295 = &inlineObject295
	return r
}

func (r ApiGroupsGroupOnenotePagesOnenotePageParentSectionParentSectionGroupSectionsOnenoteSectionCopyToSectionGroupRequest) Execute() (AnyOfmicrosoftGraphOnenoteOperation, *_nethttp.Response, error) {
	return r.ApiService.GroupsGroupOnenotePagesOnenotePageParentSectionParentSectionGroupSectionsOnenoteSectionCopyToSectionGroupExecute(r)
}

/*
GroupsGroupOnenotePagesOnenotePageParentSectionParentSectionGroupSectionsOnenoteSectionCopyToSectionGroup Invoke action copyToSectionGroup

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupId key: id of group
 @param onenotePageId key: id of onenotePage
 @param onenoteSectionId key: id of onenoteSection
 @return ApiGroupsGroupOnenotePagesOnenotePageParentSectionParentSectionGroupSectionsOnenoteSectionCopyToSectionGroupRequest
*/
func (a *GroupsActionsApiService) GroupsGroupOnenotePagesOnenotePageParentSectionParentSectionGroupSectionsOnenoteSectionCopyToSectionGroup(ctx _context.Context, groupId string, onenotePageId string, onenoteSectionId string) ApiGroupsGroupOnenotePagesOnenotePageParentSectionParentSectionGroupSectionsOnenoteSectionCopyToSectionGroupRequest {
	return ApiGroupsGroupOnenotePagesOnenotePageParentSectionParentSectionGroupSectionsOnenoteSectionCopyToSectionGroupRequest{
		ApiService: a,
		ctx: ctx,
		groupId: groupId,
		onenotePageId: onenotePageId,
		onenoteSectionId: onenoteSectionId,
	}
}

// Execute executes the request
//  @return AnyOfmicrosoftGraphOnenoteOperation
func (a *GroupsActionsApiService) GroupsGroupOnenotePagesOnenotePageParentSectionParentSectionGroupSectionsOnenoteSectionCopyToSectionGroupExecute(r ApiGroupsGroupOnenotePagesOnenotePageParentSectionParentSectionGroupSectionsOnenoteSectionCopyToSectionGroupRequest) (AnyOfmicrosoftGraphOnenoteOperation, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  AnyOfmicrosoftGraphOnenoteOperation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GroupsActionsApiService.GroupsGroupOnenotePagesOnenotePageParentSectionParentSectionGroupSectionsOnenoteSectionCopyToSectionGroup")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/groups/{group-id}/onenote/pages/{onenotePage-id}/parentSection/parentSectionGroup/sections/{onenoteSection-id}/microsoft.graph.copyToSectionGroup"
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"onenotePage-id"+"}", _neturl.PathEscape(parameterToString(r.onenotePageId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"onenoteSection-id"+"}", _neturl.PathEscape(parameterToString(r.onenoteSectionId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject295 == nil {
		return localVarReturnValue, nil, reportError("inlineObject295 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject295
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGroupsGroupOnenoteSectionGroupsSectionGroupParentNotebookCopyNotebookRequest struct {
	ctx _context.Context
	ApiService *GroupsActionsApiService
	groupId string
	sectionGroupId string
	inlineObject296 *InlineObject296
}

func (r ApiGroupsGroupOnenoteSectionGroupsSectionGroupParentNotebookCopyNotebookRequest) InlineObject296(inlineObject296 InlineObject296) ApiGroupsGroupOnenoteSectionGroupsSectionGroupParentNotebookCopyNotebookRequest {
	r.inlineObject296 = &inlineObject296
	return r
}

func (r ApiGroupsGroupOnenoteSectionGroupsSectionGroupParentNotebookCopyNotebookRequest) Execute() (AnyOfmicrosoftGraphOnenoteOperation, *_nethttp.Response, error) {
	return r.ApiService.GroupsGroupOnenoteSectionGroupsSectionGroupParentNotebookCopyNotebookExecute(r)
}

/*
GroupsGroupOnenoteSectionGroupsSectionGroupParentNotebookCopyNotebook Invoke action copyNotebook

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupId key: id of group
 @param sectionGroupId key: id of sectionGroup
 @return ApiGroupsGroupOnenoteSectionGroupsSectionGroupParentNotebookCopyNotebookRequest
*/
func (a *GroupsActionsApiService) GroupsGroupOnenoteSectionGroupsSectionGroupParentNotebookCopyNotebook(ctx _context.Context, groupId string, sectionGroupId string) ApiGroupsGroupOnenoteSectionGroupsSectionGroupParentNotebookCopyNotebookRequest {
	return ApiGroupsGroupOnenoteSectionGroupsSectionGroupParentNotebookCopyNotebookRequest{
		ApiService: a,
		ctx: ctx,
		groupId: groupId,
		sectionGroupId: sectionGroupId,
	}
}

// Execute executes the request
//  @return AnyOfmicrosoftGraphOnenoteOperation
func (a *GroupsActionsApiService) GroupsGroupOnenoteSectionGroupsSectionGroupParentNotebookCopyNotebookExecute(r ApiGroupsGroupOnenoteSectionGroupsSectionGroupParentNotebookCopyNotebookRequest) (AnyOfmicrosoftGraphOnenoteOperation, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  AnyOfmicrosoftGraphOnenoteOperation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GroupsActionsApiService.GroupsGroupOnenoteSectionGroupsSectionGroupParentNotebookCopyNotebook")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/groups/{group-id}/onenote/sectionGroups/{sectionGroup-id}/parentNotebook/microsoft.graph.copyNotebook"
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"sectionGroup-id"+"}", _neturl.PathEscape(parameterToString(r.sectionGroupId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject296 == nil {
		return localVarReturnValue, nil, reportError("inlineObject296 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject296
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGroupsGroupOnenoteSectionGroupsSectionGroupParentNotebookSectionsOnenoteSectionCopyToNotebookRequest struct {
	ctx _context.Context
	ApiService *GroupsActionsApiService
	groupId string
	sectionGroupId string
	onenoteSectionId string
	inlineObject297 *InlineObject297
}

func (r ApiGroupsGroupOnenoteSectionGroupsSectionGroupParentNotebookSectionsOnenoteSectionCopyToNotebookRequest) InlineObject297(inlineObject297 InlineObject297) ApiGroupsGroupOnenoteSectionGroupsSectionGroupParentNotebookSectionsOnenoteSectionCopyToNotebookRequest {
	r.inlineObject297 = &inlineObject297
	return r
}

func (r ApiGroupsGroupOnenoteSectionGroupsSectionGroupParentNotebookSectionsOnenoteSectionCopyToNotebookRequest) Execute() (AnyOfmicrosoftGraphOnenoteOperation, *_nethttp.Response, error) {
	return r.ApiService.GroupsGroupOnenoteSectionGroupsSectionGroupParentNotebookSectionsOnenoteSectionCopyToNotebookExecute(r)
}

/*
GroupsGroupOnenoteSectionGroupsSectionGroupParentNotebookSectionsOnenoteSectionCopyToNotebook Invoke action copyToNotebook

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupId key: id of group
 @param sectionGroupId key: id of sectionGroup
 @param onenoteSectionId key: id of onenoteSection
 @return ApiGroupsGroupOnenoteSectionGroupsSectionGroupParentNotebookSectionsOnenoteSectionCopyToNotebookRequest
*/
func (a *GroupsActionsApiService) GroupsGroupOnenoteSectionGroupsSectionGroupParentNotebookSectionsOnenoteSectionCopyToNotebook(ctx _context.Context, groupId string, sectionGroupId string, onenoteSectionId string) ApiGroupsGroupOnenoteSectionGroupsSectionGroupParentNotebookSectionsOnenoteSectionCopyToNotebookRequest {
	return ApiGroupsGroupOnenoteSectionGroupsSectionGroupParentNotebookSectionsOnenoteSectionCopyToNotebookRequest{
		ApiService: a,
		ctx: ctx,
		groupId: groupId,
		sectionGroupId: sectionGroupId,
		onenoteSectionId: onenoteSectionId,
	}
}

// Execute executes the request
//  @return AnyOfmicrosoftGraphOnenoteOperation
func (a *GroupsActionsApiService) GroupsGroupOnenoteSectionGroupsSectionGroupParentNotebookSectionsOnenoteSectionCopyToNotebookExecute(r ApiGroupsGroupOnenoteSectionGroupsSectionGroupParentNotebookSectionsOnenoteSectionCopyToNotebookRequest) (AnyOfmicrosoftGraphOnenoteOperation, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  AnyOfmicrosoftGraphOnenoteOperation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GroupsActionsApiService.GroupsGroupOnenoteSectionGroupsSectionGroupParentNotebookSectionsOnenoteSectionCopyToNotebook")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/groups/{group-id}/onenote/sectionGroups/{sectionGroup-id}/parentNotebook/sections/{onenoteSection-id}/microsoft.graph.copyToNotebook"
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"sectionGroup-id"+"}", _neturl.PathEscape(parameterToString(r.sectionGroupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"onenoteSection-id"+"}", _neturl.PathEscape(parameterToString(r.onenoteSectionId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject297 == nil {
		return localVarReturnValue, nil, reportError("inlineObject297 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject297
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGroupsGroupOnenoteSectionGroupsSectionGroupParentNotebookSectionsOnenoteSectionCopyToSectionGroupRequest struct {
	ctx _context.Context
	ApiService *GroupsActionsApiService
	groupId string
	sectionGroupId string
	onenoteSectionId string
	inlineObject298 *InlineObject298
}

func (r ApiGroupsGroupOnenoteSectionGroupsSectionGroupParentNotebookSectionsOnenoteSectionCopyToSectionGroupRequest) InlineObject298(inlineObject298 InlineObject298) ApiGroupsGroupOnenoteSectionGroupsSectionGroupParentNotebookSectionsOnenoteSectionCopyToSectionGroupRequest {
	r.inlineObject298 = &inlineObject298
	return r
}

func (r ApiGroupsGroupOnenoteSectionGroupsSectionGroupParentNotebookSectionsOnenoteSectionCopyToSectionGroupRequest) Execute() (AnyOfmicrosoftGraphOnenoteOperation, *_nethttp.Response, error) {
	return r.ApiService.GroupsGroupOnenoteSectionGroupsSectionGroupParentNotebookSectionsOnenoteSectionCopyToSectionGroupExecute(r)
}

/*
GroupsGroupOnenoteSectionGroupsSectionGroupParentNotebookSectionsOnenoteSectionCopyToSectionGroup Invoke action copyToSectionGroup

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupId key: id of group
 @param sectionGroupId key: id of sectionGroup
 @param onenoteSectionId key: id of onenoteSection
 @return ApiGroupsGroupOnenoteSectionGroupsSectionGroupParentNotebookSectionsOnenoteSectionCopyToSectionGroupRequest
*/
func (a *GroupsActionsApiService) GroupsGroupOnenoteSectionGroupsSectionGroupParentNotebookSectionsOnenoteSectionCopyToSectionGroup(ctx _context.Context, groupId string, sectionGroupId string, onenoteSectionId string) ApiGroupsGroupOnenoteSectionGroupsSectionGroupParentNotebookSectionsOnenoteSectionCopyToSectionGroupRequest {
	return ApiGroupsGroupOnenoteSectionGroupsSectionGroupParentNotebookSectionsOnenoteSectionCopyToSectionGroupRequest{
		ApiService: a,
		ctx: ctx,
		groupId: groupId,
		sectionGroupId: sectionGroupId,
		onenoteSectionId: onenoteSectionId,
	}
}

// Execute executes the request
//  @return AnyOfmicrosoftGraphOnenoteOperation
func (a *GroupsActionsApiService) GroupsGroupOnenoteSectionGroupsSectionGroupParentNotebookSectionsOnenoteSectionCopyToSectionGroupExecute(r ApiGroupsGroupOnenoteSectionGroupsSectionGroupParentNotebookSectionsOnenoteSectionCopyToSectionGroupRequest) (AnyOfmicrosoftGraphOnenoteOperation, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  AnyOfmicrosoftGraphOnenoteOperation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GroupsActionsApiService.GroupsGroupOnenoteSectionGroupsSectionGroupParentNotebookSectionsOnenoteSectionCopyToSectionGroup")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/groups/{group-id}/onenote/sectionGroups/{sectionGroup-id}/parentNotebook/sections/{onenoteSection-id}/microsoft.graph.copyToSectionGroup"
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"sectionGroup-id"+"}", _neturl.PathEscape(parameterToString(r.sectionGroupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"onenoteSection-id"+"}", _neturl.PathEscape(parameterToString(r.onenoteSectionId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject298 == nil {
		return localVarReturnValue, nil, reportError("inlineObject298 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject298
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGroupsGroupOnenoteSectionGroupsSectionGroupParentNotebookSectionsOnenoteSectionPagesOnenotePageCopyToSectionRequest struct {
	ctx _context.Context
	ApiService *GroupsActionsApiService
	groupId string
	sectionGroupId string
	onenoteSectionId string
	onenotePageId string
	inlineObject299 *InlineObject299
}

func (r ApiGroupsGroupOnenoteSectionGroupsSectionGroupParentNotebookSectionsOnenoteSectionPagesOnenotePageCopyToSectionRequest) InlineObject299(inlineObject299 InlineObject299) ApiGroupsGroupOnenoteSectionGroupsSectionGroupParentNotebookSectionsOnenoteSectionPagesOnenotePageCopyToSectionRequest {
	r.inlineObject299 = &inlineObject299
	return r
}

func (r ApiGroupsGroupOnenoteSectionGroupsSectionGroupParentNotebookSectionsOnenoteSectionPagesOnenotePageCopyToSectionRequest) Execute() (AnyOfmicrosoftGraphOnenoteOperation, *_nethttp.Response, error) {
	return r.ApiService.GroupsGroupOnenoteSectionGroupsSectionGroupParentNotebookSectionsOnenoteSectionPagesOnenotePageCopyToSectionExecute(r)
}

/*
GroupsGroupOnenoteSectionGroupsSectionGroupParentNotebookSectionsOnenoteSectionPagesOnenotePageCopyToSection Invoke action copyToSection

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupId key: id of group
 @param sectionGroupId key: id of sectionGroup
 @param onenoteSectionId key: id of onenoteSection
 @param onenotePageId key: id of onenotePage
 @return ApiGroupsGroupOnenoteSectionGroupsSectionGroupParentNotebookSectionsOnenoteSectionPagesOnenotePageCopyToSectionRequest
*/
func (a *GroupsActionsApiService) GroupsGroupOnenoteSectionGroupsSectionGroupParentNotebookSectionsOnenoteSectionPagesOnenotePageCopyToSection(ctx _context.Context, groupId string, sectionGroupId string, onenoteSectionId string, onenotePageId string) ApiGroupsGroupOnenoteSectionGroupsSectionGroupParentNotebookSectionsOnenoteSectionPagesOnenotePageCopyToSectionRequest {
	return ApiGroupsGroupOnenoteSectionGroupsSectionGroupParentNotebookSectionsOnenoteSectionPagesOnenotePageCopyToSectionRequest{
		ApiService: a,
		ctx: ctx,
		groupId: groupId,
		sectionGroupId: sectionGroupId,
		onenoteSectionId: onenoteSectionId,
		onenotePageId: onenotePageId,
	}
}

// Execute executes the request
//  @return AnyOfmicrosoftGraphOnenoteOperation
func (a *GroupsActionsApiService) GroupsGroupOnenoteSectionGroupsSectionGroupParentNotebookSectionsOnenoteSectionPagesOnenotePageCopyToSectionExecute(r ApiGroupsGroupOnenoteSectionGroupsSectionGroupParentNotebookSectionsOnenoteSectionPagesOnenotePageCopyToSectionRequest) (AnyOfmicrosoftGraphOnenoteOperation, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  AnyOfmicrosoftGraphOnenoteOperation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GroupsActionsApiService.GroupsGroupOnenoteSectionGroupsSectionGroupParentNotebookSectionsOnenoteSectionPagesOnenotePageCopyToSection")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/groups/{group-id}/onenote/sectionGroups/{sectionGroup-id}/parentNotebook/sections/{onenoteSection-id}/pages/{onenotePage-id}/microsoft.graph.copyToSection"
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"sectionGroup-id"+"}", _neturl.PathEscape(parameterToString(r.sectionGroupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"onenoteSection-id"+"}", _neturl.PathEscape(parameterToString(r.onenoteSectionId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"onenotePage-id"+"}", _neturl.PathEscape(parameterToString(r.onenotePageId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject299 == nil {
		return localVarReturnValue, nil, reportError("inlineObject299 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject299
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGroupsGroupOnenoteSectionGroupsSectionGroupParentNotebookSectionsOnenoteSectionPagesOnenotePageOnenotePatchContentRequest struct {
	ctx _context.Context
	ApiService *GroupsActionsApiService
	groupId string
	sectionGroupId string
	onenoteSectionId string
	onenotePageId string
	inlineObject300 *InlineObject300
}

func (r ApiGroupsGroupOnenoteSectionGroupsSectionGroupParentNotebookSectionsOnenoteSectionPagesOnenotePageOnenotePatchContentRequest) InlineObject300(inlineObject300 InlineObject300) ApiGroupsGroupOnenoteSectionGroupsSectionGroupParentNotebookSectionsOnenoteSectionPagesOnenotePageOnenotePatchContentRequest {
	r.inlineObject300 = &inlineObject300
	return r
}

func (r ApiGroupsGroupOnenoteSectionGroupsSectionGroupParentNotebookSectionsOnenoteSectionPagesOnenotePageOnenotePatchContentRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.GroupsGroupOnenoteSectionGroupsSectionGroupParentNotebookSectionsOnenoteSectionPagesOnenotePageOnenotePatchContentExecute(r)
}

/*
GroupsGroupOnenoteSectionGroupsSectionGroupParentNotebookSectionsOnenoteSectionPagesOnenotePageOnenotePatchContent Invoke action onenotePatchContent

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupId key: id of group
 @param sectionGroupId key: id of sectionGroup
 @param onenoteSectionId key: id of onenoteSection
 @param onenotePageId key: id of onenotePage
 @return ApiGroupsGroupOnenoteSectionGroupsSectionGroupParentNotebookSectionsOnenoteSectionPagesOnenotePageOnenotePatchContentRequest
*/
func (a *GroupsActionsApiService) GroupsGroupOnenoteSectionGroupsSectionGroupParentNotebookSectionsOnenoteSectionPagesOnenotePageOnenotePatchContent(ctx _context.Context, groupId string, sectionGroupId string, onenoteSectionId string, onenotePageId string) ApiGroupsGroupOnenoteSectionGroupsSectionGroupParentNotebookSectionsOnenoteSectionPagesOnenotePageOnenotePatchContentRequest {
	return ApiGroupsGroupOnenoteSectionGroupsSectionGroupParentNotebookSectionsOnenoteSectionPagesOnenotePageOnenotePatchContentRequest{
		ApiService: a,
		ctx: ctx,
		groupId: groupId,
		sectionGroupId: sectionGroupId,
		onenoteSectionId: onenoteSectionId,
		onenotePageId: onenotePageId,
	}
}

// Execute executes the request
func (a *GroupsActionsApiService) GroupsGroupOnenoteSectionGroupsSectionGroupParentNotebookSectionsOnenoteSectionPagesOnenotePageOnenotePatchContentExecute(r ApiGroupsGroupOnenoteSectionGroupsSectionGroupParentNotebookSectionsOnenoteSectionPagesOnenotePageOnenotePatchContentRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GroupsActionsApiService.GroupsGroupOnenoteSectionGroupsSectionGroupParentNotebookSectionsOnenoteSectionPagesOnenotePageOnenotePatchContent")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/groups/{group-id}/onenote/sectionGroups/{sectionGroup-id}/parentNotebook/sections/{onenoteSection-id}/pages/{onenotePage-id}/microsoft.graph.onenotePatchContent"
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"sectionGroup-id"+"}", _neturl.PathEscape(parameterToString(r.sectionGroupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"onenoteSection-id"+"}", _neturl.PathEscape(parameterToString(r.onenoteSectionId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"onenotePage-id"+"}", _neturl.PathEscape(parameterToString(r.onenotePageId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject300 == nil {
		return nil, reportError("inlineObject300 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject300
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGroupsGroupOnenoteSectionGroupsSectionGroupParentNotebookSectionsOnenoteSectionPagesOnenotePageParentNotebookCopyNotebookRequest struct {
	ctx _context.Context
	ApiService *GroupsActionsApiService
	groupId string
	sectionGroupId string
	onenoteSectionId string
	onenotePageId string
	inlineObject301 *InlineObject301
}

func (r ApiGroupsGroupOnenoteSectionGroupsSectionGroupParentNotebookSectionsOnenoteSectionPagesOnenotePageParentNotebookCopyNotebookRequest) InlineObject301(inlineObject301 InlineObject301) ApiGroupsGroupOnenoteSectionGroupsSectionGroupParentNotebookSectionsOnenoteSectionPagesOnenotePageParentNotebookCopyNotebookRequest {
	r.inlineObject301 = &inlineObject301
	return r
}

func (r ApiGroupsGroupOnenoteSectionGroupsSectionGroupParentNotebookSectionsOnenoteSectionPagesOnenotePageParentNotebookCopyNotebookRequest) Execute() (AnyOfmicrosoftGraphOnenoteOperation, *_nethttp.Response, error) {
	return r.ApiService.GroupsGroupOnenoteSectionGroupsSectionGroupParentNotebookSectionsOnenoteSectionPagesOnenotePageParentNotebookCopyNotebookExecute(r)
}

/*
GroupsGroupOnenoteSectionGroupsSectionGroupParentNotebookSectionsOnenoteSectionPagesOnenotePageParentNotebookCopyNotebook Invoke action copyNotebook

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupId key: id of group
 @param sectionGroupId key: id of sectionGroup
 @param onenoteSectionId key: id of onenoteSection
 @param onenotePageId key: id of onenotePage
 @return ApiGroupsGroupOnenoteSectionGroupsSectionGroupParentNotebookSectionsOnenoteSectionPagesOnenotePageParentNotebookCopyNotebookRequest
*/
func (a *GroupsActionsApiService) GroupsGroupOnenoteSectionGroupsSectionGroupParentNotebookSectionsOnenoteSectionPagesOnenotePageParentNotebookCopyNotebook(ctx _context.Context, groupId string, sectionGroupId string, onenoteSectionId string, onenotePageId string) ApiGroupsGroupOnenoteSectionGroupsSectionGroupParentNotebookSectionsOnenoteSectionPagesOnenotePageParentNotebookCopyNotebookRequest {
	return ApiGroupsGroupOnenoteSectionGroupsSectionGroupParentNotebookSectionsOnenoteSectionPagesOnenotePageParentNotebookCopyNotebookRequest{
		ApiService: a,
		ctx: ctx,
		groupId: groupId,
		sectionGroupId: sectionGroupId,
		onenoteSectionId: onenoteSectionId,
		onenotePageId: onenotePageId,
	}
}

// Execute executes the request
//  @return AnyOfmicrosoftGraphOnenoteOperation
func (a *GroupsActionsApiService) GroupsGroupOnenoteSectionGroupsSectionGroupParentNotebookSectionsOnenoteSectionPagesOnenotePageParentNotebookCopyNotebookExecute(r ApiGroupsGroupOnenoteSectionGroupsSectionGroupParentNotebookSectionsOnenoteSectionPagesOnenotePageParentNotebookCopyNotebookRequest) (AnyOfmicrosoftGraphOnenoteOperation, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  AnyOfmicrosoftGraphOnenoteOperation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GroupsActionsApiService.GroupsGroupOnenoteSectionGroupsSectionGroupParentNotebookSectionsOnenoteSectionPagesOnenotePageParentNotebookCopyNotebook")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/groups/{group-id}/onenote/sectionGroups/{sectionGroup-id}/parentNotebook/sections/{onenoteSection-id}/pages/{onenotePage-id}/parentNotebook/microsoft.graph.copyNotebook"
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"sectionGroup-id"+"}", _neturl.PathEscape(parameterToString(r.sectionGroupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"onenoteSection-id"+"}", _neturl.PathEscape(parameterToString(r.onenoteSectionId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"onenotePage-id"+"}", _neturl.PathEscape(parameterToString(r.onenotePageId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject301 == nil {
		return localVarReturnValue, nil, reportError("inlineObject301 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject301
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGroupsGroupOnenoteSectionGroupsSectionGroupParentNotebookSectionsOnenoteSectionPagesOnenotePageParentSectionCopyToNotebookRequest struct {
	ctx _context.Context
	ApiService *GroupsActionsApiService
	groupId string
	sectionGroupId string
	onenoteSectionId string
	onenotePageId string
	inlineObject302 *InlineObject302
}

func (r ApiGroupsGroupOnenoteSectionGroupsSectionGroupParentNotebookSectionsOnenoteSectionPagesOnenotePageParentSectionCopyToNotebookRequest) InlineObject302(inlineObject302 InlineObject302) ApiGroupsGroupOnenoteSectionGroupsSectionGroupParentNotebookSectionsOnenoteSectionPagesOnenotePageParentSectionCopyToNotebookRequest {
	r.inlineObject302 = &inlineObject302
	return r
}

func (r ApiGroupsGroupOnenoteSectionGroupsSectionGroupParentNotebookSectionsOnenoteSectionPagesOnenotePageParentSectionCopyToNotebookRequest) Execute() (AnyOfmicrosoftGraphOnenoteOperation, *_nethttp.Response, error) {
	return r.ApiService.GroupsGroupOnenoteSectionGroupsSectionGroupParentNotebookSectionsOnenoteSectionPagesOnenotePageParentSectionCopyToNotebookExecute(r)
}

/*
GroupsGroupOnenoteSectionGroupsSectionGroupParentNotebookSectionsOnenoteSectionPagesOnenotePageParentSectionCopyToNotebook Invoke action copyToNotebook

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupId key: id of group
 @param sectionGroupId key: id of sectionGroup
 @param onenoteSectionId key: id of onenoteSection
 @param onenotePageId key: id of onenotePage
 @return ApiGroupsGroupOnenoteSectionGroupsSectionGroupParentNotebookSectionsOnenoteSectionPagesOnenotePageParentSectionCopyToNotebookRequest
*/
func (a *GroupsActionsApiService) GroupsGroupOnenoteSectionGroupsSectionGroupParentNotebookSectionsOnenoteSectionPagesOnenotePageParentSectionCopyToNotebook(ctx _context.Context, groupId string, sectionGroupId string, onenoteSectionId string, onenotePageId string) ApiGroupsGroupOnenoteSectionGroupsSectionGroupParentNotebookSectionsOnenoteSectionPagesOnenotePageParentSectionCopyToNotebookRequest {
	return ApiGroupsGroupOnenoteSectionGroupsSectionGroupParentNotebookSectionsOnenoteSectionPagesOnenotePageParentSectionCopyToNotebookRequest{
		ApiService: a,
		ctx: ctx,
		groupId: groupId,
		sectionGroupId: sectionGroupId,
		onenoteSectionId: onenoteSectionId,
		onenotePageId: onenotePageId,
	}
}

// Execute executes the request
//  @return AnyOfmicrosoftGraphOnenoteOperation
func (a *GroupsActionsApiService) GroupsGroupOnenoteSectionGroupsSectionGroupParentNotebookSectionsOnenoteSectionPagesOnenotePageParentSectionCopyToNotebookExecute(r ApiGroupsGroupOnenoteSectionGroupsSectionGroupParentNotebookSectionsOnenoteSectionPagesOnenotePageParentSectionCopyToNotebookRequest) (AnyOfmicrosoftGraphOnenoteOperation, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  AnyOfmicrosoftGraphOnenoteOperation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GroupsActionsApiService.GroupsGroupOnenoteSectionGroupsSectionGroupParentNotebookSectionsOnenoteSectionPagesOnenotePageParentSectionCopyToNotebook")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/groups/{group-id}/onenote/sectionGroups/{sectionGroup-id}/parentNotebook/sections/{onenoteSection-id}/pages/{onenotePage-id}/parentSection/microsoft.graph.copyToNotebook"
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"sectionGroup-id"+"}", _neturl.PathEscape(parameterToString(r.sectionGroupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"onenoteSection-id"+"}", _neturl.PathEscape(parameterToString(r.onenoteSectionId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"onenotePage-id"+"}", _neturl.PathEscape(parameterToString(r.onenotePageId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject302 == nil {
		return localVarReturnValue, nil, reportError("inlineObject302 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject302
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGroupsGroupOnenoteSectionGroupsSectionGroupParentNotebookSectionsOnenoteSectionPagesOnenotePageParentSectionCopyToSectionGroupRequest struct {
	ctx _context.Context
	ApiService *GroupsActionsApiService
	groupId string
	sectionGroupId string
	onenoteSectionId string
	onenotePageId string
	inlineObject303 *InlineObject303
}

func (r ApiGroupsGroupOnenoteSectionGroupsSectionGroupParentNotebookSectionsOnenoteSectionPagesOnenotePageParentSectionCopyToSectionGroupRequest) InlineObject303(inlineObject303 InlineObject303) ApiGroupsGroupOnenoteSectionGroupsSectionGroupParentNotebookSectionsOnenoteSectionPagesOnenotePageParentSectionCopyToSectionGroupRequest {
	r.inlineObject303 = &inlineObject303
	return r
}

func (r ApiGroupsGroupOnenoteSectionGroupsSectionGroupParentNotebookSectionsOnenoteSectionPagesOnenotePageParentSectionCopyToSectionGroupRequest) Execute() (AnyOfmicrosoftGraphOnenoteOperation, *_nethttp.Response, error) {
	return r.ApiService.GroupsGroupOnenoteSectionGroupsSectionGroupParentNotebookSectionsOnenoteSectionPagesOnenotePageParentSectionCopyToSectionGroupExecute(r)
}

/*
GroupsGroupOnenoteSectionGroupsSectionGroupParentNotebookSectionsOnenoteSectionPagesOnenotePageParentSectionCopyToSectionGroup Invoke action copyToSectionGroup

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupId key: id of group
 @param sectionGroupId key: id of sectionGroup
 @param onenoteSectionId key: id of onenoteSection
 @param onenotePageId key: id of onenotePage
 @return ApiGroupsGroupOnenoteSectionGroupsSectionGroupParentNotebookSectionsOnenoteSectionPagesOnenotePageParentSectionCopyToSectionGroupRequest
*/
func (a *GroupsActionsApiService) GroupsGroupOnenoteSectionGroupsSectionGroupParentNotebookSectionsOnenoteSectionPagesOnenotePageParentSectionCopyToSectionGroup(ctx _context.Context, groupId string, sectionGroupId string, onenoteSectionId string, onenotePageId string) ApiGroupsGroupOnenoteSectionGroupsSectionGroupParentNotebookSectionsOnenoteSectionPagesOnenotePageParentSectionCopyToSectionGroupRequest {
	return ApiGroupsGroupOnenoteSectionGroupsSectionGroupParentNotebookSectionsOnenoteSectionPagesOnenotePageParentSectionCopyToSectionGroupRequest{
		ApiService: a,
		ctx: ctx,
		groupId: groupId,
		sectionGroupId: sectionGroupId,
		onenoteSectionId: onenoteSectionId,
		onenotePageId: onenotePageId,
	}
}

// Execute executes the request
//  @return AnyOfmicrosoftGraphOnenoteOperation
func (a *GroupsActionsApiService) GroupsGroupOnenoteSectionGroupsSectionGroupParentNotebookSectionsOnenoteSectionPagesOnenotePageParentSectionCopyToSectionGroupExecute(r ApiGroupsGroupOnenoteSectionGroupsSectionGroupParentNotebookSectionsOnenoteSectionPagesOnenotePageParentSectionCopyToSectionGroupRequest) (AnyOfmicrosoftGraphOnenoteOperation, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  AnyOfmicrosoftGraphOnenoteOperation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GroupsActionsApiService.GroupsGroupOnenoteSectionGroupsSectionGroupParentNotebookSectionsOnenoteSectionPagesOnenotePageParentSectionCopyToSectionGroup")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/groups/{group-id}/onenote/sectionGroups/{sectionGroup-id}/parentNotebook/sections/{onenoteSection-id}/pages/{onenotePage-id}/parentSection/microsoft.graph.copyToSectionGroup"
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"sectionGroup-id"+"}", _neturl.PathEscape(parameterToString(r.sectionGroupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"onenoteSection-id"+"}", _neturl.PathEscape(parameterToString(r.onenoteSectionId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"onenotePage-id"+"}", _neturl.PathEscape(parameterToString(r.onenotePageId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject303 == nil {
		return localVarReturnValue, nil, reportError("inlineObject303 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject303
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGroupsGroupOnenoteSectionGroupsSectionGroupParentNotebookSectionsOnenoteSectionParentNotebookCopyNotebookRequest struct {
	ctx _context.Context
	ApiService *GroupsActionsApiService
	groupId string
	sectionGroupId string
	onenoteSectionId string
	inlineObject304 *InlineObject304
}

func (r ApiGroupsGroupOnenoteSectionGroupsSectionGroupParentNotebookSectionsOnenoteSectionParentNotebookCopyNotebookRequest) InlineObject304(inlineObject304 InlineObject304) ApiGroupsGroupOnenoteSectionGroupsSectionGroupParentNotebookSectionsOnenoteSectionParentNotebookCopyNotebookRequest {
	r.inlineObject304 = &inlineObject304
	return r
}

func (r ApiGroupsGroupOnenoteSectionGroupsSectionGroupParentNotebookSectionsOnenoteSectionParentNotebookCopyNotebookRequest) Execute() (AnyOfmicrosoftGraphOnenoteOperation, *_nethttp.Response, error) {
	return r.ApiService.GroupsGroupOnenoteSectionGroupsSectionGroupParentNotebookSectionsOnenoteSectionParentNotebookCopyNotebookExecute(r)
}

/*
GroupsGroupOnenoteSectionGroupsSectionGroupParentNotebookSectionsOnenoteSectionParentNotebookCopyNotebook Invoke action copyNotebook

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupId key: id of group
 @param sectionGroupId key: id of sectionGroup
 @param onenoteSectionId key: id of onenoteSection
 @return ApiGroupsGroupOnenoteSectionGroupsSectionGroupParentNotebookSectionsOnenoteSectionParentNotebookCopyNotebookRequest
*/
func (a *GroupsActionsApiService) GroupsGroupOnenoteSectionGroupsSectionGroupParentNotebookSectionsOnenoteSectionParentNotebookCopyNotebook(ctx _context.Context, groupId string, sectionGroupId string, onenoteSectionId string) ApiGroupsGroupOnenoteSectionGroupsSectionGroupParentNotebookSectionsOnenoteSectionParentNotebookCopyNotebookRequest {
	return ApiGroupsGroupOnenoteSectionGroupsSectionGroupParentNotebookSectionsOnenoteSectionParentNotebookCopyNotebookRequest{
		ApiService: a,
		ctx: ctx,
		groupId: groupId,
		sectionGroupId: sectionGroupId,
		onenoteSectionId: onenoteSectionId,
	}
}

// Execute executes the request
//  @return AnyOfmicrosoftGraphOnenoteOperation
func (a *GroupsActionsApiService) GroupsGroupOnenoteSectionGroupsSectionGroupParentNotebookSectionsOnenoteSectionParentNotebookCopyNotebookExecute(r ApiGroupsGroupOnenoteSectionGroupsSectionGroupParentNotebookSectionsOnenoteSectionParentNotebookCopyNotebookRequest) (AnyOfmicrosoftGraphOnenoteOperation, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  AnyOfmicrosoftGraphOnenoteOperation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GroupsActionsApiService.GroupsGroupOnenoteSectionGroupsSectionGroupParentNotebookSectionsOnenoteSectionParentNotebookCopyNotebook")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/groups/{group-id}/onenote/sectionGroups/{sectionGroup-id}/parentNotebook/sections/{onenoteSection-id}/parentNotebook/microsoft.graph.copyNotebook"
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"sectionGroup-id"+"}", _neturl.PathEscape(parameterToString(r.sectionGroupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"onenoteSection-id"+"}", _neturl.PathEscape(parameterToString(r.onenoteSectionId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject304 == nil {
		return localVarReturnValue, nil, reportError("inlineObject304 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject304
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGroupsGroupOnenoteSectionGroupsSectionGroupSectionsOnenoteSectionCopyToNotebookRequest struct {
	ctx _context.Context
	ApiService *GroupsActionsApiService
	groupId string
	sectionGroupId string
	onenoteSectionId string
	inlineObject305 *InlineObject305
}

func (r ApiGroupsGroupOnenoteSectionGroupsSectionGroupSectionsOnenoteSectionCopyToNotebookRequest) InlineObject305(inlineObject305 InlineObject305) ApiGroupsGroupOnenoteSectionGroupsSectionGroupSectionsOnenoteSectionCopyToNotebookRequest {
	r.inlineObject305 = &inlineObject305
	return r
}

func (r ApiGroupsGroupOnenoteSectionGroupsSectionGroupSectionsOnenoteSectionCopyToNotebookRequest) Execute() (AnyOfmicrosoftGraphOnenoteOperation, *_nethttp.Response, error) {
	return r.ApiService.GroupsGroupOnenoteSectionGroupsSectionGroupSectionsOnenoteSectionCopyToNotebookExecute(r)
}

/*
GroupsGroupOnenoteSectionGroupsSectionGroupSectionsOnenoteSectionCopyToNotebook Invoke action copyToNotebook

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupId key: id of group
 @param sectionGroupId key: id of sectionGroup
 @param onenoteSectionId key: id of onenoteSection
 @return ApiGroupsGroupOnenoteSectionGroupsSectionGroupSectionsOnenoteSectionCopyToNotebookRequest
*/
func (a *GroupsActionsApiService) GroupsGroupOnenoteSectionGroupsSectionGroupSectionsOnenoteSectionCopyToNotebook(ctx _context.Context, groupId string, sectionGroupId string, onenoteSectionId string) ApiGroupsGroupOnenoteSectionGroupsSectionGroupSectionsOnenoteSectionCopyToNotebookRequest {
	return ApiGroupsGroupOnenoteSectionGroupsSectionGroupSectionsOnenoteSectionCopyToNotebookRequest{
		ApiService: a,
		ctx: ctx,
		groupId: groupId,
		sectionGroupId: sectionGroupId,
		onenoteSectionId: onenoteSectionId,
	}
}

// Execute executes the request
//  @return AnyOfmicrosoftGraphOnenoteOperation
func (a *GroupsActionsApiService) GroupsGroupOnenoteSectionGroupsSectionGroupSectionsOnenoteSectionCopyToNotebookExecute(r ApiGroupsGroupOnenoteSectionGroupsSectionGroupSectionsOnenoteSectionCopyToNotebookRequest) (AnyOfmicrosoftGraphOnenoteOperation, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  AnyOfmicrosoftGraphOnenoteOperation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GroupsActionsApiService.GroupsGroupOnenoteSectionGroupsSectionGroupSectionsOnenoteSectionCopyToNotebook")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/groups/{group-id}/onenote/sectionGroups/{sectionGroup-id}/sections/{onenoteSection-id}/microsoft.graph.copyToNotebook"
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"sectionGroup-id"+"}", _neturl.PathEscape(parameterToString(r.sectionGroupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"onenoteSection-id"+"}", _neturl.PathEscape(parameterToString(r.onenoteSectionId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject305 == nil {
		return localVarReturnValue, nil, reportError("inlineObject305 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject305
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGroupsGroupOnenoteSectionGroupsSectionGroupSectionsOnenoteSectionCopyToSectionGroupRequest struct {
	ctx _context.Context
	ApiService *GroupsActionsApiService
	groupId string
	sectionGroupId string
	onenoteSectionId string
	inlineObject306 *InlineObject306
}

func (r ApiGroupsGroupOnenoteSectionGroupsSectionGroupSectionsOnenoteSectionCopyToSectionGroupRequest) InlineObject306(inlineObject306 InlineObject306) ApiGroupsGroupOnenoteSectionGroupsSectionGroupSectionsOnenoteSectionCopyToSectionGroupRequest {
	r.inlineObject306 = &inlineObject306
	return r
}

func (r ApiGroupsGroupOnenoteSectionGroupsSectionGroupSectionsOnenoteSectionCopyToSectionGroupRequest) Execute() (AnyOfmicrosoftGraphOnenoteOperation, *_nethttp.Response, error) {
	return r.ApiService.GroupsGroupOnenoteSectionGroupsSectionGroupSectionsOnenoteSectionCopyToSectionGroupExecute(r)
}

/*
GroupsGroupOnenoteSectionGroupsSectionGroupSectionsOnenoteSectionCopyToSectionGroup Invoke action copyToSectionGroup

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupId key: id of group
 @param sectionGroupId key: id of sectionGroup
 @param onenoteSectionId key: id of onenoteSection
 @return ApiGroupsGroupOnenoteSectionGroupsSectionGroupSectionsOnenoteSectionCopyToSectionGroupRequest
*/
func (a *GroupsActionsApiService) GroupsGroupOnenoteSectionGroupsSectionGroupSectionsOnenoteSectionCopyToSectionGroup(ctx _context.Context, groupId string, sectionGroupId string, onenoteSectionId string) ApiGroupsGroupOnenoteSectionGroupsSectionGroupSectionsOnenoteSectionCopyToSectionGroupRequest {
	return ApiGroupsGroupOnenoteSectionGroupsSectionGroupSectionsOnenoteSectionCopyToSectionGroupRequest{
		ApiService: a,
		ctx: ctx,
		groupId: groupId,
		sectionGroupId: sectionGroupId,
		onenoteSectionId: onenoteSectionId,
	}
}

// Execute executes the request
//  @return AnyOfmicrosoftGraphOnenoteOperation
func (a *GroupsActionsApiService) GroupsGroupOnenoteSectionGroupsSectionGroupSectionsOnenoteSectionCopyToSectionGroupExecute(r ApiGroupsGroupOnenoteSectionGroupsSectionGroupSectionsOnenoteSectionCopyToSectionGroupRequest) (AnyOfmicrosoftGraphOnenoteOperation, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  AnyOfmicrosoftGraphOnenoteOperation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GroupsActionsApiService.GroupsGroupOnenoteSectionGroupsSectionGroupSectionsOnenoteSectionCopyToSectionGroup")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/groups/{group-id}/onenote/sectionGroups/{sectionGroup-id}/sections/{onenoteSection-id}/microsoft.graph.copyToSectionGroup"
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"sectionGroup-id"+"}", _neturl.PathEscape(parameterToString(r.sectionGroupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"onenoteSection-id"+"}", _neturl.PathEscape(parameterToString(r.onenoteSectionId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject306 == nil {
		return localVarReturnValue, nil, reportError("inlineObject306 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject306
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGroupsGroupOnenoteSectionGroupsSectionGroupSectionsOnenoteSectionPagesOnenotePageCopyToSectionRequest struct {
	ctx _context.Context
	ApiService *GroupsActionsApiService
	groupId string
	sectionGroupId string
	onenoteSectionId string
	onenotePageId string
	inlineObject307 *InlineObject307
}

func (r ApiGroupsGroupOnenoteSectionGroupsSectionGroupSectionsOnenoteSectionPagesOnenotePageCopyToSectionRequest) InlineObject307(inlineObject307 InlineObject307) ApiGroupsGroupOnenoteSectionGroupsSectionGroupSectionsOnenoteSectionPagesOnenotePageCopyToSectionRequest {
	r.inlineObject307 = &inlineObject307
	return r
}

func (r ApiGroupsGroupOnenoteSectionGroupsSectionGroupSectionsOnenoteSectionPagesOnenotePageCopyToSectionRequest) Execute() (AnyOfmicrosoftGraphOnenoteOperation, *_nethttp.Response, error) {
	return r.ApiService.GroupsGroupOnenoteSectionGroupsSectionGroupSectionsOnenoteSectionPagesOnenotePageCopyToSectionExecute(r)
}

/*
GroupsGroupOnenoteSectionGroupsSectionGroupSectionsOnenoteSectionPagesOnenotePageCopyToSection Invoke action copyToSection

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupId key: id of group
 @param sectionGroupId key: id of sectionGroup
 @param onenoteSectionId key: id of onenoteSection
 @param onenotePageId key: id of onenotePage
 @return ApiGroupsGroupOnenoteSectionGroupsSectionGroupSectionsOnenoteSectionPagesOnenotePageCopyToSectionRequest
*/
func (a *GroupsActionsApiService) GroupsGroupOnenoteSectionGroupsSectionGroupSectionsOnenoteSectionPagesOnenotePageCopyToSection(ctx _context.Context, groupId string, sectionGroupId string, onenoteSectionId string, onenotePageId string) ApiGroupsGroupOnenoteSectionGroupsSectionGroupSectionsOnenoteSectionPagesOnenotePageCopyToSectionRequest {
	return ApiGroupsGroupOnenoteSectionGroupsSectionGroupSectionsOnenoteSectionPagesOnenotePageCopyToSectionRequest{
		ApiService: a,
		ctx: ctx,
		groupId: groupId,
		sectionGroupId: sectionGroupId,
		onenoteSectionId: onenoteSectionId,
		onenotePageId: onenotePageId,
	}
}

// Execute executes the request
//  @return AnyOfmicrosoftGraphOnenoteOperation
func (a *GroupsActionsApiService) GroupsGroupOnenoteSectionGroupsSectionGroupSectionsOnenoteSectionPagesOnenotePageCopyToSectionExecute(r ApiGroupsGroupOnenoteSectionGroupsSectionGroupSectionsOnenoteSectionPagesOnenotePageCopyToSectionRequest) (AnyOfmicrosoftGraphOnenoteOperation, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  AnyOfmicrosoftGraphOnenoteOperation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GroupsActionsApiService.GroupsGroupOnenoteSectionGroupsSectionGroupSectionsOnenoteSectionPagesOnenotePageCopyToSection")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/groups/{group-id}/onenote/sectionGroups/{sectionGroup-id}/sections/{onenoteSection-id}/pages/{onenotePage-id}/microsoft.graph.copyToSection"
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"sectionGroup-id"+"}", _neturl.PathEscape(parameterToString(r.sectionGroupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"onenoteSection-id"+"}", _neturl.PathEscape(parameterToString(r.onenoteSectionId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"onenotePage-id"+"}", _neturl.PathEscape(parameterToString(r.onenotePageId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject307 == nil {
		return localVarReturnValue, nil, reportError("inlineObject307 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject307
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGroupsGroupOnenoteSectionGroupsSectionGroupSectionsOnenoteSectionPagesOnenotePageOnenotePatchContentRequest struct {
	ctx _context.Context
	ApiService *GroupsActionsApiService
	groupId string
	sectionGroupId string
	onenoteSectionId string
	onenotePageId string
	inlineObject308 *InlineObject308
}

func (r ApiGroupsGroupOnenoteSectionGroupsSectionGroupSectionsOnenoteSectionPagesOnenotePageOnenotePatchContentRequest) InlineObject308(inlineObject308 InlineObject308) ApiGroupsGroupOnenoteSectionGroupsSectionGroupSectionsOnenoteSectionPagesOnenotePageOnenotePatchContentRequest {
	r.inlineObject308 = &inlineObject308
	return r
}

func (r ApiGroupsGroupOnenoteSectionGroupsSectionGroupSectionsOnenoteSectionPagesOnenotePageOnenotePatchContentRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.GroupsGroupOnenoteSectionGroupsSectionGroupSectionsOnenoteSectionPagesOnenotePageOnenotePatchContentExecute(r)
}

/*
GroupsGroupOnenoteSectionGroupsSectionGroupSectionsOnenoteSectionPagesOnenotePageOnenotePatchContent Invoke action onenotePatchContent

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupId key: id of group
 @param sectionGroupId key: id of sectionGroup
 @param onenoteSectionId key: id of onenoteSection
 @param onenotePageId key: id of onenotePage
 @return ApiGroupsGroupOnenoteSectionGroupsSectionGroupSectionsOnenoteSectionPagesOnenotePageOnenotePatchContentRequest
*/
func (a *GroupsActionsApiService) GroupsGroupOnenoteSectionGroupsSectionGroupSectionsOnenoteSectionPagesOnenotePageOnenotePatchContent(ctx _context.Context, groupId string, sectionGroupId string, onenoteSectionId string, onenotePageId string) ApiGroupsGroupOnenoteSectionGroupsSectionGroupSectionsOnenoteSectionPagesOnenotePageOnenotePatchContentRequest {
	return ApiGroupsGroupOnenoteSectionGroupsSectionGroupSectionsOnenoteSectionPagesOnenotePageOnenotePatchContentRequest{
		ApiService: a,
		ctx: ctx,
		groupId: groupId,
		sectionGroupId: sectionGroupId,
		onenoteSectionId: onenoteSectionId,
		onenotePageId: onenotePageId,
	}
}

// Execute executes the request
func (a *GroupsActionsApiService) GroupsGroupOnenoteSectionGroupsSectionGroupSectionsOnenoteSectionPagesOnenotePageOnenotePatchContentExecute(r ApiGroupsGroupOnenoteSectionGroupsSectionGroupSectionsOnenoteSectionPagesOnenotePageOnenotePatchContentRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GroupsActionsApiService.GroupsGroupOnenoteSectionGroupsSectionGroupSectionsOnenoteSectionPagesOnenotePageOnenotePatchContent")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/groups/{group-id}/onenote/sectionGroups/{sectionGroup-id}/sections/{onenoteSection-id}/pages/{onenotePage-id}/microsoft.graph.onenotePatchContent"
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"sectionGroup-id"+"}", _neturl.PathEscape(parameterToString(r.sectionGroupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"onenoteSection-id"+"}", _neturl.PathEscape(parameterToString(r.onenoteSectionId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"onenotePage-id"+"}", _neturl.PathEscape(parameterToString(r.onenotePageId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject308 == nil {
		return nil, reportError("inlineObject308 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject308
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGroupsGroupOnenoteSectionGroupsSectionGroupSectionsOnenoteSectionPagesOnenotePageParentNotebookCopyNotebookRequest struct {
	ctx _context.Context
	ApiService *GroupsActionsApiService
	groupId string
	sectionGroupId string
	onenoteSectionId string
	onenotePageId string
	inlineObject309 *InlineObject309
}

func (r ApiGroupsGroupOnenoteSectionGroupsSectionGroupSectionsOnenoteSectionPagesOnenotePageParentNotebookCopyNotebookRequest) InlineObject309(inlineObject309 InlineObject309) ApiGroupsGroupOnenoteSectionGroupsSectionGroupSectionsOnenoteSectionPagesOnenotePageParentNotebookCopyNotebookRequest {
	r.inlineObject309 = &inlineObject309
	return r
}

func (r ApiGroupsGroupOnenoteSectionGroupsSectionGroupSectionsOnenoteSectionPagesOnenotePageParentNotebookCopyNotebookRequest) Execute() (AnyOfmicrosoftGraphOnenoteOperation, *_nethttp.Response, error) {
	return r.ApiService.GroupsGroupOnenoteSectionGroupsSectionGroupSectionsOnenoteSectionPagesOnenotePageParentNotebookCopyNotebookExecute(r)
}

/*
GroupsGroupOnenoteSectionGroupsSectionGroupSectionsOnenoteSectionPagesOnenotePageParentNotebookCopyNotebook Invoke action copyNotebook

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupId key: id of group
 @param sectionGroupId key: id of sectionGroup
 @param onenoteSectionId key: id of onenoteSection
 @param onenotePageId key: id of onenotePage
 @return ApiGroupsGroupOnenoteSectionGroupsSectionGroupSectionsOnenoteSectionPagesOnenotePageParentNotebookCopyNotebookRequest
*/
func (a *GroupsActionsApiService) GroupsGroupOnenoteSectionGroupsSectionGroupSectionsOnenoteSectionPagesOnenotePageParentNotebookCopyNotebook(ctx _context.Context, groupId string, sectionGroupId string, onenoteSectionId string, onenotePageId string) ApiGroupsGroupOnenoteSectionGroupsSectionGroupSectionsOnenoteSectionPagesOnenotePageParentNotebookCopyNotebookRequest {
	return ApiGroupsGroupOnenoteSectionGroupsSectionGroupSectionsOnenoteSectionPagesOnenotePageParentNotebookCopyNotebookRequest{
		ApiService: a,
		ctx: ctx,
		groupId: groupId,
		sectionGroupId: sectionGroupId,
		onenoteSectionId: onenoteSectionId,
		onenotePageId: onenotePageId,
	}
}

// Execute executes the request
//  @return AnyOfmicrosoftGraphOnenoteOperation
func (a *GroupsActionsApiService) GroupsGroupOnenoteSectionGroupsSectionGroupSectionsOnenoteSectionPagesOnenotePageParentNotebookCopyNotebookExecute(r ApiGroupsGroupOnenoteSectionGroupsSectionGroupSectionsOnenoteSectionPagesOnenotePageParentNotebookCopyNotebookRequest) (AnyOfmicrosoftGraphOnenoteOperation, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  AnyOfmicrosoftGraphOnenoteOperation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GroupsActionsApiService.GroupsGroupOnenoteSectionGroupsSectionGroupSectionsOnenoteSectionPagesOnenotePageParentNotebookCopyNotebook")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/groups/{group-id}/onenote/sectionGroups/{sectionGroup-id}/sections/{onenoteSection-id}/pages/{onenotePage-id}/parentNotebook/microsoft.graph.copyNotebook"
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"sectionGroup-id"+"}", _neturl.PathEscape(parameterToString(r.sectionGroupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"onenoteSection-id"+"}", _neturl.PathEscape(parameterToString(r.onenoteSectionId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"onenotePage-id"+"}", _neturl.PathEscape(parameterToString(r.onenotePageId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject309 == nil {
		return localVarReturnValue, nil, reportError("inlineObject309 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject309
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGroupsGroupOnenoteSectionGroupsSectionGroupSectionsOnenoteSectionPagesOnenotePageParentNotebookSectionsOnenoteSectionCopyToNotebookRequest struct {
	ctx _context.Context
	ApiService *GroupsActionsApiService
	groupId string
	sectionGroupId string
	onenoteSectionId string
	onenotePageId string
	onenoteSectionId1 string
	inlineObject310 *InlineObject310
}

func (r ApiGroupsGroupOnenoteSectionGroupsSectionGroupSectionsOnenoteSectionPagesOnenotePageParentNotebookSectionsOnenoteSectionCopyToNotebookRequest) InlineObject310(inlineObject310 InlineObject310) ApiGroupsGroupOnenoteSectionGroupsSectionGroupSectionsOnenoteSectionPagesOnenotePageParentNotebookSectionsOnenoteSectionCopyToNotebookRequest {
	r.inlineObject310 = &inlineObject310
	return r
}

func (r ApiGroupsGroupOnenoteSectionGroupsSectionGroupSectionsOnenoteSectionPagesOnenotePageParentNotebookSectionsOnenoteSectionCopyToNotebookRequest) Execute() (AnyOfmicrosoftGraphOnenoteOperation, *_nethttp.Response, error) {
	return r.ApiService.GroupsGroupOnenoteSectionGroupsSectionGroupSectionsOnenoteSectionPagesOnenotePageParentNotebookSectionsOnenoteSectionCopyToNotebookExecute(r)
}

/*
GroupsGroupOnenoteSectionGroupsSectionGroupSectionsOnenoteSectionPagesOnenotePageParentNotebookSectionsOnenoteSectionCopyToNotebook Invoke action copyToNotebook

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupId key: id of group
 @param sectionGroupId key: id of sectionGroup
 @param onenoteSectionId key: id of onenoteSection
 @param onenotePageId key: id of onenotePage
 @param onenoteSectionId1 key: id of onenoteSection
 @return ApiGroupsGroupOnenoteSectionGroupsSectionGroupSectionsOnenoteSectionPagesOnenotePageParentNotebookSectionsOnenoteSectionCopyToNotebookRequest
*/
func (a *GroupsActionsApiService) GroupsGroupOnenoteSectionGroupsSectionGroupSectionsOnenoteSectionPagesOnenotePageParentNotebookSectionsOnenoteSectionCopyToNotebook(ctx _context.Context, groupId string, sectionGroupId string, onenoteSectionId string, onenotePageId string, onenoteSectionId1 string) ApiGroupsGroupOnenoteSectionGroupsSectionGroupSectionsOnenoteSectionPagesOnenotePageParentNotebookSectionsOnenoteSectionCopyToNotebookRequest {
	return ApiGroupsGroupOnenoteSectionGroupsSectionGroupSectionsOnenoteSectionPagesOnenotePageParentNotebookSectionsOnenoteSectionCopyToNotebookRequest{
		ApiService: a,
		ctx: ctx,
		groupId: groupId,
		sectionGroupId: sectionGroupId,
		onenoteSectionId: onenoteSectionId,
		onenotePageId: onenotePageId,
		onenoteSectionId1: onenoteSectionId1,
	}
}

// Execute executes the request
//  @return AnyOfmicrosoftGraphOnenoteOperation
func (a *GroupsActionsApiService) GroupsGroupOnenoteSectionGroupsSectionGroupSectionsOnenoteSectionPagesOnenotePageParentNotebookSectionsOnenoteSectionCopyToNotebookExecute(r ApiGroupsGroupOnenoteSectionGroupsSectionGroupSectionsOnenoteSectionPagesOnenotePageParentNotebookSectionsOnenoteSectionCopyToNotebookRequest) (AnyOfmicrosoftGraphOnenoteOperation, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  AnyOfmicrosoftGraphOnenoteOperation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GroupsActionsApiService.GroupsGroupOnenoteSectionGroupsSectionGroupSectionsOnenoteSectionPagesOnenotePageParentNotebookSectionsOnenoteSectionCopyToNotebook")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/groups/{group-id}/onenote/sectionGroups/{sectionGroup-id}/sections/{onenoteSection-id}/pages/{onenotePage-id}/parentNotebook/sections/{onenoteSection-id1}/microsoft.graph.copyToNotebook"
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"sectionGroup-id"+"}", _neturl.PathEscape(parameterToString(r.sectionGroupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"onenoteSection-id"+"}", _neturl.PathEscape(parameterToString(r.onenoteSectionId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"onenotePage-id"+"}", _neturl.PathEscape(parameterToString(r.onenotePageId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"onenoteSection-id1"+"}", _neturl.PathEscape(parameterToString(r.onenoteSectionId1, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject310 == nil {
		return localVarReturnValue, nil, reportError("inlineObject310 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject310
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGroupsGroupOnenoteSectionGroupsSectionGroupSectionsOnenoteSectionPagesOnenotePageParentNotebookSectionsOnenoteSectionCopyToSectionGroupRequest struct {
	ctx _context.Context
	ApiService *GroupsActionsApiService
	groupId string
	sectionGroupId string
	onenoteSectionId string
	onenotePageId string
	onenoteSectionId1 string
	inlineObject311 *InlineObject311
}

func (r ApiGroupsGroupOnenoteSectionGroupsSectionGroupSectionsOnenoteSectionPagesOnenotePageParentNotebookSectionsOnenoteSectionCopyToSectionGroupRequest) InlineObject311(inlineObject311 InlineObject311) ApiGroupsGroupOnenoteSectionGroupsSectionGroupSectionsOnenoteSectionPagesOnenotePageParentNotebookSectionsOnenoteSectionCopyToSectionGroupRequest {
	r.inlineObject311 = &inlineObject311
	return r
}

func (r ApiGroupsGroupOnenoteSectionGroupsSectionGroupSectionsOnenoteSectionPagesOnenotePageParentNotebookSectionsOnenoteSectionCopyToSectionGroupRequest) Execute() (AnyOfmicrosoftGraphOnenoteOperation, *_nethttp.Response, error) {
	return r.ApiService.GroupsGroupOnenoteSectionGroupsSectionGroupSectionsOnenoteSectionPagesOnenotePageParentNotebookSectionsOnenoteSectionCopyToSectionGroupExecute(r)
}

/*
GroupsGroupOnenoteSectionGroupsSectionGroupSectionsOnenoteSectionPagesOnenotePageParentNotebookSectionsOnenoteSectionCopyToSectionGroup Invoke action copyToSectionGroup

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupId key: id of group
 @param sectionGroupId key: id of sectionGroup
 @param onenoteSectionId key: id of onenoteSection
 @param onenotePageId key: id of onenotePage
 @param onenoteSectionId1 key: id of onenoteSection
 @return ApiGroupsGroupOnenoteSectionGroupsSectionGroupSectionsOnenoteSectionPagesOnenotePageParentNotebookSectionsOnenoteSectionCopyToSectionGroupRequest
*/
func (a *GroupsActionsApiService) GroupsGroupOnenoteSectionGroupsSectionGroupSectionsOnenoteSectionPagesOnenotePageParentNotebookSectionsOnenoteSectionCopyToSectionGroup(ctx _context.Context, groupId string, sectionGroupId string, onenoteSectionId string, onenotePageId string, onenoteSectionId1 string) ApiGroupsGroupOnenoteSectionGroupsSectionGroupSectionsOnenoteSectionPagesOnenotePageParentNotebookSectionsOnenoteSectionCopyToSectionGroupRequest {
	return ApiGroupsGroupOnenoteSectionGroupsSectionGroupSectionsOnenoteSectionPagesOnenotePageParentNotebookSectionsOnenoteSectionCopyToSectionGroupRequest{
		ApiService: a,
		ctx: ctx,
		groupId: groupId,
		sectionGroupId: sectionGroupId,
		onenoteSectionId: onenoteSectionId,
		onenotePageId: onenotePageId,
		onenoteSectionId1: onenoteSectionId1,
	}
}

// Execute executes the request
//  @return AnyOfmicrosoftGraphOnenoteOperation
func (a *GroupsActionsApiService) GroupsGroupOnenoteSectionGroupsSectionGroupSectionsOnenoteSectionPagesOnenotePageParentNotebookSectionsOnenoteSectionCopyToSectionGroupExecute(r ApiGroupsGroupOnenoteSectionGroupsSectionGroupSectionsOnenoteSectionPagesOnenotePageParentNotebookSectionsOnenoteSectionCopyToSectionGroupRequest) (AnyOfmicrosoftGraphOnenoteOperation, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  AnyOfmicrosoftGraphOnenoteOperation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GroupsActionsApiService.GroupsGroupOnenoteSectionGroupsSectionGroupSectionsOnenoteSectionPagesOnenotePageParentNotebookSectionsOnenoteSectionCopyToSectionGroup")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/groups/{group-id}/onenote/sectionGroups/{sectionGroup-id}/sections/{onenoteSection-id}/pages/{onenotePage-id}/parentNotebook/sections/{onenoteSection-id1}/microsoft.graph.copyToSectionGroup"
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"sectionGroup-id"+"}", _neturl.PathEscape(parameterToString(r.sectionGroupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"onenoteSection-id"+"}", _neturl.PathEscape(parameterToString(r.onenoteSectionId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"onenotePage-id"+"}", _neturl.PathEscape(parameterToString(r.onenotePageId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"onenoteSection-id1"+"}", _neturl.PathEscape(parameterToString(r.onenoteSectionId1, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject311 == nil {
		return localVarReturnValue, nil, reportError("inlineObject311 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject311
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGroupsGroupOnenoteSectionGroupsSectionGroupSectionsOnenoteSectionPagesOnenotePageParentSectionCopyToNotebookRequest struct {
	ctx _context.Context
	ApiService *GroupsActionsApiService
	groupId string
	sectionGroupId string
	onenoteSectionId string
	onenotePageId string
	inlineObject312 *InlineObject312
}

func (r ApiGroupsGroupOnenoteSectionGroupsSectionGroupSectionsOnenoteSectionPagesOnenotePageParentSectionCopyToNotebookRequest) InlineObject312(inlineObject312 InlineObject312) ApiGroupsGroupOnenoteSectionGroupsSectionGroupSectionsOnenoteSectionPagesOnenotePageParentSectionCopyToNotebookRequest {
	r.inlineObject312 = &inlineObject312
	return r
}

func (r ApiGroupsGroupOnenoteSectionGroupsSectionGroupSectionsOnenoteSectionPagesOnenotePageParentSectionCopyToNotebookRequest) Execute() (AnyOfmicrosoftGraphOnenoteOperation, *_nethttp.Response, error) {
	return r.ApiService.GroupsGroupOnenoteSectionGroupsSectionGroupSectionsOnenoteSectionPagesOnenotePageParentSectionCopyToNotebookExecute(r)
}

/*
GroupsGroupOnenoteSectionGroupsSectionGroupSectionsOnenoteSectionPagesOnenotePageParentSectionCopyToNotebook Invoke action copyToNotebook

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupId key: id of group
 @param sectionGroupId key: id of sectionGroup
 @param onenoteSectionId key: id of onenoteSection
 @param onenotePageId key: id of onenotePage
 @return ApiGroupsGroupOnenoteSectionGroupsSectionGroupSectionsOnenoteSectionPagesOnenotePageParentSectionCopyToNotebookRequest
*/
func (a *GroupsActionsApiService) GroupsGroupOnenoteSectionGroupsSectionGroupSectionsOnenoteSectionPagesOnenotePageParentSectionCopyToNotebook(ctx _context.Context, groupId string, sectionGroupId string, onenoteSectionId string, onenotePageId string) ApiGroupsGroupOnenoteSectionGroupsSectionGroupSectionsOnenoteSectionPagesOnenotePageParentSectionCopyToNotebookRequest {
	return ApiGroupsGroupOnenoteSectionGroupsSectionGroupSectionsOnenoteSectionPagesOnenotePageParentSectionCopyToNotebookRequest{
		ApiService: a,
		ctx: ctx,
		groupId: groupId,
		sectionGroupId: sectionGroupId,
		onenoteSectionId: onenoteSectionId,
		onenotePageId: onenotePageId,
	}
}

// Execute executes the request
//  @return AnyOfmicrosoftGraphOnenoteOperation
func (a *GroupsActionsApiService) GroupsGroupOnenoteSectionGroupsSectionGroupSectionsOnenoteSectionPagesOnenotePageParentSectionCopyToNotebookExecute(r ApiGroupsGroupOnenoteSectionGroupsSectionGroupSectionsOnenoteSectionPagesOnenotePageParentSectionCopyToNotebookRequest) (AnyOfmicrosoftGraphOnenoteOperation, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  AnyOfmicrosoftGraphOnenoteOperation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GroupsActionsApiService.GroupsGroupOnenoteSectionGroupsSectionGroupSectionsOnenoteSectionPagesOnenotePageParentSectionCopyToNotebook")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/groups/{group-id}/onenote/sectionGroups/{sectionGroup-id}/sections/{onenoteSection-id}/pages/{onenotePage-id}/parentSection/microsoft.graph.copyToNotebook"
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"sectionGroup-id"+"}", _neturl.PathEscape(parameterToString(r.sectionGroupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"onenoteSection-id"+"}", _neturl.PathEscape(parameterToString(r.onenoteSectionId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"onenotePage-id"+"}", _neturl.PathEscape(parameterToString(r.onenotePageId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject312 == nil {
		return localVarReturnValue, nil, reportError("inlineObject312 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject312
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGroupsGroupOnenoteSectionGroupsSectionGroupSectionsOnenoteSectionPagesOnenotePageParentSectionCopyToSectionGroupRequest struct {
	ctx _context.Context
	ApiService *GroupsActionsApiService
	groupId string
	sectionGroupId string
	onenoteSectionId string
	onenotePageId string
	inlineObject313 *InlineObject313
}

func (r ApiGroupsGroupOnenoteSectionGroupsSectionGroupSectionsOnenoteSectionPagesOnenotePageParentSectionCopyToSectionGroupRequest) InlineObject313(inlineObject313 InlineObject313) ApiGroupsGroupOnenoteSectionGroupsSectionGroupSectionsOnenoteSectionPagesOnenotePageParentSectionCopyToSectionGroupRequest {
	r.inlineObject313 = &inlineObject313
	return r
}

func (r ApiGroupsGroupOnenoteSectionGroupsSectionGroupSectionsOnenoteSectionPagesOnenotePageParentSectionCopyToSectionGroupRequest) Execute() (AnyOfmicrosoftGraphOnenoteOperation, *_nethttp.Response, error) {
	return r.ApiService.GroupsGroupOnenoteSectionGroupsSectionGroupSectionsOnenoteSectionPagesOnenotePageParentSectionCopyToSectionGroupExecute(r)
}

/*
GroupsGroupOnenoteSectionGroupsSectionGroupSectionsOnenoteSectionPagesOnenotePageParentSectionCopyToSectionGroup Invoke action copyToSectionGroup

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupId key: id of group
 @param sectionGroupId key: id of sectionGroup
 @param onenoteSectionId key: id of onenoteSection
 @param onenotePageId key: id of onenotePage
 @return ApiGroupsGroupOnenoteSectionGroupsSectionGroupSectionsOnenoteSectionPagesOnenotePageParentSectionCopyToSectionGroupRequest
*/
func (a *GroupsActionsApiService) GroupsGroupOnenoteSectionGroupsSectionGroupSectionsOnenoteSectionPagesOnenotePageParentSectionCopyToSectionGroup(ctx _context.Context, groupId string, sectionGroupId string, onenoteSectionId string, onenotePageId string) ApiGroupsGroupOnenoteSectionGroupsSectionGroupSectionsOnenoteSectionPagesOnenotePageParentSectionCopyToSectionGroupRequest {
	return ApiGroupsGroupOnenoteSectionGroupsSectionGroupSectionsOnenoteSectionPagesOnenotePageParentSectionCopyToSectionGroupRequest{
		ApiService: a,
		ctx: ctx,
		groupId: groupId,
		sectionGroupId: sectionGroupId,
		onenoteSectionId: onenoteSectionId,
		onenotePageId: onenotePageId,
	}
}

// Execute executes the request
//  @return AnyOfmicrosoftGraphOnenoteOperation
func (a *GroupsActionsApiService) GroupsGroupOnenoteSectionGroupsSectionGroupSectionsOnenoteSectionPagesOnenotePageParentSectionCopyToSectionGroupExecute(r ApiGroupsGroupOnenoteSectionGroupsSectionGroupSectionsOnenoteSectionPagesOnenotePageParentSectionCopyToSectionGroupRequest) (AnyOfmicrosoftGraphOnenoteOperation, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  AnyOfmicrosoftGraphOnenoteOperation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GroupsActionsApiService.GroupsGroupOnenoteSectionGroupsSectionGroupSectionsOnenoteSectionPagesOnenotePageParentSectionCopyToSectionGroup")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/groups/{group-id}/onenote/sectionGroups/{sectionGroup-id}/sections/{onenoteSection-id}/pages/{onenotePage-id}/parentSection/microsoft.graph.copyToSectionGroup"
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"sectionGroup-id"+"}", _neturl.PathEscape(parameterToString(r.sectionGroupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"onenoteSection-id"+"}", _neturl.PathEscape(parameterToString(r.onenoteSectionId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"onenotePage-id"+"}", _neturl.PathEscape(parameterToString(r.onenotePageId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject313 == nil {
		return localVarReturnValue, nil, reportError("inlineObject313 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject313
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGroupsGroupOnenoteSectionGroupsSectionGroupSectionsOnenoteSectionParentNotebookCopyNotebookRequest struct {
	ctx _context.Context
	ApiService *GroupsActionsApiService
	groupId string
	sectionGroupId string
	onenoteSectionId string
	inlineObject314 *InlineObject314
}

func (r ApiGroupsGroupOnenoteSectionGroupsSectionGroupSectionsOnenoteSectionParentNotebookCopyNotebookRequest) InlineObject314(inlineObject314 InlineObject314) ApiGroupsGroupOnenoteSectionGroupsSectionGroupSectionsOnenoteSectionParentNotebookCopyNotebookRequest {
	r.inlineObject314 = &inlineObject314
	return r
}

func (r ApiGroupsGroupOnenoteSectionGroupsSectionGroupSectionsOnenoteSectionParentNotebookCopyNotebookRequest) Execute() (AnyOfmicrosoftGraphOnenoteOperation, *_nethttp.Response, error) {
	return r.ApiService.GroupsGroupOnenoteSectionGroupsSectionGroupSectionsOnenoteSectionParentNotebookCopyNotebookExecute(r)
}

/*
GroupsGroupOnenoteSectionGroupsSectionGroupSectionsOnenoteSectionParentNotebookCopyNotebook Invoke action copyNotebook

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupId key: id of group
 @param sectionGroupId key: id of sectionGroup
 @param onenoteSectionId key: id of onenoteSection
 @return ApiGroupsGroupOnenoteSectionGroupsSectionGroupSectionsOnenoteSectionParentNotebookCopyNotebookRequest
*/
func (a *GroupsActionsApiService) GroupsGroupOnenoteSectionGroupsSectionGroupSectionsOnenoteSectionParentNotebookCopyNotebook(ctx _context.Context, groupId string, sectionGroupId string, onenoteSectionId string) ApiGroupsGroupOnenoteSectionGroupsSectionGroupSectionsOnenoteSectionParentNotebookCopyNotebookRequest {
	return ApiGroupsGroupOnenoteSectionGroupsSectionGroupSectionsOnenoteSectionParentNotebookCopyNotebookRequest{
		ApiService: a,
		ctx: ctx,
		groupId: groupId,
		sectionGroupId: sectionGroupId,
		onenoteSectionId: onenoteSectionId,
	}
}

// Execute executes the request
//  @return AnyOfmicrosoftGraphOnenoteOperation
func (a *GroupsActionsApiService) GroupsGroupOnenoteSectionGroupsSectionGroupSectionsOnenoteSectionParentNotebookCopyNotebookExecute(r ApiGroupsGroupOnenoteSectionGroupsSectionGroupSectionsOnenoteSectionParentNotebookCopyNotebookRequest) (AnyOfmicrosoftGraphOnenoteOperation, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  AnyOfmicrosoftGraphOnenoteOperation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GroupsActionsApiService.GroupsGroupOnenoteSectionGroupsSectionGroupSectionsOnenoteSectionParentNotebookCopyNotebook")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/groups/{group-id}/onenote/sectionGroups/{sectionGroup-id}/sections/{onenoteSection-id}/parentNotebook/microsoft.graph.copyNotebook"
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"sectionGroup-id"+"}", _neturl.PathEscape(parameterToString(r.sectionGroupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"onenoteSection-id"+"}", _neturl.PathEscape(parameterToString(r.onenoteSectionId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject314 == nil {
		return localVarReturnValue, nil, reportError("inlineObject314 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject314
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGroupsGroupOnenoteSectionGroupsSectionGroupSectionsOnenoteSectionParentNotebookSectionsOnenoteSectionCopyToNotebookRequest struct {
	ctx _context.Context
	ApiService *GroupsActionsApiService
	groupId string
	sectionGroupId string
	onenoteSectionId string
	onenoteSectionId1 string
	inlineObject315 *InlineObject315
}

func (r ApiGroupsGroupOnenoteSectionGroupsSectionGroupSectionsOnenoteSectionParentNotebookSectionsOnenoteSectionCopyToNotebookRequest) InlineObject315(inlineObject315 InlineObject315) ApiGroupsGroupOnenoteSectionGroupsSectionGroupSectionsOnenoteSectionParentNotebookSectionsOnenoteSectionCopyToNotebookRequest {
	r.inlineObject315 = &inlineObject315
	return r
}

func (r ApiGroupsGroupOnenoteSectionGroupsSectionGroupSectionsOnenoteSectionParentNotebookSectionsOnenoteSectionCopyToNotebookRequest) Execute() (AnyOfmicrosoftGraphOnenoteOperation, *_nethttp.Response, error) {
	return r.ApiService.GroupsGroupOnenoteSectionGroupsSectionGroupSectionsOnenoteSectionParentNotebookSectionsOnenoteSectionCopyToNotebookExecute(r)
}

/*
GroupsGroupOnenoteSectionGroupsSectionGroupSectionsOnenoteSectionParentNotebookSectionsOnenoteSectionCopyToNotebook Invoke action copyToNotebook

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupId key: id of group
 @param sectionGroupId key: id of sectionGroup
 @param onenoteSectionId key: id of onenoteSection
 @param onenoteSectionId1 key: id of onenoteSection
 @return ApiGroupsGroupOnenoteSectionGroupsSectionGroupSectionsOnenoteSectionParentNotebookSectionsOnenoteSectionCopyToNotebookRequest
*/
func (a *GroupsActionsApiService) GroupsGroupOnenoteSectionGroupsSectionGroupSectionsOnenoteSectionParentNotebookSectionsOnenoteSectionCopyToNotebook(ctx _context.Context, groupId string, sectionGroupId string, onenoteSectionId string, onenoteSectionId1 string) ApiGroupsGroupOnenoteSectionGroupsSectionGroupSectionsOnenoteSectionParentNotebookSectionsOnenoteSectionCopyToNotebookRequest {
	return ApiGroupsGroupOnenoteSectionGroupsSectionGroupSectionsOnenoteSectionParentNotebookSectionsOnenoteSectionCopyToNotebookRequest{
		ApiService: a,
		ctx: ctx,
		groupId: groupId,
		sectionGroupId: sectionGroupId,
		onenoteSectionId: onenoteSectionId,
		onenoteSectionId1: onenoteSectionId1,
	}
}

// Execute executes the request
//  @return AnyOfmicrosoftGraphOnenoteOperation
func (a *GroupsActionsApiService) GroupsGroupOnenoteSectionGroupsSectionGroupSectionsOnenoteSectionParentNotebookSectionsOnenoteSectionCopyToNotebookExecute(r ApiGroupsGroupOnenoteSectionGroupsSectionGroupSectionsOnenoteSectionParentNotebookSectionsOnenoteSectionCopyToNotebookRequest) (AnyOfmicrosoftGraphOnenoteOperation, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  AnyOfmicrosoftGraphOnenoteOperation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GroupsActionsApiService.GroupsGroupOnenoteSectionGroupsSectionGroupSectionsOnenoteSectionParentNotebookSectionsOnenoteSectionCopyToNotebook")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/groups/{group-id}/onenote/sectionGroups/{sectionGroup-id}/sections/{onenoteSection-id}/parentNotebook/sections/{onenoteSection-id1}/microsoft.graph.copyToNotebook"
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"sectionGroup-id"+"}", _neturl.PathEscape(parameterToString(r.sectionGroupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"onenoteSection-id"+"}", _neturl.PathEscape(parameterToString(r.onenoteSectionId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"onenoteSection-id1"+"}", _neturl.PathEscape(parameterToString(r.onenoteSectionId1, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject315 == nil {
		return localVarReturnValue, nil, reportError("inlineObject315 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject315
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGroupsGroupOnenoteSectionGroupsSectionGroupSectionsOnenoteSectionParentNotebookSectionsOnenoteSectionCopyToSectionGroupRequest struct {
	ctx _context.Context
	ApiService *GroupsActionsApiService
	groupId string
	sectionGroupId string
	onenoteSectionId string
	onenoteSectionId1 string
	inlineObject316 *InlineObject316
}

func (r ApiGroupsGroupOnenoteSectionGroupsSectionGroupSectionsOnenoteSectionParentNotebookSectionsOnenoteSectionCopyToSectionGroupRequest) InlineObject316(inlineObject316 InlineObject316) ApiGroupsGroupOnenoteSectionGroupsSectionGroupSectionsOnenoteSectionParentNotebookSectionsOnenoteSectionCopyToSectionGroupRequest {
	r.inlineObject316 = &inlineObject316
	return r
}

func (r ApiGroupsGroupOnenoteSectionGroupsSectionGroupSectionsOnenoteSectionParentNotebookSectionsOnenoteSectionCopyToSectionGroupRequest) Execute() (AnyOfmicrosoftGraphOnenoteOperation, *_nethttp.Response, error) {
	return r.ApiService.GroupsGroupOnenoteSectionGroupsSectionGroupSectionsOnenoteSectionParentNotebookSectionsOnenoteSectionCopyToSectionGroupExecute(r)
}

/*
GroupsGroupOnenoteSectionGroupsSectionGroupSectionsOnenoteSectionParentNotebookSectionsOnenoteSectionCopyToSectionGroup Invoke action copyToSectionGroup

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupId key: id of group
 @param sectionGroupId key: id of sectionGroup
 @param onenoteSectionId key: id of onenoteSection
 @param onenoteSectionId1 key: id of onenoteSection
 @return ApiGroupsGroupOnenoteSectionGroupsSectionGroupSectionsOnenoteSectionParentNotebookSectionsOnenoteSectionCopyToSectionGroupRequest
*/
func (a *GroupsActionsApiService) GroupsGroupOnenoteSectionGroupsSectionGroupSectionsOnenoteSectionParentNotebookSectionsOnenoteSectionCopyToSectionGroup(ctx _context.Context, groupId string, sectionGroupId string, onenoteSectionId string, onenoteSectionId1 string) ApiGroupsGroupOnenoteSectionGroupsSectionGroupSectionsOnenoteSectionParentNotebookSectionsOnenoteSectionCopyToSectionGroupRequest {
	return ApiGroupsGroupOnenoteSectionGroupsSectionGroupSectionsOnenoteSectionParentNotebookSectionsOnenoteSectionCopyToSectionGroupRequest{
		ApiService: a,
		ctx: ctx,
		groupId: groupId,
		sectionGroupId: sectionGroupId,
		onenoteSectionId: onenoteSectionId,
		onenoteSectionId1: onenoteSectionId1,
	}
}

// Execute executes the request
//  @return AnyOfmicrosoftGraphOnenoteOperation
func (a *GroupsActionsApiService) GroupsGroupOnenoteSectionGroupsSectionGroupSectionsOnenoteSectionParentNotebookSectionsOnenoteSectionCopyToSectionGroupExecute(r ApiGroupsGroupOnenoteSectionGroupsSectionGroupSectionsOnenoteSectionParentNotebookSectionsOnenoteSectionCopyToSectionGroupRequest) (AnyOfmicrosoftGraphOnenoteOperation, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  AnyOfmicrosoftGraphOnenoteOperation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GroupsActionsApiService.GroupsGroupOnenoteSectionGroupsSectionGroupSectionsOnenoteSectionParentNotebookSectionsOnenoteSectionCopyToSectionGroup")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/groups/{group-id}/onenote/sectionGroups/{sectionGroup-id}/sections/{onenoteSection-id}/parentNotebook/sections/{onenoteSection-id1}/microsoft.graph.copyToSectionGroup"
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"sectionGroup-id"+"}", _neturl.PathEscape(parameterToString(r.sectionGroupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"onenoteSection-id"+"}", _neturl.PathEscape(parameterToString(r.onenoteSectionId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"onenoteSection-id1"+"}", _neturl.PathEscape(parameterToString(r.onenoteSectionId1, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject316 == nil {
		return localVarReturnValue, nil, reportError("inlineObject316 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject316
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGroupsGroupOnenoteSectionsOnenoteSectionCopyToNotebookRequest struct {
	ctx _context.Context
	ApiService *GroupsActionsApiService
	groupId string
	onenoteSectionId string
	inlineObject317 *InlineObject317
}

func (r ApiGroupsGroupOnenoteSectionsOnenoteSectionCopyToNotebookRequest) InlineObject317(inlineObject317 InlineObject317) ApiGroupsGroupOnenoteSectionsOnenoteSectionCopyToNotebookRequest {
	r.inlineObject317 = &inlineObject317
	return r
}

func (r ApiGroupsGroupOnenoteSectionsOnenoteSectionCopyToNotebookRequest) Execute() (AnyOfmicrosoftGraphOnenoteOperation, *_nethttp.Response, error) {
	return r.ApiService.GroupsGroupOnenoteSectionsOnenoteSectionCopyToNotebookExecute(r)
}

/*
GroupsGroupOnenoteSectionsOnenoteSectionCopyToNotebook Invoke action copyToNotebook

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupId key: id of group
 @param onenoteSectionId key: id of onenoteSection
 @return ApiGroupsGroupOnenoteSectionsOnenoteSectionCopyToNotebookRequest
*/
func (a *GroupsActionsApiService) GroupsGroupOnenoteSectionsOnenoteSectionCopyToNotebook(ctx _context.Context, groupId string, onenoteSectionId string) ApiGroupsGroupOnenoteSectionsOnenoteSectionCopyToNotebookRequest {
	return ApiGroupsGroupOnenoteSectionsOnenoteSectionCopyToNotebookRequest{
		ApiService: a,
		ctx: ctx,
		groupId: groupId,
		onenoteSectionId: onenoteSectionId,
	}
}

// Execute executes the request
//  @return AnyOfmicrosoftGraphOnenoteOperation
func (a *GroupsActionsApiService) GroupsGroupOnenoteSectionsOnenoteSectionCopyToNotebookExecute(r ApiGroupsGroupOnenoteSectionsOnenoteSectionCopyToNotebookRequest) (AnyOfmicrosoftGraphOnenoteOperation, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  AnyOfmicrosoftGraphOnenoteOperation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GroupsActionsApiService.GroupsGroupOnenoteSectionsOnenoteSectionCopyToNotebook")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/groups/{group-id}/onenote/sections/{onenoteSection-id}/microsoft.graph.copyToNotebook"
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"onenoteSection-id"+"}", _neturl.PathEscape(parameterToString(r.onenoteSectionId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject317 == nil {
		return localVarReturnValue, nil, reportError("inlineObject317 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject317
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGroupsGroupOnenoteSectionsOnenoteSectionCopyToSectionGroupRequest struct {
	ctx _context.Context
	ApiService *GroupsActionsApiService
	groupId string
	onenoteSectionId string
	inlineObject318 *InlineObject318
}

func (r ApiGroupsGroupOnenoteSectionsOnenoteSectionCopyToSectionGroupRequest) InlineObject318(inlineObject318 InlineObject318) ApiGroupsGroupOnenoteSectionsOnenoteSectionCopyToSectionGroupRequest {
	r.inlineObject318 = &inlineObject318
	return r
}

func (r ApiGroupsGroupOnenoteSectionsOnenoteSectionCopyToSectionGroupRequest) Execute() (AnyOfmicrosoftGraphOnenoteOperation, *_nethttp.Response, error) {
	return r.ApiService.GroupsGroupOnenoteSectionsOnenoteSectionCopyToSectionGroupExecute(r)
}

/*
GroupsGroupOnenoteSectionsOnenoteSectionCopyToSectionGroup Invoke action copyToSectionGroup

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupId key: id of group
 @param onenoteSectionId key: id of onenoteSection
 @return ApiGroupsGroupOnenoteSectionsOnenoteSectionCopyToSectionGroupRequest
*/
func (a *GroupsActionsApiService) GroupsGroupOnenoteSectionsOnenoteSectionCopyToSectionGroup(ctx _context.Context, groupId string, onenoteSectionId string) ApiGroupsGroupOnenoteSectionsOnenoteSectionCopyToSectionGroupRequest {
	return ApiGroupsGroupOnenoteSectionsOnenoteSectionCopyToSectionGroupRequest{
		ApiService: a,
		ctx: ctx,
		groupId: groupId,
		onenoteSectionId: onenoteSectionId,
	}
}

// Execute executes the request
//  @return AnyOfmicrosoftGraphOnenoteOperation
func (a *GroupsActionsApiService) GroupsGroupOnenoteSectionsOnenoteSectionCopyToSectionGroupExecute(r ApiGroupsGroupOnenoteSectionsOnenoteSectionCopyToSectionGroupRequest) (AnyOfmicrosoftGraphOnenoteOperation, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  AnyOfmicrosoftGraphOnenoteOperation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GroupsActionsApiService.GroupsGroupOnenoteSectionsOnenoteSectionCopyToSectionGroup")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/groups/{group-id}/onenote/sections/{onenoteSection-id}/microsoft.graph.copyToSectionGroup"
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"onenoteSection-id"+"}", _neturl.PathEscape(parameterToString(r.onenoteSectionId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject318 == nil {
		return localVarReturnValue, nil, reportError("inlineObject318 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject318
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGroupsGroupOnenoteSectionsOnenoteSectionPagesOnenotePageCopyToSectionRequest struct {
	ctx _context.Context
	ApiService *GroupsActionsApiService
	groupId string
	onenoteSectionId string
	onenotePageId string
	inlineObject319 *InlineObject319
}

func (r ApiGroupsGroupOnenoteSectionsOnenoteSectionPagesOnenotePageCopyToSectionRequest) InlineObject319(inlineObject319 InlineObject319) ApiGroupsGroupOnenoteSectionsOnenoteSectionPagesOnenotePageCopyToSectionRequest {
	r.inlineObject319 = &inlineObject319
	return r
}

func (r ApiGroupsGroupOnenoteSectionsOnenoteSectionPagesOnenotePageCopyToSectionRequest) Execute() (AnyOfmicrosoftGraphOnenoteOperation, *_nethttp.Response, error) {
	return r.ApiService.GroupsGroupOnenoteSectionsOnenoteSectionPagesOnenotePageCopyToSectionExecute(r)
}

/*
GroupsGroupOnenoteSectionsOnenoteSectionPagesOnenotePageCopyToSection Invoke action copyToSection

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupId key: id of group
 @param onenoteSectionId key: id of onenoteSection
 @param onenotePageId key: id of onenotePage
 @return ApiGroupsGroupOnenoteSectionsOnenoteSectionPagesOnenotePageCopyToSectionRequest
*/
func (a *GroupsActionsApiService) GroupsGroupOnenoteSectionsOnenoteSectionPagesOnenotePageCopyToSection(ctx _context.Context, groupId string, onenoteSectionId string, onenotePageId string) ApiGroupsGroupOnenoteSectionsOnenoteSectionPagesOnenotePageCopyToSectionRequest {
	return ApiGroupsGroupOnenoteSectionsOnenoteSectionPagesOnenotePageCopyToSectionRequest{
		ApiService: a,
		ctx: ctx,
		groupId: groupId,
		onenoteSectionId: onenoteSectionId,
		onenotePageId: onenotePageId,
	}
}

// Execute executes the request
//  @return AnyOfmicrosoftGraphOnenoteOperation
func (a *GroupsActionsApiService) GroupsGroupOnenoteSectionsOnenoteSectionPagesOnenotePageCopyToSectionExecute(r ApiGroupsGroupOnenoteSectionsOnenoteSectionPagesOnenotePageCopyToSectionRequest) (AnyOfmicrosoftGraphOnenoteOperation, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  AnyOfmicrosoftGraphOnenoteOperation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GroupsActionsApiService.GroupsGroupOnenoteSectionsOnenoteSectionPagesOnenotePageCopyToSection")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/groups/{group-id}/onenote/sections/{onenoteSection-id}/pages/{onenotePage-id}/microsoft.graph.copyToSection"
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"onenoteSection-id"+"}", _neturl.PathEscape(parameterToString(r.onenoteSectionId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"onenotePage-id"+"}", _neturl.PathEscape(parameterToString(r.onenotePageId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject319 == nil {
		return localVarReturnValue, nil, reportError("inlineObject319 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject319
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGroupsGroupOnenoteSectionsOnenoteSectionPagesOnenotePageOnenotePatchContentRequest struct {
	ctx _context.Context
	ApiService *GroupsActionsApiService
	groupId string
	onenoteSectionId string
	onenotePageId string
	inlineObject320 *InlineObject320
}

func (r ApiGroupsGroupOnenoteSectionsOnenoteSectionPagesOnenotePageOnenotePatchContentRequest) InlineObject320(inlineObject320 InlineObject320) ApiGroupsGroupOnenoteSectionsOnenoteSectionPagesOnenotePageOnenotePatchContentRequest {
	r.inlineObject320 = &inlineObject320
	return r
}

func (r ApiGroupsGroupOnenoteSectionsOnenoteSectionPagesOnenotePageOnenotePatchContentRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.GroupsGroupOnenoteSectionsOnenoteSectionPagesOnenotePageOnenotePatchContentExecute(r)
}

/*
GroupsGroupOnenoteSectionsOnenoteSectionPagesOnenotePageOnenotePatchContent Invoke action onenotePatchContent

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupId key: id of group
 @param onenoteSectionId key: id of onenoteSection
 @param onenotePageId key: id of onenotePage
 @return ApiGroupsGroupOnenoteSectionsOnenoteSectionPagesOnenotePageOnenotePatchContentRequest
*/
func (a *GroupsActionsApiService) GroupsGroupOnenoteSectionsOnenoteSectionPagesOnenotePageOnenotePatchContent(ctx _context.Context, groupId string, onenoteSectionId string, onenotePageId string) ApiGroupsGroupOnenoteSectionsOnenoteSectionPagesOnenotePageOnenotePatchContentRequest {
	return ApiGroupsGroupOnenoteSectionsOnenoteSectionPagesOnenotePageOnenotePatchContentRequest{
		ApiService: a,
		ctx: ctx,
		groupId: groupId,
		onenoteSectionId: onenoteSectionId,
		onenotePageId: onenotePageId,
	}
}

// Execute executes the request
func (a *GroupsActionsApiService) GroupsGroupOnenoteSectionsOnenoteSectionPagesOnenotePageOnenotePatchContentExecute(r ApiGroupsGroupOnenoteSectionsOnenoteSectionPagesOnenotePageOnenotePatchContentRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GroupsActionsApiService.GroupsGroupOnenoteSectionsOnenoteSectionPagesOnenotePageOnenotePatchContent")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/groups/{group-id}/onenote/sections/{onenoteSection-id}/pages/{onenotePage-id}/microsoft.graph.onenotePatchContent"
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"onenoteSection-id"+"}", _neturl.PathEscape(parameterToString(r.onenoteSectionId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"onenotePage-id"+"}", _neturl.PathEscape(parameterToString(r.onenotePageId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject320 == nil {
		return nil, reportError("inlineObject320 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject320
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGroupsGroupOnenoteSectionsOnenoteSectionPagesOnenotePageParentNotebookCopyNotebookRequest struct {
	ctx _context.Context
	ApiService *GroupsActionsApiService
	groupId string
	onenoteSectionId string
	onenotePageId string
	inlineObject321 *InlineObject321
}

func (r ApiGroupsGroupOnenoteSectionsOnenoteSectionPagesOnenotePageParentNotebookCopyNotebookRequest) InlineObject321(inlineObject321 InlineObject321) ApiGroupsGroupOnenoteSectionsOnenoteSectionPagesOnenotePageParentNotebookCopyNotebookRequest {
	r.inlineObject321 = &inlineObject321
	return r
}

func (r ApiGroupsGroupOnenoteSectionsOnenoteSectionPagesOnenotePageParentNotebookCopyNotebookRequest) Execute() (AnyOfmicrosoftGraphOnenoteOperation, *_nethttp.Response, error) {
	return r.ApiService.GroupsGroupOnenoteSectionsOnenoteSectionPagesOnenotePageParentNotebookCopyNotebookExecute(r)
}

/*
GroupsGroupOnenoteSectionsOnenoteSectionPagesOnenotePageParentNotebookCopyNotebook Invoke action copyNotebook

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupId key: id of group
 @param onenoteSectionId key: id of onenoteSection
 @param onenotePageId key: id of onenotePage
 @return ApiGroupsGroupOnenoteSectionsOnenoteSectionPagesOnenotePageParentNotebookCopyNotebookRequest
*/
func (a *GroupsActionsApiService) GroupsGroupOnenoteSectionsOnenoteSectionPagesOnenotePageParentNotebookCopyNotebook(ctx _context.Context, groupId string, onenoteSectionId string, onenotePageId string) ApiGroupsGroupOnenoteSectionsOnenoteSectionPagesOnenotePageParentNotebookCopyNotebookRequest {
	return ApiGroupsGroupOnenoteSectionsOnenoteSectionPagesOnenotePageParentNotebookCopyNotebookRequest{
		ApiService: a,
		ctx: ctx,
		groupId: groupId,
		onenoteSectionId: onenoteSectionId,
		onenotePageId: onenotePageId,
	}
}

// Execute executes the request
//  @return AnyOfmicrosoftGraphOnenoteOperation
func (a *GroupsActionsApiService) GroupsGroupOnenoteSectionsOnenoteSectionPagesOnenotePageParentNotebookCopyNotebookExecute(r ApiGroupsGroupOnenoteSectionsOnenoteSectionPagesOnenotePageParentNotebookCopyNotebookRequest) (AnyOfmicrosoftGraphOnenoteOperation, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  AnyOfmicrosoftGraphOnenoteOperation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GroupsActionsApiService.GroupsGroupOnenoteSectionsOnenoteSectionPagesOnenotePageParentNotebookCopyNotebook")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/groups/{group-id}/onenote/sections/{onenoteSection-id}/pages/{onenotePage-id}/parentNotebook/microsoft.graph.copyNotebook"
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"onenoteSection-id"+"}", _neturl.PathEscape(parameterToString(r.onenoteSectionId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"onenotePage-id"+"}", _neturl.PathEscape(parameterToString(r.onenotePageId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject321 == nil {
		return localVarReturnValue, nil, reportError("inlineObject321 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject321
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGroupsGroupOnenoteSectionsOnenoteSectionPagesOnenotePageParentNotebookSectionGroupsSectionGroupParentNotebookCopyNotebookRequest struct {
	ctx _context.Context
	ApiService *GroupsActionsApiService
	groupId string
	onenoteSectionId string
	onenotePageId string
	sectionGroupId string
	inlineObject322 *InlineObject322
}

func (r ApiGroupsGroupOnenoteSectionsOnenoteSectionPagesOnenotePageParentNotebookSectionGroupsSectionGroupParentNotebookCopyNotebookRequest) InlineObject322(inlineObject322 InlineObject322) ApiGroupsGroupOnenoteSectionsOnenoteSectionPagesOnenotePageParentNotebookSectionGroupsSectionGroupParentNotebookCopyNotebookRequest {
	r.inlineObject322 = &inlineObject322
	return r
}

func (r ApiGroupsGroupOnenoteSectionsOnenoteSectionPagesOnenotePageParentNotebookSectionGroupsSectionGroupParentNotebookCopyNotebookRequest) Execute() (AnyOfmicrosoftGraphOnenoteOperation, *_nethttp.Response, error) {
	return r.ApiService.GroupsGroupOnenoteSectionsOnenoteSectionPagesOnenotePageParentNotebookSectionGroupsSectionGroupParentNotebookCopyNotebookExecute(r)
}

/*
GroupsGroupOnenoteSectionsOnenoteSectionPagesOnenotePageParentNotebookSectionGroupsSectionGroupParentNotebookCopyNotebook Invoke action copyNotebook

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupId key: id of group
 @param onenoteSectionId key: id of onenoteSection
 @param onenotePageId key: id of onenotePage
 @param sectionGroupId key: id of sectionGroup
 @return ApiGroupsGroupOnenoteSectionsOnenoteSectionPagesOnenotePageParentNotebookSectionGroupsSectionGroupParentNotebookCopyNotebookRequest
*/
func (a *GroupsActionsApiService) GroupsGroupOnenoteSectionsOnenoteSectionPagesOnenotePageParentNotebookSectionGroupsSectionGroupParentNotebookCopyNotebook(ctx _context.Context, groupId string, onenoteSectionId string, onenotePageId string, sectionGroupId string) ApiGroupsGroupOnenoteSectionsOnenoteSectionPagesOnenotePageParentNotebookSectionGroupsSectionGroupParentNotebookCopyNotebookRequest {
	return ApiGroupsGroupOnenoteSectionsOnenoteSectionPagesOnenotePageParentNotebookSectionGroupsSectionGroupParentNotebookCopyNotebookRequest{
		ApiService: a,
		ctx: ctx,
		groupId: groupId,
		onenoteSectionId: onenoteSectionId,
		onenotePageId: onenotePageId,
		sectionGroupId: sectionGroupId,
	}
}

// Execute executes the request
//  @return AnyOfmicrosoftGraphOnenoteOperation
func (a *GroupsActionsApiService) GroupsGroupOnenoteSectionsOnenoteSectionPagesOnenotePageParentNotebookSectionGroupsSectionGroupParentNotebookCopyNotebookExecute(r ApiGroupsGroupOnenoteSectionsOnenoteSectionPagesOnenotePageParentNotebookSectionGroupsSectionGroupParentNotebookCopyNotebookRequest) (AnyOfmicrosoftGraphOnenoteOperation, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  AnyOfmicrosoftGraphOnenoteOperation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GroupsActionsApiService.GroupsGroupOnenoteSectionsOnenoteSectionPagesOnenotePageParentNotebookSectionGroupsSectionGroupParentNotebookCopyNotebook")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/groups/{group-id}/onenote/sections/{onenoteSection-id}/pages/{onenotePage-id}/parentNotebook/sectionGroups/{sectionGroup-id}/parentNotebook/microsoft.graph.copyNotebook"
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"onenoteSection-id"+"}", _neturl.PathEscape(parameterToString(r.onenoteSectionId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"onenotePage-id"+"}", _neturl.PathEscape(parameterToString(r.onenotePageId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"sectionGroup-id"+"}", _neturl.PathEscape(parameterToString(r.sectionGroupId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject322 == nil {
		return localVarReturnValue, nil, reportError("inlineObject322 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject322
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGroupsGroupOnenoteSectionsOnenoteSectionPagesOnenotePageParentNotebookSectionGroupsSectionGroupSectionsOnenoteSectionCopyToNotebookRequest struct {
	ctx _context.Context
	ApiService *GroupsActionsApiService
	groupId string
	onenoteSectionId string
	onenotePageId string
	sectionGroupId string
	onenoteSectionId1 string
	inlineObject323 *InlineObject323
}

func (r ApiGroupsGroupOnenoteSectionsOnenoteSectionPagesOnenotePageParentNotebookSectionGroupsSectionGroupSectionsOnenoteSectionCopyToNotebookRequest) InlineObject323(inlineObject323 InlineObject323) ApiGroupsGroupOnenoteSectionsOnenoteSectionPagesOnenotePageParentNotebookSectionGroupsSectionGroupSectionsOnenoteSectionCopyToNotebookRequest {
	r.inlineObject323 = &inlineObject323
	return r
}

func (r ApiGroupsGroupOnenoteSectionsOnenoteSectionPagesOnenotePageParentNotebookSectionGroupsSectionGroupSectionsOnenoteSectionCopyToNotebookRequest) Execute() (AnyOfmicrosoftGraphOnenoteOperation, *_nethttp.Response, error) {
	return r.ApiService.GroupsGroupOnenoteSectionsOnenoteSectionPagesOnenotePageParentNotebookSectionGroupsSectionGroupSectionsOnenoteSectionCopyToNotebookExecute(r)
}

/*
GroupsGroupOnenoteSectionsOnenoteSectionPagesOnenotePageParentNotebookSectionGroupsSectionGroupSectionsOnenoteSectionCopyToNotebook Invoke action copyToNotebook

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupId key: id of group
 @param onenoteSectionId key: id of onenoteSection
 @param onenotePageId key: id of onenotePage
 @param sectionGroupId key: id of sectionGroup
 @param onenoteSectionId1 key: id of onenoteSection
 @return ApiGroupsGroupOnenoteSectionsOnenoteSectionPagesOnenotePageParentNotebookSectionGroupsSectionGroupSectionsOnenoteSectionCopyToNotebookRequest
*/
func (a *GroupsActionsApiService) GroupsGroupOnenoteSectionsOnenoteSectionPagesOnenotePageParentNotebookSectionGroupsSectionGroupSectionsOnenoteSectionCopyToNotebook(ctx _context.Context, groupId string, onenoteSectionId string, onenotePageId string, sectionGroupId string, onenoteSectionId1 string) ApiGroupsGroupOnenoteSectionsOnenoteSectionPagesOnenotePageParentNotebookSectionGroupsSectionGroupSectionsOnenoteSectionCopyToNotebookRequest {
	return ApiGroupsGroupOnenoteSectionsOnenoteSectionPagesOnenotePageParentNotebookSectionGroupsSectionGroupSectionsOnenoteSectionCopyToNotebookRequest{
		ApiService: a,
		ctx: ctx,
		groupId: groupId,
		onenoteSectionId: onenoteSectionId,
		onenotePageId: onenotePageId,
		sectionGroupId: sectionGroupId,
		onenoteSectionId1: onenoteSectionId1,
	}
}

// Execute executes the request
//  @return AnyOfmicrosoftGraphOnenoteOperation
func (a *GroupsActionsApiService) GroupsGroupOnenoteSectionsOnenoteSectionPagesOnenotePageParentNotebookSectionGroupsSectionGroupSectionsOnenoteSectionCopyToNotebookExecute(r ApiGroupsGroupOnenoteSectionsOnenoteSectionPagesOnenotePageParentNotebookSectionGroupsSectionGroupSectionsOnenoteSectionCopyToNotebookRequest) (AnyOfmicrosoftGraphOnenoteOperation, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  AnyOfmicrosoftGraphOnenoteOperation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GroupsActionsApiService.GroupsGroupOnenoteSectionsOnenoteSectionPagesOnenotePageParentNotebookSectionGroupsSectionGroupSectionsOnenoteSectionCopyToNotebook")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/groups/{group-id}/onenote/sections/{onenoteSection-id}/pages/{onenotePage-id}/parentNotebook/sectionGroups/{sectionGroup-id}/sections/{onenoteSection-id1}/microsoft.graph.copyToNotebook"
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"onenoteSection-id"+"}", _neturl.PathEscape(parameterToString(r.onenoteSectionId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"onenotePage-id"+"}", _neturl.PathEscape(parameterToString(r.onenotePageId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"sectionGroup-id"+"}", _neturl.PathEscape(parameterToString(r.sectionGroupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"onenoteSection-id1"+"}", _neturl.PathEscape(parameterToString(r.onenoteSectionId1, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject323 == nil {
		return localVarReturnValue, nil, reportError("inlineObject323 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject323
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGroupsGroupOnenoteSectionsOnenoteSectionPagesOnenotePageParentNotebookSectionGroupsSectionGroupSectionsOnenoteSectionCopyToSectionGroupRequest struct {
	ctx _context.Context
	ApiService *GroupsActionsApiService
	groupId string
	onenoteSectionId string
	onenotePageId string
	sectionGroupId string
	onenoteSectionId1 string
	inlineObject324 *InlineObject324
}

func (r ApiGroupsGroupOnenoteSectionsOnenoteSectionPagesOnenotePageParentNotebookSectionGroupsSectionGroupSectionsOnenoteSectionCopyToSectionGroupRequest) InlineObject324(inlineObject324 InlineObject324) ApiGroupsGroupOnenoteSectionsOnenoteSectionPagesOnenotePageParentNotebookSectionGroupsSectionGroupSectionsOnenoteSectionCopyToSectionGroupRequest {
	r.inlineObject324 = &inlineObject324
	return r
}

func (r ApiGroupsGroupOnenoteSectionsOnenoteSectionPagesOnenotePageParentNotebookSectionGroupsSectionGroupSectionsOnenoteSectionCopyToSectionGroupRequest) Execute() (AnyOfmicrosoftGraphOnenoteOperation, *_nethttp.Response, error) {
	return r.ApiService.GroupsGroupOnenoteSectionsOnenoteSectionPagesOnenotePageParentNotebookSectionGroupsSectionGroupSectionsOnenoteSectionCopyToSectionGroupExecute(r)
}

/*
GroupsGroupOnenoteSectionsOnenoteSectionPagesOnenotePageParentNotebookSectionGroupsSectionGroupSectionsOnenoteSectionCopyToSectionGroup Invoke action copyToSectionGroup

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupId key: id of group
 @param onenoteSectionId key: id of onenoteSection
 @param onenotePageId key: id of onenotePage
 @param sectionGroupId key: id of sectionGroup
 @param onenoteSectionId1 key: id of onenoteSection
 @return ApiGroupsGroupOnenoteSectionsOnenoteSectionPagesOnenotePageParentNotebookSectionGroupsSectionGroupSectionsOnenoteSectionCopyToSectionGroupRequest
*/
func (a *GroupsActionsApiService) GroupsGroupOnenoteSectionsOnenoteSectionPagesOnenotePageParentNotebookSectionGroupsSectionGroupSectionsOnenoteSectionCopyToSectionGroup(ctx _context.Context, groupId string, onenoteSectionId string, onenotePageId string, sectionGroupId string, onenoteSectionId1 string) ApiGroupsGroupOnenoteSectionsOnenoteSectionPagesOnenotePageParentNotebookSectionGroupsSectionGroupSectionsOnenoteSectionCopyToSectionGroupRequest {
	return ApiGroupsGroupOnenoteSectionsOnenoteSectionPagesOnenotePageParentNotebookSectionGroupsSectionGroupSectionsOnenoteSectionCopyToSectionGroupRequest{
		ApiService: a,
		ctx: ctx,
		groupId: groupId,
		onenoteSectionId: onenoteSectionId,
		onenotePageId: onenotePageId,
		sectionGroupId: sectionGroupId,
		onenoteSectionId1: onenoteSectionId1,
	}
}

// Execute executes the request
//  @return AnyOfmicrosoftGraphOnenoteOperation
func (a *GroupsActionsApiService) GroupsGroupOnenoteSectionsOnenoteSectionPagesOnenotePageParentNotebookSectionGroupsSectionGroupSectionsOnenoteSectionCopyToSectionGroupExecute(r ApiGroupsGroupOnenoteSectionsOnenoteSectionPagesOnenotePageParentNotebookSectionGroupsSectionGroupSectionsOnenoteSectionCopyToSectionGroupRequest) (AnyOfmicrosoftGraphOnenoteOperation, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  AnyOfmicrosoftGraphOnenoteOperation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GroupsActionsApiService.GroupsGroupOnenoteSectionsOnenoteSectionPagesOnenotePageParentNotebookSectionGroupsSectionGroupSectionsOnenoteSectionCopyToSectionGroup")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/groups/{group-id}/onenote/sections/{onenoteSection-id}/pages/{onenotePage-id}/parentNotebook/sectionGroups/{sectionGroup-id}/sections/{onenoteSection-id1}/microsoft.graph.copyToSectionGroup"
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"onenoteSection-id"+"}", _neturl.PathEscape(parameterToString(r.onenoteSectionId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"onenotePage-id"+"}", _neturl.PathEscape(parameterToString(r.onenotePageId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"sectionGroup-id"+"}", _neturl.PathEscape(parameterToString(r.sectionGroupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"onenoteSection-id1"+"}", _neturl.PathEscape(parameterToString(r.onenoteSectionId1, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject324 == nil {
		return localVarReturnValue, nil, reportError("inlineObject324 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject324
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGroupsGroupOnenoteSectionsOnenoteSectionPagesOnenotePageParentNotebookSectionsOnenoteSectionCopyToNotebookRequest struct {
	ctx _context.Context
	ApiService *GroupsActionsApiService
	groupId string
	onenoteSectionId string
	onenotePageId string
	onenoteSectionId1 string
	inlineObject325 *InlineObject325
}

func (r ApiGroupsGroupOnenoteSectionsOnenoteSectionPagesOnenotePageParentNotebookSectionsOnenoteSectionCopyToNotebookRequest) InlineObject325(inlineObject325 InlineObject325) ApiGroupsGroupOnenoteSectionsOnenoteSectionPagesOnenotePageParentNotebookSectionsOnenoteSectionCopyToNotebookRequest {
	r.inlineObject325 = &inlineObject325
	return r
}

func (r ApiGroupsGroupOnenoteSectionsOnenoteSectionPagesOnenotePageParentNotebookSectionsOnenoteSectionCopyToNotebookRequest) Execute() (AnyOfmicrosoftGraphOnenoteOperation, *_nethttp.Response, error) {
	return r.ApiService.GroupsGroupOnenoteSectionsOnenoteSectionPagesOnenotePageParentNotebookSectionsOnenoteSectionCopyToNotebookExecute(r)
}

/*
GroupsGroupOnenoteSectionsOnenoteSectionPagesOnenotePageParentNotebookSectionsOnenoteSectionCopyToNotebook Invoke action copyToNotebook

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupId key: id of group
 @param onenoteSectionId key: id of onenoteSection
 @param onenotePageId key: id of onenotePage
 @param onenoteSectionId1 key: id of onenoteSection
 @return ApiGroupsGroupOnenoteSectionsOnenoteSectionPagesOnenotePageParentNotebookSectionsOnenoteSectionCopyToNotebookRequest
*/
func (a *GroupsActionsApiService) GroupsGroupOnenoteSectionsOnenoteSectionPagesOnenotePageParentNotebookSectionsOnenoteSectionCopyToNotebook(ctx _context.Context, groupId string, onenoteSectionId string, onenotePageId string, onenoteSectionId1 string) ApiGroupsGroupOnenoteSectionsOnenoteSectionPagesOnenotePageParentNotebookSectionsOnenoteSectionCopyToNotebookRequest {
	return ApiGroupsGroupOnenoteSectionsOnenoteSectionPagesOnenotePageParentNotebookSectionsOnenoteSectionCopyToNotebookRequest{
		ApiService: a,
		ctx: ctx,
		groupId: groupId,
		onenoteSectionId: onenoteSectionId,
		onenotePageId: onenotePageId,
		onenoteSectionId1: onenoteSectionId1,
	}
}

// Execute executes the request
//  @return AnyOfmicrosoftGraphOnenoteOperation
func (a *GroupsActionsApiService) GroupsGroupOnenoteSectionsOnenoteSectionPagesOnenotePageParentNotebookSectionsOnenoteSectionCopyToNotebookExecute(r ApiGroupsGroupOnenoteSectionsOnenoteSectionPagesOnenotePageParentNotebookSectionsOnenoteSectionCopyToNotebookRequest) (AnyOfmicrosoftGraphOnenoteOperation, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  AnyOfmicrosoftGraphOnenoteOperation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GroupsActionsApiService.GroupsGroupOnenoteSectionsOnenoteSectionPagesOnenotePageParentNotebookSectionsOnenoteSectionCopyToNotebook")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/groups/{group-id}/onenote/sections/{onenoteSection-id}/pages/{onenotePage-id}/parentNotebook/sections/{onenoteSection-id1}/microsoft.graph.copyToNotebook"
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"onenoteSection-id"+"}", _neturl.PathEscape(parameterToString(r.onenoteSectionId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"onenotePage-id"+"}", _neturl.PathEscape(parameterToString(r.onenotePageId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"onenoteSection-id1"+"}", _neturl.PathEscape(parameterToString(r.onenoteSectionId1, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject325 == nil {
		return localVarReturnValue, nil, reportError("inlineObject325 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject325
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGroupsGroupOnenoteSectionsOnenoteSectionPagesOnenotePageParentNotebookSectionsOnenoteSectionCopyToSectionGroupRequest struct {
	ctx _context.Context
	ApiService *GroupsActionsApiService
	groupId string
	onenoteSectionId string
	onenotePageId string
	onenoteSectionId1 string
	inlineObject326 *InlineObject326
}

func (r ApiGroupsGroupOnenoteSectionsOnenoteSectionPagesOnenotePageParentNotebookSectionsOnenoteSectionCopyToSectionGroupRequest) InlineObject326(inlineObject326 InlineObject326) ApiGroupsGroupOnenoteSectionsOnenoteSectionPagesOnenotePageParentNotebookSectionsOnenoteSectionCopyToSectionGroupRequest {
	r.inlineObject326 = &inlineObject326
	return r
}

func (r ApiGroupsGroupOnenoteSectionsOnenoteSectionPagesOnenotePageParentNotebookSectionsOnenoteSectionCopyToSectionGroupRequest) Execute() (AnyOfmicrosoftGraphOnenoteOperation, *_nethttp.Response, error) {
	return r.ApiService.GroupsGroupOnenoteSectionsOnenoteSectionPagesOnenotePageParentNotebookSectionsOnenoteSectionCopyToSectionGroupExecute(r)
}

/*
GroupsGroupOnenoteSectionsOnenoteSectionPagesOnenotePageParentNotebookSectionsOnenoteSectionCopyToSectionGroup Invoke action copyToSectionGroup

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupId key: id of group
 @param onenoteSectionId key: id of onenoteSection
 @param onenotePageId key: id of onenotePage
 @param onenoteSectionId1 key: id of onenoteSection
 @return ApiGroupsGroupOnenoteSectionsOnenoteSectionPagesOnenotePageParentNotebookSectionsOnenoteSectionCopyToSectionGroupRequest
*/
func (a *GroupsActionsApiService) GroupsGroupOnenoteSectionsOnenoteSectionPagesOnenotePageParentNotebookSectionsOnenoteSectionCopyToSectionGroup(ctx _context.Context, groupId string, onenoteSectionId string, onenotePageId string, onenoteSectionId1 string) ApiGroupsGroupOnenoteSectionsOnenoteSectionPagesOnenotePageParentNotebookSectionsOnenoteSectionCopyToSectionGroupRequest {
	return ApiGroupsGroupOnenoteSectionsOnenoteSectionPagesOnenotePageParentNotebookSectionsOnenoteSectionCopyToSectionGroupRequest{
		ApiService: a,
		ctx: ctx,
		groupId: groupId,
		onenoteSectionId: onenoteSectionId,
		onenotePageId: onenotePageId,
		onenoteSectionId1: onenoteSectionId1,
	}
}

// Execute executes the request
//  @return AnyOfmicrosoftGraphOnenoteOperation
func (a *GroupsActionsApiService) GroupsGroupOnenoteSectionsOnenoteSectionPagesOnenotePageParentNotebookSectionsOnenoteSectionCopyToSectionGroupExecute(r ApiGroupsGroupOnenoteSectionsOnenoteSectionPagesOnenotePageParentNotebookSectionsOnenoteSectionCopyToSectionGroupRequest) (AnyOfmicrosoftGraphOnenoteOperation, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  AnyOfmicrosoftGraphOnenoteOperation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GroupsActionsApiService.GroupsGroupOnenoteSectionsOnenoteSectionPagesOnenotePageParentNotebookSectionsOnenoteSectionCopyToSectionGroup")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/groups/{group-id}/onenote/sections/{onenoteSection-id}/pages/{onenotePage-id}/parentNotebook/sections/{onenoteSection-id1}/microsoft.graph.copyToSectionGroup"
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"onenoteSection-id"+"}", _neturl.PathEscape(parameterToString(r.onenoteSectionId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"onenotePage-id"+"}", _neturl.PathEscape(parameterToString(r.onenotePageId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"onenoteSection-id1"+"}", _neturl.PathEscape(parameterToString(r.onenoteSectionId1, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject326 == nil {
		return localVarReturnValue, nil, reportError("inlineObject326 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject326
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGroupsGroupOnenoteSectionsOnenoteSectionPagesOnenotePageParentSectionCopyToNotebookRequest struct {
	ctx _context.Context
	ApiService *GroupsActionsApiService
	groupId string
	onenoteSectionId string
	onenotePageId string
	inlineObject327 *InlineObject327
}

func (r ApiGroupsGroupOnenoteSectionsOnenoteSectionPagesOnenotePageParentSectionCopyToNotebookRequest) InlineObject327(inlineObject327 InlineObject327) ApiGroupsGroupOnenoteSectionsOnenoteSectionPagesOnenotePageParentSectionCopyToNotebookRequest {
	r.inlineObject327 = &inlineObject327
	return r
}

func (r ApiGroupsGroupOnenoteSectionsOnenoteSectionPagesOnenotePageParentSectionCopyToNotebookRequest) Execute() (AnyOfmicrosoftGraphOnenoteOperation, *_nethttp.Response, error) {
	return r.ApiService.GroupsGroupOnenoteSectionsOnenoteSectionPagesOnenotePageParentSectionCopyToNotebookExecute(r)
}

/*
GroupsGroupOnenoteSectionsOnenoteSectionPagesOnenotePageParentSectionCopyToNotebook Invoke action copyToNotebook

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupId key: id of group
 @param onenoteSectionId key: id of onenoteSection
 @param onenotePageId key: id of onenotePage
 @return ApiGroupsGroupOnenoteSectionsOnenoteSectionPagesOnenotePageParentSectionCopyToNotebookRequest
*/
func (a *GroupsActionsApiService) GroupsGroupOnenoteSectionsOnenoteSectionPagesOnenotePageParentSectionCopyToNotebook(ctx _context.Context, groupId string, onenoteSectionId string, onenotePageId string) ApiGroupsGroupOnenoteSectionsOnenoteSectionPagesOnenotePageParentSectionCopyToNotebookRequest {
	return ApiGroupsGroupOnenoteSectionsOnenoteSectionPagesOnenotePageParentSectionCopyToNotebookRequest{
		ApiService: a,
		ctx: ctx,
		groupId: groupId,
		onenoteSectionId: onenoteSectionId,
		onenotePageId: onenotePageId,
	}
}

// Execute executes the request
//  @return AnyOfmicrosoftGraphOnenoteOperation
func (a *GroupsActionsApiService) GroupsGroupOnenoteSectionsOnenoteSectionPagesOnenotePageParentSectionCopyToNotebookExecute(r ApiGroupsGroupOnenoteSectionsOnenoteSectionPagesOnenotePageParentSectionCopyToNotebookRequest) (AnyOfmicrosoftGraphOnenoteOperation, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  AnyOfmicrosoftGraphOnenoteOperation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GroupsActionsApiService.GroupsGroupOnenoteSectionsOnenoteSectionPagesOnenotePageParentSectionCopyToNotebook")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/groups/{group-id}/onenote/sections/{onenoteSection-id}/pages/{onenotePage-id}/parentSection/microsoft.graph.copyToNotebook"
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"onenoteSection-id"+"}", _neturl.PathEscape(parameterToString(r.onenoteSectionId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"onenotePage-id"+"}", _neturl.PathEscape(parameterToString(r.onenotePageId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject327 == nil {
		return localVarReturnValue, nil, reportError("inlineObject327 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject327
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGroupsGroupOnenoteSectionsOnenoteSectionPagesOnenotePageParentSectionCopyToSectionGroupRequest struct {
	ctx _context.Context
	ApiService *GroupsActionsApiService
	groupId string
	onenoteSectionId string
	onenotePageId string
	inlineObject328 *InlineObject328
}

func (r ApiGroupsGroupOnenoteSectionsOnenoteSectionPagesOnenotePageParentSectionCopyToSectionGroupRequest) InlineObject328(inlineObject328 InlineObject328) ApiGroupsGroupOnenoteSectionsOnenoteSectionPagesOnenotePageParentSectionCopyToSectionGroupRequest {
	r.inlineObject328 = &inlineObject328
	return r
}

func (r ApiGroupsGroupOnenoteSectionsOnenoteSectionPagesOnenotePageParentSectionCopyToSectionGroupRequest) Execute() (AnyOfmicrosoftGraphOnenoteOperation, *_nethttp.Response, error) {
	return r.ApiService.GroupsGroupOnenoteSectionsOnenoteSectionPagesOnenotePageParentSectionCopyToSectionGroupExecute(r)
}

/*
GroupsGroupOnenoteSectionsOnenoteSectionPagesOnenotePageParentSectionCopyToSectionGroup Invoke action copyToSectionGroup

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupId key: id of group
 @param onenoteSectionId key: id of onenoteSection
 @param onenotePageId key: id of onenotePage
 @return ApiGroupsGroupOnenoteSectionsOnenoteSectionPagesOnenotePageParentSectionCopyToSectionGroupRequest
*/
func (a *GroupsActionsApiService) GroupsGroupOnenoteSectionsOnenoteSectionPagesOnenotePageParentSectionCopyToSectionGroup(ctx _context.Context, groupId string, onenoteSectionId string, onenotePageId string) ApiGroupsGroupOnenoteSectionsOnenoteSectionPagesOnenotePageParentSectionCopyToSectionGroupRequest {
	return ApiGroupsGroupOnenoteSectionsOnenoteSectionPagesOnenotePageParentSectionCopyToSectionGroupRequest{
		ApiService: a,
		ctx: ctx,
		groupId: groupId,
		onenoteSectionId: onenoteSectionId,
		onenotePageId: onenotePageId,
	}
}

// Execute executes the request
//  @return AnyOfmicrosoftGraphOnenoteOperation
func (a *GroupsActionsApiService) GroupsGroupOnenoteSectionsOnenoteSectionPagesOnenotePageParentSectionCopyToSectionGroupExecute(r ApiGroupsGroupOnenoteSectionsOnenoteSectionPagesOnenotePageParentSectionCopyToSectionGroupRequest) (AnyOfmicrosoftGraphOnenoteOperation, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  AnyOfmicrosoftGraphOnenoteOperation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GroupsActionsApiService.GroupsGroupOnenoteSectionsOnenoteSectionPagesOnenotePageParentSectionCopyToSectionGroup")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/groups/{group-id}/onenote/sections/{onenoteSection-id}/pages/{onenotePage-id}/parentSection/microsoft.graph.copyToSectionGroup"
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"onenoteSection-id"+"}", _neturl.PathEscape(parameterToString(r.onenoteSectionId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"onenotePage-id"+"}", _neturl.PathEscape(parameterToString(r.onenotePageId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject328 == nil {
		return localVarReturnValue, nil, reportError("inlineObject328 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject328
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGroupsGroupOnenoteSectionsOnenoteSectionParentNotebookCopyNotebookRequest struct {
	ctx _context.Context
	ApiService *GroupsActionsApiService
	groupId string
	onenoteSectionId string
	inlineObject329 *InlineObject329
}

func (r ApiGroupsGroupOnenoteSectionsOnenoteSectionParentNotebookCopyNotebookRequest) InlineObject329(inlineObject329 InlineObject329) ApiGroupsGroupOnenoteSectionsOnenoteSectionParentNotebookCopyNotebookRequest {
	r.inlineObject329 = &inlineObject329
	return r
}

func (r ApiGroupsGroupOnenoteSectionsOnenoteSectionParentNotebookCopyNotebookRequest) Execute() (AnyOfmicrosoftGraphOnenoteOperation, *_nethttp.Response, error) {
	return r.ApiService.GroupsGroupOnenoteSectionsOnenoteSectionParentNotebookCopyNotebookExecute(r)
}

/*
GroupsGroupOnenoteSectionsOnenoteSectionParentNotebookCopyNotebook Invoke action copyNotebook

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupId key: id of group
 @param onenoteSectionId key: id of onenoteSection
 @return ApiGroupsGroupOnenoteSectionsOnenoteSectionParentNotebookCopyNotebookRequest
*/
func (a *GroupsActionsApiService) GroupsGroupOnenoteSectionsOnenoteSectionParentNotebookCopyNotebook(ctx _context.Context, groupId string, onenoteSectionId string) ApiGroupsGroupOnenoteSectionsOnenoteSectionParentNotebookCopyNotebookRequest {
	return ApiGroupsGroupOnenoteSectionsOnenoteSectionParentNotebookCopyNotebookRequest{
		ApiService: a,
		ctx: ctx,
		groupId: groupId,
		onenoteSectionId: onenoteSectionId,
	}
}

// Execute executes the request
//  @return AnyOfmicrosoftGraphOnenoteOperation
func (a *GroupsActionsApiService) GroupsGroupOnenoteSectionsOnenoteSectionParentNotebookCopyNotebookExecute(r ApiGroupsGroupOnenoteSectionsOnenoteSectionParentNotebookCopyNotebookRequest) (AnyOfmicrosoftGraphOnenoteOperation, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  AnyOfmicrosoftGraphOnenoteOperation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GroupsActionsApiService.GroupsGroupOnenoteSectionsOnenoteSectionParentNotebookCopyNotebook")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/groups/{group-id}/onenote/sections/{onenoteSection-id}/parentNotebook/microsoft.graph.copyNotebook"
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"onenoteSection-id"+"}", _neturl.PathEscape(parameterToString(r.onenoteSectionId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject329 == nil {
		return localVarReturnValue, nil, reportError("inlineObject329 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject329
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGroupsGroupOnenoteSectionsOnenoteSectionParentNotebookSectionGroupsSectionGroupParentNotebookCopyNotebookRequest struct {
	ctx _context.Context
	ApiService *GroupsActionsApiService
	groupId string
	onenoteSectionId string
	sectionGroupId string
	inlineObject330 *InlineObject330
}

func (r ApiGroupsGroupOnenoteSectionsOnenoteSectionParentNotebookSectionGroupsSectionGroupParentNotebookCopyNotebookRequest) InlineObject330(inlineObject330 InlineObject330) ApiGroupsGroupOnenoteSectionsOnenoteSectionParentNotebookSectionGroupsSectionGroupParentNotebookCopyNotebookRequest {
	r.inlineObject330 = &inlineObject330
	return r
}

func (r ApiGroupsGroupOnenoteSectionsOnenoteSectionParentNotebookSectionGroupsSectionGroupParentNotebookCopyNotebookRequest) Execute() (AnyOfmicrosoftGraphOnenoteOperation, *_nethttp.Response, error) {
	return r.ApiService.GroupsGroupOnenoteSectionsOnenoteSectionParentNotebookSectionGroupsSectionGroupParentNotebookCopyNotebookExecute(r)
}

/*
GroupsGroupOnenoteSectionsOnenoteSectionParentNotebookSectionGroupsSectionGroupParentNotebookCopyNotebook Invoke action copyNotebook

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupId key: id of group
 @param onenoteSectionId key: id of onenoteSection
 @param sectionGroupId key: id of sectionGroup
 @return ApiGroupsGroupOnenoteSectionsOnenoteSectionParentNotebookSectionGroupsSectionGroupParentNotebookCopyNotebookRequest
*/
func (a *GroupsActionsApiService) GroupsGroupOnenoteSectionsOnenoteSectionParentNotebookSectionGroupsSectionGroupParentNotebookCopyNotebook(ctx _context.Context, groupId string, onenoteSectionId string, sectionGroupId string) ApiGroupsGroupOnenoteSectionsOnenoteSectionParentNotebookSectionGroupsSectionGroupParentNotebookCopyNotebookRequest {
	return ApiGroupsGroupOnenoteSectionsOnenoteSectionParentNotebookSectionGroupsSectionGroupParentNotebookCopyNotebookRequest{
		ApiService: a,
		ctx: ctx,
		groupId: groupId,
		onenoteSectionId: onenoteSectionId,
		sectionGroupId: sectionGroupId,
	}
}

// Execute executes the request
//  @return AnyOfmicrosoftGraphOnenoteOperation
func (a *GroupsActionsApiService) GroupsGroupOnenoteSectionsOnenoteSectionParentNotebookSectionGroupsSectionGroupParentNotebookCopyNotebookExecute(r ApiGroupsGroupOnenoteSectionsOnenoteSectionParentNotebookSectionGroupsSectionGroupParentNotebookCopyNotebookRequest) (AnyOfmicrosoftGraphOnenoteOperation, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  AnyOfmicrosoftGraphOnenoteOperation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GroupsActionsApiService.GroupsGroupOnenoteSectionsOnenoteSectionParentNotebookSectionGroupsSectionGroupParentNotebookCopyNotebook")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/groups/{group-id}/onenote/sections/{onenoteSection-id}/parentNotebook/sectionGroups/{sectionGroup-id}/parentNotebook/microsoft.graph.copyNotebook"
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"onenoteSection-id"+"}", _neturl.PathEscape(parameterToString(r.onenoteSectionId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"sectionGroup-id"+"}", _neturl.PathEscape(parameterToString(r.sectionGroupId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject330 == nil {
		return localVarReturnValue, nil, reportError("inlineObject330 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject330
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGroupsGroupOnenoteSectionsOnenoteSectionParentNotebookSectionGroupsSectionGroupSectionsOnenoteSectionCopyToNotebookRequest struct {
	ctx _context.Context
	ApiService *GroupsActionsApiService
	groupId string
	onenoteSectionId string
	sectionGroupId string
	onenoteSectionId1 string
	inlineObject331 *InlineObject331
}

func (r ApiGroupsGroupOnenoteSectionsOnenoteSectionParentNotebookSectionGroupsSectionGroupSectionsOnenoteSectionCopyToNotebookRequest) InlineObject331(inlineObject331 InlineObject331) ApiGroupsGroupOnenoteSectionsOnenoteSectionParentNotebookSectionGroupsSectionGroupSectionsOnenoteSectionCopyToNotebookRequest {
	r.inlineObject331 = &inlineObject331
	return r
}

func (r ApiGroupsGroupOnenoteSectionsOnenoteSectionParentNotebookSectionGroupsSectionGroupSectionsOnenoteSectionCopyToNotebookRequest) Execute() (AnyOfmicrosoftGraphOnenoteOperation, *_nethttp.Response, error) {
	return r.ApiService.GroupsGroupOnenoteSectionsOnenoteSectionParentNotebookSectionGroupsSectionGroupSectionsOnenoteSectionCopyToNotebookExecute(r)
}

/*
GroupsGroupOnenoteSectionsOnenoteSectionParentNotebookSectionGroupsSectionGroupSectionsOnenoteSectionCopyToNotebook Invoke action copyToNotebook

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupId key: id of group
 @param onenoteSectionId key: id of onenoteSection
 @param sectionGroupId key: id of sectionGroup
 @param onenoteSectionId1 key: id of onenoteSection
 @return ApiGroupsGroupOnenoteSectionsOnenoteSectionParentNotebookSectionGroupsSectionGroupSectionsOnenoteSectionCopyToNotebookRequest
*/
func (a *GroupsActionsApiService) GroupsGroupOnenoteSectionsOnenoteSectionParentNotebookSectionGroupsSectionGroupSectionsOnenoteSectionCopyToNotebook(ctx _context.Context, groupId string, onenoteSectionId string, sectionGroupId string, onenoteSectionId1 string) ApiGroupsGroupOnenoteSectionsOnenoteSectionParentNotebookSectionGroupsSectionGroupSectionsOnenoteSectionCopyToNotebookRequest {
	return ApiGroupsGroupOnenoteSectionsOnenoteSectionParentNotebookSectionGroupsSectionGroupSectionsOnenoteSectionCopyToNotebookRequest{
		ApiService: a,
		ctx: ctx,
		groupId: groupId,
		onenoteSectionId: onenoteSectionId,
		sectionGroupId: sectionGroupId,
		onenoteSectionId1: onenoteSectionId1,
	}
}

// Execute executes the request
//  @return AnyOfmicrosoftGraphOnenoteOperation
func (a *GroupsActionsApiService) GroupsGroupOnenoteSectionsOnenoteSectionParentNotebookSectionGroupsSectionGroupSectionsOnenoteSectionCopyToNotebookExecute(r ApiGroupsGroupOnenoteSectionsOnenoteSectionParentNotebookSectionGroupsSectionGroupSectionsOnenoteSectionCopyToNotebookRequest) (AnyOfmicrosoftGraphOnenoteOperation, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  AnyOfmicrosoftGraphOnenoteOperation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GroupsActionsApiService.GroupsGroupOnenoteSectionsOnenoteSectionParentNotebookSectionGroupsSectionGroupSectionsOnenoteSectionCopyToNotebook")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/groups/{group-id}/onenote/sections/{onenoteSection-id}/parentNotebook/sectionGroups/{sectionGroup-id}/sections/{onenoteSection-id1}/microsoft.graph.copyToNotebook"
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"onenoteSection-id"+"}", _neturl.PathEscape(parameterToString(r.onenoteSectionId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"sectionGroup-id"+"}", _neturl.PathEscape(parameterToString(r.sectionGroupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"onenoteSection-id1"+"}", _neturl.PathEscape(parameterToString(r.onenoteSectionId1, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject331 == nil {
		return localVarReturnValue, nil, reportError("inlineObject331 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject331
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGroupsGroupOnenoteSectionsOnenoteSectionParentNotebookSectionGroupsSectionGroupSectionsOnenoteSectionCopyToSectionGroupRequest struct {
	ctx _context.Context
	ApiService *GroupsActionsApiService
	groupId string
	onenoteSectionId string
	sectionGroupId string
	onenoteSectionId1 string
	inlineObject332 *InlineObject332
}

func (r ApiGroupsGroupOnenoteSectionsOnenoteSectionParentNotebookSectionGroupsSectionGroupSectionsOnenoteSectionCopyToSectionGroupRequest) InlineObject332(inlineObject332 InlineObject332) ApiGroupsGroupOnenoteSectionsOnenoteSectionParentNotebookSectionGroupsSectionGroupSectionsOnenoteSectionCopyToSectionGroupRequest {
	r.inlineObject332 = &inlineObject332
	return r
}

func (r ApiGroupsGroupOnenoteSectionsOnenoteSectionParentNotebookSectionGroupsSectionGroupSectionsOnenoteSectionCopyToSectionGroupRequest) Execute() (AnyOfmicrosoftGraphOnenoteOperation, *_nethttp.Response, error) {
	return r.ApiService.GroupsGroupOnenoteSectionsOnenoteSectionParentNotebookSectionGroupsSectionGroupSectionsOnenoteSectionCopyToSectionGroupExecute(r)
}

/*
GroupsGroupOnenoteSectionsOnenoteSectionParentNotebookSectionGroupsSectionGroupSectionsOnenoteSectionCopyToSectionGroup Invoke action copyToSectionGroup

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupId key: id of group
 @param onenoteSectionId key: id of onenoteSection
 @param sectionGroupId key: id of sectionGroup
 @param onenoteSectionId1 key: id of onenoteSection
 @return ApiGroupsGroupOnenoteSectionsOnenoteSectionParentNotebookSectionGroupsSectionGroupSectionsOnenoteSectionCopyToSectionGroupRequest
*/
func (a *GroupsActionsApiService) GroupsGroupOnenoteSectionsOnenoteSectionParentNotebookSectionGroupsSectionGroupSectionsOnenoteSectionCopyToSectionGroup(ctx _context.Context, groupId string, onenoteSectionId string, sectionGroupId string, onenoteSectionId1 string) ApiGroupsGroupOnenoteSectionsOnenoteSectionParentNotebookSectionGroupsSectionGroupSectionsOnenoteSectionCopyToSectionGroupRequest {
	return ApiGroupsGroupOnenoteSectionsOnenoteSectionParentNotebookSectionGroupsSectionGroupSectionsOnenoteSectionCopyToSectionGroupRequest{
		ApiService: a,
		ctx: ctx,
		groupId: groupId,
		onenoteSectionId: onenoteSectionId,
		sectionGroupId: sectionGroupId,
		onenoteSectionId1: onenoteSectionId1,
	}
}

// Execute executes the request
//  @return AnyOfmicrosoftGraphOnenoteOperation
func (a *GroupsActionsApiService) GroupsGroupOnenoteSectionsOnenoteSectionParentNotebookSectionGroupsSectionGroupSectionsOnenoteSectionCopyToSectionGroupExecute(r ApiGroupsGroupOnenoteSectionsOnenoteSectionParentNotebookSectionGroupsSectionGroupSectionsOnenoteSectionCopyToSectionGroupRequest) (AnyOfmicrosoftGraphOnenoteOperation, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  AnyOfmicrosoftGraphOnenoteOperation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GroupsActionsApiService.GroupsGroupOnenoteSectionsOnenoteSectionParentNotebookSectionGroupsSectionGroupSectionsOnenoteSectionCopyToSectionGroup")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/groups/{group-id}/onenote/sections/{onenoteSection-id}/parentNotebook/sectionGroups/{sectionGroup-id}/sections/{onenoteSection-id1}/microsoft.graph.copyToSectionGroup"
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"onenoteSection-id"+"}", _neturl.PathEscape(parameterToString(r.onenoteSectionId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"sectionGroup-id"+"}", _neturl.PathEscape(parameterToString(r.sectionGroupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"onenoteSection-id1"+"}", _neturl.PathEscape(parameterToString(r.onenoteSectionId1, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject332 == nil {
		return localVarReturnValue, nil, reportError("inlineObject332 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject332
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGroupsGroupOnenoteSectionsOnenoteSectionParentNotebookSectionsOnenoteSectionCopyToNotebookRequest struct {
	ctx _context.Context
	ApiService *GroupsActionsApiService
	groupId string
	onenoteSectionId string
	onenoteSectionId1 string
	inlineObject333 *InlineObject333
}

func (r ApiGroupsGroupOnenoteSectionsOnenoteSectionParentNotebookSectionsOnenoteSectionCopyToNotebookRequest) InlineObject333(inlineObject333 InlineObject333) ApiGroupsGroupOnenoteSectionsOnenoteSectionParentNotebookSectionsOnenoteSectionCopyToNotebookRequest {
	r.inlineObject333 = &inlineObject333
	return r
}

func (r ApiGroupsGroupOnenoteSectionsOnenoteSectionParentNotebookSectionsOnenoteSectionCopyToNotebookRequest) Execute() (AnyOfmicrosoftGraphOnenoteOperation, *_nethttp.Response, error) {
	return r.ApiService.GroupsGroupOnenoteSectionsOnenoteSectionParentNotebookSectionsOnenoteSectionCopyToNotebookExecute(r)
}

/*
GroupsGroupOnenoteSectionsOnenoteSectionParentNotebookSectionsOnenoteSectionCopyToNotebook Invoke action copyToNotebook

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupId key: id of group
 @param onenoteSectionId key: id of onenoteSection
 @param onenoteSectionId1 key: id of onenoteSection
 @return ApiGroupsGroupOnenoteSectionsOnenoteSectionParentNotebookSectionsOnenoteSectionCopyToNotebookRequest
*/
func (a *GroupsActionsApiService) GroupsGroupOnenoteSectionsOnenoteSectionParentNotebookSectionsOnenoteSectionCopyToNotebook(ctx _context.Context, groupId string, onenoteSectionId string, onenoteSectionId1 string) ApiGroupsGroupOnenoteSectionsOnenoteSectionParentNotebookSectionsOnenoteSectionCopyToNotebookRequest {
	return ApiGroupsGroupOnenoteSectionsOnenoteSectionParentNotebookSectionsOnenoteSectionCopyToNotebookRequest{
		ApiService: a,
		ctx: ctx,
		groupId: groupId,
		onenoteSectionId: onenoteSectionId,
		onenoteSectionId1: onenoteSectionId1,
	}
}

// Execute executes the request
//  @return AnyOfmicrosoftGraphOnenoteOperation
func (a *GroupsActionsApiService) GroupsGroupOnenoteSectionsOnenoteSectionParentNotebookSectionsOnenoteSectionCopyToNotebookExecute(r ApiGroupsGroupOnenoteSectionsOnenoteSectionParentNotebookSectionsOnenoteSectionCopyToNotebookRequest) (AnyOfmicrosoftGraphOnenoteOperation, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  AnyOfmicrosoftGraphOnenoteOperation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GroupsActionsApiService.GroupsGroupOnenoteSectionsOnenoteSectionParentNotebookSectionsOnenoteSectionCopyToNotebook")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/groups/{group-id}/onenote/sections/{onenoteSection-id}/parentNotebook/sections/{onenoteSection-id1}/microsoft.graph.copyToNotebook"
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"onenoteSection-id"+"}", _neturl.PathEscape(parameterToString(r.onenoteSectionId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"onenoteSection-id1"+"}", _neturl.PathEscape(parameterToString(r.onenoteSectionId1, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject333 == nil {
		return localVarReturnValue, nil, reportError("inlineObject333 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject333
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGroupsGroupOnenoteSectionsOnenoteSectionParentNotebookSectionsOnenoteSectionCopyToSectionGroupRequest struct {
	ctx _context.Context
	ApiService *GroupsActionsApiService
	groupId string
	onenoteSectionId string
	onenoteSectionId1 string
	inlineObject334 *InlineObject334
}

func (r ApiGroupsGroupOnenoteSectionsOnenoteSectionParentNotebookSectionsOnenoteSectionCopyToSectionGroupRequest) InlineObject334(inlineObject334 InlineObject334) ApiGroupsGroupOnenoteSectionsOnenoteSectionParentNotebookSectionsOnenoteSectionCopyToSectionGroupRequest {
	r.inlineObject334 = &inlineObject334
	return r
}

func (r ApiGroupsGroupOnenoteSectionsOnenoteSectionParentNotebookSectionsOnenoteSectionCopyToSectionGroupRequest) Execute() (AnyOfmicrosoftGraphOnenoteOperation, *_nethttp.Response, error) {
	return r.ApiService.GroupsGroupOnenoteSectionsOnenoteSectionParentNotebookSectionsOnenoteSectionCopyToSectionGroupExecute(r)
}

/*
GroupsGroupOnenoteSectionsOnenoteSectionParentNotebookSectionsOnenoteSectionCopyToSectionGroup Invoke action copyToSectionGroup

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupId key: id of group
 @param onenoteSectionId key: id of onenoteSection
 @param onenoteSectionId1 key: id of onenoteSection
 @return ApiGroupsGroupOnenoteSectionsOnenoteSectionParentNotebookSectionsOnenoteSectionCopyToSectionGroupRequest
*/
func (a *GroupsActionsApiService) GroupsGroupOnenoteSectionsOnenoteSectionParentNotebookSectionsOnenoteSectionCopyToSectionGroup(ctx _context.Context, groupId string, onenoteSectionId string, onenoteSectionId1 string) ApiGroupsGroupOnenoteSectionsOnenoteSectionParentNotebookSectionsOnenoteSectionCopyToSectionGroupRequest {
	return ApiGroupsGroupOnenoteSectionsOnenoteSectionParentNotebookSectionsOnenoteSectionCopyToSectionGroupRequest{
		ApiService: a,
		ctx: ctx,
		groupId: groupId,
		onenoteSectionId: onenoteSectionId,
		onenoteSectionId1: onenoteSectionId1,
	}
}

// Execute executes the request
//  @return AnyOfmicrosoftGraphOnenoteOperation
func (a *GroupsActionsApiService) GroupsGroupOnenoteSectionsOnenoteSectionParentNotebookSectionsOnenoteSectionCopyToSectionGroupExecute(r ApiGroupsGroupOnenoteSectionsOnenoteSectionParentNotebookSectionsOnenoteSectionCopyToSectionGroupRequest) (AnyOfmicrosoftGraphOnenoteOperation, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  AnyOfmicrosoftGraphOnenoteOperation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GroupsActionsApiService.GroupsGroupOnenoteSectionsOnenoteSectionParentNotebookSectionsOnenoteSectionCopyToSectionGroup")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/groups/{group-id}/onenote/sections/{onenoteSection-id}/parentNotebook/sections/{onenoteSection-id1}/microsoft.graph.copyToSectionGroup"
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"onenoteSection-id"+"}", _neturl.PathEscape(parameterToString(r.onenoteSectionId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"onenoteSection-id1"+"}", _neturl.PathEscape(parameterToString(r.onenoteSectionId1, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject334 == nil {
		return localVarReturnValue, nil, reportError("inlineObject334 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject334
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGroupsGroupOnenoteSectionsOnenoteSectionParentSectionGroupParentNotebookCopyNotebookRequest struct {
	ctx _context.Context
	ApiService *GroupsActionsApiService
	groupId string
	onenoteSectionId string
	inlineObject335 *InlineObject335
}

func (r ApiGroupsGroupOnenoteSectionsOnenoteSectionParentSectionGroupParentNotebookCopyNotebookRequest) InlineObject335(inlineObject335 InlineObject335) ApiGroupsGroupOnenoteSectionsOnenoteSectionParentSectionGroupParentNotebookCopyNotebookRequest {
	r.inlineObject335 = &inlineObject335
	return r
}

func (r ApiGroupsGroupOnenoteSectionsOnenoteSectionParentSectionGroupParentNotebookCopyNotebookRequest) Execute() (AnyOfmicrosoftGraphOnenoteOperation, *_nethttp.Response, error) {
	return r.ApiService.GroupsGroupOnenoteSectionsOnenoteSectionParentSectionGroupParentNotebookCopyNotebookExecute(r)
}

/*
GroupsGroupOnenoteSectionsOnenoteSectionParentSectionGroupParentNotebookCopyNotebook Invoke action copyNotebook

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupId key: id of group
 @param onenoteSectionId key: id of onenoteSection
 @return ApiGroupsGroupOnenoteSectionsOnenoteSectionParentSectionGroupParentNotebookCopyNotebookRequest
*/
func (a *GroupsActionsApiService) GroupsGroupOnenoteSectionsOnenoteSectionParentSectionGroupParentNotebookCopyNotebook(ctx _context.Context, groupId string, onenoteSectionId string) ApiGroupsGroupOnenoteSectionsOnenoteSectionParentSectionGroupParentNotebookCopyNotebookRequest {
	return ApiGroupsGroupOnenoteSectionsOnenoteSectionParentSectionGroupParentNotebookCopyNotebookRequest{
		ApiService: a,
		ctx: ctx,
		groupId: groupId,
		onenoteSectionId: onenoteSectionId,
	}
}

// Execute executes the request
//  @return AnyOfmicrosoftGraphOnenoteOperation
func (a *GroupsActionsApiService) GroupsGroupOnenoteSectionsOnenoteSectionParentSectionGroupParentNotebookCopyNotebookExecute(r ApiGroupsGroupOnenoteSectionsOnenoteSectionParentSectionGroupParentNotebookCopyNotebookRequest) (AnyOfmicrosoftGraphOnenoteOperation, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  AnyOfmicrosoftGraphOnenoteOperation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GroupsActionsApiService.GroupsGroupOnenoteSectionsOnenoteSectionParentSectionGroupParentNotebookCopyNotebook")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/groups/{group-id}/onenote/sections/{onenoteSection-id}/parentSectionGroup/parentNotebook/microsoft.graph.copyNotebook"
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"onenoteSection-id"+"}", _neturl.PathEscape(parameterToString(r.onenoteSectionId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject335 == nil {
		return localVarReturnValue, nil, reportError("inlineObject335 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject335
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGroupsGroupOnenoteSectionsOnenoteSectionParentSectionGroupParentNotebookSectionsOnenoteSectionCopyToNotebookRequest struct {
	ctx _context.Context
	ApiService *GroupsActionsApiService
	groupId string
	onenoteSectionId string
	onenoteSectionId1 string
	inlineObject336 *InlineObject336
}

func (r ApiGroupsGroupOnenoteSectionsOnenoteSectionParentSectionGroupParentNotebookSectionsOnenoteSectionCopyToNotebookRequest) InlineObject336(inlineObject336 InlineObject336) ApiGroupsGroupOnenoteSectionsOnenoteSectionParentSectionGroupParentNotebookSectionsOnenoteSectionCopyToNotebookRequest {
	r.inlineObject336 = &inlineObject336
	return r
}

func (r ApiGroupsGroupOnenoteSectionsOnenoteSectionParentSectionGroupParentNotebookSectionsOnenoteSectionCopyToNotebookRequest) Execute() (AnyOfmicrosoftGraphOnenoteOperation, *_nethttp.Response, error) {
	return r.ApiService.GroupsGroupOnenoteSectionsOnenoteSectionParentSectionGroupParentNotebookSectionsOnenoteSectionCopyToNotebookExecute(r)
}

/*
GroupsGroupOnenoteSectionsOnenoteSectionParentSectionGroupParentNotebookSectionsOnenoteSectionCopyToNotebook Invoke action copyToNotebook

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupId key: id of group
 @param onenoteSectionId key: id of onenoteSection
 @param onenoteSectionId1 key: id of onenoteSection
 @return ApiGroupsGroupOnenoteSectionsOnenoteSectionParentSectionGroupParentNotebookSectionsOnenoteSectionCopyToNotebookRequest
*/
func (a *GroupsActionsApiService) GroupsGroupOnenoteSectionsOnenoteSectionParentSectionGroupParentNotebookSectionsOnenoteSectionCopyToNotebook(ctx _context.Context, groupId string, onenoteSectionId string, onenoteSectionId1 string) ApiGroupsGroupOnenoteSectionsOnenoteSectionParentSectionGroupParentNotebookSectionsOnenoteSectionCopyToNotebookRequest {
	return ApiGroupsGroupOnenoteSectionsOnenoteSectionParentSectionGroupParentNotebookSectionsOnenoteSectionCopyToNotebookRequest{
		ApiService: a,
		ctx: ctx,
		groupId: groupId,
		onenoteSectionId: onenoteSectionId,
		onenoteSectionId1: onenoteSectionId1,
	}
}

// Execute executes the request
//  @return AnyOfmicrosoftGraphOnenoteOperation
func (a *GroupsActionsApiService) GroupsGroupOnenoteSectionsOnenoteSectionParentSectionGroupParentNotebookSectionsOnenoteSectionCopyToNotebookExecute(r ApiGroupsGroupOnenoteSectionsOnenoteSectionParentSectionGroupParentNotebookSectionsOnenoteSectionCopyToNotebookRequest) (AnyOfmicrosoftGraphOnenoteOperation, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  AnyOfmicrosoftGraphOnenoteOperation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GroupsActionsApiService.GroupsGroupOnenoteSectionsOnenoteSectionParentSectionGroupParentNotebookSectionsOnenoteSectionCopyToNotebook")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/groups/{group-id}/onenote/sections/{onenoteSection-id}/parentSectionGroup/parentNotebook/sections/{onenoteSection-id1}/microsoft.graph.copyToNotebook"
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"onenoteSection-id"+"}", _neturl.PathEscape(parameterToString(r.onenoteSectionId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"onenoteSection-id1"+"}", _neturl.PathEscape(parameterToString(r.onenoteSectionId1, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject336 == nil {
		return localVarReturnValue, nil, reportError("inlineObject336 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject336
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGroupsGroupOnenoteSectionsOnenoteSectionParentSectionGroupParentNotebookSectionsOnenoteSectionCopyToSectionGroupRequest struct {
	ctx _context.Context
	ApiService *GroupsActionsApiService
	groupId string
	onenoteSectionId string
	onenoteSectionId1 string
	inlineObject337 *InlineObject337
}

func (r ApiGroupsGroupOnenoteSectionsOnenoteSectionParentSectionGroupParentNotebookSectionsOnenoteSectionCopyToSectionGroupRequest) InlineObject337(inlineObject337 InlineObject337) ApiGroupsGroupOnenoteSectionsOnenoteSectionParentSectionGroupParentNotebookSectionsOnenoteSectionCopyToSectionGroupRequest {
	r.inlineObject337 = &inlineObject337
	return r
}

func (r ApiGroupsGroupOnenoteSectionsOnenoteSectionParentSectionGroupParentNotebookSectionsOnenoteSectionCopyToSectionGroupRequest) Execute() (AnyOfmicrosoftGraphOnenoteOperation, *_nethttp.Response, error) {
	return r.ApiService.GroupsGroupOnenoteSectionsOnenoteSectionParentSectionGroupParentNotebookSectionsOnenoteSectionCopyToSectionGroupExecute(r)
}

/*
GroupsGroupOnenoteSectionsOnenoteSectionParentSectionGroupParentNotebookSectionsOnenoteSectionCopyToSectionGroup Invoke action copyToSectionGroup

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupId key: id of group
 @param onenoteSectionId key: id of onenoteSection
 @param onenoteSectionId1 key: id of onenoteSection
 @return ApiGroupsGroupOnenoteSectionsOnenoteSectionParentSectionGroupParentNotebookSectionsOnenoteSectionCopyToSectionGroupRequest
*/
func (a *GroupsActionsApiService) GroupsGroupOnenoteSectionsOnenoteSectionParentSectionGroupParentNotebookSectionsOnenoteSectionCopyToSectionGroup(ctx _context.Context, groupId string, onenoteSectionId string, onenoteSectionId1 string) ApiGroupsGroupOnenoteSectionsOnenoteSectionParentSectionGroupParentNotebookSectionsOnenoteSectionCopyToSectionGroupRequest {
	return ApiGroupsGroupOnenoteSectionsOnenoteSectionParentSectionGroupParentNotebookSectionsOnenoteSectionCopyToSectionGroupRequest{
		ApiService: a,
		ctx: ctx,
		groupId: groupId,
		onenoteSectionId: onenoteSectionId,
		onenoteSectionId1: onenoteSectionId1,
	}
}

// Execute executes the request
//  @return AnyOfmicrosoftGraphOnenoteOperation
func (a *GroupsActionsApiService) GroupsGroupOnenoteSectionsOnenoteSectionParentSectionGroupParentNotebookSectionsOnenoteSectionCopyToSectionGroupExecute(r ApiGroupsGroupOnenoteSectionsOnenoteSectionParentSectionGroupParentNotebookSectionsOnenoteSectionCopyToSectionGroupRequest) (AnyOfmicrosoftGraphOnenoteOperation, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  AnyOfmicrosoftGraphOnenoteOperation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GroupsActionsApiService.GroupsGroupOnenoteSectionsOnenoteSectionParentSectionGroupParentNotebookSectionsOnenoteSectionCopyToSectionGroup")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/groups/{group-id}/onenote/sections/{onenoteSection-id}/parentSectionGroup/parentNotebook/sections/{onenoteSection-id1}/microsoft.graph.copyToSectionGroup"
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"onenoteSection-id"+"}", _neturl.PathEscape(parameterToString(r.onenoteSectionId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"onenoteSection-id1"+"}", _neturl.PathEscape(parameterToString(r.onenoteSectionId1, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject337 == nil {
		return localVarReturnValue, nil, reportError("inlineObject337 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject337
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGroupsGroupOnenoteSectionsOnenoteSectionParentSectionGroupSectionsOnenoteSectionCopyToNotebookRequest struct {
	ctx _context.Context
	ApiService *GroupsActionsApiService
	groupId string
	onenoteSectionId string
	onenoteSectionId1 string
	inlineObject338 *InlineObject338
}

func (r ApiGroupsGroupOnenoteSectionsOnenoteSectionParentSectionGroupSectionsOnenoteSectionCopyToNotebookRequest) InlineObject338(inlineObject338 InlineObject338) ApiGroupsGroupOnenoteSectionsOnenoteSectionParentSectionGroupSectionsOnenoteSectionCopyToNotebookRequest {
	r.inlineObject338 = &inlineObject338
	return r
}

func (r ApiGroupsGroupOnenoteSectionsOnenoteSectionParentSectionGroupSectionsOnenoteSectionCopyToNotebookRequest) Execute() (AnyOfmicrosoftGraphOnenoteOperation, *_nethttp.Response, error) {
	return r.ApiService.GroupsGroupOnenoteSectionsOnenoteSectionParentSectionGroupSectionsOnenoteSectionCopyToNotebookExecute(r)
}

/*
GroupsGroupOnenoteSectionsOnenoteSectionParentSectionGroupSectionsOnenoteSectionCopyToNotebook Invoke action copyToNotebook

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupId key: id of group
 @param onenoteSectionId key: id of onenoteSection
 @param onenoteSectionId1 key: id of onenoteSection
 @return ApiGroupsGroupOnenoteSectionsOnenoteSectionParentSectionGroupSectionsOnenoteSectionCopyToNotebookRequest
*/
func (a *GroupsActionsApiService) GroupsGroupOnenoteSectionsOnenoteSectionParentSectionGroupSectionsOnenoteSectionCopyToNotebook(ctx _context.Context, groupId string, onenoteSectionId string, onenoteSectionId1 string) ApiGroupsGroupOnenoteSectionsOnenoteSectionParentSectionGroupSectionsOnenoteSectionCopyToNotebookRequest {
	return ApiGroupsGroupOnenoteSectionsOnenoteSectionParentSectionGroupSectionsOnenoteSectionCopyToNotebookRequest{
		ApiService: a,
		ctx: ctx,
		groupId: groupId,
		onenoteSectionId: onenoteSectionId,
		onenoteSectionId1: onenoteSectionId1,
	}
}

// Execute executes the request
//  @return AnyOfmicrosoftGraphOnenoteOperation
func (a *GroupsActionsApiService) GroupsGroupOnenoteSectionsOnenoteSectionParentSectionGroupSectionsOnenoteSectionCopyToNotebookExecute(r ApiGroupsGroupOnenoteSectionsOnenoteSectionParentSectionGroupSectionsOnenoteSectionCopyToNotebookRequest) (AnyOfmicrosoftGraphOnenoteOperation, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  AnyOfmicrosoftGraphOnenoteOperation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GroupsActionsApiService.GroupsGroupOnenoteSectionsOnenoteSectionParentSectionGroupSectionsOnenoteSectionCopyToNotebook")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/groups/{group-id}/onenote/sections/{onenoteSection-id}/parentSectionGroup/sections/{onenoteSection-id1}/microsoft.graph.copyToNotebook"
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"onenoteSection-id"+"}", _neturl.PathEscape(parameterToString(r.onenoteSectionId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"onenoteSection-id1"+"}", _neturl.PathEscape(parameterToString(r.onenoteSectionId1, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject338 == nil {
		return localVarReturnValue, nil, reportError("inlineObject338 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject338
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGroupsGroupOnenoteSectionsOnenoteSectionParentSectionGroupSectionsOnenoteSectionCopyToSectionGroupRequest struct {
	ctx _context.Context
	ApiService *GroupsActionsApiService
	groupId string
	onenoteSectionId string
	onenoteSectionId1 string
	inlineObject339 *InlineObject339
}

func (r ApiGroupsGroupOnenoteSectionsOnenoteSectionParentSectionGroupSectionsOnenoteSectionCopyToSectionGroupRequest) InlineObject339(inlineObject339 InlineObject339) ApiGroupsGroupOnenoteSectionsOnenoteSectionParentSectionGroupSectionsOnenoteSectionCopyToSectionGroupRequest {
	r.inlineObject339 = &inlineObject339
	return r
}

func (r ApiGroupsGroupOnenoteSectionsOnenoteSectionParentSectionGroupSectionsOnenoteSectionCopyToSectionGroupRequest) Execute() (AnyOfmicrosoftGraphOnenoteOperation, *_nethttp.Response, error) {
	return r.ApiService.GroupsGroupOnenoteSectionsOnenoteSectionParentSectionGroupSectionsOnenoteSectionCopyToSectionGroupExecute(r)
}

/*
GroupsGroupOnenoteSectionsOnenoteSectionParentSectionGroupSectionsOnenoteSectionCopyToSectionGroup Invoke action copyToSectionGroup

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupId key: id of group
 @param onenoteSectionId key: id of onenoteSection
 @param onenoteSectionId1 key: id of onenoteSection
 @return ApiGroupsGroupOnenoteSectionsOnenoteSectionParentSectionGroupSectionsOnenoteSectionCopyToSectionGroupRequest
*/
func (a *GroupsActionsApiService) GroupsGroupOnenoteSectionsOnenoteSectionParentSectionGroupSectionsOnenoteSectionCopyToSectionGroup(ctx _context.Context, groupId string, onenoteSectionId string, onenoteSectionId1 string) ApiGroupsGroupOnenoteSectionsOnenoteSectionParentSectionGroupSectionsOnenoteSectionCopyToSectionGroupRequest {
	return ApiGroupsGroupOnenoteSectionsOnenoteSectionParentSectionGroupSectionsOnenoteSectionCopyToSectionGroupRequest{
		ApiService: a,
		ctx: ctx,
		groupId: groupId,
		onenoteSectionId: onenoteSectionId,
		onenoteSectionId1: onenoteSectionId1,
	}
}

// Execute executes the request
//  @return AnyOfmicrosoftGraphOnenoteOperation
func (a *GroupsActionsApiService) GroupsGroupOnenoteSectionsOnenoteSectionParentSectionGroupSectionsOnenoteSectionCopyToSectionGroupExecute(r ApiGroupsGroupOnenoteSectionsOnenoteSectionParentSectionGroupSectionsOnenoteSectionCopyToSectionGroupRequest) (AnyOfmicrosoftGraphOnenoteOperation, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  AnyOfmicrosoftGraphOnenoteOperation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GroupsActionsApiService.GroupsGroupOnenoteSectionsOnenoteSectionParentSectionGroupSectionsOnenoteSectionCopyToSectionGroup")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/groups/{group-id}/onenote/sections/{onenoteSection-id}/parentSectionGroup/sections/{onenoteSection-id1}/microsoft.graph.copyToSectionGroup"
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"onenoteSection-id"+"}", _neturl.PathEscape(parameterToString(r.onenoteSectionId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"onenoteSection-id1"+"}", _neturl.PathEscape(parameterToString(r.onenoteSectionId1, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject339 == nil {
		return localVarReturnValue, nil, reportError("inlineObject339 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject339
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGroupsGroupRemoveFavoriteRequest struct {
	ctx _context.Context
	ApiService *GroupsActionsApiService
	groupId string
}


func (r ApiGroupsGroupRemoveFavoriteRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.GroupsGroupRemoveFavoriteExecute(r)
}

/*
GroupsGroupRemoveFavorite Invoke action removeFavorite

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupId key: id of group
 @return ApiGroupsGroupRemoveFavoriteRequest
*/
func (a *GroupsActionsApiService) GroupsGroupRemoveFavorite(ctx _context.Context, groupId string) ApiGroupsGroupRemoveFavoriteRequest {
	return ApiGroupsGroupRemoveFavoriteRequest{
		ApiService: a,
		ctx: ctx,
		groupId: groupId,
	}
}

// Execute executes the request
func (a *GroupsActionsApiService) GroupsGroupRemoveFavoriteExecute(r ApiGroupsGroupRemoveFavoriteRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GroupsActionsApiService.GroupsGroupRemoveFavorite")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/groups/{group-id}/microsoft.graph.removeFavorite"
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGroupsGroupRenewRequest struct {
	ctx _context.Context
	ApiService *GroupsActionsApiService
	groupId string
}


func (r ApiGroupsGroupRenewRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.GroupsGroupRenewExecute(r)
}

/*
GroupsGroupRenew Invoke action renew

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupId key: id of group
 @return ApiGroupsGroupRenewRequest
*/
func (a *GroupsActionsApiService) GroupsGroupRenew(ctx _context.Context, groupId string) ApiGroupsGroupRenewRequest {
	return ApiGroupsGroupRenewRequest{
		ApiService: a,
		ctx: ctx,
		groupId: groupId,
	}
}

// Execute executes the request
func (a *GroupsActionsApiService) GroupsGroupRenewExecute(r ApiGroupsGroupRenewRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GroupsActionsApiService.GroupsGroupRenew")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/groups/{group-id}/microsoft.graph.renew"
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGroupsGroupResetUnseenCountRequest struct {
	ctx _context.Context
	ApiService *GroupsActionsApiService
	groupId string
}


func (r ApiGroupsGroupResetUnseenCountRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.GroupsGroupResetUnseenCountExecute(r)
}

/*
GroupsGroupResetUnseenCount Invoke action resetUnseenCount

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupId key: id of group
 @return ApiGroupsGroupResetUnseenCountRequest
*/
func (a *GroupsActionsApiService) GroupsGroupResetUnseenCount(ctx _context.Context, groupId string) ApiGroupsGroupResetUnseenCountRequest {
	return ApiGroupsGroupResetUnseenCountRequest{
		ApiService: a,
		ctx: ctx,
		groupId: groupId,
	}
}

// Execute executes the request
func (a *GroupsActionsApiService) GroupsGroupResetUnseenCountExecute(r ApiGroupsGroupResetUnseenCountRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GroupsActionsApiService.GroupsGroupResetUnseenCount")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/groups/{group-id}/microsoft.graph.resetUnseenCount"
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGroupsGroupRestoreRequest struct {
	ctx _context.Context
	ApiService *GroupsActionsApiService
	groupId string
}


func (r ApiGroupsGroupRestoreRequest) Execute() (AnyOfmicrosoftGraphDirectoryObject, *_nethttp.Response, error) {
	return r.ApiService.GroupsGroupRestoreExecute(r)
}

/*
GroupsGroupRestore Invoke action restore

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupId key: id of group
 @return ApiGroupsGroupRestoreRequest
*/
func (a *GroupsActionsApiService) GroupsGroupRestore(ctx _context.Context, groupId string) ApiGroupsGroupRestoreRequest {
	return ApiGroupsGroupRestoreRequest{
		ApiService: a,
		ctx: ctx,
		groupId: groupId,
	}
}

// Execute executes the request
//  @return AnyOfmicrosoftGraphDirectoryObject
func (a *GroupsActionsApiService) GroupsGroupRestoreExecute(r ApiGroupsGroupRestoreRequest) (AnyOfmicrosoftGraphDirectoryObject, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  AnyOfmicrosoftGraphDirectoryObject
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GroupsActionsApiService.GroupsGroupRestore")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/groups/{group-id}/microsoft.graph.restore"
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGroupsGroupSubscribeByMailRequest struct {
	ctx _context.Context
	ApiService *GroupsActionsApiService
	groupId string
}


func (r ApiGroupsGroupSubscribeByMailRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.GroupsGroupSubscribeByMailExecute(r)
}

/*
GroupsGroupSubscribeByMail Invoke action subscribeByMail

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupId key: id of group
 @return ApiGroupsGroupSubscribeByMailRequest
*/
func (a *GroupsActionsApiService) GroupsGroupSubscribeByMail(ctx _context.Context, groupId string) ApiGroupsGroupSubscribeByMailRequest {
	return ApiGroupsGroupSubscribeByMailRequest{
		ApiService: a,
		ctx: ctx,
		groupId: groupId,
	}
}

// Execute executes the request
func (a *GroupsActionsApiService) GroupsGroupSubscribeByMailExecute(r ApiGroupsGroupSubscribeByMailRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GroupsActionsApiService.GroupsGroupSubscribeByMail")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/groups/{group-id}/microsoft.graph.subscribeByMail"
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGroupsGroupThreadsConversationThreadPostsPostAttachmentsCreateUploadSessionRequest struct {
	ctx _context.Context
	ApiService *GroupsActionsApiService
	groupId string
	conversationThreadId string
	postId string
	inlineObject341 *InlineObject341
}

func (r ApiGroupsGroupThreadsConversationThreadPostsPostAttachmentsCreateUploadSessionRequest) InlineObject341(inlineObject341 InlineObject341) ApiGroupsGroupThreadsConversationThreadPostsPostAttachmentsCreateUploadSessionRequest {
	r.inlineObject341 = &inlineObject341
	return r
}

func (r ApiGroupsGroupThreadsConversationThreadPostsPostAttachmentsCreateUploadSessionRequest) Execute() (AnyOfmicrosoftGraphUploadSession, *_nethttp.Response, error) {
	return r.ApiService.GroupsGroupThreadsConversationThreadPostsPostAttachmentsCreateUploadSessionExecute(r)
}

/*
GroupsGroupThreadsConversationThreadPostsPostAttachmentsCreateUploadSession Invoke action createUploadSession

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupId key: id of group
 @param conversationThreadId key: id of conversationThread
 @param postId key: id of post
 @return ApiGroupsGroupThreadsConversationThreadPostsPostAttachmentsCreateUploadSessionRequest
*/
func (a *GroupsActionsApiService) GroupsGroupThreadsConversationThreadPostsPostAttachmentsCreateUploadSession(ctx _context.Context, groupId string, conversationThreadId string, postId string) ApiGroupsGroupThreadsConversationThreadPostsPostAttachmentsCreateUploadSessionRequest {
	return ApiGroupsGroupThreadsConversationThreadPostsPostAttachmentsCreateUploadSessionRequest{
		ApiService: a,
		ctx: ctx,
		groupId: groupId,
		conversationThreadId: conversationThreadId,
		postId: postId,
	}
}

// Execute executes the request
//  @return AnyOfmicrosoftGraphUploadSession
func (a *GroupsActionsApiService) GroupsGroupThreadsConversationThreadPostsPostAttachmentsCreateUploadSessionExecute(r ApiGroupsGroupThreadsConversationThreadPostsPostAttachmentsCreateUploadSessionRequest) (AnyOfmicrosoftGraphUploadSession, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  AnyOfmicrosoftGraphUploadSession
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GroupsActionsApiService.GroupsGroupThreadsConversationThreadPostsPostAttachmentsCreateUploadSession")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/groups/{group-id}/threads/{conversationThread-id}/posts/{post-id}/attachments/microsoft.graph.createUploadSession"
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"conversationThread-id"+"}", _neturl.PathEscape(parameterToString(r.conversationThreadId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"post-id"+"}", _neturl.PathEscape(parameterToString(r.postId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject341 == nil {
		return localVarReturnValue, nil, reportError("inlineObject341 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject341
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGroupsGroupThreadsConversationThreadPostsPostForwardRequest struct {
	ctx _context.Context
	ApiService *GroupsActionsApiService
	groupId string
	conversationThreadId string
	postId string
	inlineObject344 *InlineObject344
}

func (r ApiGroupsGroupThreadsConversationThreadPostsPostForwardRequest) InlineObject344(inlineObject344 InlineObject344) ApiGroupsGroupThreadsConversationThreadPostsPostForwardRequest {
	r.inlineObject344 = &inlineObject344
	return r
}

func (r ApiGroupsGroupThreadsConversationThreadPostsPostForwardRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.GroupsGroupThreadsConversationThreadPostsPostForwardExecute(r)
}

/*
GroupsGroupThreadsConversationThreadPostsPostForward Invoke action forward

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupId key: id of group
 @param conversationThreadId key: id of conversationThread
 @param postId key: id of post
 @return ApiGroupsGroupThreadsConversationThreadPostsPostForwardRequest
*/
func (a *GroupsActionsApiService) GroupsGroupThreadsConversationThreadPostsPostForward(ctx _context.Context, groupId string, conversationThreadId string, postId string) ApiGroupsGroupThreadsConversationThreadPostsPostForwardRequest {
	return ApiGroupsGroupThreadsConversationThreadPostsPostForwardRequest{
		ApiService: a,
		ctx: ctx,
		groupId: groupId,
		conversationThreadId: conversationThreadId,
		postId: postId,
	}
}

// Execute executes the request
func (a *GroupsActionsApiService) GroupsGroupThreadsConversationThreadPostsPostForwardExecute(r ApiGroupsGroupThreadsConversationThreadPostsPostForwardRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GroupsActionsApiService.GroupsGroupThreadsConversationThreadPostsPostForward")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/groups/{group-id}/threads/{conversationThread-id}/posts/{post-id}/microsoft.graph.forward"
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"conversationThread-id"+"}", _neturl.PathEscape(parameterToString(r.conversationThreadId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"post-id"+"}", _neturl.PathEscape(parameterToString(r.postId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject344 == nil {
		return nil, reportError("inlineObject344 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject344
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGroupsGroupThreadsConversationThreadPostsPostInReplyToForwardRequest struct {
	ctx _context.Context
	ApiService *GroupsActionsApiService
	groupId string
	conversationThreadId string
	postId string
	inlineObject342 *InlineObject342
}

func (r ApiGroupsGroupThreadsConversationThreadPostsPostInReplyToForwardRequest) InlineObject342(inlineObject342 InlineObject342) ApiGroupsGroupThreadsConversationThreadPostsPostInReplyToForwardRequest {
	r.inlineObject342 = &inlineObject342
	return r
}

func (r ApiGroupsGroupThreadsConversationThreadPostsPostInReplyToForwardRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.GroupsGroupThreadsConversationThreadPostsPostInReplyToForwardExecute(r)
}

/*
GroupsGroupThreadsConversationThreadPostsPostInReplyToForward Invoke action forward

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupId key: id of group
 @param conversationThreadId key: id of conversationThread
 @param postId key: id of post
 @return ApiGroupsGroupThreadsConversationThreadPostsPostInReplyToForwardRequest
*/
func (a *GroupsActionsApiService) GroupsGroupThreadsConversationThreadPostsPostInReplyToForward(ctx _context.Context, groupId string, conversationThreadId string, postId string) ApiGroupsGroupThreadsConversationThreadPostsPostInReplyToForwardRequest {
	return ApiGroupsGroupThreadsConversationThreadPostsPostInReplyToForwardRequest{
		ApiService: a,
		ctx: ctx,
		groupId: groupId,
		conversationThreadId: conversationThreadId,
		postId: postId,
	}
}

// Execute executes the request
func (a *GroupsActionsApiService) GroupsGroupThreadsConversationThreadPostsPostInReplyToForwardExecute(r ApiGroupsGroupThreadsConversationThreadPostsPostInReplyToForwardRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GroupsActionsApiService.GroupsGroupThreadsConversationThreadPostsPostInReplyToForward")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/groups/{group-id}/threads/{conversationThread-id}/posts/{post-id}/inReplyTo/microsoft.graph.forward"
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"conversationThread-id"+"}", _neturl.PathEscape(parameterToString(r.conversationThreadId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"post-id"+"}", _neturl.PathEscape(parameterToString(r.postId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject342 == nil {
		return nil, reportError("inlineObject342 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject342
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGroupsGroupThreadsConversationThreadPostsPostInReplyToReplyRequest struct {
	ctx _context.Context
	ApiService *GroupsActionsApiService
	groupId string
	conversationThreadId string
	postId string
	inlineObject343 *InlineObject343
}

func (r ApiGroupsGroupThreadsConversationThreadPostsPostInReplyToReplyRequest) InlineObject343(inlineObject343 InlineObject343) ApiGroupsGroupThreadsConversationThreadPostsPostInReplyToReplyRequest {
	r.inlineObject343 = &inlineObject343
	return r
}

func (r ApiGroupsGroupThreadsConversationThreadPostsPostInReplyToReplyRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.GroupsGroupThreadsConversationThreadPostsPostInReplyToReplyExecute(r)
}

/*
GroupsGroupThreadsConversationThreadPostsPostInReplyToReply Invoke action reply

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupId key: id of group
 @param conversationThreadId key: id of conversationThread
 @param postId key: id of post
 @return ApiGroupsGroupThreadsConversationThreadPostsPostInReplyToReplyRequest
*/
func (a *GroupsActionsApiService) GroupsGroupThreadsConversationThreadPostsPostInReplyToReply(ctx _context.Context, groupId string, conversationThreadId string, postId string) ApiGroupsGroupThreadsConversationThreadPostsPostInReplyToReplyRequest {
	return ApiGroupsGroupThreadsConversationThreadPostsPostInReplyToReplyRequest{
		ApiService: a,
		ctx: ctx,
		groupId: groupId,
		conversationThreadId: conversationThreadId,
		postId: postId,
	}
}

// Execute executes the request
func (a *GroupsActionsApiService) GroupsGroupThreadsConversationThreadPostsPostInReplyToReplyExecute(r ApiGroupsGroupThreadsConversationThreadPostsPostInReplyToReplyRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GroupsActionsApiService.GroupsGroupThreadsConversationThreadPostsPostInReplyToReply")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/groups/{group-id}/threads/{conversationThread-id}/posts/{post-id}/inReplyTo/microsoft.graph.reply"
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"conversationThread-id"+"}", _neturl.PathEscape(parameterToString(r.conversationThreadId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"post-id"+"}", _neturl.PathEscape(parameterToString(r.postId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject343 == nil {
		return nil, reportError("inlineObject343 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject343
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGroupsGroupThreadsConversationThreadPostsPostReplyRequest struct {
	ctx _context.Context
	ApiService *GroupsActionsApiService
	groupId string
	conversationThreadId string
	postId string
	inlineObject345 *InlineObject345
}

func (r ApiGroupsGroupThreadsConversationThreadPostsPostReplyRequest) InlineObject345(inlineObject345 InlineObject345) ApiGroupsGroupThreadsConversationThreadPostsPostReplyRequest {
	r.inlineObject345 = &inlineObject345
	return r
}

func (r ApiGroupsGroupThreadsConversationThreadPostsPostReplyRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.GroupsGroupThreadsConversationThreadPostsPostReplyExecute(r)
}

/*
GroupsGroupThreadsConversationThreadPostsPostReply Invoke action reply

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupId key: id of group
 @param conversationThreadId key: id of conversationThread
 @param postId key: id of post
 @return ApiGroupsGroupThreadsConversationThreadPostsPostReplyRequest
*/
func (a *GroupsActionsApiService) GroupsGroupThreadsConversationThreadPostsPostReply(ctx _context.Context, groupId string, conversationThreadId string, postId string) ApiGroupsGroupThreadsConversationThreadPostsPostReplyRequest {
	return ApiGroupsGroupThreadsConversationThreadPostsPostReplyRequest{
		ApiService: a,
		ctx: ctx,
		groupId: groupId,
		conversationThreadId: conversationThreadId,
		postId: postId,
	}
}

// Execute executes the request
func (a *GroupsActionsApiService) GroupsGroupThreadsConversationThreadPostsPostReplyExecute(r ApiGroupsGroupThreadsConversationThreadPostsPostReplyRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GroupsActionsApiService.GroupsGroupThreadsConversationThreadPostsPostReply")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/groups/{group-id}/threads/{conversationThread-id}/posts/{post-id}/microsoft.graph.reply"
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"conversationThread-id"+"}", _neturl.PathEscape(parameterToString(r.conversationThreadId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"post-id"+"}", _neturl.PathEscape(parameterToString(r.postId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject345 == nil {
		return nil, reportError("inlineObject345 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject345
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGroupsGroupThreadsConversationThreadReplyRequest struct {
	ctx _context.Context
	ApiService *GroupsActionsApiService
	groupId string
	conversationThreadId string
	inlineObject340 *InlineObject340
}

func (r ApiGroupsGroupThreadsConversationThreadReplyRequest) InlineObject340(inlineObject340 InlineObject340) ApiGroupsGroupThreadsConversationThreadReplyRequest {
	r.inlineObject340 = &inlineObject340
	return r
}

func (r ApiGroupsGroupThreadsConversationThreadReplyRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.GroupsGroupThreadsConversationThreadReplyExecute(r)
}

/*
GroupsGroupThreadsConversationThreadReply Invoke action reply

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupId key: id of group
 @param conversationThreadId key: id of conversationThread
 @return ApiGroupsGroupThreadsConversationThreadReplyRequest
*/
func (a *GroupsActionsApiService) GroupsGroupThreadsConversationThreadReply(ctx _context.Context, groupId string, conversationThreadId string) ApiGroupsGroupThreadsConversationThreadReplyRequest {
	return ApiGroupsGroupThreadsConversationThreadReplyRequest{
		ApiService: a,
		ctx: ctx,
		groupId: groupId,
		conversationThreadId: conversationThreadId,
	}
}

// Execute executes the request
func (a *GroupsActionsApiService) GroupsGroupThreadsConversationThreadReplyExecute(r ApiGroupsGroupThreadsConversationThreadReplyRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GroupsActionsApiService.GroupsGroupThreadsConversationThreadReply")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/groups/{group-id}/threads/{conversationThread-id}/microsoft.graph.reply"
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"conversationThread-id"+"}", _neturl.PathEscape(parameterToString(r.conversationThreadId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject340 == nil {
		return nil, reportError("inlineObject340 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject340
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGroupsGroupUnsubscribeByMailRequest struct {
	ctx _context.Context
	ApiService *GroupsActionsApiService
	groupId string
}


func (r ApiGroupsGroupUnsubscribeByMailRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.GroupsGroupUnsubscribeByMailExecute(r)
}

/*
GroupsGroupUnsubscribeByMail Invoke action unsubscribeByMail

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupId key: id of group
 @return ApiGroupsGroupUnsubscribeByMailRequest
*/
func (a *GroupsActionsApiService) GroupsGroupUnsubscribeByMail(ctx _context.Context, groupId string) ApiGroupsGroupUnsubscribeByMailRequest {
	return ApiGroupsGroupUnsubscribeByMailRequest{
		ApiService: a,
		ctx: ctx,
		groupId: groupId,
	}
}

// Execute executes the request
func (a *GroupsActionsApiService) GroupsGroupUnsubscribeByMailExecute(r ApiGroupsGroupUnsubscribeByMailRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GroupsActionsApiService.GroupsGroupUnsubscribeByMail")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/groups/{group-id}/microsoft.graph.unsubscribeByMail"
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGroupsGroupValidatePropertiesRequest struct {
	ctx _context.Context
	ApiService *GroupsActionsApiService
	groupId string
	inlineObject241 *InlineObject241
}

func (r ApiGroupsGroupValidatePropertiesRequest) InlineObject241(inlineObject241 InlineObject241) ApiGroupsGroupValidatePropertiesRequest {
	r.inlineObject241 = &inlineObject241
	return r
}

func (r ApiGroupsGroupValidatePropertiesRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.GroupsGroupValidatePropertiesExecute(r)
}

/*
GroupsGroupValidateProperties Invoke action validateProperties

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupId key: id of group
 @return ApiGroupsGroupValidatePropertiesRequest
*/
func (a *GroupsActionsApiService) GroupsGroupValidateProperties(ctx _context.Context, groupId string) ApiGroupsGroupValidatePropertiesRequest {
	return ApiGroupsGroupValidatePropertiesRequest{
		ApiService: a,
		ctx: ctx,
		groupId: groupId,
	}
}

// Execute executes the request
func (a *GroupsActionsApiService) GroupsGroupValidatePropertiesExecute(r ApiGroupsGroupValidatePropertiesRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GroupsActionsApiService.GroupsGroupValidateProperties")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/groups/{group-id}/microsoft.graph.validateProperties"
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject241 == nil {
		return nil, reportError("inlineObject241 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject241
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGroupsValidatePropertiesRequest struct {
	ctx _context.Context
	ApiService *GroupsActionsApiService
	inlineObject348 *InlineObject348
}

func (r ApiGroupsValidatePropertiesRequest) InlineObject348(inlineObject348 InlineObject348) ApiGroupsValidatePropertiesRequest {
	r.inlineObject348 = &inlineObject348
	return r
}

func (r ApiGroupsValidatePropertiesRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.GroupsValidatePropertiesExecute(r)
}

/*
GroupsValidateProperties Invoke action validateProperties

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGroupsValidatePropertiesRequest
*/
func (a *GroupsActionsApiService) GroupsValidateProperties(ctx _context.Context) ApiGroupsValidatePropertiesRequest {
	return ApiGroupsValidatePropertiesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *GroupsActionsApiService) GroupsValidatePropertiesExecute(r ApiGroupsValidatePropertiesRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GroupsActionsApiService.GroupsValidateProperties")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/groups/microsoft.graph.validateProperties"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject348 == nil {
		return nil, reportError("inlineObject348 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject348
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}
