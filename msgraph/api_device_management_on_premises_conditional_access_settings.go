/*
Partial Graph API

No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

API version: v1.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package msgraph

import (
	"bytes"
	_context "context"
	_ioutil "io/ioutil"
	_nethttp "net/http"
	_neturl "net/url"
)

// Linger please
var (
	_ _context.Context
)

// DeviceManagementOnPremisesConditionalAccessSettingsApiService DeviceManagementOnPremisesConditionalAccessSettingsApi service
type DeviceManagementOnPremisesConditionalAccessSettingsApiService service

type ApiDeviceManagementDeleteConditionalAccessSettingsRequest struct {
	ctx _context.Context
	ApiService *DeviceManagementOnPremisesConditionalAccessSettingsApiService
	ifMatch *string
}

// ETag
func (r ApiDeviceManagementDeleteConditionalAccessSettingsRequest) IfMatch(ifMatch string) ApiDeviceManagementDeleteConditionalAccessSettingsRequest {
	r.ifMatch = &ifMatch
	return r
}

func (r ApiDeviceManagementDeleteConditionalAccessSettingsRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.DeviceManagementDeleteConditionalAccessSettingsExecute(r)
}

/*
DeviceManagementDeleteConditionalAccessSettings Delete navigation property conditionalAccessSettings for deviceManagement

The Exchange on premises conditional access settings. On premises conditional access will require devices to be both enrolled and compliant for mail access

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDeviceManagementDeleteConditionalAccessSettingsRequest
*/
func (a *DeviceManagementOnPremisesConditionalAccessSettingsApiService) DeviceManagementDeleteConditionalAccessSettings(ctx _context.Context) ApiDeviceManagementDeleteConditionalAccessSettingsRequest {
	return ApiDeviceManagementDeleteConditionalAccessSettingsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *DeviceManagementOnPremisesConditionalAccessSettingsApiService) DeviceManagementDeleteConditionalAccessSettingsExecute(r ApiDeviceManagementDeleteConditionalAccessSettingsRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DeviceManagementOnPremisesConditionalAccessSettingsApiService.DeviceManagementDeleteConditionalAccessSettings")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/deviceManagement/conditionalAccessSettings"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ifMatch != nil {
		localVarHeaderParams["If-Match"] = parameterToString(*r.ifMatch, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDeviceManagementGetConditionalAccessSettingsRequest struct {
	ctx _context.Context
	ApiService *DeviceManagementOnPremisesConditionalAccessSettingsApiService
	select_ *[]string
	expand *[]string
}

// Select properties to be returned
func (r ApiDeviceManagementGetConditionalAccessSettingsRequest) Select_(select_ []string) ApiDeviceManagementGetConditionalAccessSettingsRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiDeviceManagementGetConditionalAccessSettingsRequest) Expand(expand []string) ApiDeviceManagementGetConditionalAccessSettingsRequest {
	r.expand = &expand
	return r
}

func (r ApiDeviceManagementGetConditionalAccessSettingsRequest) Execute() (MicrosoftGraphOnPremisesConditionalAccessSettings, *_nethttp.Response, error) {
	return r.ApiService.DeviceManagementGetConditionalAccessSettingsExecute(r)
}

/*
DeviceManagementGetConditionalAccessSettings Get conditionalAccessSettings from deviceManagement

The Exchange on premises conditional access settings. On premises conditional access will require devices to be both enrolled and compliant for mail access

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDeviceManagementGetConditionalAccessSettingsRequest
*/
func (a *DeviceManagementOnPremisesConditionalAccessSettingsApiService) DeviceManagementGetConditionalAccessSettings(ctx _context.Context) ApiDeviceManagementGetConditionalAccessSettingsRequest {
	return ApiDeviceManagementGetConditionalAccessSettingsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return MicrosoftGraphOnPremisesConditionalAccessSettings
func (a *DeviceManagementOnPremisesConditionalAccessSettingsApiService) DeviceManagementGetConditionalAccessSettingsExecute(r ApiDeviceManagementGetConditionalAccessSettingsRequest) (MicrosoftGraphOnPremisesConditionalAccessSettings, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphOnPremisesConditionalAccessSettings
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DeviceManagementOnPremisesConditionalAccessSettingsApiService.DeviceManagementGetConditionalAccessSettings")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/deviceManagement/conditionalAccessSettings"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeviceManagementUpdateConditionalAccessSettingsRequest struct {
	ctx _context.Context
	ApiService *DeviceManagementOnPremisesConditionalAccessSettingsApiService
	microsoftGraphOnPremisesConditionalAccessSettings *MicrosoftGraphOnPremisesConditionalAccessSettings
}

// New navigation property values
func (r ApiDeviceManagementUpdateConditionalAccessSettingsRequest) MicrosoftGraphOnPremisesConditionalAccessSettings(microsoftGraphOnPremisesConditionalAccessSettings MicrosoftGraphOnPremisesConditionalAccessSettings) ApiDeviceManagementUpdateConditionalAccessSettingsRequest {
	r.microsoftGraphOnPremisesConditionalAccessSettings = &microsoftGraphOnPremisesConditionalAccessSettings
	return r
}

func (r ApiDeviceManagementUpdateConditionalAccessSettingsRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.DeviceManagementUpdateConditionalAccessSettingsExecute(r)
}

/*
DeviceManagementUpdateConditionalAccessSettings Update the navigation property conditionalAccessSettings in deviceManagement

The Exchange on premises conditional access settings. On premises conditional access will require devices to be both enrolled and compliant for mail access

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDeviceManagementUpdateConditionalAccessSettingsRequest
*/
func (a *DeviceManagementOnPremisesConditionalAccessSettingsApiService) DeviceManagementUpdateConditionalAccessSettings(ctx _context.Context) ApiDeviceManagementUpdateConditionalAccessSettingsRequest {
	return ApiDeviceManagementUpdateConditionalAccessSettingsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *DeviceManagementOnPremisesConditionalAccessSettingsApiService) DeviceManagementUpdateConditionalAccessSettingsExecute(r ApiDeviceManagementUpdateConditionalAccessSettingsRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPatch
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DeviceManagementOnPremisesConditionalAccessSettingsApiService.DeviceManagementUpdateConditionalAccessSettings")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/deviceManagement/conditionalAccessSettings"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphOnPremisesConditionalAccessSettings == nil {
		return nil, reportError("microsoftGraphOnPremisesConditionalAccessSettings is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphOnPremisesConditionalAccessSettings
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}
