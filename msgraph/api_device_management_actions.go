/*
Partial Graph API

No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

API version: v1.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package msgraph

import (
	"bytes"
	_context "context"
	_ioutil "io/ioutil"
	_nethttp "net/http"
	_neturl "net/url"
	"strings"
)

// Linger please
var (
	_ _context.Context
)

// DeviceManagementActionsApiService DeviceManagementActionsApi service
type DeviceManagementActionsApiService service

type ApiDeviceManagementDeviceCompliancePoliciesDeviceCompliancePolicyAssignRequest struct {
	ctx _context.Context
	ApiService *DeviceManagementActionsApiService
	deviceCompliancePolicyId string
	inlineObject76 *InlineObject76
}

func (r ApiDeviceManagementDeviceCompliancePoliciesDeviceCompliancePolicyAssignRequest) InlineObject76(inlineObject76 InlineObject76) ApiDeviceManagementDeviceCompliancePoliciesDeviceCompliancePolicyAssignRequest {
	r.inlineObject76 = &inlineObject76
	return r
}

func (r ApiDeviceManagementDeviceCompliancePoliciesDeviceCompliancePolicyAssignRequest) Execute() ([]*AnyOfmicrosoftGraphDeviceCompliancePolicyAssignment, *_nethttp.Response, error) {
	return r.ApiService.DeviceManagementDeviceCompliancePoliciesDeviceCompliancePolicyAssignExecute(r)
}

/*
DeviceManagementDeviceCompliancePoliciesDeviceCompliancePolicyAssign Invoke action assign

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param deviceCompliancePolicyId key: id of deviceCompliancePolicy
 @return ApiDeviceManagementDeviceCompliancePoliciesDeviceCompliancePolicyAssignRequest
*/
func (a *DeviceManagementActionsApiService) DeviceManagementDeviceCompliancePoliciesDeviceCompliancePolicyAssign(ctx _context.Context, deviceCompliancePolicyId string) ApiDeviceManagementDeviceCompliancePoliciesDeviceCompliancePolicyAssignRequest {
	return ApiDeviceManagementDeviceCompliancePoliciesDeviceCompliancePolicyAssignRequest{
		ApiService: a,
		ctx: ctx,
		deviceCompliancePolicyId: deviceCompliancePolicyId,
	}
}

// Execute executes the request
//  @return []*AnyOfmicrosoftGraphDeviceCompliancePolicyAssignment
func (a *DeviceManagementActionsApiService) DeviceManagementDeviceCompliancePoliciesDeviceCompliancePolicyAssignExecute(r ApiDeviceManagementDeviceCompliancePoliciesDeviceCompliancePolicyAssignRequest) ([]*AnyOfmicrosoftGraphDeviceCompliancePolicyAssignment, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  []*AnyOfmicrosoftGraphDeviceCompliancePolicyAssignment
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DeviceManagementActionsApiService.DeviceManagementDeviceCompliancePoliciesDeviceCompliancePolicyAssign")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/deviceManagement/deviceCompliancePolicies/{deviceCompliancePolicy-id}/microsoft.graph.assign"
	localVarPath = strings.Replace(localVarPath, "{"+"deviceCompliancePolicy-id"+"}", _neturl.PathEscape(parameterToString(r.deviceCompliancePolicyId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject76 == nil {
		return localVarReturnValue, nil, reportError("inlineObject76 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject76
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeviceManagementDeviceCompliancePoliciesDeviceCompliancePolicyScheduleActionsForRulesRequest struct {
	ctx _context.Context
	ApiService *DeviceManagementActionsApiService
	deviceCompliancePolicyId string
	inlineObject77 *InlineObject77
}

func (r ApiDeviceManagementDeviceCompliancePoliciesDeviceCompliancePolicyScheduleActionsForRulesRequest) InlineObject77(inlineObject77 InlineObject77) ApiDeviceManagementDeviceCompliancePoliciesDeviceCompliancePolicyScheduleActionsForRulesRequest {
	r.inlineObject77 = &inlineObject77
	return r
}

func (r ApiDeviceManagementDeviceCompliancePoliciesDeviceCompliancePolicyScheduleActionsForRulesRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.DeviceManagementDeviceCompliancePoliciesDeviceCompliancePolicyScheduleActionsForRulesExecute(r)
}

/*
DeviceManagementDeviceCompliancePoliciesDeviceCompliancePolicyScheduleActionsForRules Invoke action scheduleActionsForRules

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param deviceCompliancePolicyId key: id of deviceCompliancePolicy
 @return ApiDeviceManagementDeviceCompliancePoliciesDeviceCompliancePolicyScheduleActionsForRulesRequest
*/
func (a *DeviceManagementActionsApiService) DeviceManagementDeviceCompliancePoliciesDeviceCompliancePolicyScheduleActionsForRules(ctx _context.Context, deviceCompliancePolicyId string) ApiDeviceManagementDeviceCompliancePoliciesDeviceCompliancePolicyScheduleActionsForRulesRequest {
	return ApiDeviceManagementDeviceCompliancePoliciesDeviceCompliancePolicyScheduleActionsForRulesRequest{
		ApiService: a,
		ctx: ctx,
		deviceCompliancePolicyId: deviceCompliancePolicyId,
	}
}

// Execute executes the request
func (a *DeviceManagementActionsApiService) DeviceManagementDeviceCompliancePoliciesDeviceCompliancePolicyScheduleActionsForRulesExecute(r ApiDeviceManagementDeviceCompliancePoliciesDeviceCompliancePolicyScheduleActionsForRulesRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DeviceManagementActionsApiService.DeviceManagementDeviceCompliancePoliciesDeviceCompliancePolicyScheduleActionsForRules")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/deviceManagement/deviceCompliancePolicies/{deviceCompliancePolicy-id}/microsoft.graph.scheduleActionsForRules"
	localVarPath = strings.Replace(localVarPath, "{"+"deviceCompliancePolicy-id"+"}", _neturl.PathEscape(parameterToString(r.deviceCompliancePolicyId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject77 == nil {
		return nil, reportError("inlineObject77 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject77
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDeviceManagementDeviceConfigurationsDeviceConfigurationAssignRequest struct {
	ctx _context.Context
	ApiService *DeviceManagementActionsApiService
	deviceConfigurationId string
	inlineObject78 *InlineObject78
}

func (r ApiDeviceManagementDeviceConfigurationsDeviceConfigurationAssignRequest) InlineObject78(inlineObject78 InlineObject78) ApiDeviceManagementDeviceConfigurationsDeviceConfigurationAssignRequest {
	r.inlineObject78 = &inlineObject78
	return r
}

func (r ApiDeviceManagementDeviceConfigurationsDeviceConfigurationAssignRequest) Execute() ([]*AnyOfmicrosoftGraphDeviceConfigurationAssignment, *_nethttp.Response, error) {
	return r.ApiService.DeviceManagementDeviceConfigurationsDeviceConfigurationAssignExecute(r)
}

/*
DeviceManagementDeviceConfigurationsDeviceConfigurationAssign Invoke action assign

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param deviceConfigurationId key: id of deviceConfiguration
 @return ApiDeviceManagementDeviceConfigurationsDeviceConfigurationAssignRequest
*/
func (a *DeviceManagementActionsApiService) DeviceManagementDeviceConfigurationsDeviceConfigurationAssign(ctx _context.Context, deviceConfigurationId string) ApiDeviceManagementDeviceConfigurationsDeviceConfigurationAssignRequest {
	return ApiDeviceManagementDeviceConfigurationsDeviceConfigurationAssignRequest{
		ApiService: a,
		ctx: ctx,
		deviceConfigurationId: deviceConfigurationId,
	}
}

// Execute executes the request
//  @return []*AnyOfmicrosoftGraphDeviceConfigurationAssignment
func (a *DeviceManagementActionsApiService) DeviceManagementDeviceConfigurationsDeviceConfigurationAssignExecute(r ApiDeviceManagementDeviceConfigurationsDeviceConfigurationAssignRequest) ([]*AnyOfmicrosoftGraphDeviceConfigurationAssignment, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  []*AnyOfmicrosoftGraphDeviceConfigurationAssignment
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DeviceManagementActionsApiService.DeviceManagementDeviceConfigurationsDeviceConfigurationAssign")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/deviceManagement/deviceConfigurations/{deviceConfiguration-id}/microsoft.graph.assign"
	localVarPath = strings.Replace(localVarPath, "{"+"deviceConfiguration-id"+"}", _neturl.PathEscape(parameterToString(r.deviceConfigurationId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject78 == nil {
		return localVarReturnValue, nil, reportError("inlineObject78 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject78
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeviceManagementDeviceEnrollmentConfigurationsDeviceEnrollmentConfigurationAssignRequest struct {
	ctx _context.Context
	ApiService *DeviceManagementActionsApiService
	deviceEnrollmentConfigurationId string
	inlineObject79 *InlineObject79
}

func (r ApiDeviceManagementDeviceEnrollmentConfigurationsDeviceEnrollmentConfigurationAssignRequest) InlineObject79(inlineObject79 InlineObject79) ApiDeviceManagementDeviceEnrollmentConfigurationsDeviceEnrollmentConfigurationAssignRequest {
	r.inlineObject79 = &inlineObject79
	return r
}

func (r ApiDeviceManagementDeviceEnrollmentConfigurationsDeviceEnrollmentConfigurationAssignRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.DeviceManagementDeviceEnrollmentConfigurationsDeviceEnrollmentConfigurationAssignExecute(r)
}

/*
DeviceManagementDeviceEnrollmentConfigurationsDeviceEnrollmentConfigurationAssign Invoke action assign

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param deviceEnrollmentConfigurationId key: id of deviceEnrollmentConfiguration
 @return ApiDeviceManagementDeviceEnrollmentConfigurationsDeviceEnrollmentConfigurationAssignRequest
*/
func (a *DeviceManagementActionsApiService) DeviceManagementDeviceEnrollmentConfigurationsDeviceEnrollmentConfigurationAssign(ctx _context.Context, deviceEnrollmentConfigurationId string) ApiDeviceManagementDeviceEnrollmentConfigurationsDeviceEnrollmentConfigurationAssignRequest {
	return ApiDeviceManagementDeviceEnrollmentConfigurationsDeviceEnrollmentConfigurationAssignRequest{
		ApiService: a,
		ctx: ctx,
		deviceEnrollmentConfigurationId: deviceEnrollmentConfigurationId,
	}
}

// Execute executes the request
func (a *DeviceManagementActionsApiService) DeviceManagementDeviceEnrollmentConfigurationsDeviceEnrollmentConfigurationAssignExecute(r ApiDeviceManagementDeviceEnrollmentConfigurationsDeviceEnrollmentConfigurationAssignRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DeviceManagementActionsApiService.DeviceManagementDeviceEnrollmentConfigurationsDeviceEnrollmentConfigurationAssign")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/deviceManagement/deviceEnrollmentConfigurations/{deviceEnrollmentConfiguration-id}/microsoft.graph.assign"
	localVarPath = strings.Replace(localVarPath, "{"+"deviceEnrollmentConfiguration-id"+"}", _neturl.PathEscape(parameterToString(r.deviceEnrollmentConfigurationId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject79 == nil {
		return nil, reportError("inlineObject79 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject79
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDeviceManagementDeviceEnrollmentConfigurationsDeviceEnrollmentConfigurationSetPriorityRequest struct {
	ctx _context.Context
	ApiService *DeviceManagementActionsApiService
	deviceEnrollmentConfigurationId string
	inlineObject80 *InlineObject80
}

func (r ApiDeviceManagementDeviceEnrollmentConfigurationsDeviceEnrollmentConfigurationSetPriorityRequest) InlineObject80(inlineObject80 InlineObject80) ApiDeviceManagementDeviceEnrollmentConfigurationsDeviceEnrollmentConfigurationSetPriorityRequest {
	r.inlineObject80 = &inlineObject80
	return r
}

func (r ApiDeviceManagementDeviceEnrollmentConfigurationsDeviceEnrollmentConfigurationSetPriorityRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.DeviceManagementDeviceEnrollmentConfigurationsDeviceEnrollmentConfigurationSetPriorityExecute(r)
}

/*
DeviceManagementDeviceEnrollmentConfigurationsDeviceEnrollmentConfigurationSetPriority Invoke action setPriority

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param deviceEnrollmentConfigurationId key: id of deviceEnrollmentConfiguration
 @return ApiDeviceManagementDeviceEnrollmentConfigurationsDeviceEnrollmentConfigurationSetPriorityRequest
*/
func (a *DeviceManagementActionsApiService) DeviceManagementDeviceEnrollmentConfigurationsDeviceEnrollmentConfigurationSetPriority(ctx _context.Context, deviceEnrollmentConfigurationId string) ApiDeviceManagementDeviceEnrollmentConfigurationsDeviceEnrollmentConfigurationSetPriorityRequest {
	return ApiDeviceManagementDeviceEnrollmentConfigurationsDeviceEnrollmentConfigurationSetPriorityRequest{
		ApiService: a,
		ctx: ctx,
		deviceEnrollmentConfigurationId: deviceEnrollmentConfigurationId,
	}
}

// Execute executes the request
func (a *DeviceManagementActionsApiService) DeviceManagementDeviceEnrollmentConfigurationsDeviceEnrollmentConfigurationSetPriorityExecute(r ApiDeviceManagementDeviceEnrollmentConfigurationsDeviceEnrollmentConfigurationSetPriorityRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DeviceManagementActionsApiService.DeviceManagementDeviceEnrollmentConfigurationsDeviceEnrollmentConfigurationSetPriority")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/deviceManagement/deviceEnrollmentConfigurations/{deviceEnrollmentConfiguration-id}/microsoft.graph.setPriority"
	localVarPath = strings.Replace(localVarPath, "{"+"deviceEnrollmentConfiguration-id"+"}", _neturl.PathEscape(parameterToString(r.deviceEnrollmentConfigurationId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject80 == nil {
		return nil, reportError("inlineObject80 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject80
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDeviceManagementExchangeConnectorsDeviceManagementExchangeConnectorSyncRequest struct {
	ctx _context.Context
	ApiService *DeviceManagementActionsApiService
	deviceManagementExchangeConnectorId string
	inlineObject81 *InlineObject81
}

func (r ApiDeviceManagementExchangeConnectorsDeviceManagementExchangeConnectorSyncRequest) InlineObject81(inlineObject81 InlineObject81) ApiDeviceManagementExchangeConnectorsDeviceManagementExchangeConnectorSyncRequest {
	r.inlineObject81 = &inlineObject81
	return r
}

func (r ApiDeviceManagementExchangeConnectorsDeviceManagementExchangeConnectorSyncRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.DeviceManagementExchangeConnectorsDeviceManagementExchangeConnectorSyncExecute(r)
}

/*
DeviceManagementExchangeConnectorsDeviceManagementExchangeConnectorSync Invoke action sync

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param deviceManagementExchangeConnectorId key: id of deviceManagementExchangeConnector
 @return ApiDeviceManagementExchangeConnectorsDeviceManagementExchangeConnectorSyncRequest
*/
func (a *DeviceManagementActionsApiService) DeviceManagementExchangeConnectorsDeviceManagementExchangeConnectorSync(ctx _context.Context, deviceManagementExchangeConnectorId string) ApiDeviceManagementExchangeConnectorsDeviceManagementExchangeConnectorSyncRequest {
	return ApiDeviceManagementExchangeConnectorsDeviceManagementExchangeConnectorSyncRequest{
		ApiService: a,
		ctx: ctx,
		deviceManagementExchangeConnectorId: deviceManagementExchangeConnectorId,
	}
}

// Execute executes the request
func (a *DeviceManagementActionsApiService) DeviceManagementExchangeConnectorsDeviceManagementExchangeConnectorSyncExecute(r ApiDeviceManagementExchangeConnectorsDeviceManagementExchangeConnectorSyncRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DeviceManagementActionsApiService.DeviceManagementExchangeConnectorsDeviceManagementExchangeConnectorSync")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/deviceManagement/exchangeConnectors/{deviceManagementExchangeConnector-id}/microsoft.graph.sync"
	localVarPath = strings.Replace(localVarPath, "{"+"deviceManagementExchangeConnector-id"+"}", _neturl.PathEscape(parameterToString(r.deviceManagementExchangeConnectorId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject81 == nil {
		return nil, reportError("inlineObject81 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject81
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDeviceManagementImportedWindowsAutopilotDeviceIdentitiesImportRequest struct {
	ctx _context.Context
	ApiService *DeviceManagementActionsApiService
	inlineObject82 *InlineObject82
}

func (r ApiDeviceManagementImportedWindowsAutopilotDeviceIdentitiesImportRequest) InlineObject82(inlineObject82 InlineObject82) ApiDeviceManagementImportedWindowsAutopilotDeviceIdentitiesImportRequest {
	r.inlineObject82 = &inlineObject82
	return r
}

func (r ApiDeviceManagementImportedWindowsAutopilotDeviceIdentitiesImportRequest) Execute() ([]*AnyOfmicrosoftGraphImportedWindowsAutopilotDeviceIdentity, *_nethttp.Response, error) {
	return r.ApiService.DeviceManagementImportedWindowsAutopilotDeviceIdentitiesImportExecute(r)
}

/*
DeviceManagementImportedWindowsAutopilotDeviceIdentitiesImport Invoke action import

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDeviceManagementImportedWindowsAutopilotDeviceIdentitiesImportRequest
*/
func (a *DeviceManagementActionsApiService) DeviceManagementImportedWindowsAutopilotDeviceIdentitiesImport(ctx _context.Context) ApiDeviceManagementImportedWindowsAutopilotDeviceIdentitiesImportRequest {
	return ApiDeviceManagementImportedWindowsAutopilotDeviceIdentitiesImportRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []*AnyOfmicrosoftGraphImportedWindowsAutopilotDeviceIdentity
func (a *DeviceManagementActionsApiService) DeviceManagementImportedWindowsAutopilotDeviceIdentitiesImportExecute(r ApiDeviceManagementImportedWindowsAutopilotDeviceIdentitiesImportRequest) ([]*AnyOfmicrosoftGraphImportedWindowsAutopilotDeviceIdentity, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  []*AnyOfmicrosoftGraphImportedWindowsAutopilotDeviceIdentity
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DeviceManagementActionsApiService.DeviceManagementImportedWindowsAutopilotDeviceIdentitiesImport")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/deviceManagement/importedWindowsAutopilotDeviceIdentities/microsoft.graph.import"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject82 == nil {
		return localVarReturnValue, nil, reportError("inlineObject82 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject82
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeviceManagementManagedDevicesManagedDeviceBypassActivationLockRequest struct {
	ctx _context.Context
	ApiService *DeviceManagementActionsApiService
	managedDeviceId string
}


func (r ApiDeviceManagementManagedDevicesManagedDeviceBypassActivationLockRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.DeviceManagementManagedDevicesManagedDeviceBypassActivationLockExecute(r)
}

/*
DeviceManagementManagedDevicesManagedDeviceBypassActivationLock Invoke action bypassActivationLock

Bypass activation lock

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param managedDeviceId key: id of managedDevice
 @return ApiDeviceManagementManagedDevicesManagedDeviceBypassActivationLockRequest
*/
func (a *DeviceManagementActionsApiService) DeviceManagementManagedDevicesManagedDeviceBypassActivationLock(ctx _context.Context, managedDeviceId string) ApiDeviceManagementManagedDevicesManagedDeviceBypassActivationLockRequest {
	return ApiDeviceManagementManagedDevicesManagedDeviceBypassActivationLockRequest{
		ApiService: a,
		ctx: ctx,
		managedDeviceId: managedDeviceId,
	}
}

// Execute executes the request
func (a *DeviceManagementActionsApiService) DeviceManagementManagedDevicesManagedDeviceBypassActivationLockExecute(r ApiDeviceManagementManagedDevicesManagedDeviceBypassActivationLockRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DeviceManagementActionsApiService.DeviceManagementManagedDevicesManagedDeviceBypassActivationLock")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/deviceManagement/managedDevices/{managedDevice-id}/microsoft.graph.bypassActivationLock"
	localVarPath = strings.Replace(localVarPath, "{"+"managedDevice-id"+"}", _neturl.PathEscape(parameterToString(r.managedDeviceId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDeviceManagementManagedDevicesManagedDeviceCleanWindowsDeviceRequest struct {
	ctx _context.Context
	ApiService *DeviceManagementActionsApiService
	managedDeviceId string
	inlineObject83 *InlineObject83
}

func (r ApiDeviceManagementManagedDevicesManagedDeviceCleanWindowsDeviceRequest) InlineObject83(inlineObject83 InlineObject83) ApiDeviceManagementManagedDevicesManagedDeviceCleanWindowsDeviceRequest {
	r.inlineObject83 = &inlineObject83
	return r
}

func (r ApiDeviceManagementManagedDevicesManagedDeviceCleanWindowsDeviceRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.DeviceManagementManagedDevicesManagedDeviceCleanWindowsDeviceExecute(r)
}

/*
DeviceManagementManagedDevicesManagedDeviceCleanWindowsDevice Invoke action cleanWindowsDevice

Clean Windows device

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param managedDeviceId key: id of managedDevice
 @return ApiDeviceManagementManagedDevicesManagedDeviceCleanWindowsDeviceRequest
*/
func (a *DeviceManagementActionsApiService) DeviceManagementManagedDevicesManagedDeviceCleanWindowsDevice(ctx _context.Context, managedDeviceId string) ApiDeviceManagementManagedDevicesManagedDeviceCleanWindowsDeviceRequest {
	return ApiDeviceManagementManagedDevicesManagedDeviceCleanWindowsDeviceRequest{
		ApiService: a,
		ctx: ctx,
		managedDeviceId: managedDeviceId,
	}
}

// Execute executes the request
func (a *DeviceManagementActionsApiService) DeviceManagementManagedDevicesManagedDeviceCleanWindowsDeviceExecute(r ApiDeviceManagementManagedDevicesManagedDeviceCleanWindowsDeviceRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DeviceManagementActionsApiService.DeviceManagementManagedDevicesManagedDeviceCleanWindowsDevice")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/deviceManagement/managedDevices/{managedDevice-id}/microsoft.graph.cleanWindowsDevice"
	localVarPath = strings.Replace(localVarPath, "{"+"managedDevice-id"+"}", _neturl.PathEscape(parameterToString(r.managedDeviceId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject83 == nil {
		return nil, reportError("inlineObject83 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject83
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDeviceManagementManagedDevicesManagedDeviceDeleteUserFromSharedAppleDeviceRequest struct {
	ctx _context.Context
	ApiService *DeviceManagementActionsApiService
	managedDeviceId string
	inlineObject84 *InlineObject84
}

func (r ApiDeviceManagementManagedDevicesManagedDeviceDeleteUserFromSharedAppleDeviceRequest) InlineObject84(inlineObject84 InlineObject84) ApiDeviceManagementManagedDevicesManagedDeviceDeleteUserFromSharedAppleDeviceRequest {
	r.inlineObject84 = &inlineObject84
	return r
}

func (r ApiDeviceManagementManagedDevicesManagedDeviceDeleteUserFromSharedAppleDeviceRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.DeviceManagementManagedDevicesManagedDeviceDeleteUserFromSharedAppleDeviceExecute(r)
}

/*
DeviceManagementManagedDevicesManagedDeviceDeleteUserFromSharedAppleDevice Invoke action deleteUserFromSharedAppleDevice

Delete user from shared Apple device

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param managedDeviceId key: id of managedDevice
 @return ApiDeviceManagementManagedDevicesManagedDeviceDeleteUserFromSharedAppleDeviceRequest
*/
func (a *DeviceManagementActionsApiService) DeviceManagementManagedDevicesManagedDeviceDeleteUserFromSharedAppleDevice(ctx _context.Context, managedDeviceId string) ApiDeviceManagementManagedDevicesManagedDeviceDeleteUserFromSharedAppleDeviceRequest {
	return ApiDeviceManagementManagedDevicesManagedDeviceDeleteUserFromSharedAppleDeviceRequest{
		ApiService: a,
		ctx: ctx,
		managedDeviceId: managedDeviceId,
	}
}

// Execute executes the request
func (a *DeviceManagementActionsApiService) DeviceManagementManagedDevicesManagedDeviceDeleteUserFromSharedAppleDeviceExecute(r ApiDeviceManagementManagedDevicesManagedDeviceDeleteUserFromSharedAppleDeviceRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DeviceManagementActionsApiService.DeviceManagementManagedDevicesManagedDeviceDeleteUserFromSharedAppleDevice")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/deviceManagement/managedDevices/{managedDevice-id}/microsoft.graph.deleteUserFromSharedAppleDevice"
	localVarPath = strings.Replace(localVarPath, "{"+"managedDevice-id"+"}", _neturl.PathEscape(parameterToString(r.managedDeviceId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject84 == nil {
		return nil, reportError("inlineObject84 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject84
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDeviceManagementManagedDevicesManagedDeviceDisableLostModeRequest struct {
	ctx _context.Context
	ApiService *DeviceManagementActionsApiService
	managedDeviceId string
}


func (r ApiDeviceManagementManagedDevicesManagedDeviceDisableLostModeRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.DeviceManagementManagedDevicesManagedDeviceDisableLostModeExecute(r)
}

/*
DeviceManagementManagedDevicesManagedDeviceDisableLostMode Invoke action disableLostMode

Disable lost mode

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param managedDeviceId key: id of managedDevice
 @return ApiDeviceManagementManagedDevicesManagedDeviceDisableLostModeRequest
*/
func (a *DeviceManagementActionsApiService) DeviceManagementManagedDevicesManagedDeviceDisableLostMode(ctx _context.Context, managedDeviceId string) ApiDeviceManagementManagedDevicesManagedDeviceDisableLostModeRequest {
	return ApiDeviceManagementManagedDevicesManagedDeviceDisableLostModeRequest{
		ApiService: a,
		ctx: ctx,
		managedDeviceId: managedDeviceId,
	}
}

// Execute executes the request
func (a *DeviceManagementActionsApiService) DeviceManagementManagedDevicesManagedDeviceDisableLostModeExecute(r ApiDeviceManagementManagedDevicesManagedDeviceDisableLostModeRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DeviceManagementActionsApiService.DeviceManagementManagedDevicesManagedDeviceDisableLostMode")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/deviceManagement/managedDevices/{managedDevice-id}/microsoft.graph.disableLostMode"
	localVarPath = strings.Replace(localVarPath, "{"+"managedDevice-id"+"}", _neturl.PathEscape(parameterToString(r.managedDeviceId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDeviceManagementManagedDevicesManagedDeviceLocateDeviceRequest struct {
	ctx _context.Context
	ApiService *DeviceManagementActionsApiService
	managedDeviceId string
}


func (r ApiDeviceManagementManagedDevicesManagedDeviceLocateDeviceRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.DeviceManagementManagedDevicesManagedDeviceLocateDeviceExecute(r)
}

/*
DeviceManagementManagedDevicesManagedDeviceLocateDevice Invoke action locateDevice

Locate a device

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param managedDeviceId key: id of managedDevice
 @return ApiDeviceManagementManagedDevicesManagedDeviceLocateDeviceRequest
*/
func (a *DeviceManagementActionsApiService) DeviceManagementManagedDevicesManagedDeviceLocateDevice(ctx _context.Context, managedDeviceId string) ApiDeviceManagementManagedDevicesManagedDeviceLocateDeviceRequest {
	return ApiDeviceManagementManagedDevicesManagedDeviceLocateDeviceRequest{
		ApiService: a,
		ctx: ctx,
		managedDeviceId: managedDeviceId,
	}
}

// Execute executes the request
func (a *DeviceManagementActionsApiService) DeviceManagementManagedDevicesManagedDeviceLocateDeviceExecute(r ApiDeviceManagementManagedDevicesManagedDeviceLocateDeviceRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DeviceManagementActionsApiService.DeviceManagementManagedDevicesManagedDeviceLocateDevice")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/deviceManagement/managedDevices/{managedDevice-id}/microsoft.graph.locateDevice"
	localVarPath = strings.Replace(localVarPath, "{"+"managedDevice-id"+"}", _neturl.PathEscape(parameterToString(r.managedDeviceId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDeviceManagementManagedDevicesManagedDeviceLogoutSharedAppleDeviceActiveUserRequest struct {
	ctx _context.Context
	ApiService *DeviceManagementActionsApiService
	managedDeviceId string
}


func (r ApiDeviceManagementManagedDevicesManagedDeviceLogoutSharedAppleDeviceActiveUserRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.DeviceManagementManagedDevicesManagedDeviceLogoutSharedAppleDeviceActiveUserExecute(r)
}

/*
DeviceManagementManagedDevicesManagedDeviceLogoutSharedAppleDeviceActiveUser Invoke action logoutSharedAppleDeviceActiveUser

Logout shared Apple device active user

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param managedDeviceId key: id of managedDevice
 @return ApiDeviceManagementManagedDevicesManagedDeviceLogoutSharedAppleDeviceActiveUserRequest
*/
func (a *DeviceManagementActionsApiService) DeviceManagementManagedDevicesManagedDeviceLogoutSharedAppleDeviceActiveUser(ctx _context.Context, managedDeviceId string) ApiDeviceManagementManagedDevicesManagedDeviceLogoutSharedAppleDeviceActiveUserRequest {
	return ApiDeviceManagementManagedDevicesManagedDeviceLogoutSharedAppleDeviceActiveUserRequest{
		ApiService: a,
		ctx: ctx,
		managedDeviceId: managedDeviceId,
	}
}

// Execute executes the request
func (a *DeviceManagementActionsApiService) DeviceManagementManagedDevicesManagedDeviceLogoutSharedAppleDeviceActiveUserExecute(r ApiDeviceManagementManagedDevicesManagedDeviceLogoutSharedAppleDeviceActiveUserRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DeviceManagementActionsApiService.DeviceManagementManagedDevicesManagedDeviceLogoutSharedAppleDeviceActiveUser")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/deviceManagement/managedDevices/{managedDevice-id}/microsoft.graph.logoutSharedAppleDeviceActiveUser"
	localVarPath = strings.Replace(localVarPath, "{"+"managedDevice-id"+"}", _neturl.PathEscape(parameterToString(r.managedDeviceId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDeviceManagementManagedDevicesManagedDeviceRebootNowRequest struct {
	ctx _context.Context
	ApiService *DeviceManagementActionsApiService
	managedDeviceId string
}


func (r ApiDeviceManagementManagedDevicesManagedDeviceRebootNowRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.DeviceManagementManagedDevicesManagedDeviceRebootNowExecute(r)
}

/*
DeviceManagementManagedDevicesManagedDeviceRebootNow Invoke action rebootNow

Reboot device

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param managedDeviceId key: id of managedDevice
 @return ApiDeviceManagementManagedDevicesManagedDeviceRebootNowRequest
*/
func (a *DeviceManagementActionsApiService) DeviceManagementManagedDevicesManagedDeviceRebootNow(ctx _context.Context, managedDeviceId string) ApiDeviceManagementManagedDevicesManagedDeviceRebootNowRequest {
	return ApiDeviceManagementManagedDevicesManagedDeviceRebootNowRequest{
		ApiService: a,
		ctx: ctx,
		managedDeviceId: managedDeviceId,
	}
}

// Execute executes the request
func (a *DeviceManagementActionsApiService) DeviceManagementManagedDevicesManagedDeviceRebootNowExecute(r ApiDeviceManagementManagedDevicesManagedDeviceRebootNowRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DeviceManagementActionsApiService.DeviceManagementManagedDevicesManagedDeviceRebootNow")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/deviceManagement/managedDevices/{managedDevice-id}/microsoft.graph.rebootNow"
	localVarPath = strings.Replace(localVarPath, "{"+"managedDevice-id"+"}", _neturl.PathEscape(parameterToString(r.managedDeviceId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDeviceManagementManagedDevicesManagedDeviceRecoverPasscodeRequest struct {
	ctx _context.Context
	ApiService *DeviceManagementActionsApiService
	managedDeviceId string
}


func (r ApiDeviceManagementManagedDevicesManagedDeviceRecoverPasscodeRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.DeviceManagementManagedDevicesManagedDeviceRecoverPasscodeExecute(r)
}

/*
DeviceManagementManagedDevicesManagedDeviceRecoverPasscode Invoke action recoverPasscode

Recover passcode

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param managedDeviceId key: id of managedDevice
 @return ApiDeviceManagementManagedDevicesManagedDeviceRecoverPasscodeRequest
*/
func (a *DeviceManagementActionsApiService) DeviceManagementManagedDevicesManagedDeviceRecoverPasscode(ctx _context.Context, managedDeviceId string) ApiDeviceManagementManagedDevicesManagedDeviceRecoverPasscodeRequest {
	return ApiDeviceManagementManagedDevicesManagedDeviceRecoverPasscodeRequest{
		ApiService: a,
		ctx: ctx,
		managedDeviceId: managedDeviceId,
	}
}

// Execute executes the request
func (a *DeviceManagementActionsApiService) DeviceManagementManagedDevicesManagedDeviceRecoverPasscodeExecute(r ApiDeviceManagementManagedDevicesManagedDeviceRecoverPasscodeRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DeviceManagementActionsApiService.DeviceManagementManagedDevicesManagedDeviceRecoverPasscode")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/deviceManagement/managedDevices/{managedDevice-id}/microsoft.graph.recoverPasscode"
	localVarPath = strings.Replace(localVarPath, "{"+"managedDevice-id"+"}", _neturl.PathEscape(parameterToString(r.managedDeviceId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDeviceManagementManagedDevicesManagedDeviceRemoteLockRequest struct {
	ctx _context.Context
	ApiService *DeviceManagementActionsApiService
	managedDeviceId string
}


func (r ApiDeviceManagementManagedDevicesManagedDeviceRemoteLockRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.DeviceManagementManagedDevicesManagedDeviceRemoteLockExecute(r)
}

/*
DeviceManagementManagedDevicesManagedDeviceRemoteLock Invoke action remoteLock

Remote lock

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param managedDeviceId key: id of managedDevice
 @return ApiDeviceManagementManagedDevicesManagedDeviceRemoteLockRequest
*/
func (a *DeviceManagementActionsApiService) DeviceManagementManagedDevicesManagedDeviceRemoteLock(ctx _context.Context, managedDeviceId string) ApiDeviceManagementManagedDevicesManagedDeviceRemoteLockRequest {
	return ApiDeviceManagementManagedDevicesManagedDeviceRemoteLockRequest{
		ApiService: a,
		ctx: ctx,
		managedDeviceId: managedDeviceId,
	}
}

// Execute executes the request
func (a *DeviceManagementActionsApiService) DeviceManagementManagedDevicesManagedDeviceRemoteLockExecute(r ApiDeviceManagementManagedDevicesManagedDeviceRemoteLockRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DeviceManagementActionsApiService.DeviceManagementManagedDevicesManagedDeviceRemoteLock")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/deviceManagement/managedDevices/{managedDevice-id}/microsoft.graph.remoteLock"
	localVarPath = strings.Replace(localVarPath, "{"+"managedDevice-id"+"}", _neturl.PathEscape(parameterToString(r.managedDeviceId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDeviceManagementManagedDevicesManagedDeviceRequestRemoteAssistanceRequest struct {
	ctx _context.Context
	ApiService *DeviceManagementActionsApiService
	managedDeviceId string
}


func (r ApiDeviceManagementManagedDevicesManagedDeviceRequestRemoteAssistanceRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.DeviceManagementManagedDevicesManagedDeviceRequestRemoteAssistanceExecute(r)
}

/*
DeviceManagementManagedDevicesManagedDeviceRequestRemoteAssistance Invoke action requestRemoteAssistance

Request remote assistance

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param managedDeviceId key: id of managedDevice
 @return ApiDeviceManagementManagedDevicesManagedDeviceRequestRemoteAssistanceRequest
*/
func (a *DeviceManagementActionsApiService) DeviceManagementManagedDevicesManagedDeviceRequestRemoteAssistance(ctx _context.Context, managedDeviceId string) ApiDeviceManagementManagedDevicesManagedDeviceRequestRemoteAssistanceRequest {
	return ApiDeviceManagementManagedDevicesManagedDeviceRequestRemoteAssistanceRequest{
		ApiService: a,
		ctx: ctx,
		managedDeviceId: managedDeviceId,
	}
}

// Execute executes the request
func (a *DeviceManagementActionsApiService) DeviceManagementManagedDevicesManagedDeviceRequestRemoteAssistanceExecute(r ApiDeviceManagementManagedDevicesManagedDeviceRequestRemoteAssistanceRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DeviceManagementActionsApiService.DeviceManagementManagedDevicesManagedDeviceRequestRemoteAssistance")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/deviceManagement/managedDevices/{managedDevice-id}/microsoft.graph.requestRemoteAssistance"
	localVarPath = strings.Replace(localVarPath, "{"+"managedDevice-id"+"}", _neturl.PathEscape(parameterToString(r.managedDeviceId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDeviceManagementManagedDevicesManagedDeviceResetPasscodeRequest struct {
	ctx _context.Context
	ApiService *DeviceManagementActionsApiService
	managedDeviceId string
}


func (r ApiDeviceManagementManagedDevicesManagedDeviceResetPasscodeRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.DeviceManagementManagedDevicesManagedDeviceResetPasscodeExecute(r)
}

/*
DeviceManagementManagedDevicesManagedDeviceResetPasscode Invoke action resetPasscode

Reset passcode

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param managedDeviceId key: id of managedDevice
 @return ApiDeviceManagementManagedDevicesManagedDeviceResetPasscodeRequest
*/
func (a *DeviceManagementActionsApiService) DeviceManagementManagedDevicesManagedDeviceResetPasscode(ctx _context.Context, managedDeviceId string) ApiDeviceManagementManagedDevicesManagedDeviceResetPasscodeRequest {
	return ApiDeviceManagementManagedDevicesManagedDeviceResetPasscodeRequest{
		ApiService: a,
		ctx: ctx,
		managedDeviceId: managedDeviceId,
	}
}

// Execute executes the request
func (a *DeviceManagementActionsApiService) DeviceManagementManagedDevicesManagedDeviceResetPasscodeExecute(r ApiDeviceManagementManagedDevicesManagedDeviceResetPasscodeRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DeviceManagementActionsApiService.DeviceManagementManagedDevicesManagedDeviceResetPasscode")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/deviceManagement/managedDevices/{managedDevice-id}/microsoft.graph.resetPasscode"
	localVarPath = strings.Replace(localVarPath, "{"+"managedDevice-id"+"}", _neturl.PathEscape(parameterToString(r.managedDeviceId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDeviceManagementManagedDevicesManagedDeviceRetireRequest struct {
	ctx _context.Context
	ApiService *DeviceManagementActionsApiService
	managedDeviceId string
}


func (r ApiDeviceManagementManagedDevicesManagedDeviceRetireRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.DeviceManagementManagedDevicesManagedDeviceRetireExecute(r)
}

/*
DeviceManagementManagedDevicesManagedDeviceRetire Invoke action retire

Retire a device

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param managedDeviceId key: id of managedDevice
 @return ApiDeviceManagementManagedDevicesManagedDeviceRetireRequest
*/
func (a *DeviceManagementActionsApiService) DeviceManagementManagedDevicesManagedDeviceRetire(ctx _context.Context, managedDeviceId string) ApiDeviceManagementManagedDevicesManagedDeviceRetireRequest {
	return ApiDeviceManagementManagedDevicesManagedDeviceRetireRequest{
		ApiService: a,
		ctx: ctx,
		managedDeviceId: managedDeviceId,
	}
}

// Execute executes the request
func (a *DeviceManagementActionsApiService) DeviceManagementManagedDevicesManagedDeviceRetireExecute(r ApiDeviceManagementManagedDevicesManagedDeviceRetireRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DeviceManagementActionsApiService.DeviceManagementManagedDevicesManagedDeviceRetire")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/deviceManagement/managedDevices/{managedDevice-id}/microsoft.graph.retire"
	localVarPath = strings.Replace(localVarPath, "{"+"managedDevice-id"+"}", _neturl.PathEscape(parameterToString(r.managedDeviceId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDeviceManagementManagedDevicesManagedDeviceShutDownRequest struct {
	ctx _context.Context
	ApiService *DeviceManagementActionsApiService
	managedDeviceId string
}


func (r ApiDeviceManagementManagedDevicesManagedDeviceShutDownRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.DeviceManagementManagedDevicesManagedDeviceShutDownExecute(r)
}

/*
DeviceManagementManagedDevicesManagedDeviceShutDown Invoke action shutDown

Shut down device

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param managedDeviceId key: id of managedDevice
 @return ApiDeviceManagementManagedDevicesManagedDeviceShutDownRequest
*/
func (a *DeviceManagementActionsApiService) DeviceManagementManagedDevicesManagedDeviceShutDown(ctx _context.Context, managedDeviceId string) ApiDeviceManagementManagedDevicesManagedDeviceShutDownRequest {
	return ApiDeviceManagementManagedDevicesManagedDeviceShutDownRequest{
		ApiService: a,
		ctx: ctx,
		managedDeviceId: managedDeviceId,
	}
}

// Execute executes the request
func (a *DeviceManagementActionsApiService) DeviceManagementManagedDevicesManagedDeviceShutDownExecute(r ApiDeviceManagementManagedDevicesManagedDeviceShutDownRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DeviceManagementActionsApiService.DeviceManagementManagedDevicesManagedDeviceShutDown")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/deviceManagement/managedDevices/{managedDevice-id}/microsoft.graph.shutDown"
	localVarPath = strings.Replace(localVarPath, "{"+"managedDevice-id"+"}", _neturl.PathEscape(parameterToString(r.managedDeviceId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDeviceManagementManagedDevicesManagedDeviceSyncDeviceRequest struct {
	ctx _context.Context
	ApiService *DeviceManagementActionsApiService
	managedDeviceId string
}


func (r ApiDeviceManagementManagedDevicesManagedDeviceSyncDeviceRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.DeviceManagementManagedDevicesManagedDeviceSyncDeviceExecute(r)
}

/*
DeviceManagementManagedDevicesManagedDeviceSyncDevice Invoke action syncDevice

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param managedDeviceId key: id of managedDevice
 @return ApiDeviceManagementManagedDevicesManagedDeviceSyncDeviceRequest
*/
func (a *DeviceManagementActionsApiService) DeviceManagementManagedDevicesManagedDeviceSyncDevice(ctx _context.Context, managedDeviceId string) ApiDeviceManagementManagedDevicesManagedDeviceSyncDeviceRequest {
	return ApiDeviceManagementManagedDevicesManagedDeviceSyncDeviceRequest{
		ApiService: a,
		ctx: ctx,
		managedDeviceId: managedDeviceId,
	}
}

// Execute executes the request
func (a *DeviceManagementActionsApiService) DeviceManagementManagedDevicesManagedDeviceSyncDeviceExecute(r ApiDeviceManagementManagedDevicesManagedDeviceSyncDeviceRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DeviceManagementActionsApiService.DeviceManagementManagedDevicesManagedDeviceSyncDevice")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/deviceManagement/managedDevices/{managedDevice-id}/microsoft.graph.syncDevice"
	localVarPath = strings.Replace(localVarPath, "{"+"managedDevice-id"+"}", _neturl.PathEscape(parameterToString(r.managedDeviceId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDeviceManagementManagedDevicesManagedDeviceUpdateWindowsDeviceAccountRequest struct {
	ctx _context.Context
	ApiService *DeviceManagementActionsApiService
	managedDeviceId string
	inlineObject85 *InlineObject85
}

func (r ApiDeviceManagementManagedDevicesManagedDeviceUpdateWindowsDeviceAccountRequest) InlineObject85(inlineObject85 InlineObject85) ApiDeviceManagementManagedDevicesManagedDeviceUpdateWindowsDeviceAccountRequest {
	r.inlineObject85 = &inlineObject85
	return r
}

func (r ApiDeviceManagementManagedDevicesManagedDeviceUpdateWindowsDeviceAccountRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.DeviceManagementManagedDevicesManagedDeviceUpdateWindowsDeviceAccountExecute(r)
}

/*
DeviceManagementManagedDevicesManagedDeviceUpdateWindowsDeviceAccount Invoke action updateWindowsDeviceAccount

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param managedDeviceId key: id of managedDevice
 @return ApiDeviceManagementManagedDevicesManagedDeviceUpdateWindowsDeviceAccountRequest
*/
func (a *DeviceManagementActionsApiService) DeviceManagementManagedDevicesManagedDeviceUpdateWindowsDeviceAccount(ctx _context.Context, managedDeviceId string) ApiDeviceManagementManagedDevicesManagedDeviceUpdateWindowsDeviceAccountRequest {
	return ApiDeviceManagementManagedDevicesManagedDeviceUpdateWindowsDeviceAccountRequest{
		ApiService: a,
		ctx: ctx,
		managedDeviceId: managedDeviceId,
	}
}

// Execute executes the request
func (a *DeviceManagementActionsApiService) DeviceManagementManagedDevicesManagedDeviceUpdateWindowsDeviceAccountExecute(r ApiDeviceManagementManagedDevicesManagedDeviceUpdateWindowsDeviceAccountRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DeviceManagementActionsApiService.DeviceManagementManagedDevicesManagedDeviceUpdateWindowsDeviceAccount")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/deviceManagement/managedDevices/{managedDevice-id}/microsoft.graph.updateWindowsDeviceAccount"
	localVarPath = strings.Replace(localVarPath, "{"+"managedDevice-id"+"}", _neturl.PathEscape(parameterToString(r.managedDeviceId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject85 == nil {
		return nil, reportError("inlineObject85 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject85
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDeviceManagementManagedDevicesManagedDeviceWindowsDefenderScanRequest struct {
	ctx _context.Context
	ApiService *DeviceManagementActionsApiService
	managedDeviceId string
	inlineObject86 *InlineObject86
}

func (r ApiDeviceManagementManagedDevicesManagedDeviceWindowsDefenderScanRequest) InlineObject86(inlineObject86 InlineObject86) ApiDeviceManagementManagedDevicesManagedDeviceWindowsDefenderScanRequest {
	r.inlineObject86 = &inlineObject86
	return r
}

func (r ApiDeviceManagementManagedDevicesManagedDeviceWindowsDefenderScanRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.DeviceManagementManagedDevicesManagedDeviceWindowsDefenderScanExecute(r)
}

/*
DeviceManagementManagedDevicesManagedDeviceWindowsDefenderScan Invoke action windowsDefenderScan

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param managedDeviceId key: id of managedDevice
 @return ApiDeviceManagementManagedDevicesManagedDeviceWindowsDefenderScanRequest
*/
func (a *DeviceManagementActionsApiService) DeviceManagementManagedDevicesManagedDeviceWindowsDefenderScan(ctx _context.Context, managedDeviceId string) ApiDeviceManagementManagedDevicesManagedDeviceWindowsDefenderScanRequest {
	return ApiDeviceManagementManagedDevicesManagedDeviceWindowsDefenderScanRequest{
		ApiService: a,
		ctx: ctx,
		managedDeviceId: managedDeviceId,
	}
}

// Execute executes the request
func (a *DeviceManagementActionsApiService) DeviceManagementManagedDevicesManagedDeviceWindowsDefenderScanExecute(r ApiDeviceManagementManagedDevicesManagedDeviceWindowsDefenderScanRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DeviceManagementActionsApiService.DeviceManagementManagedDevicesManagedDeviceWindowsDefenderScan")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/deviceManagement/managedDevices/{managedDevice-id}/microsoft.graph.windowsDefenderScan"
	localVarPath = strings.Replace(localVarPath, "{"+"managedDevice-id"+"}", _neturl.PathEscape(parameterToString(r.managedDeviceId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject86 == nil {
		return nil, reportError("inlineObject86 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject86
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDeviceManagementManagedDevicesManagedDeviceWindowsDefenderUpdateSignaturesRequest struct {
	ctx _context.Context
	ApiService *DeviceManagementActionsApiService
	managedDeviceId string
}


func (r ApiDeviceManagementManagedDevicesManagedDeviceWindowsDefenderUpdateSignaturesRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.DeviceManagementManagedDevicesManagedDeviceWindowsDefenderUpdateSignaturesExecute(r)
}

/*
DeviceManagementManagedDevicesManagedDeviceWindowsDefenderUpdateSignatures Invoke action windowsDefenderUpdateSignatures

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param managedDeviceId key: id of managedDevice
 @return ApiDeviceManagementManagedDevicesManagedDeviceWindowsDefenderUpdateSignaturesRequest
*/
func (a *DeviceManagementActionsApiService) DeviceManagementManagedDevicesManagedDeviceWindowsDefenderUpdateSignatures(ctx _context.Context, managedDeviceId string) ApiDeviceManagementManagedDevicesManagedDeviceWindowsDefenderUpdateSignaturesRequest {
	return ApiDeviceManagementManagedDevicesManagedDeviceWindowsDefenderUpdateSignaturesRequest{
		ApiService: a,
		ctx: ctx,
		managedDeviceId: managedDeviceId,
	}
}

// Execute executes the request
func (a *DeviceManagementActionsApiService) DeviceManagementManagedDevicesManagedDeviceWindowsDefenderUpdateSignaturesExecute(r ApiDeviceManagementManagedDevicesManagedDeviceWindowsDefenderUpdateSignaturesRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DeviceManagementActionsApiService.DeviceManagementManagedDevicesManagedDeviceWindowsDefenderUpdateSignatures")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/deviceManagement/managedDevices/{managedDevice-id}/microsoft.graph.windowsDefenderUpdateSignatures"
	localVarPath = strings.Replace(localVarPath, "{"+"managedDevice-id"+"}", _neturl.PathEscape(parameterToString(r.managedDeviceId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDeviceManagementManagedDevicesManagedDeviceWipeRequest struct {
	ctx _context.Context
	ApiService *DeviceManagementActionsApiService
	managedDeviceId string
	inlineObject87 *InlineObject87
}

func (r ApiDeviceManagementManagedDevicesManagedDeviceWipeRequest) InlineObject87(inlineObject87 InlineObject87) ApiDeviceManagementManagedDevicesManagedDeviceWipeRequest {
	r.inlineObject87 = &inlineObject87
	return r
}

func (r ApiDeviceManagementManagedDevicesManagedDeviceWipeRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.DeviceManagementManagedDevicesManagedDeviceWipeExecute(r)
}

/*
DeviceManagementManagedDevicesManagedDeviceWipe Invoke action wipe

Wipe a device

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param managedDeviceId key: id of managedDevice
 @return ApiDeviceManagementManagedDevicesManagedDeviceWipeRequest
*/
func (a *DeviceManagementActionsApiService) DeviceManagementManagedDevicesManagedDeviceWipe(ctx _context.Context, managedDeviceId string) ApiDeviceManagementManagedDevicesManagedDeviceWipeRequest {
	return ApiDeviceManagementManagedDevicesManagedDeviceWipeRequest{
		ApiService: a,
		ctx: ctx,
		managedDeviceId: managedDeviceId,
	}
}

// Execute executes the request
func (a *DeviceManagementActionsApiService) DeviceManagementManagedDevicesManagedDeviceWipeExecute(r ApiDeviceManagementManagedDevicesManagedDeviceWipeRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DeviceManagementActionsApiService.DeviceManagementManagedDevicesManagedDeviceWipe")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/deviceManagement/managedDevices/{managedDevice-id}/microsoft.graph.wipe"
	localVarPath = strings.Replace(localVarPath, "{"+"managedDevice-id"+"}", _neturl.PathEscape(parameterToString(r.managedDeviceId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject87 == nil {
		return nil, reportError("inlineObject87 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject87
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDeviceManagementNotificationMessageTemplatesNotificationMessageTemplateSendTestMessageRequest struct {
	ctx _context.Context
	ApiService *DeviceManagementActionsApiService
	notificationMessageTemplateId string
}


func (r ApiDeviceManagementNotificationMessageTemplatesNotificationMessageTemplateSendTestMessageRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.DeviceManagementNotificationMessageTemplatesNotificationMessageTemplateSendTestMessageExecute(r)
}

/*
DeviceManagementNotificationMessageTemplatesNotificationMessageTemplateSendTestMessage Invoke action sendTestMessage

Sends test message using the specified notificationMessageTemplate in the default locale

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param notificationMessageTemplateId key: id of notificationMessageTemplate
 @return ApiDeviceManagementNotificationMessageTemplatesNotificationMessageTemplateSendTestMessageRequest
*/
func (a *DeviceManagementActionsApiService) DeviceManagementNotificationMessageTemplatesNotificationMessageTemplateSendTestMessage(ctx _context.Context, notificationMessageTemplateId string) ApiDeviceManagementNotificationMessageTemplatesNotificationMessageTemplateSendTestMessageRequest {
	return ApiDeviceManagementNotificationMessageTemplatesNotificationMessageTemplateSendTestMessageRequest{
		ApiService: a,
		ctx: ctx,
		notificationMessageTemplateId: notificationMessageTemplateId,
	}
}

// Execute executes the request
func (a *DeviceManagementActionsApiService) DeviceManagementNotificationMessageTemplatesNotificationMessageTemplateSendTestMessageExecute(r ApiDeviceManagementNotificationMessageTemplatesNotificationMessageTemplateSendTestMessageRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DeviceManagementActionsApiService.DeviceManagementNotificationMessageTemplatesNotificationMessageTemplateSendTestMessage")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/deviceManagement/notificationMessageTemplates/{notificationMessageTemplate-id}/microsoft.graph.sendTestMessage"
	localVarPath = strings.Replace(localVarPath, "{"+"notificationMessageTemplate-id"+"}", _neturl.PathEscape(parameterToString(r.notificationMessageTemplateId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDeviceManagementRemoteAssistancePartnersRemoteAssistancePartnerBeginOnboardingRequest struct {
	ctx _context.Context
	ApiService *DeviceManagementActionsApiService
	remoteAssistancePartnerId string
}


func (r ApiDeviceManagementRemoteAssistancePartnersRemoteAssistancePartnerBeginOnboardingRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.DeviceManagementRemoteAssistancePartnersRemoteAssistancePartnerBeginOnboardingExecute(r)
}

/*
DeviceManagementRemoteAssistancePartnersRemoteAssistancePartnerBeginOnboarding Invoke action beginOnboarding

A request to start onboarding.  Must be coupled with the appropriate TeamViewer account information

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param remoteAssistancePartnerId key: id of remoteAssistancePartner
 @return ApiDeviceManagementRemoteAssistancePartnersRemoteAssistancePartnerBeginOnboardingRequest
*/
func (a *DeviceManagementActionsApiService) DeviceManagementRemoteAssistancePartnersRemoteAssistancePartnerBeginOnboarding(ctx _context.Context, remoteAssistancePartnerId string) ApiDeviceManagementRemoteAssistancePartnersRemoteAssistancePartnerBeginOnboardingRequest {
	return ApiDeviceManagementRemoteAssistancePartnersRemoteAssistancePartnerBeginOnboardingRequest{
		ApiService: a,
		ctx: ctx,
		remoteAssistancePartnerId: remoteAssistancePartnerId,
	}
}

// Execute executes the request
func (a *DeviceManagementActionsApiService) DeviceManagementRemoteAssistancePartnersRemoteAssistancePartnerBeginOnboardingExecute(r ApiDeviceManagementRemoteAssistancePartnersRemoteAssistancePartnerBeginOnboardingRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DeviceManagementActionsApiService.DeviceManagementRemoteAssistancePartnersRemoteAssistancePartnerBeginOnboarding")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/deviceManagement/remoteAssistancePartners/{remoteAssistancePartner-id}/microsoft.graph.beginOnboarding"
	localVarPath = strings.Replace(localVarPath, "{"+"remoteAssistancePartner-id"+"}", _neturl.PathEscape(parameterToString(r.remoteAssistancePartnerId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDeviceManagementRemoteAssistancePartnersRemoteAssistancePartnerDisconnectRequest struct {
	ctx _context.Context
	ApiService *DeviceManagementActionsApiService
	remoteAssistancePartnerId string
}


func (r ApiDeviceManagementRemoteAssistancePartnersRemoteAssistancePartnerDisconnectRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.DeviceManagementRemoteAssistancePartnersRemoteAssistancePartnerDisconnectExecute(r)
}

/*
DeviceManagementRemoteAssistancePartnersRemoteAssistancePartnerDisconnect Invoke action disconnect

A request to remove the active TeamViewer connector

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param remoteAssistancePartnerId key: id of remoteAssistancePartner
 @return ApiDeviceManagementRemoteAssistancePartnersRemoteAssistancePartnerDisconnectRequest
*/
func (a *DeviceManagementActionsApiService) DeviceManagementRemoteAssistancePartnersRemoteAssistancePartnerDisconnect(ctx _context.Context, remoteAssistancePartnerId string) ApiDeviceManagementRemoteAssistancePartnersRemoteAssistancePartnerDisconnectRequest {
	return ApiDeviceManagementRemoteAssistancePartnersRemoteAssistancePartnerDisconnectRequest{
		ApiService: a,
		ctx: ctx,
		remoteAssistancePartnerId: remoteAssistancePartnerId,
	}
}

// Execute executes the request
func (a *DeviceManagementActionsApiService) DeviceManagementRemoteAssistancePartnersRemoteAssistancePartnerDisconnectExecute(r ApiDeviceManagementRemoteAssistancePartnersRemoteAssistancePartnerDisconnectRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DeviceManagementActionsApiService.DeviceManagementRemoteAssistancePartnersRemoteAssistancePartnerDisconnect")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/deviceManagement/remoteAssistancePartners/{remoteAssistancePartner-id}/microsoft.graph.disconnect"
	localVarPath = strings.Replace(localVarPath, "{"+"remoteAssistancePartner-id"+"}", _neturl.PathEscape(parameterToString(r.remoteAssistancePartnerId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDeviceManagementReportsGetCachedReportRequest struct {
	ctx _context.Context
	ApiService *DeviceManagementActionsApiService
	inlineObject88 *InlineObject88
}

func (r ApiDeviceManagementReportsGetCachedReportRequest) InlineObject88(inlineObject88 InlineObject88) ApiDeviceManagementReportsGetCachedReportRequest {
	r.inlineObject88 = &inlineObject88
	return r
}

func (r ApiDeviceManagementReportsGetCachedReportRequest) Execute() (string, *_nethttp.Response, error) {
	return r.ApiService.DeviceManagementReportsGetCachedReportExecute(r)
}

/*
DeviceManagementReportsGetCachedReport Invoke action getCachedReport

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDeviceManagementReportsGetCachedReportRequest
*/
func (a *DeviceManagementActionsApiService) DeviceManagementReportsGetCachedReport(ctx _context.Context) ApiDeviceManagementReportsGetCachedReportRequest {
	return ApiDeviceManagementReportsGetCachedReportRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return string
func (a *DeviceManagementActionsApiService) DeviceManagementReportsGetCachedReportExecute(r ApiDeviceManagementReportsGetCachedReportRequest) (string, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  string
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DeviceManagementActionsApiService.DeviceManagementReportsGetCachedReport")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/deviceManagement/reports/microsoft.graph.getCachedReport"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject88 == nil {
		return localVarReturnValue, nil, reportError("inlineObject88 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject88
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeviceManagementReportsGetCompliancePolicyNonComplianceReportRequest struct {
	ctx _context.Context
	ApiService *DeviceManagementActionsApiService
	inlineObject89 *InlineObject89
}

func (r ApiDeviceManagementReportsGetCompliancePolicyNonComplianceReportRequest) InlineObject89(inlineObject89 InlineObject89) ApiDeviceManagementReportsGetCompliancePolicyNonComplianceReportRequest {
	r.inlineObject89 = &inlineObject89
	return r
}

func (r ApiDeviceManagementReportsGetCompliancePolicyNonComplianceReportRequest) Execute() (string, *_nethttp.Response, error) {
	return r.ApiService.DeviceManagementReportsGetCompliancePolicyNonComplianceReportExecute(r)
}

/*
DeviceManagementReportsGetCompliancePolicyNonComplianceReport Invoke action getCompliancePolicyNonComplianceReport

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDeviceManagementReportsGetCompliancePolicyNonComplianceReportRequest
*/
func (a *DeviceManagementActionsApiService) DeviceManagementReportsGetCompliancePolicyNonComplianceReport(ctx _context.Context) ApiDeviceManagementReportsGetCompliancePolicyNonComplianceReportRequest {
	return ApiDeviceManagementReportsGetCompliancePolicyNonComplianceReportRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return string
func (a *DeviceManagementActionsApiService) DeviceManagementReportsGetCompliancePolicyNonComplianceReportExecute(r ApiDeviceManagementReportsGetCompliancePolicyNonComplianceReportRequest) (string, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  string
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DeviceManagementActionsApiService.DeviceManagementReportsGetCompliancePolicyNonComplianceReport")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/deviceManagement/reports/microsoft.graph.getCompliancePolicyNonComplianceReport"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject89 == nil {
		return localVarReturnValue, nil, reportError("inlineObject89 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject89
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeviceManagementReportsGetCompliancePolicyNonComplianceSummaryReportRequest struct {
	ctx _context.Context
	ApiService *DeviceManagementActionsApiService
	inlineObject90 *InlineObject90
}

func (r ApiDeviceManagementReportsGetCompliancePolicyNonComplianceSummaryReportRequest) InlineObject90(inlineObject90 InlineObject90) ApiDeviceManagementReportsGetCompliancePolicyNonComplianceSummaryReportRequest {
	r.inlineObject90 = &inlineObject90
	return r
}

func (r ApiDeviceManagementReportsGetCompliancePolicyNonComplianceSummaryReportRequest) Execute() (string, *_nethttp.Response, error) {
	return r.ApiService.DeviceManagementReportsGetCompliancePolicyNonComplianceSummaryReportExecute(r)
}

/*
DeviceManagementReportsGetCompliancePolicyNonComplianceSummaryReport Invoke action getCompliancePolicyNonComplianceSummaryReport

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDeviceManagementReportsGetCompliancePolicyNonComplianceSummaryReportRequest
*/
func (a *DeviceManagementActionsApiService) DeviceManagementReportsGetCompliancePolicyNonComplianceSummaryReport(ctx _context.Context) ApiDeviceManagementReportsGetCompliancePolicyNonComplianceSummaryReportRequest {
	return ApiDeviceManagementReportsGetCompliancePolicyNonComplianceSummaryReportRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return string
func (a *DeviceManagementActionsApiService) DeviceManagementReportsGetCompliancePolicyNonComplianceSummaryReportExecute(r ApiDeviceManagementReportsGetCompliancePolicyNonComplianceSummaryReportRequest) (string, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  string
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DeviceManagementActionsApiService.DeviceManagementReportsGetCompliancePolicyNonComplianceSummaryReport")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/deviceManagement/reports/microsoft.graph.getCompliancePolicyNonComplianceSummaryReport"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject90 == nil {
		return localVarReturnValue, nil, reportError("inlineObject90 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject90
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeviceManagementReportsGetComplianceSettingNonComplianceReportRequest struct {
	ctx _context.Context
	ApiService *DeviceManagementActionsApiService
	inlineObject91 *InlineObject91
}

func (r ApiDeviceManagementReportsGetComplianceSettingNonComplianceReportRequest) InlineObject91(inlineObject91 InlineObject91) ApiDeviceManagementReportsGetComplianceSettingNonComplianceReportRequest {
	r.inlineObject91 = &inlineObject91
	return r
}

func (r ApiDeviceManagementReportsGetComplianceSettingNonComplianceReportRequest) Execute() (string, *_nethttp.Response, error) {
	return r.ApiService.DeviceManagementReportsGetComplianceSettingNonComplianceReportExecute(r)
}

/*
DeviceManagementReportsGetComplianceSettingNonComplianceReport Invoke action getComplianceSettingNonComplianceReport

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDeviceManagementReportsGetComplianceSettingNonComplianceReportRequest
*/
func (a *DeviceManagementActionsApiService) DeviceManagementReportsGetComplianceSettingNonComplianceReport(ctx _context.Context) ApiDeviceManagementReportsGetComplianceSettingNonComplianceReportRequest {
	return ApiDeviceManagementReportsGetComplianceSettingNonComplianceReportRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return string
func (a *DeviceManagementActionsApiService) DeviceManagementReportsGetComplianceSettingNonComplianceReportExecute(r ApiDeviceManagementReportsGetComplianceSettingNonComplianceReportRequest) (string, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  string
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DeviceManagementActionsApiService.DeviceManagementReportsGetComplianceSettingNonComplianceReport")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/deviceManagement/reports/microsoft.graph.getComplianceSettingNonComplianceReport"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject91 == nil {
		return localVarReturnValue, nil, reportError("inlineObject91 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject91
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeviceManagementReportsGetConfigurationPolicyNonComplianceReportRequest struct {
	ctx _context.Context
	ApiService *DeviceManagementActionsApiService
	inlineObject92 *InlineObject92
}

func (r ApiDeviceManagementReportsGetConfigurationPolicyNonComplianceReportRequest) InlineObject92(inlineObject92 InlineObject92) ApiDeviceManagementReportsGetConfigurationPolicyNonComplianceReportRequest {
	r.inlineObject92 = &inlineObject92
	return r
}

func (r ApiDeviceManagementReportsGetConfigurationPolicyNonComplianceReportRequest) Execute() (string, *_nethttp.Response, error) {
	return r.ApiService.DeviceManagementReportsGetConfigurationPolicyNonComplianceReportExecute(r)
}

/*
DeviceManagementReportsGetConfigurationPolicyNonComplianceReport Invoke action getConfigurationPolicyNonComplianceReport

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDeviceManagementReportsGetConfigurationPolicyNonComplianceReportRequest
*/
func (a *DeviceManagementActionsApiService) DeviceManagementReportsGetConfigurationPolicyNonComplianceReport(ctx _context.Context) ApiDeviceManagementReportsGetConfigurationPolicyNonComplianceReportRequest {
	return ApiDeviceManagementReportsGetConfigurationPolicyNonComplianceReportRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return string
func (a *DeviceManagementActionsApiService) DeviceManagementReportsGetConfigurationPolicyNonComplianceReportExecute(r ApiDeviceManagementReportsGetConfigurationPolicyNonComplianceReportRequest) (string, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  string
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DeviceManagementActionsApiService.DeviceManagementReportsGetConfigurationPolicyNonComplianceReport")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/deviceManagement/reports/microsoft.graph.getConfigurationPolicyNonComplianceReport"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject92 == nil {
		return localVarReturnValue, nil, reportError("inlineObject92 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject92
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeviceManagementReportsGetConfigurationPolicyNonComplianceSummaryReportRequest struct {
	ctx _context.Context
	ApiService *DeviceManagementActionsApiService
	inlineObject93 *InlineObject93
}

func (r ApiDeviceManagementReportsGetConfigurationPolicyNonComplianceSummaryReportRequest) InlineObject93(inlineObject93 InlineObject93) ApiDeviceManagementReportsGetConfigurationPolicyNonComplianceSummaryReportRequest {
	r.inlineObject93 = &inlineObject93
	return r
}

func (r ApiDeviceManagementReportsGetConfigurationPolicyNonComplianceSummaryReportRequest) Execute() (string, *_nethttp.Response, error) {
	return r.ApiService.DeviceManagementReportsGetConfigurationPolicyNonComplianceSummaryReportExecute(r)
}

/*
DeviceManagementReportsGetConfigurationPolicyNonComplianceSummaryReport Invoke action getConfigurationPolicyNonComplianceSummaryReport

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDeviceManagementReportsGetConfigurationPolicyNonComplianceSummaryReportRequest
*/
func (a *DeviceManagementActionsApiService) DeviceManagementReportsGetConfigurationPolicyNonComplianceSummaryReport(ctx _context.Context) ApiDeviceManagementReportsGetConfigurationPolicyNonComplianceSummaryReportRequest {
	return ApiDeviceManagementReportsGetConfigurationPolicyNonComplianceSummaryReportRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return string
func (a *DeviceManagementActionsApiService) DeviceManagementReportsGetConfigurationPolicyNonComplianceSummaryReportExecute(r ApiDeviceManagementReportsGetConfigurationPolicyNonComplianceSummaryReportRequest) (string, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  string
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DeviceManagementActionsApiService.DeviceManagementReportsGetConfigurationPolicyNonComplianceSummaryReport")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/deviceManagement/reports/microsoft.graph.getConfigurationPolicyNonComplianceSummaryReport"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject93 == nil {
		return localVarReturnValue, nil, reportError("inlineObject93 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject93
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeviceManagementReportsGetConfigurationSettingNonComplianceReportRequest struct {
	ctx _context.Context
	ApiService *DeviceManagementActionsApiService
	inlineObject94 *InlineObject94
}

func (r ApiDeviceManagementReportsGetConfigurationSettingNonComplianceReportRequest) InlineObject94(inlineObject94 InlineObject94) ApiDeviceManagementReportsGetConfigurationSettingNonComplianceReportRequest {
	r.inlineObject94 = &inlineObject94
	return r
}

func (r ApiDeviceManagementReportsGetConfigurationSettingNonComplianceReportRequest) Execute() (string, *_nethttp.Response, error) {
	return r.ApiService.DeviceManagementReportsGetConfigurationSettingNonComplianceReportExecute(r)
}

/*
DeviceManagementReportsGetConfigurationSettingNonComplianceReport Invoke action getConfigurationSettingNonComplianceReport

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDeviceManagementReportsGetConfigurationSettingNonComplianceReportRequest
*/
func (a *DeviceManagementActionsApiService) DeviceManagementReportsGetConfigurationSettingNonComplianceReport(ctx _context.Context) ApiDeviceManagementReportsGetConfigurationSettingNonComplianceReportRequest {
	return ApiDeviceManagementReportsGetConfigurationSettingNonComplianceReportRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return string
func (a *DeviceManagementActionsApiService) DeviceManagementReportsGetConfigurationSettingNonComplianceReportExecute(r ApiDeviceManagementReportsGetConfigurationSettingNonComplianceReportRequest) (string, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  string
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DeviceManagementActionsApiService.DeviceManagementReportsGetConfigurationSettingNonComplianceReport")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/deviceManagement/reports/microsoft.graph.getConfigurationSettingNonComplianceReport"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject94 == nil {
		return localVarReturnValue, nil, reportError("inlineObject94 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject94
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeviceManagementReportsGetDeviceManagementIntentPerSettingContributingProfilesRequest struct {
	ctx _context.Context
	ApiService *DeviceManagementActionsApiService
	inlineObject95 *InlineObject95
}

func (r ApiDeviceManagementReportsGetDeviceManagementIntentPerSettingContributingProfilesRequest) InlineObject95(inlineObject95 InlineObject95) ApiDeviceManagementReportsGetDeviceManagementIntentPerSettingContributingProfilesRequest {
	r.inlineObject95 = &inlineObject95
	return r
}

func (r ApiDeviceManagementReportsGetDeviceManagementIntentPerSettingContributingProfilesRequest) Execute() (string, *_nethttp.Response, error) {
	return r.ApiService.DeviceManagementReportsGetDeviceManagementIntentPerSettingContributingProfilesExecute(r)
}

/*
DeviceManagementReportsGetDeviceManagementIntentPerSettingContributingProfiles Invoke action getDeviceManagementIntentPerSettingContributingProfiles

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDeviceManagementReportsGetDeviceManagementIntentPerSettingContributingProfilesRequest
*/
func (a *DeviceManagementActionsApiService) DeviceManagementReportsGetDeviceManagementIntentPerSettingContributingProfiles(ctx _context.Context) ApiDeviceManagementReportsGetDeviceManagementIntentPerSettingContributingProfilesRequest {
	return ApiDeviceManagementReportsGetDeviceManagementIntentPerSettingContributingProfilesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return string
func (a *DeviceManagementActionsApiService) DeviceManagementReportsGetDeviceManagementIntentPerSettingContributingProfilesExecute(r ApiDeviceManagementReportsGetDeviceManagementIntentPerSettingContributingProfilesRequest) (string, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  string
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DeviceManagementActionsApiService.DeviceManagementReportsGetDeviceManagementIntentPerSettingContributingProfiles")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/deviceManagement/reports/microsoft.graph.getDeviceManagementIntentPerSettingContributingProfiles"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject95 == nil {
		return localVarReturnValue, nil, reportError("inlineObject95 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject95
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeviceManagementReportsGetDeviceManagementIntentSettingsReportRequest struct {
	ctx _context.Context
	ApiService *DeviceManagementActionsApiService
	inlineObject96 *InlineObject96
}

func (r ApiDeviceManagementReportsGetDeviceManagementIntentSettingsReportRequest) InlineObject96(inlineObject96 InlineObject96) ApiDeviceManagementReportsGetDeviceManagementIntentSettingsReportRequest {
	r.inlineObject96 = &inlineObject96
	return r
}

func (r ApiDeviceManagementReportsGetDeviceManagementIntentSettingsReportRequest) Execute() (string, *_nethttp.Response, error) {
	return r.ApiService.DeviceManagementReportsGetDeviceManagementIntentSettingsReportExecute(r)
}

/*
DeviceManagementReportsGetDeviceManagementIntentSettingsReport Invoke action getDeviceManagementIntentSettingsReport

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDeviceManagementReportsGetDeviceManagementIntentSettingsReportRequest
*/
func (a *DeviceManagementActionsApiService) DeviceManagementReportsGetDeviceManagementIntentSettingsReport(ctx _context.Context) ApiDeviceManagementReportsGetDeviceManagementIntentSettingsReportRequest {
	return ApiDeviceManagementReportsGetDeviceManagementIntentSettingsReportRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return string
func (a *DeviceManagementActionsApiService) DeviceManagementReportsGetDeviceManagementIntentSettingsReportExecute(r ApiDeviceManagementReportsGetDeviceManagementIntentSettingsReportRequest) (string, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  string
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DeviceManagementActionsApiService.DeviceManagementReportsGetDeviceManagementIntentSettingsReport")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/deviceManagement/reports/microsoft.graph.getDeviceManagementIntentSettingsReport"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject96 == nil {
		return localVarReturnValue, nil, reportError("inlineObject96 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject96
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeviceManagementReportsGetDeviceNonComplianceReportRequest struct {
	ctx _context.Context
	ApiService *DeviceManagementActionsApiService
	inlineObject97 *InlineObject97
}

func (r ApiDeviceManagementReportsGetDeviceNonComplianceReportRequest) InlineObject97(inlineObject97 InlineObject97) ApiDeviceManagementReportsGetDeviceNonComplianceReportRequest {
	r.inlineObject97 = &inlineObject97
	return r
}

func (r ApiDeviceManagementReportsGetDeviceNonComplianceReportRequest) Execute() (string, *_nethttp.Response, error) {
	return r.ApiService.DeviceManagementReportsGetDeviceNonComplianceReportExecute(r)
}

/*
DeviceManagementReportsGetDeviceNonComplianceReport Invoke action getDeviceNonComplianceReport

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDeviceManagementReportsGetDeviceNonComplianceReportRequest
*/
func (a *DeviceManagementActionsApiService) DeviceManagementReportsGetDeviceNonComplianceReport(ctx _context.Context) ApiDeviceManagementReportsGetDeviceNonComplianceReportRequest {
	return ApiDeviceManagementReportsGetDeviceNonComplianceReportRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return string
func (a *DeviceManagementActionsApiService) DeviceManagementReportsGetDeviceNonComplianceReportExecute(r ApiDeviceManagementReportsGetDeviceNonComplianceReportRequest) (string, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  string
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DeviceManagementActionsApiService.DeviceManagementReportsGetDeviceNonComplianceReport")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/deviceManagement/reports/microsoft.graph.getDeviceNonComplianceReport"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject97 == nil {
		return localVarReturnValue, nil, reportError("inlineObject97 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject97
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeviceManagementReportsGetHistoricalReportRequest struct {
	ctx _context.Context
	ApiService *DeviceManagementActionsApiService
	inlineObject98 *InlineObject98
}

func (r ApiDeviceManagementReportsGetHistoricalReportRequest) InlineObject98(inlineObject98 InlineObject98) ApiDeviceManagementReportsGetHistoricalReportRequest {
	r.inlineObject98 = &inlineObject98
	return r
}

func (r ApiDeviceManagementReportsGetHistoricalReportRequest) Execute() (string, *_nethttp.Response, error) {
	return r.ApiService.DeviceManagementReportsGetHistoricalReportExecute(r)
}

/*
DeviceManagementReportsGetHistoricalReport Invoke action getHistoricalReport

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDeviceManagementReportsGetHistoricalReportRequest
*/
func (a *DeviceManagementActionsApiService) DeviceManagementReportsGetHistoricalReport(ctx _context.Context) ApiDeviceManagementReportsGetHistoricalReportRequest {
	return ApiDeviceManagementReportsGetHistoricalReportRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return string
func (a *DeviceManagementActionsApiService) DeviceManagementReportsGetHistoricalReportExecute(r ApiDeviceManagementReportsGetHistoricalReportRequest) (string, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  string
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DeviceManagementActionsApiService.DeviceManagementReportsGetHistoricalReport")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/deviceManagement/reports/microsoft.graph.getHistoricalReport"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject98 == nil {
		return localVarReturnValue, nil, reportError("inlineObject98 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject98
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeviceManagementReportsGetPolicyNonComplianceMetadataRequest struct {
	ctx _context.Context
	ApiService *DeviceManagementActionsApiService
	inlineObject99 *InlineObject99
}

func (r ApiDeviceManagementReportsGetPolicyNonComplianceMetadataRequest) InlineObject99(inlineObject99 InlineObject99) ApiDeviceManagementReportsGetPolicyNonComplianceMetadataRequest {
	r.inlineObject99 = &inlineObject99
	return r
}

func (r ApiDeviceManagementReportsGetPolicyNonComplianceMetadataRequest) Execute() (string, *_nethttp.Response, error) {
	return r.ApiService.DeviceManagementReportsGetPolicyNonComplianceMetadataExecute(r)
}

/*
DeviceManagementReportsGetPolicyNonComplianceMetadata Invoke action getPolicyNonComplianceMetadata

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDeviceManagementReportsGetPolicyNonComplianceMetadataRequest
*/
func (a *DeviceManagementActionsApiService) DeviceManagementReportsGetPolicyNonComplianceMetadata(ctx _context.Context) ApiDeviceManagementReportsGetPolicyNonComplianceMetadataRequest {
	return ApiDeviceManagementReportsGetPolicyNonComplianceMetadataRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return string
func (a *DeviceManagementActionsApiService) DeviceManagementReportsGetPolicyNonComplianceMetadataExecute(r ApiDeviceManagementReportsGetPolicyNonComplianceMetadataRequest) (string, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  string
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DeviceManagementActionsApiService.DeviceManagementReportsGetPolicyNonComplianceMetadata")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/deviceManagement/reports/microsoft.graph.getPolicyNonComplianceMetadata"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject99 == nil {
		return localVarReturnValue, nil, reportError("inlineObject99 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject99
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeviceManagementReportsGetPolicyNonComplianceReportRequest struct {
	ctx _context.Context
	ApiService *DeviceManagementActionsApiService
	inlineObject100 *InlineObject100
}

func (r ApiDeviceManagementReportsGetPolicyNonComplianceReportRequest) InlineObject100(inlineObject100 InlineObject100) ApiDeviceManagementReportsGetPolicyNonComplianceReportRequest {
	r.inlineObject100 = &inlineObject100
	return r
}

func (r ApiDeviceManagementReportsGetPolicyNonComplianceReportRequest) Execute() (string, *_nethttp.Response, error) {
	return r.ApiService.DeviceManagementReportsGetPolicyNonComplianceReportExecute(r)
}

/*
DeviceManagementReportsGetPolicyNonComplianceReport Invoke action getPolicyNonComplianceReport

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDeviceManagementReportsGetPolicyNonComplianceReportRequest
*/
func (a *DeviceManagementActionsApiService) DeviceManagementReportsGetPolicyNonComplianceReport(ctx _context.Context) ApiDeviceManagementReportsGetPolicyNonComplianceReportRequest {
	return ApiDeviceManagementReportsGetPolicyNonComplianceReportRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return string
func (a *DeviceManagementActionsApiService) DeviceManagementReportsGetPolicyNonComplianceReportExecute(r ApiDeviceManagementReportsGetPolicyNonComplianceReportRequest) (string, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  string
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DeviceManagementActionsApiService.DeviceManagementReportsGetPolicyNonComplianceReport")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/deviceManagement/reports/microsoft.graph.getPolicyNonComplianceReport"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject100 == nil {
		return localVarReturnValue, nil, reportError("inlineObject100 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject100
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeviceManagementReportsGetPolicyNonComplianceSummaryReportRequest struct {
	ctx _context.Context
	ApiService *DeviceManagementActionsApiService
	inlineObject101 *InlineObject101
}

func (r ApiDeviceManagementReportsGetPolicyNonComplianceSummaryReportRequest) InlineObject101(inlineObject101 InlineObject101) ApiDeviceManagementReportsGetPolicyNonComplianceSummaryReportRequest {
	r.inlineObject101 = &inlineObject101
	return r
}

func (r ApiDeviceManagementReportsGetPolicyNonComplianceSummaryReportRequest) Execute() (string, *_nethttp.Response, error) {
	return r.ApiService.DeviceManagementReportsGetPolicyNonComplianceSummaryReportExecute(r)
}

/*
DeviceManagementReportsGetPolicyNonComplianceSummaryReport Invoke action getPolicyNonComplianceSummaryReport

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDeviceManagementReportsGetPolicyNonComplianceSummaryReportRequest
*/
func (a *DeviceManagementActionsApiService) DeviceManagementReportsGetPolicyNonComplianceSummaryReport(ctx _context.Context) ApiDeviceManagementReportsGetPolicyNonComplianceSummaryReportRequest {
	return ApiDeviceManagementReportsGetPolicyNonComplianceSummaryReportRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return string
func (a *DeviceManagementActionsApiService) DeviceManagementReportsGetPolicyNonComplianceSummaryReportExecute(r ApiDeviceManagementReportsGetPolicyNonComplianceSummaryReportRequest) (string, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  string
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DeviceManagementActionsApiService.DeviceManagementReportsGetPolicyNonComplianceSummaryReport")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/deviceManagement/reports/microsoft.graph.getPolicyNonComplianceSummaryReport"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject101 == nil {
		return localVarReturnValue, nil, reportError("inlineObject101 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject101
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeviceManagementReportsGetReportFiltersRequest struct {
	ctx _context.Context
	ApiService *DeviceManagementActionsApiService
	inlineObject102 *InlineObject102
}

func (r ApiDeviceManagementReportsGetReportFiltersRequest) InlineObject102(inlineObject102 InlineObject102) ApiDeviceManagementReportsGetReportFiltersRequest {
	r.inlineObject102 = &inlineObject102
	return r
}

func (r ApiDeviceManagementReportsGetReportFiltersRequest) Execute() (string, *_nethttp.Response, error) {
	return r.ApiService.DeviceManagementReportsGetReportFiltersExecute(r)
}

/*
DeviceManagementReportsGetReportFilters Invoke action getReportFilters

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDeviceManagementReportsGetReportFiltersRequest
*/
func (a *DeviceManagementActionsApiService) DeviceManagementReportsGetReportFilters(ctx _context.Context) ApiDeviceManagementReportsGetReportFiltersRequest {
	return ApiDeviceManagementReportsGetReportFiltersRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return string
func (a *DeviceManagementActionsApiService) DeviceManagementReportsGetReportFiltersExecute(r ApiDeviceManagementReportsGetReportFiltersRequest) (string, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  string
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DeviceManagementActionsApiService.DeviceManagementReportsGetReportFilters")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/deviceManagement/reports/microsoft.graph.getReportFilters"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject102 == nil {
		return localVarReturnValue, nil, reportError("inlineObject102 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject102
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeviceManagementReportsGetSettingNonComplianceReportRequest struct {
	ctx _context.Context
	ApiService *DeviceManagementActionsApiService
	inlineObject103 *InlineObject103
}

func (r ApiDeviceManagementReportsGetSettingNonComplianceReportRequest) InlineObject103(inlineObject103 InlineObject103) ApiDeviceManagementReportsGetSettingNonComplianceReportRequest {
	r.inlineObject103 = &inlineObject103
	return r
}

func (r ApiDeviceManagementReportsGetSettingNonComplianceReportRequest) Execute() (string, *_nethttp.Response, error) {
	return r.ApiService.DeviceManagementReportsGetSettingNonComplianceReportExecute(r)
}

/*
DeviceManagementReportsGetSettingNonComplianceReport Invoke action getSettingNonComplianceReport

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDeviceManagementReportsGetSettingNonComplianceReportRequest
*/
func (a *DeviceManagementActionsApiService) DeviceManagementReportsGetSettingNonComplianceReport(ctx _context.Context) ApiDeviceManagementReportsGetSettingNonComplianceReportRequest {
	return ApiDeviceManagementReportsGetSettingNonComplianceReportRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return string
func (a *DeviceManagementActionsApiService) DeviceManagementReportsGetSettingNonComplianceReportExecute(r ApiDeviceManagementReportsGetSettingNonComplianceReportRequest) (string, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  string
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DeviceManagementActionsApiService.DeviceManagementReportsGetSettingNonComplianceReport")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/deviceManagement/reports/microsoft.graph.getSettingNonComplianceReport"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject103 == nil {
		return localVarReturnValue, nil, reportError("inlineObject103 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject103
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeviceManagementWindowsAutopilotDeviceIdentitiesWindowsAutopilotDeviceIdentityAssignUserToDeviceRequest struct {
	ctx _context.Context
	ApiService *DeviceManagementActionsApiService
	windowsAutopilotDeviceIdentityId string
	inlineObject104 *InlineObject104
}

func (r ApiDeviceManagementWindowsAutopilotDeviceIdentitiesWindowsAutopilotDeviceIdentityAssignUserToDeviceRequest) InlineObject104(inlineObject104 InlineObject104) ApiDeviceManagementWindowsAutopilotDeviceIdentitiesWindowsAutopilotDeviceIdentityAssignUserToDeviceRequest {
	r.inlineObject104 = &inlineObject104
	return r
}

func (r ApiDeviceManagementWindowsAutopilotDeviceIdentitiesWindowsAutopilotDeviceIdentityAssignUserToDeviceRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.DeviceManagementWindowsAutopilotDeviceIdentitiesWindowsAutopilotDeviceIdentityAssignUserToDeviceExecute(r)
}

/*
DeviceManagementWindowsAutopilotDeviceIdentitiesWindowsAutopilotDeviceIdentityAssignUserToDevice Invoke action assignUserToDevice

Assigns user to Autopilot devices.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param windowsAutopilotDeviceIdentityId key: id of windowsAutopilotDeviceIdentity
 @return ApiDeviceManagementWindowsAutopilotDeviceIdentitiesWindowsAutopilotDeviceIdentityAssignUserToDeviceRequest
*/
func (a *DeviceManagementActionsApiService) DeviceManagementWindowsAutopilotDeviceIdentitiesWindowsAutopilotDeviceIdentityAssignUserToDevice(ctx _context.Context, windowsAutopilotDeviceIdentityId string) ApiDeviceManagementWindowsAutopilotDeviceIdentitiesWindowsAutopilotDeviceIdentityAssignUserToDeviceRequest {
	return ApiDeviceManagementWindowsAutopilotDeviceIdentitiesWindowsAutopilotDeviceIdentityAssignUserToDeviceRequest{
		ApiService: a,
		ctx: ctx,
		windowsAutopilotDeviceIdentityId: windowsAutopilotDeviceIdentityId,
	}
}

// Execute executes the request
func (a *DeviceManagementActionsApiService) DeviceManagementWindowsAutopilotDeviceIdentitiesWindowsAutopilotDeviceIdentityAssignUserToDeviceExecute(r ApiDeviceManagementWindowsAutopilotDeviceIdentitiesWindowsAutopilotDeviceIdentityAssignUserToDeviceRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DeviceManagementActionsApiService.DeviceManagementWindowsAutopilotDeviceIdentitiesWindowsAutopilotDeviceIdentityAssignUserToDevice")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/deviceManagement/windowsAutopilotDeviceIdentities/{windowsAutopilotDeviceIdentity-id}/microsoft.graph.assignUserToDevice"
	localVarPath = strings.Replace(localVarPath, "{"+"windowsAutopilotDeviceIdentity-id"+"}", _neturl.PathEscape(parameterToString(r.windowsAutopilotDeviceIdentityId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject104 == nil {
		return nil, reportError("inlineObject104 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject104
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDeviceManagementWindowsAutopilotDeviceIdentitiesWindowsAutopilotDeviceIdentityUnassignUserFromDeviceRequest struct {
	ctx _context.Context
	ApiService *DeviceManagementActionsApiService
	windowsAutopilotDeviceIdentityId string
}


func (r ApiDeviceManagementWindowsAutopilotDeviceIdentitiesWindowsAutopilotDeviceIdentityUnassignUserFromDeviceRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.DeviceManagementWindowsAutopilotDeviceIdentitiesWindowsAutopilotDeviceIdentityUnassignUserFromDeviceExecute(r)
}

/*
DeviceManagementWindowsAutopilotDeviceIdentitiesWindowsAutopilotDeviceIdentityUnassignUserFromDevice Invoke action unassignUserFromDevice

Unassigns the user from an Autopilot device.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param windowsAutopilotDeviceIdentityId key: id of windowsAutopilotDeviceIdentity
 @return ApiDeviceManagementWindowsAutopilotDeviceIdentitiesWindowsAutopilotDeviceIdentityUnassignUserFromDeviceRequest
*/
func (a *DeviceManagementActionsApiService) DeviceManagementWindowsAutopilotDeviceIdentitiesWindowsAutopilotDeviceIdentityUnassignUserFromDevice(ctx _context.Context, windowsAutopilotDeviceIdentityId string) ApiDeviceManagementWindowsAutopilotDeviceIdentitiesWindowsAutopilotDeviceIdentityUnassignUserFromDeviceRequest {
	return ApiDeviceManagementWindowsAutopilotDeviceIdentitiesWindowsAutopilotDeviceIdentityUnassignUserFromDeviceRequest{
		ApiService: a,
		ctx: ctx,
		windowsAutopilotDeviceIdentityId: windowsAutopilotDeviceIdentityId,
	}
}

// Execute executes the request
func (a *DeviceManagementActionsApiService) DeviceManagementWindowsAutopilotDeviceIdentitiesWindowsAutopilotDeviceIdentityUnassignUserFromDeviceExecute(r ApiDeviceManagementWindowsAutopilotDeviceIdentitiesWindowsAutopilotDeviceIdentityUnassignUserFromDeviceRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DeviceManagementActionsApiService.DeviceManagementWindowsAutopilotDeviceIdentitiesWindowsAutopilotDeviceIdentityUnassignUserFromDevice")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/deviceManagement/windowsAutopilotDeviceIdentities/{windowsAutopilotDeviceIdentity-id}/microsoft.graph.unassignUserFromDevice"
	localVarPath = strings.Replace(localVarPath, "{"+"windowsAutopilotDeviceIdentity-id"+"}", _neturl.PathEscape(parameterToString(r.windowsAutopilotDeviceIdentityId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDeviceManagementWindowsAutopilotDeviceIdentitiesWindowsAutopilotDeviceIdentityUpdateDevicePropertiesRequest struct {
	ctx _context.Context
	ApiService *DeviceManagementActionsApiService
	windowsAutopilotDeviceIdentityId string
	inlineObject105 *InlineObject105
}

func (r ApiDeviceManagementWindowsAutopilotDeviceIdentitiesWindowsAutopilotDeviceIdentityUpdateDevicePropertiesRequest) InlineObject105(inlineObject105 InlineObject105) ApiDeviceManagementWindowsAutopilotDeviceIdentitiesWindowsAutopilotDeviceIdentityUpdateDevicePropertiesRequest {
	r.inlineObject105 = &inlineObject105
	return r
}

func (r ApiDeviceManagementWindowsAutopilotDeviceIdentitiesWindowsAutopilotDeviceIdentityUpdateDevicePropertiesRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.DeviceManagementWindowsAutopilotDeviceIdentitiesWindowsAutopilotDeviceIdentityUpdateDevicePropertiesExecute(r)
}

/*
DeviceManagementWindowsAutopilotDeviceIdentitiesWindowsAutopilotDeviceIdentityUpdateDeviceProperties Invoke action updateDeviceProperties

Updates properties on Autopilot devices.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param windowsAutopilotDeviceIdentityId key: id of windowsAutopilotDeviceIdentity
 @return ApiDeviceManagementWindowsAutopilotDeviceIdentitiesWindowsAutopilotDeviceIdentityUpdateDevicePropertiesRequest
*/
func (a *DeviceManagementActionsApiService) DeviceManagementWindowsAutopilotDeviceIdentitiesWindowsAutopilotDeviceIdentityUpdateDeviceProperties(ctx _context.Context, windowsAutopilotDeviceIdentityId string) ApiDeviceManagementWindowsAutopilotDeviceIdentitiesWindowsAutopilotDeviceIdentityUpdateDevicePropertiesRequest {
	return ApiDeviceManagementWindowsAutopilotDeviceIdentitiesWindowsAutopilotDeviceIdentityUpdateDevicePropertiesRequest{
		ApiService: a,
		ctx: ctx,
		windowsAutopilotDeviceIdentityId: windowsAutopilotDeviceIdentityId,
	}
}

// Execute executes the request
func (a *DeviceManagementActionsApiService) DeviceManagementWindowsAutopilotDeviceIdentitiesWindowsAutopilotDeviceIdentityUpdateDevicePropertiesExecute(r ApiDeviceManagementWindowsAutopilotDeviceIdentitiesWindowsAutopilotDeviceIdentityUpdateDevicePropertiesRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DeviceManagementActionsApiService.DeviceManagementWindowsAutopilotDeviceIdentitiesWindowsAutopilotDeviceIdentityUpdateDeviceProperties")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/deviceManagement/windowsAutopilotDeviceIdentities/{windowsAutopilotDeviceIdentity-id}/microsoft.graph.updateDeviceProperties"
	localVarPath = strings.Replace(localVarPath, "{"+"windowsAutopilotDeviceIdentity-id"+"}", _neturl.PathEscape(parameterToString(r.windowsAutopilotDeviceIdentityId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject105 == nil {
		return nil, reportError("inlineObject105 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject105
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}
