/*
Partial Graph API

No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

API version: v1.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package msgraph

import (
	"bytes"
	_context "context"
	_ioutil "io/ioutil"
	_nethttp "net/http"
	_neturl "net/url"
	"strings"
)

// Linger please
var (
	_ _context.Context
)

// MeCalendarGroupApiService MeCalendarGroupApi service
type MeCalendarGroupApiService service

type ApiMeCalendarGroupsCalendarsCalendarViewCreateAttachmentsRequest struct {
	ctx _context.Context
	ApiService *MeCalendarGroupApiService
	calendarGroupId string
	calendarId string
	eventId string
	microsoftGraphAttachment *MicrosoftGraphAttachment
}

// New navigation property
func (r ApiMeCalendarGroupsCalendarsCalendarViewCreateAttachmentsRequest) MicrosoftGraphAttachment(microsoftGraphAttachment MicrosoftGraphAttachment) ApiMeCalendarGroupsCalendarsCalendarViewCreateAttachmentsRequest {
	r.microsoftGraphAttachment = &microsoftGraphAttachment
	return r
}

func (r ApiMeCalendarGroupsCalendarsCalendarViewCreateAttachmentsRequest) Execute() (MicrosoftGraphAttachment, *_nethttp.Response, error) {
	return r.ApiService.MeCalendarGroupsCalendarsCalendarViewCreateAttachmentsExecute(r)
}

/*
MeCalendarGroupsCalendarsCalendarViewCreateAttachments Create new navigation property to attachments for me

The collection of FileAttachment, ItemAttachment, and referenceAttachment attachments for the event. Navigation property. Read-only. Nullable.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param calendarGroupId key: id of calendarGroup
 @param calendarId key: id of calendar
 @param eventId key: id of event
 @return ApiMeCalendarGroupsCalendarsCalendarViewCreateAttachmentsRequest
*/
func (a *MeCalendarGroupApiService) MeCalendarGroupsCalendarsCalendarViewCreateAttachments(ctx _context.Context, calendarGroupId string, calendarId string, eventId string) ApiMeCalendarGroupsCalendarsCalendarViewCreateAttachmentsRequest {
	return ApiMeCalendarGroupsCalendarsCalendarViewCreateAttachmentsRequest{
		ApiService: a,
		ctx: ctx,
		calendarGroupId: calendarGroupId,
		calendarId: calendarId,
		eventId: eventId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphAttachment
func (a *MeCalendarGroupApiService) MeCalendarGroupsCalendarsCalendarViewCreateAttachmentsExecute(r ApiMeCalendarGroupsCalendarsCalendarViewCreateAttachmentsRequest) (MicrosoftGraphAttachment, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphAttachment
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MeCalendarGroupApiService.MeCalendarGroupsCalendarsCalendarViewCreateAttachments")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/calendarGroups/{calendarGroup-id}/calendars/{calendar-id}/calendarView/{event-id}/attachments"
	localVarPath = strings.Replace(localVarPath, "{"+"calendarGroup-id"+"}", _neturl.PathEscape(parameterToString(r.calendarGroupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"calendar-id"+"}", _neturl.PathEscape(parameterToString(r.calendarId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphAttachment == nil {
		return localVarReturnValue, nil, reportError("microsoftGraphAttachment is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphAttachment
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMeCalendarGroupsCalendarsCalendarViewCreateExtensionsRequest struct {
	ctx _context.Context
	ApiService *MeCalendarGroupApiService
	calendarGroupId string
	calendarId string
	eventId string
	microsoftGraphExtension *MicrosoftGraphExtension
}

// New navigation property
func (r ApiMeCalendarGroupsCalendarsCalendarViewCreateExtensionsRequest) MicrosoftGraphExtension(microsoftGraphExtension MicrosoftGraphExtension) ApiMeCalendarGroupsCalendarsCalendarViewCreateExtensionsRequest {
	r.microsoftGraphExtension = &microsoftGraphExtension
	return r
}

func (r ApiMeCalendarGroupsCalendarsCalendarViewCreateExtensionsRequest) Execute() (MicrosoftGraphExtension, *_nethttp.Response, error) {
	return r.ApiService.MeCalendarGroupsCalendarsCalendarViewCreateExtensionsExecute(r)
}

/*
MeCalendarGroupsCalendarsCalendarViewCreateExtensions Create new navigation property to extensions for me

The collection of open extensions defined for the event. Nullable.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param calendarGroupId key: id of calendarGroup
 @param calendarId key: id of calendar
 @param eventId key: id of event
 @return ApiMeCalendarGroupsCalendarsCalendarViewCreateExtensionsRequest
*/
func (a *MeCalendarGroupApiService) MeCalendarGroupsCalendarsCalendarViewCreateExtensions(ctx _context.Context, calendarGroupId string, calendarId string, eventId string) ApiMeCalendarGroupsCalendarsCalendarViewCreateExtensionsRequest {
	return ApiMeCalendarGroupsCalendarsCalendarViewCreateExtensionsRequest{
		ApiService: a,
		ctx: ctx,
		calendarGroupId: calendarGroupId,
		calendarId: calendarId,
		eventId: eventId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphExtension
func (a *MeCalendarGroupApiService) MeCalendarGroupsCalendarsCalendarViewCreateExtensionsExecute(r ApiMeCalendarGroupsCalendarsCalendarViewCreateExtensionsRequest) (MicrosoftGraphExtension, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphExtension
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MeCalendarGroupApiService.MeCalendarGroupsCalendarsCalendarViewCreateExtensions")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/calendarGroups/{calendarGroup-id}/calendars/{calendar-id}/calendarView/{event-id}/extensions"
	localVarPath = strings.Replace(localVarPath, "{"+"calendarGroup-id"+"}", _neturl.PathEscape(parameterToString(r.calendarGroupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"calendar-id"+"}", _neturl.PathEscape(parameterToString(r.calendarId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphExtension == nil {
		return localVarReturnValue, nil, reportError("microsoftGraphExtension is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphExtension
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMeCalendarGroupsCalendarsCalendarViewCreateInstancesRequest struct {
	ctx _context.Context
	ApiService *MeCalendarGroupApiService
	calendarGroupId string
	calendarId string
	eventId string
	microsoftGraphEvent *MicrosoftGraphEvent
}

// New navigation property
func (r ApiMeCalendarGroupsCalendarsCalendarViewCreateInstancesRequest) MicrosoftGraphEvent(microsoftGraphEvent MicrosoftGraphEvent) ApiMeCalendarGroupsCalendarsCalendarViewCreateInstancesRequest {
	r.microsoftGraphEvent = &microsoftGraphEvent
	return r
}

func (r ApiMeCalendarGroupsCalendarsCalendarViewCreateInstancesRequest) Execute() (MicrosoftGraphEvent, *_nethttp.Response, error) {
	return r.ApiService.MeCalendarGroupsCalendarsCalendarViewCreateInstancesExecute(r)
}

/*
MeCalendarGroupsCalendarsCalendarViewCreateInstances Create new navigation property to instances for me

The occurrences of a recurring series, if the event is a series master. This property includes occurrences that are part of the recurrence pattern, and exceptions that have been modified, but does not include occurrences that have been cancelled from the series. Navigation property. Read-only. Nullable.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param calendarGroupId key: id of calendarGroup
 @param calendarId key: id of calendar
 @param eventId key: id of event
 @return ApiMeCalendarGroupsCalendarsCalendarViewCreateInstancesRequest
*/
func (a *MeCalendarGroupApiService) MeCalendarGroupsCalendarsCalendarViewCreateInstances(ctx _context.Context, calendarGroupId string, calendarId string, eventId string) ApiMeCalendarGroupsCalendarsCalendarViewCreateInstancesRequest {
	return ApiMeCalendarGroupsCalendarsCalendarViewCreateInstancesRequest{
		ApiService: a,
		ctx: ctx,
		calendarGroupId: calendarGroupId,
		calendarId: calendarId,
		eventId: eventId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphEvent
func (a *MeCalendarGroupApiService) MeCalendarGroupsCalendarsCalendarViewCreateInstancesExecute(r ApiMeCalendarGroupsCalendarsCalendarViewCreateInstancesRequest) (MicrosoftGraphEvent, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphEvent
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MeCalendarGroupApiService.MeCalendarGroupsCalendarsCalendarViewCreateInstances")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/calendarGroups/{calendarGroup-id}/calendars/{calendar-id}/calendarView/{event-id}/instances"
	localVarPath = strings.Replace(localVarPath, "{"+"calendarGroup-id"+"}", _neturl.PathEscape(parameterToString(r.calendarGroupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"calendar-id"+"}", _neturl.PathEscape(parameterToString(r.calendarId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphEvent == nil {
		return localVarReturnValue, nil, reportError("microsoftGraphEvent is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphEvent
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMeCalendarGroupsCalendarsCalendarViewCreateMultiValueExtendedPropertiesRequest struct {
	ctx _context.Context
	ApiService *MeCalendarGroupApiService
	calendarGroupId string
	calendarId string
	eventId string
	microsoftGraphMultiValueLegacyExtendedProperty *MicrosoftGraphMultiValueLegacyExtendedProperty
}

// New navigation property
func (r ApiMeCalendarGroupsCalendarsCalendarViewCreateMultiValueExtendedPropertiesRequest) MicrosoftGraphMultiValueLegacyExtendedProperty(microsoftGraphMultiValueLegacyExtendedProperty MicrosoftGraphMultiValueLegacyExtendedProperty) ApiMeCalendarGroupsCalendarsCalendarViewCreateMultiValueExtendedPropertiesRequest {
	r.microsoftGraphMultiValueLegacyExtendedProperty = &microsoftGraphMultiValueLegacyExtendedProperty
	return r
}

func (r ApiMeCalendarGroupsCalendarsCalendarViewCreateMultiValueExtendedPropertiesRequest) Execute() (MicrosoftGraphMultiValueLegacyExtendedProperty, *_nethttp.Response, error) {
	return r.ApiService.MeCalendarGroupsCalendarsCalendarViewCreateMultiValueExtendedPropertiesExecute(r)
}

/*
MeCalendarGroupsCalendarsCalendarViewCreateMultiValueExtendedProperties Create new navigation property to multiValueExtendedProperties for me

The collection of multi-value extended properties defined for the event. Read-only. Nullable.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param calendarGroupId key: id of calendarGroup
 @param calendarId key: id of calendar
 @param eventId key: id of event
 @return ApiMeCalendarGroupsCalendarsCalendarViewCreateMultiValueExtendedPropertiesRequest
*/
func (a *MeCalendarGroupApiService) MeCalendarGroupsCalendarsCalendarViewCreateMultiValueExtendedProperties(ctx _context.Context, calendarGroupId string, calendarId string, eventId string) ApiMeCalendarGroupsCalendarsCalendarViewCreateMultiValueExtendedPropertiesRequest {
	return ApiMeCalendarGroupsCalendarsCalendarViewCreateMultiValueExtendedPropertiesRequest{
		ApiService: a,
		ctx: ctx,
		calendarGroupId: calendarGroupId,
		calendarId: calendarId,
		eventId: eventId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphMultiValueLegacyExtendedProperty
func (a *MeCalendarGroupApiService) MeCalendarGroupsCalendarsCalendarViewCreateMultiValueExtendedPropertiesExecute(r ApiMeCalendarGroupsCalendarsCalendarViewCreateMultiValueExtendedPropertiesRequest) (MicrosoftGraphMultiValueLegacyExtendedProperty, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphMultiValueLegacyExtendedProperty
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MeCalendarGroupApiService.MeCalendarGroupsCalendarsCalendarViewCreateMultiValueExtendedProperties")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/calendarGroups/{calendarGroup-id}/calendars/{calendar-id}/calendarView/{event-id}/multiValueExtendedProperties"
	localVarPath = strings.Replace(localVarPath, "{"+"calendarGroup-id"+"}", _neturl.PathEscape(parameterToString(r.calendarGroupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"calendar-id"+"}", _neturl.PathEscape(parameterToString(r.calendarId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphMultiValueLegacyExtendedProperty == nil {
		return localVarReturnValue, nil, reportError("microsoftGraphMultiValueLegacyExtendedProperty is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphMultiValueLegacyExtendedProperty
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMeCalendarGroupsCalendarsCalendarViewCreateSingleValueExtendedPropertiesRequest struct {
	ctx _context.Context
	ApiService *MeCalendarGroupApiService
	calendarGroupId string
	calendarId string
	eventId string
	microsoftGraphSingleValueLegacyExtendedProperty *MicrosoftGraphSingleValueLegacyExtendedProperty
}

// New navigation property
func (r ApiMeCalendarGroupsCalendarsCalendarViewCreateSingleValueExtendedPropertiesRequest) MicrosoftGraphSingleValueLegacyExtendedProperty(microsoftGraphSingleValueLegacyExtendedProperty MicrosoftGraphSingleValueLegacyExtendedProperty) ApiMeCalendarGroupsCalendarsCalendarViewCreateSingleValueExtendedPropertiesRequest {
	r.microsoftGraphSingleValueLegacyExtendedProperty = &microsoftGraphSingleValueLegacyExtendedProperty
	return r
}

func (r ApiMeCalendarGroupsCalendarsCalendarViewCreateSingleValueExtendedPropertiesRequest) Execute() (MicrosoftGraphSingleValueLegacyExtendedProperty, *_nethttp.Response, error) {
	return r.ApiService.MeCalendarGroupsCalendarsCalendarViewCreateSingleValueExtendedPropertiesExecute(r)
}

/*
MeCalendarGroupsCalendarsCalendarViewCreateSingleValueExtendedProperties Create new navigation property to singleValueExtendedProperties for me

The collection of single-value extended properties defined for the event. Read-only. Nullable.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param calendarGroupId key: id of calendarGroup
 @param calendarId key: id of calendar
 @param eventId key: id of event
 @return ApiMeCalendarGroupsCalendarsCalendarViewCreateSingleValueExtendedPropertiesRequest
*/
func (a *MeCalendarGroupApiService) MeCalendarGroupsCalendarsCalendarViewCreateSingleValueExtendedProperties(ctx _context.Context, calendarGroupId string, calendarId string, eventId string) ApiMeCalendarGroupsCalendarsCalendarViewCreateSingleValueExtendedPropertiesRequest {
	return ApiMeCalendarGroupsCalendarsCalendarViewCreateSingleValueExtendedPropertiesRequest{
		ApiService: a,
		ctx: ctx,
		calendarGroupId: calendarGroupId,
		calendarId: calendarId,
		eventId: eventId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphSingleValueLegacyExtendedProperty
func (a *MeCalendarGroupApiService) MeCalendarGroupsCalendarsCalendarViewCreateSingleValueExtendedPropertiesExecute(r ApiMeCalendarGroupsCalendarsCalendarViewCreateSingleValueExtendedPropertiesRequest) (MicrosoftGraphSingleValueLegacyExtendedProperty, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphSingleValueLegacyExtendedProperty
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MeCalendarGroupApiService.MeCalendarGroupsCalendarsCalendarViewCreateSingleValueExtendedProperties")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/calendarGroups/{calendarGroup-id}/calendars/{calendar-id}/calendarView/{event-id}/singleValueExtendedProperties"
	localVarPath = strings.Replace(localVarPath, "{"+"calendarGroup-id"+"}", _neturl.PathEscape(parameterToString(r.calendarGroupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"calendar-id"+"}", _neturl.PathEscape(parameterToString(r.calendarId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphSingleValueLegacyExtendedProperty == nil {
		return localVarReturnValue, nil, reportError("microsoftGraphSingleValueLegacyExtendedProperty is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphSingleValueLegacyExtendedProperty
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMeCalendarGroupsCalendarsCalendarViewDeleteAttachmentsRequest struct {
	ctx _context.Context
	ApiService *MeCalendarGroupApiService
	calendarGroupId string
	calendarId string
	eventId string
	attachmentId string
	ifMatch *string
}

// ETag
func (r ApiMeCalendarGroupsCalendarsCalendarViewDeleteAttachmentsRequest) IfMatch(ifMatch string) ApiMeCalendarGroupsCalendarsCalendarViewDeleteAttachmentsRequest {
	r.ifMatch = &ifMatch
	return r
}

func (r ApiMeCalendarGroupsCalendarsCalendarViewDeleteAttachmentsRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.MeCalendarGroupsCalendarsCalendarViewDeleteAttachmentsExecute(r)
}

/*
MeCalendarGroupsCalendarsCalendarViewDeleteAttachments Delete navigation property attachments for me

The collection of FileAttachment, ItemAttachment, and referenceAttachment attachments for the event. Navigation property. Read-only. Nullable.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param calendarGroupId key: id of calendarGroup
 @param calendarId key: id of calendar
 @param eventId key: id of event
 @param attachmentId key: id of attachment
 @return ApiMeCalendarGroupsCalendarsCalendarViewDeleteAttachmentsRequest
*/
func (a *MeCalendarGroupApiService) MeCalendarGroupsCalendarsCalendarViewDeleteAttachments(ctx _context.Context, calendarGroupId string, calendarId string, eventId string, attachmentId string) ApiMeCalendarGroupsCalendarsCalendarViewDeleteAttachmentsRequest {
	return ApiMeCalendarGroupsCalendarsCalendarViewDeleteAttachmentsRequest{
		ApiService: a,
		ctx: ctx,
		calendarGroupId: calendarGroupId,
		calendarId: calendarId,
		eventId: eventId,
		attachmentId: attachmentId,
	}
}

// Execute executes the request
func (a *MeCalendarGroupApiService) MeCalendarGroupsCalendarsCalendarViewDeleteAttachmentsExecute(r ApiMeCalendarGroupsCalendarsCalendarViewDeleteAttachmentsRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MeCalendarGroupApiService.MeCalendarGroupsCalendarsCalendarViewDeleteAttachments")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/calendarGroups/{calendarGroup-id}/calendars/{calendar-id}/calendarView/{event-id}/attachments/{attachment-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"calendarGroup-id"+"}", _neturl.PathEscape(parameterToString(r.calendarGroupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"calendar-id"+"}", _neturl.PathEscape(parameterToString(r.calendarId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"attachment-id"+"}", _neturl.PathEscape(parameterToString(r.attachmentId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ifMatch != nil {
		localVarHeaderParams["If-Match"] = parameterToString(*r.ifMatch, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiMeCalendarGroupsCalendarsCalendarViewDeleteCalendarRequest struct {
	ctx _context.Context
	ApiService *MeCalendarGroupApiService
	calendarGroupId string
	calendarId string
	eventId string
	ifMatch *string
}

// ETag
func (r ApiMeCalendarGroupsCalendarsCalendarViewDeleteCalendarRequest) IfMatch(ifMatch string) ApiMeCalendarGroupsCalendarsCalendarViewDeleteCalendarRequest {
	r.ifMatch = &ifMatch
	return r
}

func (r ApiMeCalendarGroupsCalendarsCalendarViewDeleteCalendarRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.MeCalendarGroupsCalendarsCalendarViewDeleteCalendarExecute(r)
}

/*
MeCalendarGroupsCalendarsCalendarViewDeleteCalendar Delete navigation property calendar for me

The calendar that contains the event. Navigation property. Read-only.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param calendarGroupId key: id of calendarGroup
 @param calendarId key: id of calendar
 @param eventId key: id of event
 @return ApiMeCalendarGroupsCalendarsCalendarViewDeleteCalendarRequest
*/
func (a *MeCalendarGroupApiService) MeCalendarGroupsCalendarsCalendarViewDeleteCalendar(ctx _context.Context, calendarGroupId string, calendarId string, eventId string) ApiMeCalendarGroupsCalendarsCalendarViewDeleteCalendarRequest {
	return ApiMeCalendarGroupsCalendarsCalendarViewDeleteCalendarRequest{
		ApiService: a,
		ctx: ctx,
		calendarGroupId: calendarGroupId,
		calendarId: calendarId,
		eventId: eventId,
	}
}

// Execute executes the request
func (a *MeCalendarGroupApiService) MeCalendarGroupsCalendarsCalendarViewDeleteCalendarExecute(r ApiMeCalendarGroupsCalendarsCalendarViewDeleteCalendarRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MeCalendarGroupApiService.MeCalendarGroupsCalendarsCalendarViewDeleteCalendar")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/calendarGroups/{calendarGroup-id}/calendars/{calendar-id}/calendarView/{event-id}/calendar"
	localVarPath = strings.Replace(localVarPath, "{"+"calendarGroup-id"+"}", _neturl.PathEscape(parameterToString(r.calendarGroupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"calendar-id"+"}", _neturl.PathEscape(parameterToString(r.calendarId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ifMatch != nil {
		localVarHeaderParams["If-Match"] = parameterToString(*r.ifMatch, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiMeCalendarGroupsCalendarsCalendarViewDeleteExtensionsRequest struct {
	ctx _context.Context
	ApiService *MeCalendarGroupApiService
	calendarGroupId string
	calendarId string
	eventId string
	extensionId string
	ifMatch *string
}

// ETag
func (r ApiMeCalendarGroupsCalendarsCalendarViewDeleteExtensionsRequest) IfMatch(ifMatch string) ApiMeCalendarGroupsCalendarsCalendarViewDeleteExtensionsRequest {
	r.ifMatch = &ifMatch
	return r
}

func (r ApiMeCalendarGroupsCalendarsCalendarViewDeleteExtensionsRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.MeCalendarGroupsCalendarsCalendarViewDeleteExtensionsExecute(r)
}

/*
MeCalendarGroupsCalendarsCalendarViewDeleteExtensions Delete navigation property extensions for me

The collection of open extensions defined for the event. Nullable.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param calendarGroupId key: id of calendarGroup
 @param calendarId key: id of calendar
 @param eventId key: id of event
 @param extensionId key: id of extension
 @return ApiMeCalendarGroupsCalendarsCalendarViewDeleteExtensionsRequest
*/
func (a *MeCalendarGroupApiService) MeCalendarGroupsCalendarsCalendarViewDeleteExtensions(ctx _context.Context, calendarGroupId string, calendarId string, eventId string, extensionId string) ApiMeCalendarGroupsCalendarsCalendarViewDeleteExtensionsRequest {
	return ApiMeCalendarGroupsCalendarsCalendarViewDeleteExtensionsRequest{
		ApiService: a,
		ctx: ctx,
		calendarGroupId: calendarGroupId,
		calendarId: calendarId,
		eventId: eventId,
		extensionId: extensionId,
	}
}

// Execute executes the request
func (a *MeCalendarGroupApiService) MeCalendarGroupsCalendarsCalendarViewDeleteExtensionsExecute(r ApiMeCalendarGroupsCalendarsCalendarViewDeleteExtensionsRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MeCalendarGroupApiService.MeCalendarGroupsCalendarsCalendarViewDeleteExtensions")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/calendarGroups/{calendarGroup-id}/calendars/{calendar-id}/calendarView/{event-id}/extensions/{extension-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"calendarGroup-id"+"}", _neturl.PathEscape(parameterToString(r.calendarGroupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"calendar-id"+"}", _neturl.PathEscape(parameterToString(r.calendarId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"extension-id"+"}", _neturl.PathEscape(parameterToString(r.extensionId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ifMatch != nil {
		localVarHeaderParams["If-Match"] = parameterToString(*r.ifMatch, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiMeCalendarGroupsCalendarsCalendarViewDeleteInstancesRequest struct {
	ctx _context.Context
	ApiService *MeCalendarGroupApiService
	calendarGroupId string
	calendarId string
	eventId string
	eventId1 string
	ifMatch *string
}

// ETag
func (r ApiMeCalendarGroupsCalendarsCalendarViewDeleteInstancesRequest) IfMatch(ifMatch string) ApiMeCalendarGroupsCalendarsCalendarViewDeleteInstancesRequest {
	r.ifMatch = &ifMatch
	return r
}

func (r ApiMeCalendarGroupsCalendarsCalendarViewDeleteInstancesRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.MeCalendarGroupsCalendarsCalendarViewDeleteInstancesExecute(r)
}

/*
MeCalendarGroupsCalendarsCalendarViewDeleteInstances Delete navigation property instances for me

The occurrences of a recurring series, if the event is a series master. This property includes occurrences that are part of the recurrence pattern, and exceptions that have been modified, but does not include occurrences that have been cancelled from the series. Navigation property. Read-only. Nullable.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param calendarGroupId key: id of calendarGroup
 @param calendarId key: id of calendar
 @param eventId key: id of event
 @param eventId1 key: id of event
 @return ApiMeCalendarGroupsCalendarsCalendarViewDeleteInstancesRequest
*/
func (a *MeCalendarGroupApiService) MeCalendarGroupsCalendarsCalendarViewDeleteInstances(ctx _context.Context, calendarGroupId string, calendarId string, eventId string, eventId1 string) ApiMeCalendarGroupsCalendarsCalendarViewDeleteInstancesRequest {
	return ApiMeCalendarGroupsCalendarsCalendarViewDeleteInstancesRequest{
		ApiService: a,
		ctx: ctx,
		calendarGroupId: calendarGroupId,
		calendarId: calendarId,
		eventId: eventId,
		eventId1: eventId1,
	}
}

// Execute executes the request
func (a *MeCalendarGroupApiService) MeCalendarGroupsCalendarsCalendarViewDeleteInstancesExecute(r ApiMeCalendarGroupsCalendarsCalendarViewDeleteInstancesRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MeCalendarGroupApiService.MeCalendarGroupsCalendarsCalendarViewDeleteInstances")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/calendarGroups/{calendarGroup-id}/calendars/{calendar-id}/calendarView/{event-id}/instances/{event-id1}"
	localVarPath = strings.Replace(localVarPath, "{"+"calendarGroup-id"+"}", _neturl.PathEscape(parameterToString(r.calendarGroupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"calendar-id"+"}", _neturl.PathEscape(parameterToString(r.calendarId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id1"+"}", _neturl.PathEscape(parameterToString(r.eventId1, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ifMatch != nil {
		localVarHeaderParams["If-Match"] = parameterToString(*r.ifMatch, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiMeCalendarGroupsCalendarsCalendarViewDeleteMultiValueExtendedPropertiesRequest struct {
	ctx _context.Context
	ApiService *MeCalendarGroupApiService
	calendarGroupId string
	calendarId string
	eventId string
	multiValueLegacyExtendedPropertyId string
	ifMatch *string
}

// ETag
func (r ApiMeCalendarGroupsCalendarsCalendarViewDeleteMultiValueExtendedPropertiesRequest) IfMatch(ifMatch string) ApiMeCalendarGroupsCalendarsCalendarViewDeleteMultiValueExtendedPropertiesRequest {
	r.ifMatch = &ifMatch
	return r
}

func (r ApiMeCalendarGroupsCalendarsCalendarViewDeleteMultiValueExtendedPropertiesRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.MeCalendarGroupsCalendarsCalendarViewDeleteMultiValueExtendedPropertiesExecute(r)
}

/*
MeCalendarGroupsCalendarsCalendarViewDeleteMultiValueExtendedProperties Delete navigation property multiValueExtendedProperties for me

The collection of multi-value extended properties defined for the event. Read-only. Nullable.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param calendarGroupId key: id of calendarGroup
 @param calendarId key: id of calendar
 @param eventId key: id of event
 @param multiValueLegacyExtendedPropertyId key: id of multiValueLegacyExtendedProperty
 @return ApiMeCalendarGroupsCalendarsCalendarViewDeleteMultiValueExtendedPropertiesRequest
*/
func (a *MeCalendarGroupApiService) MeCalendarGroupsCalendarsCalendarViewDeleteMultiValueExtendedProperties(ctx _context.Context, calendarGroupId string, calendarId string, eventId string, multiValueLegacyExtendedPropertyId string) ApiMeCalendarGroupsCalendarsCalendarViewDeleteMultiValueExtendedPropertiesRequest {
	return ApiMeCalendarGroupsCalendarsCalendarViewDeleteMultiValueExtendedPropertiesRequest{
		ApiService: a,
		ctx: ctx,
		calendarGroupId: calendarGroupId,
		calendarId: calendarId,
		eventId: eventId,
		multiValueLegacyExtendedPropertyId: multiValueLegacyExtendedPropertyId,
	}
}

// Execute executes the request
func (a *MeCalendarGroupApiService) MeCalendarGroupsCalendarsCalendarViewDeleteMultiValueExtendedPropertiesExecute(r ApiMeCalendarGroupsCalendarsCalendarViewDeleteMultiValueExtendedPropertiesRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MeCalendarGroupApiService.MeCalendarGroupsCalendarsCalendarViewDeleteMultiValueExtendedProperties")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/calendarGroups/{calendarGroup-id}/calendars/{calendar-id}/calendarView/{event-id}/multiValueExtendedProperties/{multiValueLegacyExtendedProperty-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"calendarGroup-id"+"}", _neturl.PathEscape(parameterToString(r.calendarGroupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"calendar-id"+"}", _neturl.PathEscape(parameterToString(r.calendarId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"multiValueLegacyExtendedProperty-id"+"}", _neturl.PathEscape(parameterToString(r.multiValueLegacyExtendedPropertyId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ifMatch != nil {
		localVarHeaderParams["If-Match"] = parameterToString(*r.ifMatch, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiMeCalendarGroupsCalendarsCalendarViewDeleteSingleValueExtendedPropertiesRequest struct {
	ctx _context.Context
	ApiService *MeCalendarGroupApiService
	calendarGroupId string
	calendarId string
	eventId string
	singleValueLegacyExtendedPropertyId string
	ifMatch *string
}

// ETag
func (r ApiMeCalendarGroupsCalendarsCalendarViewDeleteSingleValueExtendedPropertiesRequest) IfMatch(ifMatch string) ApiMeCalendarGroupsCalendarsCalendarViewDeleteSingleValueExtendedPropertiesRequest {
	r.ifMatch = &ifMatch
	return r
}

func (r ApiMeCalendarGroupsCalendarsCalendarViewDeleteSingleValueExtendedPropertiesRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.MeCalendarGroupsCalendarsCalendarViewDeleteSingleValueExtendedPropertiesExecute(r)
}

/*
MeCalendarGroupsCalendarsCalendarViewDeleteSingleValueExtendedProperties Delete navigation property singleValueExtendedProperties for me

The collection of single-value extended properties defined for the event. Read-only. Nullable.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param calendarGroupId key: id of calendarGroup
 @param calendarId key: id of calendar
 @param eventId key: id of event
 @param singleValueLegacyExtendedPropertyId key: id of singleValueLegacyExtendedProperty
 @return ApiMeCalendarGroupsCalendarsCalendarViewDeleteSingleValueExtendedPropertiesRequest
*/
func (a *MeCalendarGroupApiService) MeCalendarGroupsCalendarsCalendarViewDeleteSingleValueExtendedProperties(ctx _context.Context, calendarGroupId string, calendarId string, eventId string, singleValueLegacyExtendedPropertyId string) ApiMeCalendarGroupsCalendarsCalendarViewDeleteSingleValueExtendedPropertiesRequest {
	return ApiMeCalendarGroupsCalendarsCalendarViewDeleteSingleValueExtendedPropertiesRequest{
		ApiService: a,
		ctx: ctx,
		calendarGroupId: calendarGroupId,
		calendarId: calendarId,
		eventId: eventId,
		singleValueLegacyExtendedPropertyId: singleValueLegacyExtendedPropertyId,
	}
}

// Execute executes the request
func (a *MeCalendarGroupApiService) MeCalendarGroupsCalendarsCalendarViewDeleteSingleValueExtendedPropertiesExecute(r ApiMeCalendarGroupsCalendarsCalendarViewDeleteSingleValueExtendedPropertiesRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MeCalendarGroupApiService.MeCalendarGroupsCalendarsCalendarViewDeleteSingleValueExtendedProperties")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/calendarGroups/{calendarGroup-id}/calendars/{calendar-id}/calendarView/{event-id}/singleValueExtendedProperties/{singleValueLegacyExtendedProperty-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"calendarGroup-id"+"}", _neturl.PathEscape(parameterToString(r.calendarGroupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"calendar-id"+"}", _neturl.PathEscape(parameterToString(r.calendarId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"singleValueLegacyExtendedProperty-id"+"}", _neturl.PathEscape(parameterToString(r.singleValueLegacyExtendedPropertyId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ifMatch != nil {
		localVarHeaderParams["If-Match"] = parameterToString(*r.ifMatch, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiMeCalendarGroupsCalendarsCalendarViewGetAttachmentsRequest struct {
	ctx _context.Context
	ApiService *MeCalendarGroupApiService
	calendarGroupId string
	calendarId string
	eventId string
	attachmentId string
	select_ *[]string
	expand *[]string
}

// Select properties to be returned
func (r ApiMeCalendarGroupsCalendarsCalendarViewGetAttachmentsRequest) Select_(select_ []string) ApiMeCalendarGroupsCalendarsCalendarViewGetAttachmentsRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiMeCalendarGroupsCalendarsCalendarViewGetAttachmentsRequest) Expand(expand []string) ApiMeCalendarGroupsCalendarsCalendarViewGetAttachmentsRequest {
	r.expand = &expand
	return r
}

func (r ApiMeCalendarGroupsCalendarsCalendarViewGetAttachmentsRequest) Execute() (MicrosoftGraphAttachment, *_nethttp.Response, error) {
	return r.ApiService.MeCalendarGroupsCalendarsCalendarViewGetAttachmentsExecute(r)
}

/*
MeCalendarGroupsCalendarsCalendarViewGetAttachments Get attachments from me

The collection of FileAttachment, ItemAttachment, and referenceAttachment attachments for the event. Navigation property. Read-only. Nullable.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param calendarGroupId key: id of calendarGroup
 @param calendarId key: id of calendar
 @param eventId key: id of event
 @param attachmentId key: id of attachment
 @return ApiMeCalendarGroupsCalendarsCalendarViewGetAttachmentsRequest
*/
func (a *MeCalendarGroupApiService) MeCalendarGroupsCalendarsCalendarViewGetAttachments(ctx _context.Context, calendarGroupId string, calendarId string, eventId string, attachmentId string) ApiMeCalendarGroupsCalendarsCalendarViewGetAttachmentsRequest {
	return ApiMeCalendarGroupsCalendarsCalendarViewGetAttachmentsRequest{
		ApiService: a,
		ctx: ctx,
		calendarGroupId: calendarGroupId,
		calendarId: calendarId,
		eventId: eventId,
		attachmentId: attachmentId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphAttachment
func (a *MeCalendarGroupApiService) MeCalendarGroupsCalendarsCalendarViewGetAttachmentsExecute(r ApiMeCalendarGroupsCalendarsCalendarViewGetAttachmentsRequest) (MicrosoftGraphAttachment, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphAttachment
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MeCalendarGroupApiService.MeCalendarGroupsCalendarsCalendarViewGetAttachments")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/calendarGroups/{calendarGroup-id}/calendars/{calendar-id}/calendarView/{event-id}/attachments/{attachment-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"calendarGroup-id"+"}", _neturl.PathEscape(parameterToString(r.calendarGroupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"calendar-id"+"}", _neturl.PathEscape(parameterToString(r.calendarId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"attachment-id"+"}", _neturl.PathEscape(parameterToString(r.attachmentId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMeCalendarGroupsCalendarsCalendarViewGetCalendarRequest struct {
	ctx _context.Context
	ApiService *MeCalendarGroupApiService
	calendarGroupId string
	calendarId string
	eventId string
	select_ *[]string
}

// Select properties to be returned
func (r ApiMeCalendarGroupsCalendarsCalendarViewGetCalendarRequest) Select_(select_ []string) ApiMeCalendarGroupsCalendarsCalendarViewGetCalendarRequest {
	r.select_ = &select_
	return r
}

func (r ApiMeCalendarGroupsCalendarsCalendarViewGetCalendarRequest) Execute() (MicrosoftGraphCalendar, *_nethttp.Response, error) {
	return r.ApiService.MeCalendarGroupsCalendarsCalendarViewGetCalendarExecute(r)
}

/*
MeCalendarGroupsCalendarsCalendarViewGetCalendar Get calendar from me

The calendar that contains the event. Navigation property. Read-only.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param calendarGroupId key: id of calendarGroup
 @param calendarId key: id of calendar
 @param eventId key: id of event
 @return ApiMeCalendarGroupsCalendarsCalendarViewGetCalendarRequest
*/
func (a *MeCalendarGroupApiService) MeCalendarGroupsCalendarsCalendarViewGetCalendar(ctx _context.Context, calendarGroupId string, calendarId string, eventId string) ApiMeCalendarGroupsCalendarsCalendarViewGetCalendarRequest {
	return ApiMeCalendarGroupsCalendarsCalendarViewGetCalendarRequest{
		ApiService: a,
		ctx: ctx,
		calendarGroupId: calendarGroupId,
		calendarId: calendarId,
		eventId: eventId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphCalendar
func (a *MeCalendarGroupApiService) MeCalendarGroupsCalendarsCalendarViewGetCalendarExecute(r ApiMeCalendarGroupsCalendarsCalendarViewGetCalendarRequest) (MicrosoftGraphCalendar, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphCalendar
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MeCalendarGroupApiService.MeCalendarGroupsCalendarsCalendarViewGetCalendar")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/calendarGroups/{calendarGroup-id}/calendars/{calendar-id}/calendarView/{event-id}/calendar"
	localVarPath = strings.Replace(localVarPath, "{"+"calendarGroup-id"+"}", _neturl.PathEscape(parameterToString(r.calendarGroupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"calendar-id"+"}", _neturl.PathEscape(parameterToString(r.calendarId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMeCalendarGroupsCalendarsCalendarViewGetExtensionsRequest struct {
	ctx _context.Context
	ApiService *MeCalendarGroupApiService
	calendarGroupId string
	calendarId string
	eventId string
	extensionId string
	select_ *[]string
	expand *[]string
}

// Select properties to be returned
func (r ApiMeCalendarGroupsCalendarsCalendarViewGetExtensionsRequest) Select_(select_ []string) ApiMeCalendarGroupsCalendarsCalendarViewGetExtensionsRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiMeCalendarGroupsCalendarsCalendarViewGetExtensionsRequest) Expand(expand []string) ApiMeCalendarGroupsCalendarsCalendarViewGetExtensionsRequest {
	r.expand = &expand
	return r
}

func (r ApiMeCalendarGroupsCalendarsCalendarViewGetExtensionsRequest) Execute() (MicrosoftGraphExtension, *_nethttp.Response, error) {
	return r.ApiService.MeCalendarGroupsCalendarsCalendarViewGetExtensionsExecute(r)
}

/*
MeCalendarGroupsCalendarsCalendarViewGetExtensions Get extensions from me

The collection of open extensions defined for the event. Nullable.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param calendarGroupId key: id of calendarGroup
 @param calendarId key: id of calendar
 @param eventId key: id of event
 @param extensionId key: id of extension
 @return ApiMeCalendarGroupsCalendarsCalendarViewGetExtensionsRequest
*/
func (a *MeCalendarGroupApiService) MeCalendarGroupsCalendarsCalendarViewGetExtensions(ctx _context.Context, calendarGroupId string, calendarId string, eventId string, extensionId string) ApiMeCalendarGroupsCalendarsCalendarViewGetExtensionsRequest {
	return ApiMeCalendarGroupsCalendarsCalendarViewGetExtensionsRequest{
		ApiService: a,
		ctx: ctx,
		calendarGroupId: calendarGroupId,
		calendarId: calendarId,
		eventId: eventId,
		extensionId: extensionId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphExtension
func (a *MeCalendarGroupApiService) MeCalendarGroupsCalendarsCalendarViewGetExtensionsExecute(r ApiMeCalendarGroupsCalendarsCalendarViewGetExtensionsRequest) (MicrosoftGraphExtension, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphExtension
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MeCalendarGroupApiService.MeCalendarGroupsCalendarsCalendarViewGetExtensions")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/calendarGroups/{calendarGroup-id}/calendars/{calendar-id}/calendarView/{event-id}/extensions/{extension-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"calendarGroup-id"+"}", _neturl.PathEscape(parameterToString(r.calendarGroupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"calendar-id"+"}", _neturl.PathEscape(parameterToString(r.calendarId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"extension-id"+"}", _neturl.PathEscape(parameterToString(r.extensionId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMeCalendarGroupsCalendarsCalendarViewGetInstancesRequest struct {
	ctx _context.Context
	ApiService *MeCalendarGroupApiService
	calendarGroupId string
	calendarId string
	eventId string
	eventId1 string
	select_ *[]string
}

// Select properties to be returned
func (r ApiMeCalendarGroupsCalendarsCalendarViewGetInstancesRequest) Select_(select_ []string) ApiMeCalendarGroupsCalendarsCalendarViewGetInstancesRequest {
	r.select_ = &select_
	return r
}

func (r ApiMeCalendarGroupsCalendarsCalendarViewGetInstancesRequest) Execute() (MicrosoftGraphEvent, *_nethttp.Response, error) {
	return r.ApiService.MeCalendarGroupsCalendarsCalendarViewGetInstancesExecute(r)
}

/*
MeCalendarGroupsCalendarsCalendarViewGetInstances Get instances from me

The occurrences of a recurring series, if the event is a series master. This property includes occurrences that are part of the recurrence pattern, and exceptions that have been modified, but does not include occurrences that have been cancelled from the series. Navigation property. Read-only. Nullable.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param calendarGroupId key: id of calendarGroup
 @param calendarId key: id of calendar
 @param eventId key: id of event
 @param eventId1 key: id of event
 @return ApiMeCalendarGroupsCalendarsCalendarViewGetInstancesRequest
*/
func (a *MeCalendarGroupApiService) MeCalendarGroupsCalendarsCalendarViewGetInstances(ctx _context.Context, calendarGroupId string, calendarId string, eventId string, eventId1 string) ApiMeCalendarGroupsCalendarsCalendarViewGetInstancesRequest {
	return ApiMeCalendarGroupsCalendarsCalendarViewGetInstancesRequest{
		ApiService: a,
		ctx: ctx,
		calendarGroupId: calendarGroupId,
		calendarId: calendarId,
		eventId: eventId,
		eventId1: eventId1,
	}
}

// Execute executes the request
//  @return MicrosoftGraphEvent
func (a *MeCalendarGroupApiService) MeCalendarGroupsCalendarsCalendarViewGetInstancesExecute(r ApiMeCalendarGroupsCalendarsCalendarViewGetInstancesRequest) (MicrosoftGraphEvent, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphEvent
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MeCalendarGroupApiService.MeCalendarGroupsCalendarsCalendarViewGetInstances")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/calendarGroups/{calendarGroup-id}/calendars/{calendar-id}/calendarView/{event-id}/instances/{event-id1}"
	localVarPath = strings.Replace(localVarPath, "{"+"calendarGroup-id"+"}", _neturl.PathEscape(parameterToString(r.calendarGroupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"calendar-id"+"}", _neturl.PathEscape(parameterToString(r.calendarId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id1"+"}", _neturl.PathEscape(parameterToString(r.eventId1, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMeCalendarGroupsCalendarsCalendarViewGetMultiValueExtendedPropertiesRequest struct {
	ctx _context.Context
	ApiService *MeCalendarGroupApiService
	calendarGroupId string
	calendarId string
	eventId string
	multiValueLegacyExtendedPropertyId string
	select_ *[]string
	expand *[]string
}

// Select properties to be returned
func (r ApiMeCalendarGroupsCalendarsCalendarViewGetMultiValueExtendedPropertiesRequest) Select_(select_ []string) ApiMeCalendarGroupsCalendarsCalendarViewGetMultiValueExtendedPropertiesRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiMeCalendarGroupsCalendarsCalendarViewGetMultiValueExtendedPropertiesRequest) Expand(expand []string) ApiMeCalendarGroupsCalendarsCalendarViewGetMultiValueExtendedPropertiesRequest {
	r.expand = &expand
	return r
}

func (r ApiMeCalendarGroupsCalendarsCalendarViewGetMultiValueExtendedPropertiesRequest) Execute() (MicrosoftGraphMultiValueLegacyExtendedProperty, *_nethttp.Response, error) {
	return r.ApiService.MeCalendarGroupsCalendarsCalendarViewGetMultiValueExtendedPropertiesExecute(r)
}

/*
MeCalendarGroupsCalendarsCalendarViewGetMultiValueExtendedProperties Get multiValueExtendedProperties from me

The collection of multi-value extended properties defined for the event. Read-only. Nullable.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param calendarGroupId key: id of calendarGroup
 @param calendarId key: id of calendar
 @param eventId key: id of event
 @param multiValueLegacyExtendedPropertyId key: id of multiValueLegacyExtendedProperty
 @return ApiMeCalendarGroupsCalendarsCalendarViewGetMultiValueExtendedPropertiesRequest
*/
func (a *MeCalendarGroupApiService) MeCalendarGroupsCalendarsCalendarViewGetMultiValueExtendedProperties(ctx _context.Context, calendarGroupId string, calendarId string, eventId string, multiValueLegacyExtendedPropertyId string) ApiMeCalendarGroupsCalendarsCalendarViewGetMultiValueExtendedPropertiesRequest {
	return ApiMeCalendarGroupsCalendarsCalendarViewGetMultiValueExtendedPropertiesRequest{
		ApiService: a,
		ctx: ctx,
		calendarGroupId: calendarGroupId,
		calendarId: calendarId,
		eventId: eventId,
		multiValueLegacyExtendedPropertyId: multiValueLegacyExtendedPropertyId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphMultiValueLegacyExtendedProperty
func (a *MeCalendarGroupApiService) MeCalendarGroupsCalendarsCalendarViewGetMultiValueExtendedPropertiesExecute(r ApiMeCalendarGroupsCalendarsCalendarViewGetMultiValueExtendedPropertiesRequest) (MicrosoftGraphMultiValueLegacyExtendedProperty, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphMultiValueLegacyExtendedProperty
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MeCalendarGroupApiService.MeCalendarGroupsCalendarsCalendarViewGetMultiValueExtendedProperties")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/calendarGroups/{calendarGroup-id}/calendars/{calendar-id}/calendarView/{event-id}/multiValueExtendedProperties/{multiValueLegacyExtendedProperty-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"calendarGroup-id"+"}", _neturl.PathEscape(parameterToString(r.calendarGroupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"calendar-id"+"}", _neturl.PathEscape(parameterToString(r.calendarId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"multiValueLegacyExtendedProperty-id"+"}", _neturl.PathEscape(parameterToString(r.multiValueLegacyExtendedPropertyId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMeCalendarGroupsCalendarsCalendarViewGetSingleValueExtendedPropertiesRequest struct {
	ctx _context.Context
	ApiService *MeCalendarGroupApiService
	calendarGroupId string
	calendarId string
	eventId string
	singleValueLegacyExtendedPropertyId string
	select_ *[]string
	expand *[]string
}

// Select properties to be returned
func (r ApiMeCalendarGroupsCalendarsCalendarViewGetSingleValueExtendedPropertiesRequest) Select_(select_ []string) ApiMeCalendarGroupsCalendarsCalendarViewGetSingleValueExtendedPropertiesRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiMeCalendarGroupsCalendarsCalendarViewGetSingleValueExtendedPropertiesRequest) Expand(expand []string) ApiMeCalendarGroupsCalendarsCalendarViewGetSingleValueExtendedPropertiesRequest {
	r.expand = &expand
	return r
}

func (r ApiMeCalendarGroupsCalendarsCalendarViewGetSingleValueExtendedPropertiesRequest) Execute() (MicrosoftGraphSingleValueLegacyExtendedProperty, *_nethttp.Response, error) {
	return r.ApiService.MeCalendarGroupsCalendarsCalendarViewGetSingleValueExtendedPropertiesExecute(r)
}

/*
MeCalendarGroupsCalendarsCalendarViewGetSingleValueExtendedProperties Get singleValueExtendedProperties from me

The collection of single-value extended properties defined for the event. Read-only. Nullable.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param calendarGroupId key: id of calendarGroup
 @param calendarId key: id of calendar
 @param eventId key: id of event
 @param singleValueLegacyExtendedPropertyId key: id of singleValueLegacyExtendedProperty
 @return ApiMeCalendarGroupsCalendarsCalendarViewGetSingleValueExtendedPropertiesRequest
*/
func (a *MeCalendarGroupApiService) MeCalendarGroupsCalendarsCalendarViewGetSingleValueExtendedProperties(ctx _context.Context, calendarGroupId string, calendarId string, eventId string, singleValueLegacyExtendedPropertyId string) ApiMeCalendarGroupsCalendarsCalendarViewGetSingleValueExtendedPropertiesRequest {
	return ApiMeCalendarGroupsCalendarsCalendarViewGetSingleValueExtendedPropertiesRequest{
		ApiService: a,
		ctx: ctx,
		calendarGroupId: calendarGroupId,
		calendarId: calendarId,
		eventId: eventId,
		singleValueLegacyExtendedPropertyId: singleValueLegacyExtendedPropertyId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphSingleValueLegacyExtendedProperty
func (a *MeCalendarGroupApiService) MeCalendarGroupsCalendarsCalendarViewGetSingleValueExtendedPropertiesExecute(r ApiMeCalendarGroupsCalendarsCalendarViewGetSingleValueExtendedPropertiesRequest) (MicrosoftGraphSingleValueLegacyExtendedProperty, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphSingleValueLegacyExtendedProperty
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MeCalendarGroupApiService.MeCalendarGroupsCalendarsCalendarViewGetSingleValueExtendedProperties")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/calendarGroups/{calendarGroup-id}/calendars/{calendar-id}/calendarView/{event-id}/singleValueExtendedProperties/{singleValueLegacyExtendedProperty-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"calendarGroup-id"+"}", _neturl.PathEscape(parameterToString(r.calendarGroupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"calendar-id"+"}", _neturl.PathEscape(parameterToString(r.calendarId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"singleValueLegacyExtendedProperty-id"+"}", _neturl.PathEscape(parameterToString(r.singleValueLegacyExtendedPropertyId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMeCalendarGroupsCalendarsCalendarViewListAttachmentsRequest struct {
	ctx _context.Context
	ApiService *MeCalendarGroupApiService
	calendarGroupId string
	calendarId string
	eventId string
	top *int32
	skip *int32
	filter *string
	count *bool
	orderby *[]string
	select_ *[]string
	expand *[]string
}

// Show only the first n items
func (r ApiMeCalendarGroupsCalendarsCalendarViewListAttachmentsRequest) Top(top int32) ApiMeCalendarGroupsCalendarsCalendarViewListAttachmentsRequest {
	r.top = &top
	return r
}
// Skip the first n items
func (r ApiMeCalendarGroupsCalendarsCalendarViewListAttachmentsRequest) Skip(skip int32) ApiMeCalendarGroupsCalendarsCalendarViewListAttachmentsRequest {
	r.skip = &skip
	return r
}
// Filter items by property values
func (r ApiMeCalendarGroupsCalendarsCalendarViewListAttachmentsRequest) Filter(filter string) ApiMeCalendarGroupsCalendarsCalendarViewListAttachmentsRequest {
	r.filter = &filter
	return r
}
// Include count of items
func (r ApiMeCalendarGroupsCalendarsCalendarViewListAttachmentsRequest) Count(count bool) ApiMeCalendarGroupsCalendarsCalendarViewListAttachmentsRequest {
	r.count = &count
	return r
}
// Order items by property values
func (r ApiMeCalendarGroupsCalendarsCalendarViewListAttachmentsRequest) Orderby(orderby []string) ApiMeCalendarGroupsCalendarsCalendarViewListAttachmentsRequest {
	r.orderby = &orderby
	return r
}
// Select properties to be returned
func (r ApiMeCalendarGroupsCalendarsCalendarViewListAttachmentsRequest) Select_(select_ []string) ApiMeCalendarGroupsCalendarsCalendarViewListAttachmentsRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiMeCalendarGroupsCalendarsCalendarViewListAttachmentsRequest) Expand(expand []string) ApiMeCalendarGroupsCalendarsCalendarViewListAttachmentsRequest {
	r.expand = &expand
	return r
}

func (r ApiMeCalendarGroupsCalendarsCalendarViewListAttachmentsRequest) Execute() (CollectionOfAttachment, *_nethttp.Response, error) {
	return r.ApiService.MeCalendarGroupsCalendarsCalendarViewListAttachmentsExecute(r)
}

/*
MeCalendarGroupsCalendarsCalendarViewListAttachments Get attachments from me

The collection of FileAttachment, ItemAttachment, and referenceAttachment attachments for the event. Navigation property. Read-only. Nullable.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param calendarGroupId key: id of calendarGroup
 @param calendarId key: id of calendar
 @param eventId key: id of event
 @return ApiMeCalendarGroupsCalendarsCalendarViewListAttachmentsRequest
*/
func (a *MeCalendarGroupApiService) MeCalendarGroupsCalendarsCalendarViewListAttachments(ctx _context.Context, calendarGroupId string, calendarId string, eventId string) ApiMeCalendarGroupsCalendarsCalendarViewListAttachmentsRequest {
	return ApiMeCalendarGroupsCalendarsCalendarViewListAttachmentsRequest{
		ApiService: a,
		ctx: ctx,
		calendarGroupId: calendarGroupId,
		calendarId: calendarId,
		eventId: eventId,
	}
}

// Execute executes the request
//  @return CollectionOfAttachment
func (a *MeCalendarGroupApiService) MeCalendarGroupsCalendarsCalendarViewListAttachmentsExecute(r ApiMeCalendarGroupsCalendarsCalendarViewListAttachmentsRequest) (CollectionOfAttachment, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  CollectionOfAttachment
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MeCalendarGroupApiService.MeCalendarGroupsCalendarsCalendarViewListAttachments")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/calendarGroups/{calendarGroup-id}/calendars/{calendar-id}/calendarView/{event-id}/attachments"
	localVarPath = strings.Replace(localVarPath, "{"+"calendarGroup-id"+"}", _neturl.PathEscape(parameterToString(r.calendarGroupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"calendar-id"+"}", _neturl.PathEscape(parameterToString(r.calendarId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.top != nil {
		localVarQueryParams.Add("$top", parameterToString(*r.top, ""))
	}
	if r.skip != nil {
		localVarQueryParams.Add("$skip", parameterToString(*r.skip, ""))
	}
	if r.filter != nil {
		localVarQueryParams.Add("$filter", parameterToString(*r.filter, ""))
	}
	if r.count != nil {
		localVarQueryParams.Add("$count", parameterToString(*r.count, ""))
	}
	if r.orderby != nil {
		localVarQueryParams.Add("$orderby", parameterToString(*r.orderby, "csv"))
	}
	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMeCalendarGroupsCalendarsCalendarViewListExtensionsRequest struct {
	ctx _context.Context
	ApiService *MeCalendarGroupApiService
	calendarGroupId string
	calendarId string
	eventId string
	top *int32
	skip *int32
	filter *string
	count *bool
	orderby *[]string
	select_ *[]string
	expand *[]string
}

// Show only the first n items
func (r ApiMeCalendarGroupsCalendarsCalendarViewListExtensionsRequest) Top(top int32) ApiMeCalendarGroupsCalendarsCalendarViewListExtensionsRequest {
	r.top = &top
	return r
}
// Skip the first n items
func (r ApiMeCalendarGroupsCalendarsCalendarViewListExtensionsRequest) Skip(skip int32) ApiMeCalendarGroupsCalendarsCalendarViewListExtensionsRequest {
	r.skip = &skip
	return r
}
// Filter items by property values
func (r ApiMeCalendarGroupsCalendarsCalendarViewListExtensionsRequest) Filter(filter string) ApiMeCalendarGroupsCalendarsCalendarViewListExtensionsRequest {
	r.filter = &filter
	return r
}
// Include count of items
func (r ApiMeCalendarGroupsCalendarsCalendarViewListExtensionsRequest) Count(count bool) ApiMeCalendarGroupsCalendarsCalendarViewListExtensionsRequest {
	r.count = &count
	return r
}
// Order items by property values
func (r ApiMeCalendarGroupsCalendarsCalendarViewListExtensionsRequest) Orderby(orderby []string) ApiMeCalendarGroupsCalendarsCalendarViewListExtensionsRequest {
	r.orderby = &orderby
	return r
}
// Select properties to be returned
func (r ApiMeCalendarGroupsCalendarsCalendarViewListExtensionsRequest) Select_(select_ []string) ApiMeCalendarGroupsCalendarsCalendarViewListExtensionsRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiMeCalendarGroupsCalendarsCalendarViewListExtensionsRequest) Expand(expand []string) ApiMeCalendarGroupsCalendarsCalendarViewListExtensionsRequest {
	r.expand = &expand
	return r
}

func (r ApiMeCalendarGroupsCalendarsCalendarViewListExtensionsRequest) Execute() (CollectionOfExtension, *_nethttp.Response, error) {
	return r.ApiService.MeCalendarGroupsCalendarsCalendarViewListExtensionsExecute(r)
}

/*
MeCalendarGroupsCalendarsCalendarViewListExtensions Get extensions from me

The collection of open extensions defined for the event. Nullable.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param calendarGroupId key: id of calendarGroup
 @param calendarId key: id of calendar
 @param eventId key: id of event
 @return ApiMeCalendarGroupsCalendarsCalendarViewListExtensionsRequest
*/
func (a *MeCalendarGroupApiService) MeCalendarGroupsCalendarsCalendarViewListExtensions(ctx _context.Context, calendarGroupId string, calendarId string, eventId string) ApiMeCalendarGroupsCalendarsCalendarViewListExtensionsRequest {
	return ApiMeCalendarGroupsCalendarsCalendarViewListExtensionsRequest{
		ApiService: a,
		ctx: ctx,
		calendarGroupId: calendarGroupId,
		calendarId: calendarId,
		eventId: eventId,
	}
}

// Execute executes the request
//  @return CollectionOfExtension
func (a *MeCalendarGroupApiService) MeCalendarGroupsCalendarsCalendarViewListExtensionsExecute(r ApiMeCalendarGroupsCalendarsCalendarViewListExtensionsRequest) (CollectionOfExtension, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  CollectionOfExtension
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MeCalendarGroupApiService.MeCalendarGroupsCalendarsCalendarViewListExtensions")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/calendarGroups/{calendarGroup-id}/calendars/{calendar-id}/calendarView/{event-id}/extensions"
	localVarPath = strings.Replace(localVarPath, "{"+"calendarGroup-id"+"}", _neturl.PathEscape(parameterToString(r.calendarGroupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"calendar-id"+"}", _neturl.PathEscape(parameterToString(r.calendarId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.top != nil {
		localVarQueryParams.Add("$top", parameterToString(*r.top, ""))
	}
	if r.skip != nil {
		localVarQueryParams.Add("$skip", parameterToString(*r.skip, ""))
	}
	if r.filter != nil {
		localVarQueryParams.Add("$filter", parameterToString(*r.filter, ""))
	}
	if r.count != nil {
		localVarQueryParams.Add("$count", parameterToString(*r.count, ""))
	}
	if r.orderby != nil {
		localVarQueryParams.Add("$orderby", parameterToString(*r.orderby, "csv"))
	}
	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMeCalendarGroupsCalendarsCalendarViewListInstancesRequest struct {
	ctx _context.Context
	ApiService *MeCalendarGroupApiService
	calendarGroupId string
	calendarId string
	eventId string
	top *int32
	skip *int32
	filter *string
	count *bool
	orderby *[]string
	select_ *[]string
}

// Show only the first n items
func (r ApiMeCalendarGroupsCalendarsCalendarViewListInstancesRequest) Top(top int32) ApiMeCalendarGroupsCalendarsCalendarViewListInstancesRequest {
	r.top = &top
	return r
}
// Skip the first n items
func (r ApiMeCalendarGroupsCalendarsCalendarViewListInstancesRequest) Skip(skip int32) ApiMeCalendarGroupsCalendarsCalendarViewListInstancesRequest {
	r.skip = &skip
	return r
}
// Filter items by property values
func (r ApiMeCalendarGroupsCalendarsCalendarViewListInstancesRequest) Filter(filter string) ApiMeCalendarGroupsCalendarsCalendarViewListInstancesRequest {
	r.filter = &filter
	return r
}
// Include count of items
func (r ApiMeCalendarGroupsCalendarsCalendarViewListInstancesRequest) Count(count bool) ApiMeCalendarGroupsCalendarsCalendarViewListInstancesRequest {
	r.count = &count
	return r
}
// Order items by property values
func (r ApiMeCalendarGroupsCalendarsCalendarViewListInstancesRequest) Orderby(orderby []string) ApiMeCalendarGroupsCalendarsCalendarViewListInstancesRequest {
	r.orderby = &orderby
	return r
}
// Select properties to be returned
func (r ApiMeCalendarGroupsCalendarsCalendarViewListInstancesRequest) Select_(select_ []string) ApiMeCalendarGroupsCalendarsCalendarViewListInstancesRequest {
	r.select_ = &select_
	return r
}

func (r ApiMeCalendarGroupsCalendarsCalendarViewListInstancesRequest) Execute() (CollectionOfEvent, *_nethttp.Response, error) {
	return r.ApiService.MeCalendarGroupsCalendarsCalendarViewListInstancesExecute(r)
}

/*
MeCalendarGroupsCalendarsCalendarViewListInstances Get instances from me

The occurrences of a recurring series, if the event is a series master. This property includes occurrences that are part of the recurrence pattern, and exceptions that have been modified, but does not include occurrences that have been cancelled from the series. Navigation property. Read-only. Nullable.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param calendarGroupId key: id of calendarGroup
 @param calendarId key: id of calendar
 @param eventId key: id of event
 @return ApiMeCalendarGroupsCalendarsCalendarViewListInstancesRequest
*/
func (a *MeCalendarGroupApiService) MeCalendarGroupsCalendarsCalendarViewListInstances(ctx _context.Context, calendarGroupId string, calendarId string, eventId string) ApiMeCalendarGroupsCalendarsCalendarViewListInstancesRequest {
	return ApiMeCalendarGroupsCalendarsCalendarViewListInstancesRequest{
		ApiService: a,
		ctx: ctx,
		calendarGroupId: calendarGroupId,
		calendarId: calendarId,
		eventId: eventId,
	}
}

// Execute executes the request
//  @return CollectionOfEvent
func (a *MeCalendarGroupApiService) MeCalendarGroupsCalendarsCalendarViewListInstancesExecute(r ApiMeCalendarGroupsCalendarsCalendarViewListInstancesRequest) (CollectionOfEvent, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  CollectionOfEvent
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MeCalendarGroupApiService.MeCalendarGroupsCalendarsCalendarViewListInstances")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/calendarGroups/{calendarGroup-id}/calendars/{calendar-id}/calendarView/{event-id}/instances"
	localVarPath = strings.Replace(localVarPath, "{"+"calendarGroup-id"+"}", _neturl.PathEscape(parameterToString(r.calendarGroupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"calendar-id"+"}", _neturl.PathEscape(parameterToString(r.calendarId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.top != nil {
		localVarQueryParams.Add("$top", parameterToString(*r.top, ""))
	}
	if r.skip != nil {
		localVarQueryParams.Add("$skip", parameterToString(*r.skip, ""))
	}
	if r.filter != nil {
		localVarQueryParams.Add("$filter", parameterToString(*r.filter, ""))
	}
	if r.count != nil {
		localVarQueryParams.Add("$count", parameterToString(*r.count, ""))
	}
	if r.orderby != nil {
		localVarQueryParams.Add("$orderby", parameterToString(*r.orderby, "csv"))
	}
	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMeCalendarGroupsCalendarsCalendarViewListMultiValueExtendedPropertiesRequest struct {
	ctx _context.Context
	ApiService *MeCalendarGroupApiService
	calendarGroupId string
	calendarId string
	eventId string
	top *int32
	skip *int32
	search *string
	filter *string
	count *bool
	orderby *[]string
	select_ *[]string
	expand *[]string
}

// Show only the first n items
func (r ApiMeCalendarGroupsCalendarsCalendarViewListMultiValueExtendedPropertiesRequest) Top(top int32) ApiMeCalendarGroupsCalendarsCalendarViewListMultiValueExtendedPropertiesRequest {
	r.top = &top
	return r
}
// Skip the first n items
func (r ApiMeCalendarGroupsCalendarsCalendarViewListMultiValueExtendedPropertiesRequest) Skip(skip int32) ApiMeCalendarGroupsCalendarsCalendarViewListMultiValueExtendedPropertiesRequest {
	r.skip = &skip
	return r
}
// Search items by search phrases
func (r ApiMeCalendarGroupsCalendarsCalendarViewListMultiValueExtendedPropertiesRequest) Search(search string) ApiMeCalendarGroupsCalendarsCalendarViewListMultiValueExtendedPropertiesRequest {
	r.search = &search
	return r
}
// Filter items by property values
func (r ApiMeCalendarGroupsCalendarsCalendarViewListMultiValueExtendedPropertiesRequest) Filter(filter string) ApiMeCalendarGroupsCalendarsCalendarViewListMultiValueExtendedPropertiesRequest {
	r.filter = &filter
	return r
}
// Include count of items
func (r ApiMeCalendarGroupsCalendarsCalendarViewListMultiValueExtendedPropertiesRequest) Count(count bool) ApiMeCalendarGroupsCalendarsCalendarViewListMultiValueExtendedPropertiesRequest {
	r.count = &count
	return r
}
// Order items by property values
func (r ApiMeCalendarGroupsCalendarsCalendarViewListMultiValueExtendedPropertiesRequest) Orderby(orderby []string) ApiMeCalendarGroupsCalendarsCalendarViewListMultiValueExtendedPropertiesRequest {
	r.orderby = &orderby
	return r
}
// Select properties to be returned
func (r ApiMeCalendarGroupsCalendarsCalendarViewListMultiValueExtendedPropertiesRequest) Select_(select_ []string) ApiMeCalendarGroupsCalendarsCalendarViewListMultiValueExtendedPropertiesRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiMeCalendarGroupsCalendarsCalendarViewListMultiValueExtendedPropertiesRequest) Expand(expand []string) ApiMeCalendarGroupsCalendarsCalendarViewListMultiValueExtendedPropertiesRequest {
	r.expand = &expand
	return r
}

func (r ApiMeCalendarGroupsCalendarsCalendarViewListMultiValueExtendedPropertiesRequest) Execute() (CollectionOfMultiValueLegacyExtendedProperty, *_nethttp.Response, error) {
	return r.ApiService.MeCalendarGroupsCalendarsCalendarViewListMultiValueExtendedPropertiesExecute(r)
}

/*
MeCalendarGroupsCalendarsCalendarViewListMultiValueExtendedProperties Get multiValueExtendedProperties from me

The collection of multi-value extended properties defined for the event. Read-only. Nullable.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param calendarGroupId key: id of calendarGroup
 @param calendarId key: id of calendar
 @param eventId key: id of event
 @return ApiMeCalendarGroupsCalendarsCalendarViewListMultiValueExtendedPropertiesRequest
*/
func (a *MeCalendarGroupApiService) MeCalendarGroupsCalendarsCalendarViewListMultiValueExtendedProperties(ctx _context.Context, calendarGroupId string, calendarId string, eventId string) ApiMeCalendarGroupsCalendarsCalendarViewListMultiValueExtendedPropertiesRequest {
	return ApiMeCalendarGroupsCalendarsCalendarViewListMultiValueExtendedPropertiesRequest{
		ApiService: a,
		ctx: ctx,
		calendarGroupId: calendarGroupId,
		calendarId: calendarId,
		eventId: eventId,
	}
}

// Execute executes the request
//  @return CollectionOfMultiValueLegacyExtendedProperty
func (a *MeCalendarGroupApiService) MeCalendarGroupsCalendarsCalendarViewListMultiValueExtendedPropertiesExecute(r ApiMeCalendarGroupsCalendarsCalendarViewListMultiValueExtendedPropertiesRequest) (CollectionOfMultiValueLegacyExtendedProperty, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  CollectionOfMultiValueLegacyExtendedProperty
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MeCalendarGroupApiService.MeCalendarGroupsCalendarsCalendarViewListMultiValueExtendedProperties")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/calendarGroups/{calendarGroup-id}/calendars/{calendar-id}/calendarView/{event-id}/multiValueExtendedProperties"
	localVarPath = strings.Replace(localVarPath, "{"+"calendarGroup-id"+"}", _neturl.PathEscape(parameterToString(r.calendarGroupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"calendar-id"+"}", _neturl.PathEscape(parameterToString(r.calendarId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.top != nil {
		localVarQueryParams.Add("$top", parameterToString(*r.top, ""))
	}
	if r.skip != nil {
		localVarQueryParams.Add("$skip", parameterToString(*r.skip, ""))
	}
	if r.search != nil {
		localVarQueryParams.Add("$search", parameterToString(*r.search, ""))
	}
	if r.filter != nil {
		localVarQueryParams.Add("$filter", parameterToString(*r.filter, ""))
	}
	if r.count != nil {
		localVarQueryParams.Add("$count", parameterToString(*r.count, ""))
	}
	if r.orderby != nil {
		localVarQueryParams.Add("$orderby", parameterToString(*r.orderby, "csv"))
	}
	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMeCalendarGroupsCalendarsCalendarViewListSingleValueExtendedPropertiesRequest struct {
	ctx _context.Context
	ApiService *MeCalendarGroupApiService
	calendarGroupId string
	calendarId string
	eventId string
	top *int32
	skip *int32
	search *string
	filter *string
	count *bool
	orderby *[]string
	select_ *[]string
	expand *[]string
}

// Show only the first n items
func (r ApiMeCalendarGroupsCalendarsCalendarViewListSingleValueExtendedPropertiesRequest) Top(top int32) ApiMeCalendarGroupsCalendarsCalendarViewListSingleValueExtendedPropertiesRequest {
	r.top = &top
	return r
}
// Skip the first n items
func (r ApiMeCalendarGroupsCalendarsCalendarViewListSingleValueExtendedPropertiesRequest) Skip(skip int32) ApiMeCalendarGroupsCalendarsCalendarViewListSingleValueExtendedPropertiesRequest {
	r.skip = &skip
	return r
}
// Search items by search phrases
func (r ApiMeCalendarGroupsCalendarsCalendarViewListSingleValueExtendedPropertiesRequest) Search(search string) ApiMeCalendarGroupsCalendarsCalendarViewListSingleValueExtendedPropertiesRequest {
	r.search = &search
	return r
}
// Filter items by property values
func (r ApiMeCalendarGroupsCalendarsCalendarViewListSingleValueExtendedPropertiesRequest) Filter(filter string) ApiMeCalendarGroupsCalendarsCalendarViewListSingleValueExtendedPropertiesRequest {
	r.filter = &filter
	return r
}
// Include count of items
func (r ApiMeCalendarGroupsCalendarsCalendarViewListSingleValueExtendedPropertiesRequest) Count(count bool) ApiMeCalendarGroupsCalendarsCalendarViewListSingleValueExtendedPropertiesRequest {
	r.count = &count
	return r
}
// Order items by property values
func (r ApiMeCalendarGroupsCalendarsCalendarViewListSingleValueExtendedPropertiesRequest) Orderby(orderby []string) ApiMeCalendarGroupsCalendarsCalendarViewListSingleValueExtendedPropertiesRequest {
	r.orderby = &orderby
	return r
}
// Select properties to be returned
func (r ApiMeCalendarGroupsCalendarsCalendarViewListSingleValueExtendedPropertiesRequest) Select_(select_ []string) ApiMeCalendarGroupsCalendarsCalendarViewListSingleValueExtendedPropertiesRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiMeCalendarGroupsCalendarsCalendarViewListSingleValueExtendedPropertiesRequest) Expand(expand []string) ApiMeCalendarGroupsCalendarsCalendarViewListSingleValueExtendedPropertiesRequest {
	r.expand = &expand
	return r
}

func (r ApiMeCalendarGroupsCalendarsCalendarViewListSingleValueExtendedPropertiesRequest) Execute() (CollectionOfSingleValueLegacyExtendedProperty, *_nethttp.Response, error) {
	return r.ApiService.MeCalendarGroupsCalendarsCalendarViewListSingleValueExtendedPropertiesExecute(r)
}

/*
MeCalendarGroupsCalendarsCalendarViewListSingleValueExtendedProperties Get singleValueExtendedProperties from me

The collection of single-value extended properties defined for the event. Read-only. Nullable.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param calendarGroupId key: id of calendarGroup
 @param calendarId key: id of calendar
 @param eventId key: id of event
 @return ApiMeCalendarGroupsCalendarsCalendarViewListSingleValueExtendedPropertiesRequest
*/
func (a *MeCalendarGroupApiService) MeCalendarGroupsCalendarsCalendarViewListSingleValueExtendedProperties(ctx _context.Context, calendarGroupId string, calendarId string, eventId string) ApiMeCalendarGroupsCalendarsCalendarViewListSingleValueExtendedPropertiesRequest {
	return ApiMeCalendarGroupsCalendarsCalendarViewListSingleValueExtendedPropertiesRequest{
		ApiService: a,
		ctx: ctx,
		calendarGroupId: calendarGroupId,
		calendarId: calendarId,
		eventId: eventId,
	}
}

// Execute executes the request
//  @return CollectionOfSingleValueLegacyExtendedProperty
func (a *MeCalendarGroupApiService) MeCalendarGroupsCalendarsCalendarViewListSingleValueExtendedPropertiesExecute(r ApiMeCalendarGroupsCalendarsCalendarViewListSingleValueExtendedPropertiesRequest) (CollectionOfSingleValueLegacyExtendedProperty, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  CollectionOfSingleValueLegacyExtendedProperty
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MeCalendarGroupApiService.MeCalendarGroupsCalendarsCalendarViewListSingleValueExtendedProperties")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/calendarGroups/{calendarGroup-id}/calendars/{calendar-id}/calendarView/{event-id}/singleValueExtendedProperties"
	localVarPath = strings.Replace(localVarPath, "{"+"calendarGroup-id"+"}", _neturl.PathEscape(parameterToString(r.calendarGroupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"calendar-id"+"}", _neturl.PathEscape(parameterToString(r.calendarId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.top != nil {
		localVarQueryParams.Add("$top", parameterToString(*r.top, ""))
	}
	if r.skip != nil {
		localVarQueryParams.Add("$skip", parameterToString(*r.skip, ""))
	}
	if r.search != nil {
		localVarQueryParams.Add("$search", parameterToString(*r.search, ""))
	}
	if r.filter != nil {
		localVarQueryParams.Add("$filter", parameterToString(*r.filter, ""))
	}
	if r.count != nil {
		localVarQueryParams.Add("$count", parameterToString(*r.count, ""))
	}
	if r.orderby != nil {
		localVarQueryParams.Add("$orderby", parameterToString(*r.orderby, "csv"))
	}
	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMeCalendarGroupsCalendarsCalendarViewUpdateAttachmentsRequest struct {
	ctx _context.Context
	ApiService *MeCalendarGroupApiService
	calendarGroupId string
	calendarId string
	eventId string
	attachmentId string
	microsoftGraphAttachment *MicrosoftGraphAttachment
}

// New navigation property values
func (r ApiMeCalendarGroupsCalendarsCalendarViewUpdateAttachmentsRequest) MicrosoftGraphAttachment(microsoftGraphAttachment MicrosoftGraphAttachment) ApiMeCalendarGroupsCalendarsCalendarViewUpdateAttachmentsRequest {
	r.microsoftGraphAttachment = &microsoftGraphAttachment
	return r
}

func (r ApiMeCalendarGroupsCalendarsCalendarViewUpdateAttachmentsRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.MeCalendarGroupsCalendarsCalendarViewUpdateAttachmentsExecute(r)
}

/*
MeCalendarGroupsCalendarsCalendarViewUpdateAttachments Update the navigation property attachments in me

The collection of FileAttachment, ItemAttachment, and referenceAttachment attachments for the event. Navigation property. Read-only. Nullable.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param calendarGroupId key: id of calendarGroup
 @param calendarId key: id of calendar
 @param eventId key: id of event
 @param attachmentId key: id of attachment
 @return ApiMeCalendarGroupsCalendarsCalendarViewUpdateAttachmentsRequest
*/
func (a *MeCalendarGroupApiService) MeCalendarGroupsCalendarsCalendarViewUpdateAttachments(ctx _context.Context, calendarGroupId string, calendarId string, eventId string, attachmentId string) ApiMeCalendarGroupsCalendarsCalendarViewUpdateAttachmentsRequest {
	return ApiMeCalendarGroupsCalendarsCalendarViewUpdateAttachmentsRequest{
		ApiService: a,
		ctx: ctx,
		calendarGroupId: calendarGroupId,
		calendarId: calendarId,
		eventId: eventId,
		attachmentId: attachmentId,
	}
}

// Execute executes the request
func (a *MeCalendarGroupApiService) MeCalendarGroupsCalendarsCalendarViewUpdateAttachmentsExecute(r ApiMeCalendarGroupsCalendarsCalendarViewUpdateAttachmentsRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPatch
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MeCalendarGroupApiService.MeCalendarGroupsCalendarsCalendarViewUpdateAttachments")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/calendarGroups/{calendarGroup-id}/calendars/{calendar-id}/calendarView/{event-id}/attachments/{attachment-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"calendarGroup-id"+"}", _neturl.PathEscape(parameterToString(r.calendarGroupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"calendar-id"+"}", _neturl.PathEscape(parameterToString(r.calendarId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"attachment-id"+"}", _neturl.PathEscape(parameterToString(r.attachmentId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphAttachment == nil {
		return nil, reportError("microsoftGraphAttachment is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphAttachment
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiMeCalendarGroupsCalendarsCalendarViewUpdateCalendarRequest struct {
	ctx _context.Context
	ApiService *MeCalendarGroupApiService
	calendarGroupId string
	calendarId string
	eventId string
	microsoftGraphCalendar *MicrosoftGraphCalendar
}

// New navigation property values
func (r ApiMeCalendarGroupsCalendarsCalendarViewUpdateCalendarRequest) MicrosoftGraphCalendar(microsoftGraphCalendar MicrosoftGraphCalendar) ApiMeCalendarGroupsCalendarsCalendarViewUpdateCalendarRequest {
	r.microsoftGraphCalendar = &microsoftGraphCalendar
	return r
}

func (r ApiMeCalendarGroupsCalendarsCalendarViewUpdateCalendarRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.MeCalendarGroupsCalendarsCalendarViewUpdateCalendarExecute(r)
}

/*
MeCalendarGroupsCalendarsCalendarViewUpdateCalendar Update the navigation property calendar in me

The calendar that contains the event. Navigation property. Read-only.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param calendarGroupId key: id of calendarGroup
 @param calendarId key: id of calendar
 @param eventId key: id of event
 @return ApiMeCalendarGroupsCalendarsCalendarViewUpdateCalendarRequest
*/
func (a *MeCalendarGroupApiService) MeCalendarGroupsCalendarsCalendarViewUpdateCalendar(ctx _context.Context, calendarGroupId string, calendarId string, eventId string) ApiMeCalendarGroupsCalendarsCalendarViewUpdateCalendarRequest {
	return ApiMeCalendarGroupsCalendarsCalendarViewUpdateCalendarRequest{
		ApiService: a,
		ctx: ctx,
		calendarGroupId: calendarGroupId,
		calendarId: calendarId,
		eventId: eventId,
	}
}

// Execute executes the request
func (a *MeCalendarGroupApiService) MeCalendarGroupsCalendarsCalendarViewUpdateCalendarExecute(r ApiMeCalendarGroupsCalendarsCalendarViewUpdateCalendarRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPatch
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MeCalendarGroupApiService.MeCalendarGroupsCalendarsCalendarViewUpdateCalendar")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/calendarGroups/{calendarGroup-id}/calendars/{calendar-id}/calendarView/{event-id}/calendar"
	localVarPath = strings.Replace(localVarPath, "{"+"calendarGroup-id"+"}", _neturl.PathEscape(parameterToString(r.calendarGroupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"calendar-id"+"}", _neturl.PathEscape(parameterToString(r.calendarId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphCalendar == nil {
		return nil, reportError("microsoftGraphCalendar is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphCalendar
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiMeCalendarGroupsCalendarsCalendarViewUpdateExtensionsRequest struct {
	ctx _context.Context
	ApiService *MeCalendarGroupApiService
	calendarGroupId string
	calendarId string
	eventId string
	extensionId string
	microsoftGraphExtension *MicrosoftGraphExtension
}

// New navigation property values
func (r ApiMeCalendarGroupsCalendarsCalendarViewUpdateExtensionsRequest) MicrosoftGraphExtension(microsoftGraphExtension MicrosoftGraphExtension) ApiMeCalendarGroupsCalendarsCalendarViewUpdateExtensionsRequest {
	r.microsoftGraphExtension = &microsoftGraphExtension
	return r
}

func (r ApiMeCalendarGroupsCalendarsCalendarViewUpdateExtensionsRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.MeCalendarGroupsCalendarsCalendarViewUpdateExtensionsExecute(r)
}

/*
MeCalendarGroupsCalendarsCalendarViewUpdateExtensions Update the navigation property extensions in me

The collection of open extensions defined for the event. Nullable.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param calendarGroupId key: id of calendarGroup
 @param calendarId key: id of calendar
 @param eventId key: id of event
 @param extensionId key: id of extension
 @return ApiMeCalendarGroupsCalendarsCalendarViewUpdateExtensionsRequest
*/
func (a *MeCalendarGroupApiService) MeCalendarGroupsCalendarsCalendarViewUpdateExtensions(ctx _context.Context, calendarGroupId string, calendarId string, eventId string, extensionId string) ApiMeCalendarGroupsCalendarsCalendarViewUpdateExtensionsRequest {
	return ApiMeCalendarGroupsCalendarsCalendarViewUpdateExtensionsRequest{
		ApiService: a,
		ctx: ctx,
		calendarGroupId: calendarGroupId,
		calendarId: calendarId,
		eventId: eventId,
		extensionId: extensionId,
	}
}

// Execute executes the request
func (a *MeCalendarGroupApiService) MeCalendarGroupsCalendarsCalendarViewUpdateExtensionsExecute(r ApiMeCalendarGroupsCalendarsCalendarViewUpdateExtensionsRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPatch
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MeCalendarGroupApiService.MeCalendarGroupsCalendarsCalendarViewUpdateExtensions")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/calendarGroups/{calendarGroup-id}/calendars/{calendar-id}/calendarView/{event-id}/extensions/{extension-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"calendarGroup-id"+"}", _neturl.PathEscape(parameterToString(r.calendarGroupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"calendar-id"+"}", _neturl.PathEscape(parameterToString(r.calendarId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"extension-id"+"}", _neturl.PathEscape(parameterToString(r.extensionId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphExtension == nil {
		return nil, reportError("microsoftGraphExtension is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphExtension
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiMeCalendarGroupsCalendarsCalendarViewUpdateInstancesRequest struct {
	ctx _context.Context
	ApiService *MeCalendarGroupApiService
	calendarGroupId string
	calendarId string
	eventId string
	eventId1 string
	microsoftGraphEvent *MicrosoftGraphEvent
}

// New navigation property values
func (r ApiMeCalendarGroupsCalendarsCalendarViewUpdateInstancesRequest) MicrosoftGraphEvent(microsoftGraphEvent MicrosoftGraphEvent) ApiMeCalendarGroupsCalendarsCalendarViewUpdateInstancesRequest {
	r.microsoftGraphEvent = &microsoftGraphEvent
	return r
}

func (r ApiMeCalendarGroupsCalendarsCalendarViewUpdateInstancesRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.MeCalendarGroupsCalendarsCalendarViewUpdateInstancesExecute(r)
}

/*
MeCalendarGroupsCalendarsCalendarViewUpdateInstances Update the navigation property instances in me

The occurrences of a recurring series, if the event is a series master. This property includes occurrences that are part of the recurrence pattern, and exceptions that have been modified, but does not include occurrences that have been cancelled from the series. Navigation property. Read-only. Nullable.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param calendarGroupId key: id of calendarGroup
 @param calendarId key: id of calendar
 @param eventId key: id of event
 @param eventId1 key: id of event
 @return ApiMeCalendarGroupsCalendarsCalendarViewUpdateInstancesRequest
*/
func (a *MeCalendarGroupApiService) MeCalendarGroupsCalendarsCalendarViewUpdateInstances(ctx _context.Context, calendarGroupId string, calendarId string, eventId string, eventId1 string) ApiMeCalendarGroupsCalendarsCalendarViewUpdateInstancesRequest {
	return ApiMeCalendarGroupsCalendarsCalendarViewUpdateInstancesRequest{
		ApiService: a,
		ctx: ctx,
		calendarGroupId: calendarGroupId,
		calendarId: calendarId,
		eventId: eventId,
		eventId1: eventId1,
	}
}

// Execute executes the request
func (a *MeCalendarGroupApiService) MeCalendarGroupsCalendarsCalendarViewUpdateInstancesExecute(r ApiMeCalendarGroupsCalendarsCalendarViewUpdateInstancesRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPatch
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MeCalendarGroupApiService.MeCalendarGroupsCalendarsCalendarViewUpdateInstances")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/calendarGroups/{calendarGroup-id}/calendars/{calendar-id}/calendarView/{event-id}/instances/{event-id1}"
	localVarPath = strings.Replace(localVarPath, "{"+"calendarGroup-id"+"}", _neturl.PathEscape(parameterToString(r.calendarGroupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"calendar-id"+"}", _neturl.PathEscape(parameterToString(r.calendarId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id1"+"}", _neturl.PathEscape(parameterToString(r.eventId1, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphEvent == nil {
		return nil, reportError("microsoftGraphEvent is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphEvent
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiMeCalendarGroupsCalendarsCalendarViewUpdateMultiValueExtendedPropertiesRequest struct {
	ctx _context.Context
	ApiService *MeCalendarGroupApiService
	calendarGroupId string
	calendarId string
	eventId string
	multiValueLegacyExtendedPropertyId string
	microsoftGraphMultiValueLegacyExtendedProperty *MicrosoftGraphMultiValueLegacyExtendedProperty
}

// New navigation property values
func (r ApiMeCalendarGroupsCalendarsCalendarViewUpdateMultiValueExtendedPropertiesRequest) MicrosoftGraphMultiValueLegacyExtendedProperty(microsoftGraphMultiValueLegacyExtendedProperty MicrosoftGraphMultiValueLegacyExtendedProperty) ApiMeCalendarGroupsCalendarsCalendarViewUpdateMultiValueExtendedPropertiesRequest {
	r.microsoftGraphMultiValueLegacyExtendedProperty = &microsoftGraphMultiValueLegacyExtendedProperty
	return r
}

func (r ApiMeCalendarGroupsCalendarsCalendarViewUpdateMultiValueExtendedPropertiesRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.MeCalendarGroupsCalendarsCalendarViewUpdateMultiValueExtendedPropertiesExecute(r)
}

/*
MeCalendarGroupsCalendarsCalendarViewUpdateMultiValueExtendedProperties Update the navigation property multiValueExtendedProperties in me

The collection of multi-value extended properties defined for the event. Read-only. Nullable.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param calendarGroupId key: id of calendarGroup
 @param calendarId key: id of calendar
 @param eventId key: id of event
 @param multiValueLegacyExtendedPropertyId key: id of multiValueLegacyExtendedProperty
 @return ApiMeCalendarGroupsCalendarsCalendarViewUpdateMultiValueExtendedPropertiesRequest
*/
func (a *MeCalendarGroupApiService) MeCalendarGroupsCalendarsCalendarViewUpdateMultiValueExtendedProperties(ctx _context.Context, calendarGroupId string, calendarId string, eventId string, multiValueLegacyExtendedPropertyId string) ApiMeCalendarGroupsCalendarsCalendarViewUpdateMultiValueExtendedPropertiesRequest {
	return ApiMeCalendarGroupsCalendarsCalendarViewUpdateMultiValueExtendedPropertiesRequest{
		ApiService: a,
		ctx: ctx,
		calendarGroupId: calendarGroupId,
		calendarId: calendarId,
		eventId: eventId,
		multiValueLegacyExtendedPropertyId: multiValueLegacyExtendedPropertyId,
	}
}

// Execute executes the request
func (a *MeCalendarGroupApiService) MeCalendarGroupsCalendarsCalendarViewUpdateMultiValueExtendedPropertiesExecute(r ApiMeCalendarGroupsCalendarsCalendarViewUpdateMultiValueExtendedPropertiesRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPatch
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MeCalendarGroupApiService.MeCalendarGroupsCalendarsCalendarViewUpdateMultiValueExtendedProperties")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/calendarGroups/{calendarGroup-id}/calendars/{calendar-id}/calendarView/{event-id}/multiValueExtendedProperties/{multiValueLegacyExtendedProperty-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"calendarGroup-id"+"}", _neturl.PathEscape(parameterToString(r.calendarGroupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"calendar-id"+"}", _neturl.PathEscape(parameterToString(r.calendarId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"multiValueLegacyExtendedProperty-id"+"}", _neturl.PathEscape(parameterToString(r.multiValueLegacyExtendedPropertyId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphMultiValueLegacyExtendedProperty == nil {
		return nil, reportError("microsoftGraphMultiValueLegacyExtendedProperty is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphMultiValueLegacyExtendedProperty
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiMeCalendarGroupsCalendarsCalendarViewUpdateSingleValueExtendedPropertiesRequest struct {
	ctx _context.Context
	ApiService *MeCalendarGroupApiService
	calendarGroupId string
	calendarId string
	eventId string
	singleValueLegacyExtendedPropertyId string
	microsoftGraphSingleValueLegacyExtendedProperty *MicrosoftGraphSingleValueLegacyExtendedProperty
}

// New navigation property values
func (r ApiMeCalendarGroupsCalendarsCalendarViewUpdateSingleValueExtendedPropertiesRequest) MicrosoftGraphSingleValueLegacyExtendedProperty(microsoftGraphSingleValueLegacyExtendedProperty MicrosoftGraphSingleValueLegacyExtendedProperty) ApiMeCalendarGroupsCalendarsCalendarViewUpdateSingleValueExtendedPropertiesRequest {
	r.microsoftGraphSingleValueLegacyExtendedProperty = &microsoftGraphSingleValueLegacyExtendedProperty
	return r
}

func (r ApiMeCalendarGroupsCalendarsCalendarViewUpdateSingleValueExtendedPropertiesRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.MeCalendarGroupsCalendarsCalendarViewUpdateSingleValueExtendedPropertiesExecute(r)
}

/*
MeCalendarGroupsCalendarsCalendarViewUpdateSingleValueExtendedProperties Update the navigation property singleValueExtendedProperties in me

The collection of single-value extended properties defined for the event. Read-only. Nullable.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param calendarGroupId key: id of calendarGroup
 @param calendarId key: id of calendar
 @param eventId key: id of event
 @param singleValueLegacyExtendedPropertyId key: id of singleValueLegacyExtendedProperty
 @return ApiMeCalendarGroupsCalendarsCalendarViewUpdateSingleValueExtendedPropertiesRequest
*/
func (a *MeCalendarGroupApiService) MeCalendarGroupsCalendarsCalendarViewUpdateSingleValueExtendedProperties(ctx _context.Context, calendarGroupId string, calendarId string, eventId string, singleValueLegacyExtendedPropertyId string) ApiMeCalendarGroupsCalendarsCalendarViewUpdateSingleValueExtendedPropertiesRequest {
	return ApiMeCalendarGroupsCalendarsCalendarViewUpdateSingleValueExtendedPropertiesRequest{
		ApiService: a,
		ctx: ctx,
		calendarGroupId: calendarGroupId,
		calendarId: calendarId,
		eventId: eventId,
		singleValueLegacyExtendedPropertyId: singleValueLegacyExtendedPropertyId,
	}
}

// Execute executes the request
func (a *MeCalendarGroupApiService) MeCalendarGroupsCalendarsCalendarViewUpdateSingleValueExtendedPropertiesExecute(r ApiMeCalendarGroupsCalendarsCalendarViewUpdateSingleValueExtendedPropertiesRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPatch
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MeCalendarGroupApiService.MeCalendarGroupsCalendarsCalendarViewUpdateSingleValueExtendedProperties")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/calendarGroups/{calendarGroup-id}/calendars/{calendar-id}/calendarView/{event-id}/singleValueExtendedProperties/{singleValueLegacyExtendedProperty-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"calendarGroup-id"+"}", _neturl.PathEscape(parameterToString(r.calendarGroupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"calendar-id"+"}", _neturl.PathEscape(parameterToString(r.calendarId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"singleValueLegacyExtendedProperty-id"+"}", _neturl.PathEscape(parameterToString(r.singleValueLegacyExtendedPropertyId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphSingleValueLegacyExtendedProperty == nil {
		return nil, reportError("microsoftGraphSingleValueLegacyExtendedProperty is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphSingleValueLegacyExtendedProperty
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiMeCalendarGroupsCalendarsCreateCalendarPermissionsRequest struct {
	ctx _context.Context
	ApiService *MeCalendarGroupApiService
	calendarGroupId string
	calendarId string
	microsoftGraphCalendarPermission *MicrosoftGraphCalendarPermission
}

// New navigation property
func (r ApiMeCalendarGroupsCalendarsCreateCalendarPermissionsRequest) MicrosoftGraphCalendarPermission(microsoftGraphCalendarPermission MicrosoftGraphCalendarPermission) ApiMeCalendarGroupsCalendarsCreateCalendarPermissionsRequest {
	r.microsoftGraphCalendarPermission = &microsoftGraphCalendarPermission
	return r
}

func (r ApiMeCalendarGroupsCalendarsCreateCalendarPermissionsRequest) Execute() (MicrosoftGraphCalendarPermission, *_nethttp.Response, error) {
	return r.ApiService.MeCalendarGroupsCalendarsCreateCalendarPermissionsExecute(r)
}

/*
MeCalendarGroupsCalendarsCreateCalendarPermissions Create new navigation property to calendarPermissions for me

The permissions of the users with whom the calendar is shared.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param calendarGroupId key: id of calendarGroup
 @param calendarId key: id of calendar
 @return ApiMeCalendarGroupsCalendarsCreateCalendarPermissionsRequest
*/
func (a *MeCalendarGroupApiService) MeCalendarGroupsCalendarsCreateCalendarPermissions(ctx _context.Context, calendarGroupId string, calendarId string) ApiMeCalendarGroupsCalendarsCreateCalendarPermissionsRequest {
	return ApiMeCalendarGroupsCalendarsCreateCalendarPermissionsRequest{
		ApiService: a,
		ctx: ctx,
		calendarGroupId: calendarGroupId,
		calendarId: calendarId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphCalendarPermission
func (a *MeCalendarGroupApiService) MeCalendarGroupsCalendarsCreateCalendarPermissionsExecute(r ApiMeCalendarGroupsCalendarsCreateCalendarPermissionsRequest) (MicrosoftGraphCalendarPermission, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphCalendarPermission
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MeCalendarGroupApiService.MeCalendarGroupsCalendarsCreateCalendarPermissions")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/calendarGroups/{calendarGroup-id}/calendars/{calendar-id}/calendarPermissions"
	localVarPath = strings.Replace(localVarPath, "{"+"calendarGroup-id"+"}", _neturl.PathEscape(parameterToString(r.calendarGroupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"calendar-id"+"}", _neturl.PathEscape(parameterToString(r.calendarId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphCalendarPermission == nil {
		return localVarReturnValue, nil, reportError("microsoftGraphCalendarPermission is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphCalendarPermission
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMeCalendarGroupsCalendarsCreateCalendarViewRequest struct {
	ctx _context.Context
	ApiService *MeCalendarGroupApiService
	calendarGroupId string
	calendarId string
	microsoftGraphEvent *MicrosoftGraphEvent
}

// New navigation property
func (r ApiMeCalendarGroupsCalendarsCreateCalendarViewRequest) MicrosoftGraphEvent(microsoftGraphEvent MicrosoftGraphEvent) ApiMeCalendarGroupsCalendarsCreateCalendarViewRequest {
	r.microsoftGraphEvent = &microsoftGraphEvent
	return r
}

func (r ApiMeCalendarGroupsCalendarsCreateCalendarViewRequest) Execute() (MicrosoftGraphEvent, *_nethttp.Response, error) {
	return r.ApiService.MeCalendarGroupsCalendarsCreateCalendarViewExecute(r)
}

/*
MeCalendarGroupsCalendarsCreateCalendarView Create new navigation property to calendarView for me

The calendar view for the calendar. Navigation property. Read-only.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param calendarGroupId key: id of calendarGroup
 @param calendarId key: id of calendar
 @return ApiMeCalendarGroupsCalendarsCreateCalendarViewRequest
*/
func (a *MeCalendarGroupApiService) MeCalendarGroupsCalendarsCreateCalendarView(ctx _context.Context, calendarGroupId string, calendarId string) ApiMeCalendarGroupsCalendarsCreateCalendarViewRequest {
	return ApiMeCalendarGroupsCalendarsCreateCalendarViewRequest{
		ApiService: a,
		ctx: ctx,
		calendarGroupId: calendarGroupId,
		calendarId: calendarId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphEvent
func (a *MeCalendarGroupApiService) MeCalendarGroupsCalendarsCreateCalendarViewExecute(r ApiMeCalendarGroupsCalendarsCreateCalendarViewRequest) (MicrosoftGraphEvent, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphEvent
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MeCalendarGroupApiService.MeCalendarGroupsCalendarsCreateCalendarView")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/calendarGroups/{calendarGroup-id}/calendars/{calendar-id}/calendarView"
	localVarPath = strings.Replace(localVarPath, "{"+"calendarGroup-id"+"}", _neturl.PathEscape(parameterToString(r.calendarGroupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"calendar-id"+"}", _neturl.PathEscape(parameterToString(r.calendarId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphEvent == nil {
		return localVarReturnValue, nil, reportError("microsoftGraphEvent is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphEvent
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMeCalendarGroupsCalendarsCreateEventsRequest struct {
	ctx _context.Context
	ApiService *MeCalendarGroupApiService
	calendarGroupId string
	calendarId string
	microsoftGraphEvent *MicrosoftGraphEvent
}

// New navigation property
func (r ApiMeCalendarGroupsCalendarsCreateEventsRequest) MicrosoftGraphEvent(microsoftGraphEvent MicrosoftGraphEvent) ApiMeCalendarGroupsCalendarsCreateEventsRequest {
	r.microsoftGraphEvent = &microsoftGraphEvent
	return r
}

func (r ApiMeCalendarGroupsCalendarsCreateEventsRequest) Execute() (MicrosoftGraphEvent, *_nethttp.Response, error) {
	return r.ApiService.MeCalendarGroupsCalendarsCreateEventsExecute(r)
}

/*
MeCalendarGroupsCalendarsCreateEvents Create new navigation property to events for me

The events in the calendar. Navigation property. Read-only.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param calendarGroupId key: id of calendarGroup
 @param calendarId key: id of calendar
 @return ApiMeCalendarGroupsCalendarsCreateEventsRequest
*/
func (a *MeCalendarGroupApiService) MeCalendarGroupsCalendarsCreateEvents(ctx _context.Context, calendarGroupId string, calendarId string) ApiMeCalendarGroupsCalendarsCreateEventsRequest {
	return ApiMeCalendarGroupsCalendarsCreateEventsRequest{
		ApiService: a,
		ctx: ctx,
		calendarGroupId: calendarGroupId,
		calendarId: calendarId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphEvent
func (a *MeCalendarGroupApiService) MeCalendarGroupsCalendarsCreateEventsExecute(r ApiMeCalendarGroupsCalendarsCreateEventsRequest) (MicrosoftGraphEvent, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphEvent
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MeCalendarGroupApiService.MeCalendarGroupsCalendarsCreateEvents")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/calendarGroups/{calendarGroup-id}/calendars/{calendar-id}/events"
	localVarPath = strings.Replace(localVarPath, "{"+"calendarGroup-id"+"}", _neturl.PathEscape(parameterToString(r.calendarGroupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"calendar-id"+"}", _neturl.PathEscape(parameterToString(r.calendarId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphEvent == nil {
		return localVarReturnValue, nil, reportError("microsoftGraphEvent is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphEvent
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMeCalendarGroupsCalendarsCreateMultiValueExtendedPropertiesRequest struct {
	ctx _context.Context
	ApiService *MeCalendarGroupApiService
	calendarGroupId string
	calendarId string
	microsoftGraphMultiValueLegacyExtendedProperty *MicrosoftGraphMultiValueLegacyExtendedProperty
}

// New navigation property
func (r ApiMeCalendarGroupsCalendarsCreateMultiValueExtendedPropertiesRequest) MicrosoftGraphMultiValueLegacyExtendedProperty(microsoftGraphMultiValueLegacyExtendedProperty MicrosoftGraphMultiValueLegacyExtendedProperty) ApiMeCalendarGroupsCalendarsCreateMultiValueExtendedPropertiesRequest {
	r.microsoftGraphMultiValueLegacyExtendedProperty = &microsoftGraphMultiValueLegacyExtendedProperty
	return r
}

func (r ApiMeCalendarGroupsCalendarsCreateMultiValueExtendedPropertiesRequest) Execute() (MicrosoftGraphMultiValueLegacyExtendedProperty, *_nethttp.Response, error) {
	return r.ApiService.MeCalendarGroupsCalendarsCreateMultiValueExtendedPropertiesExecute(r)
}

/*
MeCalendarGroupsCalendarsCreateMultiValueExtendedProperties Create new navigation property to multiValueExtendedProperties for me

The collection of multi-value extended properties defined for the calendar. Read-only. Nullable.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param calendarGroupId key: id of calendarGroup
 @param calendarId key: id of calendar
 @return ApiMeCalendarGroupsCalendarsCreateMultiValueExtendedPropertiesRequest
*/
func (a *MeCalendarGroupApiService) MeCalendarGroupsCalendarsCreateMultiValueExtendedProperties(ctx _context.Context, calendarGroupId string, calendarId string) ApiMeCalendarGroupsCalendarsCreateMultiValueExtendedPropertiesRequest {
	return ApiMeCalendarGroupsCalendarsCreateMultiValueExtendedPropertiesRequest{
		ApiService: a,
		ctx: ctx,
		calendarGroupId: calendarGroupId,
		calendarId: calendarId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphMultiValueLegacyExtendedProperty
func (a *MeCalendarGroupApiService) MeCalendarGroupsCalendarsCreateMultiValueExtendedPropertiesExecute(r ApiMeCalendarGroupsCalendarsCreateMultiValueExtendedPropertiesRequest) (MicrosoftGraphMultiValueLegacyExtendedProperty, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphMultiValueLegacyExtendedProperty
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MeCalendarGroupApiService.MeCalendarGroupsCalendarsCreateMultiValueExtendedProperties")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/calendarGroups/{calendarGroup-id}/calendars/{calendar-id}/multiValueExtendedProperties"
	localVarPath = strings.Replace(localVarPath, "{"+"calendarGroup-id"+"}", _neturl.PathEscape(parameterToString(r.calendarGroupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"calendar-id"+"}", _neturl.PathEscape(parameterToString(r.calendarId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphMultiValueLegacyExtendedProperty == nil {
		return localVarReturnValue, nil, reportError("microsoftGraphMultiValueLegacyExtendedProperty is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphMultiValueLegacyExtendedProperty
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMeCalendarGroupsCalendarsCreateSingleValueExtendedPropertiesRequest struct {
	ctx _context.Context
	ApiService *MeCalendarGroupApiService
	calendarGroupId string
	calendarId string
	microsoftGraphSingleValueLegacyExtendedProperty *MicrosoftGraphSingleValueLegacyExtendedProperty
}

// New navigation property
func (r ApiMeCalendarGroupsCalendarsCreateSingleValueExtendedPropertiesRequest) MicrosoftGraphSingleValueLegacyExtendedProperty(microsoftGraphSingleValueLegacyExtendedProperty MicrosoftGraphSingleValueLegacyExtendedProperty) ApiMeCalendarGroupsCalendarsCreateSingleValueExtendedPropertiesRequest {
	r.microsoftGraphSingleValueLegacyExtendedProperty = &microsoftGraphSingleValueLegacyExtendedProperty
	return r
}

func (r ApiMeCalendarGroupsCalendarsCreateSingleValueExtendedPropertiesRequest) Execute() (MicrosoftGraphSingleValueLegacyExtendedProperty, *_nethttp.Response, error) {
	return r.ApiService.MeCalendarGroupsCalendarsCreateSingleValueExtendedPropertiesExecute(r)
}

/*
MeCalendarGroupsCalendarsCreateSingleValueExtendedProperties Create new navigation property to singleValueExtendedProperties for me

The collection of single-value extended properties defined for the calendar. Read-only. Nullable.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param calendarGroupId key: id of calendarGroup
 @param calendarId key: id of calendar
 @return ApiMeCalendarGroupsCalendarsCreateSingleValueExtendedPropertiesRequest
*/
func (a *MeCalendarGroupApiService) MeCalendarGroupsCalendarsCreateSingleValueExtendedProperties(ctx _context.Context, calendarGroupId string, calendarId string) ApiMeCalendarGroupsCalendarsCreateSingleValueExtendedPropertiesRequest {
	return ApiMeCalendarGroupsCalendarsCreateSingleValueExtendedPropertiesRequest{
		ApiService: a,
		ctx: ctx,
		calendarGroupId: calendarGroupId,
		calendarId: calendarId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphSingleValueLegacyExtendedProperty
func (a *MeCalendarGroupApiService) MeCalendarGroupsCalendarsCreateSingleValueExtendedPropertiesExecute(r ApiMeCalendarGroupsCalendarsCreateSingleValueExtendedPropertiesRequest) (MicrosoftGraphSingleValueLegacyExtendedProperty, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphSingleValueLegacyExtendedProperty
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MeCalendarGroupApiService.MeCalendarGroupsCalendarsCreateSingleValueExtendedProperties")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/calendarGroups/{calendarGroup-id}/calendars/{calendar-id}/singleValueExtendedProperties"
	localVarPath = strings.Replace(localVarPath, "{"+"calendarGroup-id"+"}", _neturl.PathEscape(parameterToString(r.calendarGroupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"calendar-id"+"}", _neturl.PathEscape(parameterToString(r.calendarId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphSingleValueLegacyExtendedProperty == nil {
		return localVarReturnValue, nil, reportError("microsoftGraphSingleValueLegacyExtendedProperty is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphSingleValueLegacyExtendedProperty
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMeCalendarGroupsCalendarsDeleteCalendarPermissionsRequest struct {
	ctx _context.Context
	ApiService *MeCalendarGroupApiService
	calendarGroupId string
	calendarId string
	calendarPermissionId string
	ifMatch *string
}

// ETag
func (r ApiMeCalendarGroupsCalendarsDeleteCalendarPermissionsRequest) IfMatch(ifMatch string) ApiMeCalendarGroupsCalendarsDeleteCalendarPermissionsRequest {
	r.ifMatch = &ifMatch
	return r
}

func (r ApiMeCalendarGroupsCalendarsDeleteCalendarPermissionsRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.MeCalendarGroupsCalendarsDeleteCalendarPermissionsExecute(r)
}

/*
MeCalendarGroupsCalendarsDeleteCalendarPermissions Delete navigation property calendarPermissions for me

The permissions of the users with whom the calendar is shared.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param calendarGroupId key: id of calendarGroup
 @param calendarId key: id of calendar
 @param calendarPermissionId key: id of calendarPermission
 @return ApiMeCalendarGroupsCalendarsDeleteCalendarPermissionsRequest
*/
func (a *MeCalendarGroupApiService) MeCalendarGroupsCalendarsDeleteCalendarPermissions(ctx _context.Context, calendarGroupId string, calendarId string, calendarPermissionId string) ApiMeCalendarGroupsCalendarsDeleteCalendarPermissionsRequest {
	return ApiMeCalendarGroupsCalendarsDeleteCalendarPermissionsRequest{
		ApiService: a,
		ctx: ctx,
		calendarGroupId: calendarGroupId,
		calendarId: calendarId,
		calendarPermissionId: calendarPermissionId,
	}
}

// Execute executes the request
func (a *MeCalendarGroupApiService) MeCalendarGroupsCalendarsDeleteCalendarPermissionsExecute(r ApiMeCalendarGroupsCalendarsDeleteCalendarPermissionsRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MeCalendarGroupApiService.MeCalendarGroupsCalendarsDeleteCalendarPermissions")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/calendarGroups/{calendarGroup-id}/calendars/{calendar-id}/calendarPermissions/{calendarPermission-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"calendarGroup-id"+"}", _neturl.PathEscape(parameterToString(r.calendarGroupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"calendar-id"+"}", _neturl.PathEscape(parameterToString(r.calendarId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"calendarPermission-id"+"}", _neturl.PathEscape(parameterToString(r.calendarPermissionId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ifMatch != nil {
		localVarHeaderParams["If-Match"] = parameterToString(*r.ifMatch, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiMeCalendarGroupsCalendarsDeleteCalendarViewRequest struct {
	ctx _context.Context
	ApiService *MeCalendarGroupApiService
	calendarGroupId string
	calendarId string
	eventId string
	ifMatch *string
}

// ETag
func (r ApiMeCalendarGroupsCalendarsDeleteCalendarViewRequest) IfMatch(ifMatch string) ApiMeCalendarGroupsCalendarsDeleteCalendarViewRequest {
	r.ifMatch = &ifMatch
	return r
}

func (r ApiMeCalendarGroupsCalendarsDeleteCalendarViewRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.MeCalendarGroupsCalendarsDeleteCalendarViewExecute(r)
}

/*
MeCalendarGroupsCalendarsDeleteCalendarView Delete navigation property calendarView for me

The calendar view for the calendar. Navigation property. Read-only.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param calendarGroupId key: id of calendarGroup
 @param calendarId key: id of calendar
 @param eventId key: id of event
 @return ApiMeCalendarGroupsCalendarsDeleteCalendarViewRequest
*/
func (a *MeCalendarGroupApiService) MeCalendarGroupsCalendarsDeleteCalendarView(ctx _context.Context, calendarGroupId string, calendarId string, eventId string) ApiMeCalendarGroupsCalendarsDeleteCalendarViewRequest {
	return ApiMeCalendarGroupsCalendarsDeleteCalendarViewRequest{
		ApiService: a,
		ctx: ctx,
		calendarGroupId: calendarGroupId,
		calendarId: calendarId,
		eventId: eventId,
	}
}

// Execute executes the request
func (a *MeCalendarGroupApiService) MeCalendarGroupsCalendarsDeleteCalendarViewExecute(r ApiMeCalendarGroupsCalendarsDeleteCalendarViewRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MeCalendarGroupApiService.MeCalendarGroupsCalendarsDeleteCalendarView")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/calendarGroups/{calendarGroup-id}/calendars/{calendar-id}/calendarView/{event-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"calendarGroup-id"+"}", _neturl.PathEscape(parameterToString(r.calendarGroupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"calendar-id"+"}", _neturl.PathEscape(parameterToString(r.calendarId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ifMatch != nil {
		localVarHeaderParams["If-Match"] = parameterToString(*r.ifMatch, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiMeCalendarGroupsCalendarsDeleteEventsRequest struct {
	ctx _context.Context
	ApiService *MeCalendarGroupApiService
	calendarGroupId string
	calendarId string
	eventId string
	ifMatch *string
}

// ETag
func (r ApiMeCalendarGroupsCalendarsDeleteEventsRequest) IfMatch(ifMatch string) ApiMeCalendarGroupsCalendarsDeleteEventsRequest {
	r.ifMatch = &ifMatch
	return r
}

func (r ApiMeCalendarGroupsCalendarsDeleteEventsRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.MeCalendarGroupsCalendarsDeleteEventsExecute(r)
}

/*
MeCalendarGroupsCalendarsDeleteEvents Delete navigation property events for me

The events in the calendar. Navigation property. Read-only.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param calendarGroupId key: id of calendarGroup
 @param calendarId key: id of calendar
 @param eventId key: id of event
 @return ApiMeCalendarGroupsCalendarsDeleteEventsRequest
*/
func (a *MeCalendarGroupApiService) MeCalendarGroupsCalendarsDeleteEvents(ctx _context.Context, calendarGroupId string, calendarId string, eventId string) ApiMeCalendarGroupsCalendarsDeleteEventsRequest {
	return ApiMeCalendarGroupsCalendarsDeleteEventsRequest{
		ApiService: a,
		ctx: ctx,
		calendarGroupId: calendarGroupId,
		calendarId: calendarId,
		eventId: eventId,
	}
}

// Execute executes the request
func (a *MeCalendarGroupApiService) MeCalendarGroupsCalendarsDeleteEventsExecute(r ApiMeCalendarGroupsCalendarsDeleteEventsRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MeCalendarGroupApiService.MeCalendarGroupsCalendarsDeleteEvents")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/calendarGroups/{calendarGroup-id}/calendars/{calendar-id}/events/{event-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"calendarGroup-id"+"}", _neturl.PathEscape(parameterToString(r.calendarGroupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"calendar-id"+"}", _neturl.PathEscape(parameterToString(r.calendarId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ifMatch != nil {
		localVarHeaderParams["If-Match"] = parameterToString(*r.ifMatch, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiMeCalendarGroupsCalendarsDeleteMultiValueExtendedPropertiesRequest struct {
	ctx _context.Context
	ApiService *MeCalendarGroupApiService
	calendarGroupId string
	calendarId string
	multiValueLegacyExtendedPropertyId string
	ifMatch *string
}

// ETag
func (r ApiMeCalendarGroupsCalendarsDeleteMultiValueExtendedPropertiesRequest) IfMatch(ifMatch string) ApiMeCalendarGroupsCalendarsDeleteMultiValueExtendedPropertiesRequest {
	r.ifMatch = &ifMatch
	return r
}

func (r ApiMeCalendarGroupsCalendarsDeleteMultiValueExtendedPropertiesRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.MeCalendarGroupsCalendarsDeleteMultiValueExtendedPropertiesExecute(r)
}

/*
MeCalendarGroupsCalendarsDeleteMultiValueExtendedProperties Delete navigation property multiValueExtendedProperties for me

The collection of multi-value extended properties defined for the calendar. Read-only. Nullable.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param calendarGroupId key: id of calendarGroup
 @param calendarId key: id of calendar
 @param multiValueLegacyExtendedPropertyId key: id of multiValueLegacyExtendedProperty
 @return ApiMeCalendarGroupsCalendarsDeleteMultiValueExtendedPropertiesRequest
*/
func (a *MeCalendarGroupApiService) MeCalendarGroupsCalendarsDeleteMultiValueExtendedProperties(ctx _context.Context, calendarGroupId string, calendarId string, multiValueLegacyExtendedPropertyId string) ApiMeCalendarGroupsCalendarsDeleteMultiValueExtendedPropertiesRequest {
	return ApiMeCalendarGroupsCalendarsDeleteMultiValueExtendedPropertiesRequest{
		ApiService: a,
		ctx: ctx,
		calendarGroupId: calendarGroupId,
		calendarId: calendarId,
		multiValueLegacyExtendedPropertyId: multiValueLegacyExtendedPropertyId,
	}
}

// Execute executes the request
func (a *MeCalendarGroupApiService) MeCalendarGroupsCalendarsDeleteMultiValueExtendedPropertiesExecute(r ApiMeCalendarGroupsCalendarsDeleteMultiValueExtendedPropertiesRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MeCalendarGroupApiService.MeCalendarGroupsCalendarsDeleteMultiValueExtendedProperties")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/calendarGroups/{calendarGroup-id}/calendars/{calendar-id}/multiValueExtendedProperties/{multiValueLegacyExtendedProperty-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"calendarGroup-id"+"}", _neturl.PathEscape(parameterToString(r.calendarGroupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"calendar-id"+"}", _neturl.PathEscape(parameterToString(r.calendarId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"multiValueLegacyExtendedProperty-id"+"}", _neturl.PathEscape(parameterToString(r.multiValueLegacyExtendedPropertyId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ifMatch != nil {
		localVarHeaderParams["If-Match"] = parameterToString(*r.ifMatch, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiMeCalendarGroupsCalendarsDeleteSingleValueExtendedPropertiesRequest struct {
	ctx _context.Context
	ApiService *MeCalendarGroupApiService
	calendarGroupId string
	calendarId string
	singleValueLegacyExtendedPropertyId string
	ifMatch *string
}

// ETag
func (r ApiMeCalendarGroupsCalendarsDeleteSingleValueExtendedPropertiesRequest) IfMatch(ifMatch string) ApiMeCalendarGroupsCalendarsDeleteSingleValueExtendedPropertiesRequest {
	r.ifMatch = &ifMatch
	return r
}

func (r ApiMeCalendarGroupsCalendarsDeleteSingleValueExtendedPropertiesRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.MeCalendarGroupsCalendarsDeleteSingleValueExtendedPropertiesExecute(r)
}

/*
MeCalendarGroupsCalendarsDeleteSingleValueExtendedProperties Delete navigation property singleValueExtendedProperties for me

The collection of single-value extended properties defined for the calendar. Read-only. Nullable.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param calendarGroupId key: id of calendarGroup
 @param calendarId key: id of calendar
 @param singleValueLegacyExtendedPropertyId key: id of singleValueLegacyExtendedProperty
 @return ApiMeCalendarGroupsCalendarsDeleteSingleValueExtendedPropertiesRequest
*/
func (a *MeCalendarGroupApiService) MeCalendarGroupsCalendarsDeleteSingleValueExtendedProperties(ctx _context.Context, calendarGroupId string, calendarId string, singleValueLegacyExtendedPropertyId string) ApiMeCalendarGroupsCalendarsDeleteSingleValueExtendedPropertiesRequest {
	return ApiMeCalendarGroupsCalendarsDeleteSingleValueExtendedPropertiesRequest{
		ApiService: a,
		ctx: ctx,
		calendarGroupId: calendarGroupId,
		calendarId: calendarId,
		singleValueLegacyExtendedPropertyId: singleValueLegacyExtendedPropertyId,
	}
}

// Execute executes the request
func (a *MeCalendarGroupApiService) MeCalendarGroupsCalendarsDeleteSingleValueExtendedPropertiesExecute(r ApiMeCalendarGroupsCalendarsDeleteSingleValueExtendedPropertiesRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MeCalendarGroupApiService.MeCalendarGroupsCalendarsDeleteSingleValueExtendedProperties")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/calendarGroups/{calendarGroup-id}/calendars/{calendar-id}/singleValueExtendedProperties/{singleValueLegacyExtendedProperty-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"calendarGroup-id"+"}", _neturl.PathEscape(parameterToString(r.calendarGroupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"calendar-id"+"}", _neturl.PathEscape(parameterToString(r.calendarId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"singleValueLegacyExtendedProperty-id"+"}", _neturl.PathEscape(parameterToString(r.singleValueLegacyExtendedPropertyId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ifMatch != nil {
		localVarHeaderParams["If-Match"] = parameterToString(*r.ifMatch, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiMeCalendarGroupsCalendarsEventsCreateAttachmentsRequest struct {
	ctx _context.Context
	ApiService *MeCalendarGroupApiService
	calendarGroupId string
	calendarId string
	eventId string
	microsoftGraphAttachment *MicrosoftGraphAttachment
}

// New navigation property
func (r ApiMeCalendarGroupsCalendarsEventsCreateAttachmentsRequest) MicrosoftGraphAttachment(microsoftGraphAttachment MicrosoftGraphAttachment) ApiMeCalendarGroupsCalendarsEventsCreateAttachmentsRequest {
	r.microsoftGraphAttachment = &microsoftGraphAttachment
	return r
}

func (r ApiMeCalendarGroupsCalendarsEventsCreateAttachmentsRequest) Execute() (MicrosoftGraphAttachment, *_nethttp.Response, error) {
	return r.ApiService.MeCalendarGroupsCalendarsEventsCreateAttachmentsExecute(r)
}

/*
MeCalendarGroupsCalendarsEventsCreateAttachments Create new navigation property to attachments for me

The collection of FileAttachment, ItemAttachment, and referenceAttachment attachments for the event. Navigation property. Read-only. Nullable.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param calendarGroupId key: id of calendarGroup
 @param calendarId key: id of calendar
 @param eventId key: id of event
 @return ApiMeCalendarGroupsCalendarsEventsCreateAttachmentsRequest
*/
func (a *MeCalendarGroupApiService) MeCalendarGroupsCalendarsEventsCreateAttachments(ctx _context.Context, calendarGroupId string, calendarId string, eventId string) ApiMeCalendarGroupsCalendarsEventsCreateAttachmentsRequest {
	return ApiMeCalendarGroupsCalendarsEventsCreateAttachmentsRequest{
		ApiService: a,
		ctx: ctx,
		calendarGroupId: calendarGroupId,
		calendarId: calendarId,
		eventId: eventId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphAttachment
func (a *MeCalendarGroupApiService) MeCalendarGroupsCalendarsEventsCreateAttachmentsExecute(r ApiMeCalendarGroupsCalendarsEventsCreateAttachmentsRequest) (MicrosoftGraphAttachment, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphAttachment
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MeCalendarGroupApiService.MeCalendarGroupsCalendarsEventsCreateAttachments")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/calendarGroups/{calendarGroup-id}/calendars/{calendar-id}/events/{event-id}/attachments"
	localVarPath = strings.Replace(localVarPath, "{"+"calendarGroup-id"+"}", _neturl.PathEscape(parameterToString(r.calendarGroupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"calendar-id"+"}", _neturl.PathEscape(parameterToString(r.calendarId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphAttachment == nil {
		return localVarReturnValue, nil, reportError("microsoftGraphAttachment is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphAttachment
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMeCalendarGroupsCalendarsEventsCreateExtensionsRequest struct {
	ctx _context.Context
	ApiService *MeCalendarGroupApiService
	calendarGroupId string
	calendarId string
	eventId string
	microsoftGraphExtension *MicrosoftGraphExtension
}

// New navigation property
func (r ApiMeCalendarGroupsCalendarsEventsCreateExtensionsRequest) MicrosoftGraphExtension(microsoftGraphExtension MicrosoftGraphExtension) ApiMeCalendarGroupsCalendarsEventsCreateExtensionsRequest {
	r.microsoftGraphExtension = &microsoftGraphExtension
	return r
}

func (r ApiMeCalendarGroupsCalendarsEventsCreateExtensionsRequest) Execute() (MicrosoftGraphExtension, *_nethttp.Response, error) {
	return r.ApiService.MeCalendarGroupsCalendarsEventsCreateExtensionsExecute(r)
}

/*
MeCalendarGroupsCalendarsEventsCreateExtensions Create new navigation property to extensions for me

The collection of open extensions defined for the event. Nullable.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param calendarGroupId key: id of calendarGroup
 @param calendarId key: id of calendar
 @param eventId key: id of event
 @return ApiMeCalendarGroupsCalendarsEventsCreateExtensionsRequest
*/
func (a *MeCalendarGroupApiService) MeCalendarGroupsCalendarsEventsCreateExtensions(ctx _context.Context, calendarGroupId string, calendarId string, eventId string) ApiMeCalendarGroupsCalendarsEventsCreateExtensionsRequest {
	return ApiMeCalendarGroupsCalendarsEventsCreateExtensionsRequest{
		ApiService: a,
		ctx: ctx,
		calendarGroupId: calendarGroupId,
		calendarId: calendarId,
		eventId: eventId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphExtension
func (a *MeCalendarGroupApiService) MeCalendarGroupsCalendarsEventsCreateExtensionsExecute(r ApiMeCalendarGroupsCalendarsEventsCreateExtensionsRequest) (MicrosoftGraphExtension, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphExtension
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MeCalendarGroupApiService.MeCalendarGroupsCalendarsEventsCreateExtensions")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/calendarGroups/{calendarGroup-id}/calendars/{calendar-id}/events/{event-id}/extensions"
	localVarPath = strings.Replace(localVarPath, "{"+"calendarGroup-id"+"}", _neturl.PathEscape(parameterToString(r.calendarGroupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"calendar-id"+"}", _neturl.PathEscape(parameterToString(r.calendarId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphExtension == nil {
		return localVarReturnValue, nil, reportError("microsoftGraphExtension is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphExtension
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMeCalendarGroupsCalendarsEventsCreateInstancesRequest struct {
	ctx _context.Context
	ApiService *MeCalendarGroupApiService
	calendarGroupId string
	calendarId string
	eventId string
	microsoftGraphEvent *MicrosoftGraphEvent
}

// New navigation property
func (r ApiMeCalendarGroupsCalendarsEventsCreateInstancesRequest) MicrosoftGraphEvent(microsoftGraphEvent MicrosoftGraphEvent) ApiMeCalendarGroupsCalendarsEventsCreateInstancesRequest {
	r.microsoftGraphEvent = &microsoftGraphEvent
	return r
}

func (r ApiMeCalendarGroupsCalendarsEventsCreateInstancesRequest) Execute() (MicrosoftGraphEvent, *_nethttp.Response, error) {
	return r.ApiService.MeCalendarGroupsCalendarsEventsCreateInstancesExecute(r)
}

/*
MeCalendarGroupsCalendarsEventsCreateInstances Create new navigation property to instances for me

The occurrences of a recurring series, if the event is a series master. This property includes occurrences that are part of the recurrence pattern, and exceptions that have been modified, but does not include occurrences that have been cancelled from the series. Navigation property. Read-only. Nullable.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param calendarGroupId key: id of calendarGroup
 @param calendarId key: id of calendar
 @param eventId key: id of event
 @return ApiMeCalendarGroupsCalendarsEventsCreateInstancesRequest
*/
func (a *MeCalendarGroupApiService) MeCalendarGroupsCalendarsEventsCreateInstances(ctx _context.Context, calendarGroupId string, calendarId string, eventId string) ApiMeCalendarGroupsCalendarsEventsCreateInstancesRequest {
	return ApiMeCalendarGroupsCalendarsEventsCreateInstancesRequest{
		ApiService: a,
		ctx: ctx,
		calendarGroupId: calendarGroupId,
		calendarId: calendarId,
		eventId: eventId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphEvent
func (a *MeCalendarGroupApiService) MeCalendarGroupsCalendarsEventsCreateInstancesExecute(r ApiMeCalendarGroupsCalendarsEventsCreateInstancesRequest) (MicrosoftGraphEvent, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphEvent
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MeCalendarGroupApiService.MeCalendarGroupsCalendarsEventsCreateInstances")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/calendarGroups/{calendarGroup-id}/calendars/{calendar-id}/events/{event-id}/instances"
	localVarPath = strings.Replace(localVarPath, "{"+"calendarGroup-id"+"}", _neturl.PathEscape(parameterToString(r.calendarGroupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"calendar-id"+"}", _neturl.PathEscape(parameterToString(r.calendarId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphEvent == nil {
		return localVarReturnValue, nil, reportError("microsoftGraphEvent is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphEvent
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMeCalendarGroupsCalendarsEventsCreateMultiValueExtendedPropertiesRequest struct {
	ctx _context.Context
	ApiService *MeCalendarGroupApiService
	calendarGroupId string
	calendarId string
	eventId string
	microsoftGraphMultiValueLegacyExtendedProperty *MicrosoftGraphMultiValueLegacyExtendedProperty
}

// New navigation property
func (r ApiMeCalendarGroupsCalendarsEventsCreateMultiValueExtendedPropertiesRequest) MicrosoftGraphMultiValueLegacyExtendedProperty(microsoftGraphMultiValueLegacyExtendedProperty MicrosoftGraphMultiValueLegacyExtendedProperty) ApiMeCalendarGroupsCalendarsEventsCreateMultiValueExtendedPropertiesRequest {
	r.microsoftGraphMultiValueLegacyExtendedProperty = &microsoftGraphMultiValueLegacyExtendedProperty
	return r
}

func (r ApiMeCalendarGroupsCalendarsEventsCreateMultiValueExtendedPropertiesRequest) Execute() (MicrosoftGraphMultiValueLegacyExtendedProperty, *_nethttp.Response, error) {
	return r.ApiService.MeCalendarGroupsCalendarsEventsCreateMultiValueExtendedPropertiesExecute(r)
}

/*
MeCalendarGroupsCalendarsEventsCreateMultiValueExtendedProperties Create new navigation property to multiValueExtendedProperties for me

The collection of multi-value extended properties defined for the event. Read-only. Nullable.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param calendarGroupId key: id of calendarGroup
 @param calendarId key: id of calendar
 @param eventId key: id of event
 @return ApiMeCalendarGroupsCalendarsEventsCreateMultiValueExtendedPropertiesRequest
*/
func (a *MeCalendarGroupApiService) MeCalendarGroupsCalendarsEventsCreateMultiValueExtendedProperties(ctx _context.Context, calendarGroupId string, calendarId string, eventId string) ApiMeCalendarGroupsCalendarsEventsCreateMultiValueExtendedPropertiesRequest {
	return ApiMeCalendarGroupsCalendarsEventsCreateMultiValueExtendedPropertiesRequest{
		ApiService: a,
		ctx: ctx,
		calendarGroupId: calendarGroupId,
		calendarId: calendarId,
		eventId: eventId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphMultiValueLegacyExtendedProperty
func (a *MeCalendarGroupApiService) MeCalendarGroupsCalendarsEventsCreateMultiValueExtendedPropertiesExecute(r ApiMeCalendarGroupsCalendarsEventsCreateMultiValueExtendedPropertiesRequest) (MicrosoftGraphMultiValueLegacyExtendedProperty, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphMultiValueLegacyExtendedProperty
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MeCalendarGroupApiService.MeCalendarGroupsCalendarsEventsCreateMultiValueExtendedProperties")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/calendarGroups/{calendarGroup-id}/calendars/{calendar-id}/events/{event-id}/multiValueExtendedProperties"
	localVarPath = strings.Replace(localVarPath, "{"+"calendarGroup-id"+"}", _neturl.PathEscape(parameterToString(r.calendarGroupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"calendar-id"+"}", _neturl.PathEscape(parameterToString(r.calendarId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphMultiValueLegacyExtendedProperty == nil {
		return localVarReturnValue, nil, reportError("microsoftGraphMultiValueLegacyExtendedProperty is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphMultiValueLegacyExtendedProperty
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMeCalendarGroupsCalendarsEventsCreateSingleValueExtendedPropertiesRequest struct {
	ctx _context.Context
	ApiService *MeCalendarGroupApiService
	calendarGroupId string
	calendarId string
	eventId string
	microsoftGraphSingleValueLegacyExtendedProperty *MicrosoftGraphSingleValueLegacyExtendedProperty
}

// New navigation property
func (r ApiMeCalendarGroupsCalendarsEventsCreateSingleValueExtendedPropertiesRequest) MicrosoftGraphSingleValueLegacyExtendedProperty(microsoftGraphSingleValueLegacyExtendedProperty MicrosoftGraphSingleValueLegacyExtendedProperty) ApiMeCalendarGroupsCalendarsEventsCreateSingleValueExtendedPropertiesRequest {
	r.microsoftGraphSingleValueLegacyExtendedProperty = &microsoftGraphSingleValueLegacyExtendedProperty
	return r
}

func (r ApiMeCalendarGroupsCalendarsEventsCreateSingleValueExtendedPropertiesRequest) Execute() (MicrosoftGraphSingleValueLegacyExtendedProperty, *_nethttp.Response, error) {
	return r.ApiService.MeCalendarGroupsCalendarsEventsCreateSingleValueExtendedPropertiesExecute(r)
}

/*
MeCalendarGroupsCalendarsEventsCreateSingleValueExtendedProperties Create new navigation property to singleValueExtendedProperties for me

The collection of single-value extended properties defined for the event. Read-only. Nullable.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param calendarGroupId key: id of calendarGroup
 @param calendarId key: id of calendar
 @param eventId key: id of event
 @return ApiMeCalendarGroupsCalendarsEventsCreateSingleValueExtendedPropertiesRequest
*/
func (a *MeCalendarGroupApiService) MeCalendarGroupsCalendarsEventsCreateSingleValueExtendedProperties(ctx _context.Context, calendarGroupId string, calendarId string, eventId string) ApiMeCalendarGroupsCalendarsEventsCreateSingleValueExtendedPropertiesRequest {
	return ApiMeCalendarGroupsCalendarsEventsCreateSingleValueExtendedPropertiesRequest{
		ApiService: a,
		ctx: ctx,
		calendarGroupId: calendarGroupId,
		calendarId: calendarId,
		eventId: eventId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphSingleValueLegacyExtendedProperty
func (a *MeCalendarGroupApiService) MeCalendarGroupsCalendarsEventsCreateSingleValueExtendedPropertiesExecute(r ApiMeCalendarGroupsCalendarsEventsCreateSingleValueExtendedPropertiesRequest) (MicrosoftGraphSingleValueLegacyExtendedProperty, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphSingleValueLegacyExtendedProperty
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MeCalendarGroupApiService.MeCalendarGroupsCalendarsEventsCreateSingleValueExtendedProperties")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/calendarGroups/{calendarGroup-id}/calendars/{calendar-id}/events/{event-id}/singleValueExtendedProperties"
	localVarPath = strings.Replace(localVarPath, "{"+"calendarGroup-id"+"}", _neturl.PathEscape(parameterToString(r.calendarGroupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"calendar-id"+"}", _neturl.PathEscape(parameterToString(r.calendarId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphSingleValueLegacyExtendedProperty == nil {
		return localVarReturnValue, nil, reportError("microsoftGraphSingleValueLegacyExtendedProperty is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphSingleValueLegacyExtendedProperty
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMeCalendarGroupsCalendarsEventsDeleteAttachmentsRequest struct {
	ctx _context.Context
	ApiService *MeCalendarGroupApiService
	calendarGroupId string
	calendarId string
	eventId string
	attachmentId string
	ifMatch *string
}

// ETag
func (r ApiMeCalendarGroupsCalendarsEventsDeleteAttachmentsRequest) IfMatch(ifMatch string) ApiMeCalendarGroupsCalendarsEventsDeleteAttachmentsRequest {
	r.ifMatch = &ifMatch
	return r
}

func (r ApiMeCalendarGroupsCalendarsEventsDeleteAttachmentsRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.MeCalendarGroupsCalendarsEventsDeleteAttachmentsExecute(r)
}

/*
MeCalendarGroupsCalendarsEventsDeleteAttachments Delete navigation property attachments for me

The collection of FileAttachment, ItemAttachment, and referenceAttachment attachments for the event. Navigation property. Read-only. Nullable.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param calendarGroupId key: id of calendarGroup
 @param calendarId key: id of calendar
 @param eventId key: id of event
 @param attachmentId key: id of attachment
 @return ApiMeCalendarGroupsCalendarsEventsDeleteAttachmentsRequest
*/
func (a *MeCalendarGroupApiService) MeCalendarGroupsCalendarsEventsDeleteAttachments(ctx _context.Context, calendarGroupId string, calendarId string, eventId string, attachmentId string) ApiMeCalendarGroupsCalendarsEventsDeleteAttachmentsRequest {
	return ApiMeCalendarGroupsCalendarsEventsDeleteAttachmentsRequest{
		ApiService: a,
		ctx: ctx,
		calendarGroupId: calendarGroupId,
		calendarId: calendarId,
		eventId: eventId,
		attachmentId: attachmentId,
	}
}

// Execute executes the request
func (a *MeCalendarGroupApiService) MeCalendarGroupsCalendarsEventsDeleteAttachmentsExecute(r ApiMeCalendarGroupsCalendarsEventsDeleteAttachmentsRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MeCalendarGroupApiService.MeCalendarGroupsCalendarsEventsDeleteAttachments")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/calendarGroups/{calendarGroup-id}/calendars/{calendar-id}/events/{event-id}/attachments/{attachment-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"calendarGroup-id"+"}", _neturl.PathEscape(parameterToString(r.calendarGroupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"calendar-id"+"}", _neturl.PathEscape(parameterToString(r.calendarId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"attachment-id"+"}", _neturl.PathEscape(parameterToString(r.attachmentId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ifMatch != nil {
		localVarHeaderParams["If-Match"] = parameterToString(*r.ifMatch, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiMeCalendarGroupsCalendarsEventsDeleteCalendarRequest struct {
	ctx _context.Context
	ApiService *MeCalendarGroupApiService
	calendarGroupId string
	calendarId string
	eventId string
	ifMatch *string
}

// ETag
func (r ApiMeCalendarGroupsCalendarsEventsDeleteCalendarRequest) IfMatch(ifMatch string) ApiMeCalendarGroupsCalendarsEventsDeleteCalendarRequest {
	r.ifMatch = &ifMatch
	return r
}

func (r ApiMeCalendarGroupsCalendarsEventsDeleteCalendarRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.MeCalendarGroupsCalendarsEventsDeleteCalendarExecute(r)
}

/*
MeCalendarGroupsCalendarsEventsDeleteCalendar Delete navigation property calendar for me

The calendar that contains the event. Navigation property. Read-only.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param calendarGroupId key: id of calendarGroup
 @param calendarId key: id of calendar
 @param eventId key: id of event
 @return ApiMeCalendarGroupsCalendarsEventsDeleteCalendarRequest
*/
func (a *MeCalendarGroupApiService) MeCalendarGroupsCalendarsEventsDeleteCalendar(ctx _context.Context, calendarGroupId string, calendarId string, eventId string) ApiMeCalendarGroupsCalendarsEventsDeleteCalendarRequest {
	return ApiMeCalendarGroupsCalendarsEventsDeleteCalendarRequest{
		ApiService: a,
		ctx: ctx,
		calendarGroupId: calendarGroupId,
		calendarId: calendarId,
		eventId: eventId,
	}
}

// Execute executes the request
func (a *MeCalendarGroupApiService) MeCalendarGroupsCalendarsEventsDeleteCalendarExecute(r ApiMeCalendarGroupsCalendarsEventsDeleteCalendarRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MeCalendarGroupApiService.MeCalendarGroupsCalendarsEventsDeleteCalendar")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/calendarGroups/{calendarGroup-id}/calendars/{calendar-id}/events/{event-id}/calendar"
	localVarPath = strings.Replace(localVarPath, "{"+"calendarGroup-id"+"}", _neturl.PathEscape(parameterToString(r.calendarGroupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"calendar-id"+"}", _neturl.PathEscape(parameterToString(r.calendarId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ifMatch != nil {
		localVarHeaderParams["If-Match"] = parameterToString(*r.ifMatch, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiMeCalendarGroupsCalendarsEventsDeleteExtensionsRequest struct {
	ctx _context.Context
	ApiService *MeCalendarGroupApiService
	calendarGroupId string
	calendarId string
	eventId string
	extensionId string
	ifMatch *string
}

// ETag
func (r ApiMeCalendarGroupsCalendarsEventsDeleteExtensionsRequest) IfMatch(ifMatch string) ApiMeCalendarGroupsCalendarsEventsDeleteExtensionsRequest {
	r.ifMatch = &ifMatch
	return r
}

func (r ApiMeCalendarGroupsCalendarsEventsDeleteExtensionsRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.MeCalendarGroupsCalendarsEventsDeleteExtensionsExecute(r)
}

/*
MeCalendarGroupsCalendarsEventsDeleteExtensions Delete navigation property extensions for me

The collection of open extensions defined for the event. Nullable.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param calendarGroupId key: id of calendarGroup
 @param calendarId key: id of calendar
 @param eventId key: id of event
 @param extensionId key: id of extension
 @return ApiMeCalendarGroupsCalendarsEventsDeleteExtensionsRequest
*/
func (a *MeCalendarGroupApiService) MeCalendarGroupsCalendarsEventsDeleteExtensions(ctx _context.Context, calendarGroupId string, calendarId string, eventId string, extensionId string) ApiMeCalendarGroupsCalendarsEventsDeleteExtensionsRequest {
	return ApiMeCalendarGroupsCalendarsEventsDeleteExtensionsRequest{
		ApiService: a,
		ctx: ctx,
		calendarGroupId: calendarGroupId,
		calendarId: calendarId,
		eventId: eventId,
		extensionId: extensionId,
	}
}

// Execute executes the request
func (a *MeCalendarGroupApiService) MeCalendarGroupsCalendarsEventsDeleteExtensionsExecute(r ApiMeCalendarGroupsCalendarsEventsDeleteExtensionsRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MeCalendarGroupApiService.MeCalendarGroupsCalendarsEventsDeleteExtensions")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/calendarGroups/{calendarGroup-id}/calendars/{calendar-id}/events/{event-id}/extensions/{extension-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"calendarGroup-id"+"}", _neturl.PathEscape(parameterToString(r.calendarGroupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"calendar-id"+"}", _neturl.PathEscape(parameterToString(r.calendarId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"extension-id"+"}", _neturl.PathEscape(parameterToString(r.extensionId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ifMatch != nil {
		localVarHeaderParams["If-Match"] = parameterToString(*r.ifMatch, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiMeCalendarGroupsCalendarsEventsDeleteInstancesRequest struct {
	ctx _context.Context
	ApiService *MeCalendarGroupApiService
	calendarGroupId string
	calendarId string
	eventId string
	eventId1 string
	ifMatch *string
}

// ETag
func (r ApiMeCalendarGroupsCalendarsEventsDeleteInstancesRequest) IfMatch(ifMatch string) ApiMeCalendarGroupsCalendarsEventsDeleteInstancesRequest {
	r.ifMatch = &ifMatch
	return r
}

func (r ApiMeCalendarGroupsCalendarsEventsDeleteInstancesRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.MeCalendarGroupsCalendarsEventsDeleteInstancesExecute(r)
}

/*
MeCalendarGroupsCalendarsEventsDeleteInstances Delete navigation property instances for me

The occurrences of a recurring series, if the event is a series master. This property includes occurrences that are part of the recurrence pattern, and exceptions that have been modified, but does not include occurrences that have been cancelled from the series. Navigation property. Read-only. Nullable.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param calendarGroupId key: id of calendarGroup
 @param calendarId key: id of calendar
 @param eventId key: id of event
 @param eventId1 key: id of event
 @return ApiMeCalendarGroupsCalendarsEventsDeleteInstancesRequest
*/
func (a *MeCalendarGroupApiService) MeCalendarGroupsCalendarsEventsDeleteInstances(ctx _context.Context, calendarGroupId string, calendarId string, eventId string, eventId1 string) ApiMeCalendarGroupsCalendarsEventsDeleteInstancesRequest {
	return ApiMeCalendarGroupsCalendarsEventsDeleteInstancesRequest{
		ApiService: a,
		ctx: ctx,
		calendarGroupId: calendarGroupId,
		calendarId: calendarId,
		eventId: eventId,
		eventId1: eventId1,
	}
}

// Execute executes the request
func (a *MeCalendarGroupApiService) MeCalendarGroupsCalendarsEventsDeleteInstancesExecute(r ApiMeCalendarGroupsCalendarsEventsDeleteInstancesRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MeCalendarGroupApiService.MeCalendarGroupsCalendarsEventsDeleteInstances")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/calendarGroups/{calendarGroup-id}/calendars/{calendar-id}/events/{event-id}/instances/{event-id1}"
	localVarPath = strings.Replace(localVarPath, "{"+"calendarGroup-id"+"}", _neturl.PathEscape(parameterToString(r.calendarGroupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"calendar-id"+"}", _neturl.PathEscape(parameterToString(r.calendarId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id1"+"}", _neturl.PathEscape(parameterToString(r.eventId1, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ifMatch != nil {
		localVarHeaderParams["If-Match"] = parameterToString(*r.ifMatch, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiMeCalendarGroupsCalendarsEventsDeleteMultiValueExtendedPropertiesRequest struct {
	ctx _context.Context
	ApiService *MeCalendarGroupApiService
	calendarGroupId string
	calendarId string
	eventId string
	multiValueLegacyExtendedPropertyId string
	ifMatch *string
}

// ETag
func (r ApiMeCalendarGroupsCalendarsEventsDeleteMultiValueExtendedPropertiesRequest) IfMatch(ifMatch string) ApiMeCalendarGroupsCalendarsEventsDeleteMultiValueExtendedPropertiesRequest {
	r.ifMatch = &ifMatch
	return r
}

func (r ApiMeCalendarGroupsCalendarsEventsDeleteMultiValueExtendedPropertiesRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.MeCalendarGroupsCalendarsEventsDeleteMultiValueExtendedPropertiesExecute(r)
}

/*
MeCalendarGroupsCalendarsEventsDeleteMultiValueExtendedProperties Delete navigation property multiValueExtendedProperties for me

The collection of multi-value extended properties defined for the event. Read-only. Nullable.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param calendarGroupId key: id of calendarGroup
 @param calendarId key: id of calendar
 @param eventId key: id of event
 @param multiValueLegacyExtendedPropertyId key: id of multiValueLegacyExtendedProperty
 @return ApiMeCalendarGroupsCalendarsEventsDeleteMultiValueExtendedPropertiesRequest
*/
func (a *MeCalendarGroupApiService) MeCalendarGroupsCalendarsEventsDeleteMultiValueExtendedProperties(ctx _context.Context, calendarGroupId string, calendarId string, eventId string, multiValueLegacyExtendedPropertyId string) ApiMeCalendarGroupsCalendarsEventsDeleteMultiValueExtendedPropertiesRequest {
	return ApiMeCalendarGroupsCalendarsEventsDeleteMultiValueExtendedPropertiesRequest{
		ApiService: a,
		ctx: ctx,
		calendarGroupId: calendarGroupId,
		calendarId: calendarId,
		eventId: eventId,
		multiValueLegacyExtendedPropertyId: multiValueLegacyExtendedPropertyId,
	}
}

// Execute executes the request
func (a *MeCalendarGroupApiService) MeCalendarGroupsCalendarsEventsDeleteMultiValueExtendedPropertiesExecute(r ApiMeCalendarGroupsCalendarsEventsDeleteMultiValueExtendedPropertiesRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MeCalendarGroupApiService.MeCalendarGroupsCalendarsEventsDeleteMultiValueExtendedProperties")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/calendarGroups/{calendarGroup-id}/calendars/{calendar-id}/events/{event-id}/multiValueExtendedProperties/{multiValueLegacyExtendedProperty-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"calendarGroup-id"+"}", _neturl.PathEscape(parameterToString(r.calendarGroupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"calendar-id"+"}", _neturl.PathEscape(parameterToString(r.calendarId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"multiValueLegacyExtendedProperty-id"+"}", _neturl.PathEscape(parameterToString(r.multiValueLegacyExtendedPropertyId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ifMatch != nil {
		localVarHeaderParams["If-Match"] = parameterToString(*r.ifMatch, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiMeCalendarGroupsCalendarsEventsDeleteSingleValueExtendedPropertiesRequest struct {
	ctx _context.Context
	ApiService *MeCalendarGroupApiService
	calendarGroupId string
	calendarId string
	eventId string
	singleValueLegacyExtendedPropertyId string
	ifMatch *string
}

// ETag
func (r ApiMeCalendarGroupsCalendarsEventsDeleteSingleValueExtendedPropertiesRequest) IfMatch(ifMatch string) ApiMeCalendarGroupsCalendarsEventsDeleteSingleValueExtendedPropertiesRequest {
	r.ifMatch = &ifMatch
	return r
}

func (r ApiMeCalendarGroupsCalendarsEventsDeleteSingleValueExtendedPropertiesRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.MeCalendarGroupsCalendarsEventsDeleteSingleValueExtendedPropertiesExecute(r)
}

/*
MeCalendarGroupsCalendarsEventsDeleteSingleValueExtendedProperties Delete navigation property singleValueExtendedProperties for me

The collection of single-value extended properties defined for the event. Read-only. Nullable.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param calendarGroupId key: id of calendarGroup
 @param calendarId key: id of calendar
 @param eventId key: id of event
 @param singleValueLegacyExtendedPropertyId key: id of singleValueLegacyExtendedProperty
 @return ApiMeCalendarGroupsCalendarsEventsDeleteSingleValueExtendedPropertiesRequest
*/
func (a *MeCalendarGroupApiService) MeCalendarGroupsCalendarsEventsDeleteSingleValueExtendedProperties(ctx _context.Context, calendarGroupId string, calendarId string, eventId string, singleValueLegacyExtendedPropertyId string) ApiMeCalendarGroupsCalendarsEventsDeleteSingleValueExtendedPropertiesRequest {
	return ApiMeCalendarGroupsCalendarsEventsDeleteSingleValueExtendedPropertiesRequest{
		ApiService: a,
		ctx: ctx,
		calendarGroupId: calendarGroupId,
		calendarId: calendarId,
		eventId: eventId,
		singleValueLegacyExtendedPropertyId: singleValueLegacyExtendedPropertyId,
	}
}

// Execute executes the request
func (a *MeCalendarGroupApiService) MeCalendarGroupsCalendarsEventsDeleteSingleValueExtendedPropertiesExecute(r ApiMeCalendarGroupsCalendarsEventsDeleteSingleValueExtendedPropertiesRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MeCalendarGroupApiService.MeCalendarGroupsCalendarsEventsDeleteSingleValueExtendedProperties")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/calendarGroups/{calendarGroup-id}/calendars/{calendar-id}/events/{event-id}/singleValueExtendedProperties/{singleValueLegacyExtendedProperty-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"calendarGroup-id"+"}", _neturl.PathEscape(parameterToString(r.calendarGroupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"calendar-id"+"}", _neturl.PathEscape(parameterToString(r.calendarId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"singleValueLegacyExtendedProperty-id"+"}", _neturl.PathEscape(parameterToString(r.singleValueLegacyExtendedPropertyId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ifMatch != nil {
		localVarHeaderParams["If-Match"] = parameterToString(*r.ifMatch, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiMeCalendarGroupsCalendarsEventsGetAttachmentsRequest struct {
	ctx _context.Context
	ApiService *MeCalendarGroupApiService
	calendarGroupId string
	calendarId string
	eventId string
	attachmentId string
	select_ *[]string
	expand *[]string
}

// Select properties to be returned
func (r ApiMeCalendarGroupsCalendarsEventsGetAttachmentsRequest) Select_(select_ []string) ApiMeCalendarGroupsCalendarsEventsGetAttachmentsRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiMeCalendarGroupsCalendarsEventsGetAttachmentsRequest) Expand(expand []string) ApiMeCalendarGroupsCalendarsEventsGetAttachmentsRequest {
	r.expand = &expand
	return r
}

func (r ApiMeCalendarGroupsCalendarsEventsGetAttachmentsRequest) Execute() (MicrosoftGraphAttachment, *_nethttp.Response, error) {
	return r.ApiService.MeCalendarGroupsCalendarsEventsGetAttachmentsExecute(r)
}

/*
MeCalendarGroupsCalendarsEventsGetAttachments Get attachments from me

The collection of FileAttachment, ItemAttachment, and referenceAttachment attachments for the event. Navigation property. Read-only. Nullable.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param calendarGroupId key: id of calendarGroup
 @param calendarId key: id of calendar
 @param eventId key: id of event
 @param attachmentId key: id of attachment
 @return ApiMeCalendarGroupsCalendarsEventsGetAttachmentsRequest
*/
func (a *MeCalendarGroupApiService) MeCalendarGroupsCalendarsEventsGetAttachments(ctx _context.Context, calendarGroupId string, calendarId string, eventId string, attachmentId string) ApiMeCalendarGroupsCalendarsEventsGetAttachmentsRequest {
	return ApiMeCalendarGroupsCalendarsEventsGetAttachmentsRequest{
		ApiService: a,
		ctx: ctx,
		calendarGroupId: calendarGroupId,
		calendarId: calendarId,
		eventId: eventId,
		attachmentId: attachmentId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphAttachment
func (a *MeCalendarGroupApiService) MeCalendarGroupsCalendarsEventsGetAttachmentsExecute(r ApiMeCalendarGroupsCalendarsEventsGetAttachmentsRequest) (MicrosoftGraphAttachment, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphAttachment
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MeCalendarGroupApiService.MeCalendarGroupsCalendarsEventsGetAttachments")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/calendarGroups/{calendarGroup-id}/calendars/{calendar-id}/events/{event-id}/attachments/{attachment-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"calendarGroup-id"+"}", _neturl.PathEscape(parameterToString(r.calendarGroupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"calendar-id"+"}", _neturl.PathEscape(parameterToString(r.calendarId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"attachment-id"+"}", _neturl.PathEscape(parameterToString(r.attachmentId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMeCalendarGroupsCalendarsEventsGetCalendarRequest struct {
	ctx _context.Context
	ApiService *MeCalendarGroupApiService
	calendarGroupId string
	calendarId string
	eventId string
	select_ *[]string
}

// Select properties to be returned
func (r ApiMeCalendarGroupsCalendarsEventsGetCalendarRequest) Select_(select_ []string) ApiMeCalendarGroupsCalendarsEventsGetCalendarRequest {
	r.select_ = &select_
	return r
}

func (r ApiMeCalendarGroupsCalendarsEventsGetCalendarRequest) Execute() (MicrosoftGraphCalendar, *_nethttp.Response, error) {
	return r.ApiService.MeCalendarGroupsCalendarsEventsGetCalendarExecute(r)
}

/*
MeCalendarGroupsCalendarsEventsGetCalendar Get calendar from me

The calendar that contains the event. Navigation property. Read-only.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param calendarGroupId key: id of calendarGroup
 @param calendarId key: id of calendar
 @param eventId key: id of event
 @return ApiMeCalendarGroupsCalendarsEventsGetCalendarRequest
*/
func (a *MeCalendarGroupApiService) MeCalendarGroupsCalendarsEventsGetCalendar(ctx _context.Context, calendarGroupId string, calendarId string, eventId string) ApiMeCalendarGroupsCalendarsEventsGetCalendarRequest {
	return ApiMeCalendarGroupsCalendarsEventsGetCalendarRequest{
		ApiService: a,
		ctx: ctx,
		calendarGroupId: calendarGroupId,
		calendarId: calendarId,
		eventId: eventId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphCalendar
func (a *MeCalendarGroupApiService) MeCalendarGroupsCalendarsEventsGetCalendarExecute(r ApiMeCalendarGroupsCalendarsEventsGetCalendarRequest) (MicrosoftGraphCalendar, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphCalendar
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MeCalendarGroupApiService.MeCalendarGroupsCalendarsEventsGetCalendar")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/calendarGroups/{calendarGroup-id}/calendars/{calendar-id}/events/{event-id}/calendar"
	localVarPath = strings.Replace(localVarPath, "{"+"calendarGroup-id"+"}", _neturl.PathEscape(parameterToString(r.calendarGroupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"calendar-id"+"}", _neturl.PathEscape(parameterToString(r.calendarId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMeCalendarGroupsCalendarsEventsGetExtensionsRequest struct {
	ctx _context.Context
	ApiService *MeCalendarGroupApiService
	calendarGroupId string
	calendarId string
	eventId string
	extensionId string
	select_ *[]string
	expand *[]string
}

// Select properties to be returned
func (r ApiMeCalendarGroupsCalendarsEventsGetExtensionsRequest) Select_(select_ []string) ApiMeCalendarGroupsCalendarsEventsGetExtensionsRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiMeCalendarGroupsCalendarsEventsGetExtensionsRequest) Expand(expand []string) ApiMeCalendarGroupsCalendarsEventsGetExtensionsRequest {
	r.expand = &expand
	return r
}

func (r ApiMeCalendarGroupsCalendarsEventsGetExtensionsRequest) Execute() (MicrosoftGraphExtension, *_nethttp.Response, error) {
	return r.ApiService.MeCalendarGroupsCalendarsEventsGetExtensionsExecute(r)
}

/*
MeCalendarGroupsCalendarsEventsGetExtensions Get extensions from me

The collection of open extensions defined for the event. Nullable.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param calendarGroupId key: id of calendarGroup
 @param calendarId key: id of calendar
 @param eventId key: id of event
 @param extensionId key: id of extension
 @return ApiMeCalendarGroupsCalendarsEventsGetExtensionsRequest
*/
func (a *MeCalendarGroupApiService) MeCalendarGroupsCalendarsEventsGetExtensions(ctx _context.Context, calendarGroupId string, calendarId string, eventId string, extensionId string) ApiMeCalendarGroupsCalendarsEventsGetExtensionsRequest {
	return ApiMeCalendarGroupsCalendarsEventsGetExtensionsRequest{
		ApiService: a,
		ctx: ctx,
		calendarGroupId: calendarGroupId,
		calendarId: calendarId,
		eventId: eventId,
		extensionId: extensionId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphExtension
func (a *MeCalendarGroupApiService) MeCalendarGroupsCalendarsEventsGetExtensionsExecute(r ApiMeCalendarGroupsCalendarsEventsGetExtensionsRequest) (MicrosoftGraphExtension, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphExtension
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MeCalendarGroupApiService.MeCalendarGroupsCalendarsEventsGetExtensions")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/calendarGroups/{calendarGroup-id}/calendars/{calendar-id}/events/{event-id}/extensions/{extension-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"calendarGroup-id"+"}", _neturl.PathEscape(parameterToString(r.calendarGroupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"calendar-id"+"}", _neturl.PathEscape(parameterToString(r.calendarId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"extension-id"+"}", _neturl.PathEscape(parameterToString(r.extensionId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMeCalendarGroupsCalendarsEventsGetInstancesRequest struct {
	ctx _context.Context
	ApiService *MeCalendarGroupApiService
	calendarGroupId string
	calendarId string
	eventId string
	eventId1 string
	select_ *[]string
}

// Select properties to be returned
func (r ApiMeCalendarGroupsCalendarsEventsGetInstancesRequest) Select_(select_ []string) ApiMeCalendarGroupsCalendarsEventsGetInstancesRequest {
	r.select_ = &select_
	return r
}

func (r ApiMeCalendarGroupsCalendarsEventsGetInstancesRequest) Execute() (MicrosoftGraphEvent, *_nethttp.Response, error) {
	return r.ApiService.MeCalendarGroupsCalendarsEventsGetInstancesExecute(r)
}

/*
MeCalendarGroupsCalendarsEventsGetInstances Get instances from me

The occurrences of a recurring series, if the event is a series master. This property includes occurrences that are part of the recurrence pattern, and exceptions that have been modified, but does not include occurrences that have been cancelled from the series. Navigation property. Read-only. Nullable.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param calendarGroupId key: id of calendarGroup
 @param calendarId key: id of calendar
 @param eventId key: id of event
 @param eventId1 key: id of event
 @return ApiMeCalendarGroupsCalendarsEventsGetInstancesRequest
*/
func (a *MeCalendarGroupApiService) MeCalendarGroupsCalendarsEventsGetInstances(ctx _context.Context, calendarGroupId string, calendarId string, eventId string, eventId1 string) ApiMeCalendarGroupsCalendarsEventsGetInstancesRequest {
	return ApiMeCalendarGroupsCalendarsEventsGetInstancesRequest{
		ApiService: a,
		ctx: ctx,
		calendarGroupId: calendarGroupId,
		calendarId: calendarId,
		eventId: eventId,
		eventId1: eventId1,
	}
}

// Execute executes the request
//  @return MicrosoftGraphEvent
func (a *MeCalendarGroupApiService) MeCalendarGroupsCalendarsEventsGetInstancesExecute(r ApiMeCalendarGroupsCalendarsEventsGetInstancesRequest) (MicrosoftGraphEvent, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphEvent
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MeCalendarGroupApiService.MeCalendarGroupsCalendarsEventsGetInstances")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/calendarGroups/{calendarGroup-id}/calendars/{calendar-id}/events/{event-id}/instances/{event-id1}"
	localVarPath = strings.Replace(localVarPath, "{"+"calendarGroup-id"+"}", _neturl.PathEscape(parameterToString(r.calendarGroupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"calendar-id"+"}", _neturl.PathEscape(parameterToString(r.calendarId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id1"+"}", _neturl.PathEscape(parameterToString(r.eventId1, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMeCalendarGroupsCalendarsEventsGetMultiValueExtendedPropertiesRequest struct {
	ctx _context.Context
	ApiService *MeCalendarGroupApiService
	calendarGroupId string
	calendarId string
	eventId string
	multiValueLegacyExtendedPropertyId string
	select_ *[]string
	expand *[]string
}

// Select properties to be returned
func (r ApiMeCalendarGroupsCalendarsEventsGetMultiValueExtendedPropertiesRequest) Select_(select_ []string) ApiMeCalendarGroupsCalendarsEventsGetMultiValueExtendedPropertiesRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiMeCalendarGroupsCalendarsEventsGetMultiValueExtendedPropertiesRequest) Expand(expand []string) ApiMeCalendarGroupsCalendarsEventsGetMultiValueExtendedPropertiesRequest {
	r.expand = &expand
	return r
}

func (r ApiMeCalendarGroupsCalendarsEventsGetMultiValueExtendedPropertiesRequest) Execute() (MicrosoftGraphMultiValueLegacyExtendedProperty, *_nethttp.Response, error) {
	return r.ApiService.MeCalendarGroupsCalendarsEventsGetMultiValueExtendedPropertiesExecute(r)
}

/*
MeCalendarGroupsCalendarsEventsGetMultiValueExtendedProperties Get multiValueExtendedProperties from me

The collection of multi-value extended properties defined for the event. Read-only. Nullable.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param calendarGroupId key: id of calendarGroup
 @param calendarId key: id of calendar
 @param eventId key: id of event
 @param multiValueLegacyExtendedPropertyId key: id of multiValueLegacyExtendedProperty
 @return ApiMeCalendarGroupsCalendarsEventsGetMultiValueExtendedPropertiesRequest
*/
func (a *MeCalendarGroupApiService) MeCalendarGroupsCalendarsEventsGetMultiValueExtendedProperties(ctx _context.Context, calendarGroupId string, calendarId string, eventId string, multiValueLegacyExtendedPropertyId string) ApiMeCalendarGroupsCalendarsEventsGetMultiValueExtendedPropertiesRequest {
	return ApiMeCalendarGroupsCalendarsEventsGetMultiValueExtendedPropertiesRequest{
		ApiService: a,
		ctx: ctx,
		calendarGroupId: calendarGroupId,
		calendarId: calendarId,
		eventId: eventId,
		multiValueLegacyExtendedPropertyId: multiValueLegacyExtendedPropertyId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphMultiValueLegacyExtendedProperty
func (a *MeCalendarGroupApiService) MeCalendarGroupsCalendarsEventsGetMultiValueExtendedPropertiesExecute(r ApiMeCalendarGroupsCalendarsEventsGetMultiValueExtendedPropertiesRequest) (MicrosoftGraphMultiValueLegacyExtendedProperty, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphMultiValueLegacyExtendedProperty
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MeCalendarGroupApiService.MeCalendarGroupsCalendarsEventsGetMultiValueExtendedProperties")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/calendarGroups/{calendarGroup-id}/calendars/{calendar-id}/events/{event-id}/multiValueExtendedProperties/{multiValueLegacyExtendedProperty-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"calendarGroup-id"+"}", _neturl.PathEscape(parameterToString(r.calendarGroupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"calendar-id"+"}", _neturl.PathEscape(parameterToString(r.calendarId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"multiValueLegacyExtendedProperty-id"+"}", _neturl.PathEscape(parameterToString(r.multiValueLegacyExtendedPropertyId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMeCalendarGroupsCalendarsEventsGetSingleValueExtendedPropertiesRequest struct {
	ctx _context.Context
	ApiService *MeCalendarGroupApiService
	calendarGroupId string
	calendarId string
	eventId string
	singleValueLegacyExtendedPropertyId string
	select_ *[]string
	expand *[]string
}

// Select properties to be returned
func (r ApiMeCalendarGroupsCalendarsEventsGetSingleValueExtendedPropertiesRequest) Select_(select_ []string) ApiMeCalendarGroupsCalendarsEventsGetSingleValueExtendedPropertiesRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiMeCalendarGroupsCalendarsEventsGetSingleValueExtendedPropertiesRequest) Expand(expand []string) ApiMeCalendarGroupsCalendarsEventsGetSingleValueExtendedPropertiesRequest {
	r.expand = &expand
	return r
}

func (r ApiMeCalendarGroupsCalendarsEventsGetSingleValueExtendedPropertiesRequest) Execute() (MicrosoftGraphSingleValueLegacyExtendedProperty, *_nethttp.Response, error) {
	return r.ApiService.MeCalendarGroupsCalendarsEventsGetSingleValueExtendedPropertiesExecute(r)
}

/*
MeCalendarGroupsCalendarsEventsGetSingleValueExtendedProperties Get singleValueExtendedProperties from me

The collection of single-value extended properties defined for the event. Read-only. Nullable.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param calendarGroupId key: id of calendarGroup
 @param calendarId key: id of calendar
 @param eventId key: id of event
 @param singleValueLegacyExtendedPropertyId key: id of singleValueLegacyExtendedProperty
 @return ApiMeCalendarGroupsCalendarsEventsGetSingleValueExtendedPropertiesRequest
*/
func (a *MeCalendarGroupApiService) MeCalendarGroupsCalendarsEventsGetSingleValueExtendedProperties(ctx _context.Context, calendarGroupId string, calendarId string, eventId string, singleValueLegacyExtendedPropertyId string) ApiMeCalendarGroupsCalendarsEventsGetSingleValueExtendedPropertiesRequest {
	return ApiMeCalendarGroupsCalendarsEventsGetSingleValueExtendedPropertiesRequest{
		ApiService: a,
		ctx: ctx,
		calendarGroupId: calendarGroupId,
		calendarId: calendarId,
		eventId: eventId,
		singleValueLegacyExtendedPropertyId: singleValueLegacyExtendedPropertyId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphSingleValueLegacyExtendedProperty
func (a *MeCalendarGroupApiService) MeCalendarGroupsCalendarsEventsGetSingleValueExtendedPropertiesExecute(r ApiMeCalendarGroupsCalendarsEventsGetSingleValueExtendedPropertiesRequest) (MicrosoftGraphSingleValueLegacyExtendedProperty, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphSingleValueLegacyExtendedProperty
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MeCalendarGroupApiService.MeCalendarGroupsCalendarsEventsGetSingleValueExtendedProperties")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/calendarGroups/{calendarGroup-id}/calendars/{calendar-id}/events/{event-id}/singleValueExtendedProperties/{singleValueLegacyExtendedProperty-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"calendarGroup-id"+"}", _neturl.PathEscape(parameterToString(r.calendarGroupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"calendar-id"+"}", _neturl.PathEscape(parameterToString(r.calendarId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"singleValueLegacyExtendedProperty-id"+"}", _neturl.PathEscape(parameterToString(r.singleValueLegacyExtendedPropertyId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMeCalendarGroupsCalendarsEventsListAttachmentsRequest struct {
	ctx _context.Context
	ApiService *MeCalendarGroupApiService
	calendarGroupId string
	calendarId string
	eventId string
	top *int32
	skip *int32
	filter *string
	count *bool
	orderby *[]string
	select_ *[]string
	expand *[]string
}

// Show only the first n items
func (r ApiMeCalendarGroupsCalendarsEventsListAttachmentsRequest) Top(top int32) ApiMeCalendarGroupsCalendarsEventsListAttachmentsRequest {
	r.top = &top
	return r
}
// Skip the first n items
func (r ApiMeCalendarGroupsCalendarsEventsListAttachmentsRequest) Skip(skip int32) ApiMeCalendarGroupsCalendarsEventsListAttachmentsRequest {
	r.skip = &skip
	return r
}
// Filter items by property values
func (r ApiMeCalendarGroupsCalendarsEventsListAttachmentsRequest) Filter(filter string) ApiMeCalendarGroupsCalendarsEventsListAttachmentsRequest {
	r.filter = &filter
	return r
}
// Include count of items
func (r ApiMeCalendarGroupsCalendarsEventsListAttachmentsRequest) Count(count bool) ApiMeCalendarGroupsCalendarsEventsListAttachmentsRequest {
	r.count = &count
	return r
}
// Order items by property values
func (r ApiMeCalendarGroupsCalendarsEventsListAttachmentsRequest) Orderby(orderby []string) ApiMeCalendarGroupsCalendarsEventsListAttachmentsRequest {
	r.orderby = &orderby
	return r
}
// Select properties to be returned
func (r ApiMeCalendarGroupsCalendarsEventsListAttachmentsRequest) Select_(select_ []string) ApiMeCalendarGroupsCalendarsEventsListAttachmentsRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiMeCalendarGroupsCalendarsEventsListAttachmentsRequest) Expand(expand []string) ApiMeCalendarGroupsCalendarsEventsListAttachmentsRequest {
	r.expand = &expand
	return r
}

func (r ApiMeCalendarGroupsCalendarsEventsListAttachmentsRequest) Execute() (CollectionOfAttachment, *_nethttp.Response, error) {
	return r.ApiService.MeCalendarGroupsCalendarsEventsListAttachmentsExecute(r)
}

/*
MeCalendarGroupsCalendarsEventsListAttachments Get attachments from me

The collection of FileAttachment, ItemAttachment, and referenceAttachment attachments for the event. Navigation property. Read-only. Nullable.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param calendarGroupId key: id of calendarGroup
 @param calendarId key: id of calendar
 @param eventId key: id of event
 @return ApiMeCalendarGroupsCalendarsEventsListAttachmentsRequest
*/
func (a *MeCalendarGroupApiService) MeCalendarGroupsCalendarsEventsListAttachments(ctx _context.Context, calendarGroupId string, calendarId string, eventId string) ApiMeCalendarGroupsCalendarsEventsListAttachmentsRequest {
	return ApiMeCalendarGroupsCalendarsEventsListAttachmentsRequest{
		ApiService: a,
		ctx: ctx,
		calendarGroupId: calendarGroupId,
		calendarId: calendarId,
		eventId: eventId,
	}
}

// Execute executes the request
//  @return CollectionOfAttachment
func (a *MeCalendarGroupApiService) MeCalendarGroupsCalendarsEventsListAttachmentsExecute(r ApiMeCalendarGroupsCalendarsEventsListAttachmentsRequest) (CollectionOfAttachment, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  CollectionOfAttachment
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MeCalendarGroupApiService.MeCalendarGroupsCalendarsEventsListAttachments")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/calendarGroups/{calendarGroup-id}/calendars/{calendar-id}/events/{event-id}/attachments"
	localVarPath = strings.Replace(localVarPath, "{"+"calendarGroup-id"+"}", _neturl.PathEscape(parameterToString(r.calendarGroupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"calendar-id"+"}", _neturl.PathEscape(parameterToString(r.calendarId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.top != nil {
		localVarQueryParams.Add("$top", parameterToString(*r.top, ""))
	}
	if r.skip != nil {
		localVarQueryParams.Add("$skip", parameterToString(*r.skip, ""))
	}
	if r.filter != nil {
		localVarQueryParams.Add("$filter", parameterToString(*r.filter, ""))
	}
	if r.count != nil {
		localVarQueryParams.Add("$count", parameterToString(*r.count, ""))
	}
	if r.orderby != nil {
		localVarQueryParams.Add("$orderby", parameterToString(*r.orderby, "csv"))
	}
	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMeCalendarGroupsCalendarsEventsListExtensionsRequest struct {
	ctx _context.Context
	ApiService *MeCalendarGroupApiService
	calendarGroupId string
	calendarId string
	eventId string
	top *int32
	skip *int32
	filter *string
	count *bool
	orderby *[]string
	select_ *[]string
	expand *[]string
}

// Show only the first n items
func (r ApiMeCalendarGroupsCalendarsEventsListExtensionsRequest) Top(top int32) ApiMeCalendarGroupsCalendarsEventsListExtensionsRequest {
	r.top = &top
	return r
}
// Skip the first n items
func (r ApiMeCalendarGroupsCalendarsEventsListExtensionsRequest) Skip(skip int32) ApiMeCalendarGroupsCalendarsEventsListExtensionsRequest {
	r.skip = &skip
	return r
}
// Filter items by property values
func (r ApiMeCalendarGroupsCalendarsEventsListExtensionsRequest) Filter(filter string) ApiMeCalendarGroupsCalendarsEventsListExtensionsRequest {
	r.filter = &filter
	return r
}
// Include count of items
func (r ApiMeCalendarGroupsCalendarsEventsListExtensionsRequest) Count(count bool) ApiMeCalendarGroupsCalendarsEventsListExtensionsRequest {
	r.count = &count
	return r
}
// Order items by property values
func (r ApiMeCalendarGroupsCalendarsEventsListExtensionsRequest) Orderby(orderby []string) ApiMeCalendarGroupsCalendarsEventsListExtensionsRequest {
	r.orderby = &orderby
	return r
}
// Select properties to be returned
func (r ApiMeCalendarGroupsCalendarsEventsListExtensionsRequest) Select_(select_ []string) ApiMeCalendarGroupsCalendarsEventsListExtensionsRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiMeCalendarGroupsCalendarsEventsListExtensionsRequest) Expand(expand []string) ApiMeCalendarGroupsCalendarsEventsListExtensionsRequest {
	r.expand = &expand
	return r
}

func (r ApiMeCalendarGroupsCalendarsEventsListExtensionsRequest) Execute() (CollectionOfExtension, *_nethttp.Response, error) {
	return r.ApiService.MeCalendarGroupsCalendarsEventsListExtensionsExecute(r)
}

/*
MeCalendarGroupsCalendarsEventsListExtensions Get extensions from me

The collection of open extensions defined for the event. Nullable.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param calendarGroupId key: id of calendarGroup
 @param calendarId key: id of calendar
 @param eventId key: id of event
 @return ApiMeCalendarGroupsCalendarsEventsListExtensionsRequest
*/
func (a *MeCalendarGroupApiService) MeCalendarGroupsCalendarsEventsListExtensions(ctx _context.Context, calendarGroupId string, calendarId string, eventId string) ApiMeCalendarGroupsCalendarsEventsListExtensionsRequest {
	return ApiMeCalendarGroupsCalendarsEventsListExtensionsRequest{
		ApiService: a,
		ctx: ctx,
		calendarGroupId: calendarGroupId,
		calendarId: calendarId,
		eventId: eventId,
	}
}

// Execute executes the request
//  @return CollectionOfExtension
func (a *MeCalendarGroupApiService) MeCalendarGroupsCalendarsEventsListExtensionsExecute(r ApiMeCalendarGroupsCalendarsEventsListExtensionsRequest) (CollectionOfExtension, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  CollectionOfExtension
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MeCalendarGroupApiService.MeCalendarGroupsCalendarsEventsListExtensions")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/calendarGroups/{calendarGroup-id}/calendars/{calendar-id}/events/{event-id}/extensions"
	localVarPath = strings.Replace(localVarPath, "{"+"calendarGroup-id"+"}", _neturl.PathEscape(parameterToString(r.calendarGroupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"calendar-id"+"}", _neturl.PathEscape(parameterToString(r.calendarId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.top != nil {
		localVarQueryParams.Add("$top", parameterToString(*r.top, ""))
	}
	if r.skip != nil {
		localVarQueryParams.Add("$skip", parameterToString(*r.skip, ""))
	}
	if r.filter != nil {
		localVarQueryParams.Add("$filter", parameterToString(*r.filter, ""))
	}
	if r.count != nil {
		localVarQueryParams.Add("$count", parameterToString(*r.count, ""))
	}
	if r.orderby != nil {
		localVarQueryParams.Add("$orderby", parameterToString(*r.orderby, "csv"))
	}
	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMeCalendarGroupsCalendarsEventsListInstancesRequest struct {
	ctx _context.Context
	ApiService *MeCalendarGroupApiService
	calendarGroupId string
	calendarId string
	eventId string
	top *int32
	skip *int32
	filter *string
	count *bool
	orderby *[]string
	select_ *[]string
}

// Show only the first n items
func (r ApiMeCalendarGroupsCalendarsEventsListInstancesRequest) Top(top int32) ApiMeCalendarGroupsCalendarsEventsListInstancesRequest {
	r.top = &top
	return r
}
// Skip the first n items
func (r ApiMeCalendarGroupsCalendarsEventsListInstancesRequest) Skip(skip int32) ApiMeCalendarGroupsCalendarsEventsListInstancesRequest {
	r.skip = &skip
	return r
}
// Filter items by property values
func (r ApiMeCalendarGroupsCalendarsEventsListInstancesRequest) Filter(filter string) ApiMeCalendarGroupsCalendarsEventsListInstancesRequest {
	r.filter = &filter
	return r
}
// Include count of items
func (r ApiMeCalendarGroupsCalendarsEventsListInstancesRequest) Count(count bool) ApiMeCalendarGroupsCalendarsEventsListInstancesRequest {
	r.count = &count
	return r
}
// Order items by property values
func (r ApiMeCalendarGroupsCalendarsEventsListInstancesRequest) Orderby(orderby []string) ApiMeCalendarGroupsCalendarsEventsListInstancesRequest {
	r.orderby = &orderby
	return r
}
// Select properties to be returned
func (r ApiMeCalendarGroupsCalendarsEventsListInstancesRequest) Select_(select_ []string) ApiMeCalendarGroupsCalendarsEventsListInstancesRequest {
	r.select_ = &select_
	return r
}

func (r ApiMeCalendarGroupsCalendarsEventsListInstancesRequest) Execute() (CollectionOfEvent, *_nethttp.Response, error) {
	return r.ApiService.MeCalendarGroupsCalendarsEventsListInstancesExecute(r)
}

/*
MeCalendarGroupsCalendarsEventsListInstances Get instances from me

The occurrences of a recurring series, if the event is a series master. This property includes occurrences that are part of the recurrence pattern, and exceptions that have been modified, but does not include occurrences that have been cancelled from the series. Navigation property. Read-only. Nullable.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param calendarGroupId key: id of calendarGroup
 @param calendarId key: id of calendar
 @param eventId key: id of event
 @return ApiMeCalendarGroupsCalendarsEventsListInstancesRequest
*/
func (a *MeCalendarGroupApiService) MeCalendarGroupsCalendarsEventsListInstances(ctx _context.Context, calendarGroupId string, calendarId string, eventId string) ApiMeCalendarGroupsCalendarsEventsListInstancesRequest {
	return ApiMeCalendarGroupsCalendarsEventsListInstancesRequest{
		ApiService: a,
		ctx: ctx,
		calendarGroupId: calendarGroupId,
		calendarId: calendarId,
		eventId: eventId,
	}
}

// Execute executes the request
//  @return CollectionOfEvent
func (a *MeCalendarGroupApiService) MeCalendarGroupsCalendarsEventsListInstancesExecute(r ApiMeCalendarGroupsCalendarsEventsListInstancesRequest) (CollectionOfEvent, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  CollectionOfEvent
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MeCalendarGroupApiService.MeCalendarGroupsCalendarsEventsListInstances")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/calendarGroups/{calendarGroup-id}/calendars/{calendar-id}/events/{event-id}/instances"
	localVarPath = strings.Replace(localVarPath, "{"+"calendarGroup-id"+"}", _neturl.PathEscape(parameterToString(r.calendarGroupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"calendar-id"+"}", _neturl.PathEscape(parameterToString(r.calendarId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.top != nil {
		localVarQueryParams.Add("$top", parameterToString(*r.top, ""))
	}
	if r.skip != nil {
		localVarQueryParams.Add("$skip", parameterToString(*r.skip, ""))
	}
	if r.filter != nil {
		localVarQueryParams.Add("$filter", parameterToString(*r.filter, ""))
	}
	if r.count != nil {
		localVarQueryParams.Add("$count", parameterToString(*r.count, ""))
	}
	if r.orderby != nil {
		localVarQueryParams.Add("$orderby", parameterToString(*r.orderby, "csv"))
	}
	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMeCalendarGroupsCalendarsEventsListMultiValueExtendedPropertiesRequest struct {
	ctx _context.Context
	ApiService *MeCalendarGroupApiService
	calendarGroupId string
	calendarId string
	eventId string
	top *int32
	skip *int32
	search *string
	filter *string
	count *bool
	orderby *[]string
	select_ *[]string
	expand *[]string
}

// Show only the first n items
func (r ApiMeCalendarGroupsCalendarsEventsListMultiValueExtendedPropertiesRequest) Top(top int32) ApiMeCalendarGroupsCalendarsEventsListMultiValueExtendedPropertiesRequest {
	r.top = &top
	return r
}
// Skip the first n items
func (r ApiMeCalendarGroupsCalendarsEventsListMultiValueExtendedPropertiesRequest) Skip(skip int32) ApiMeCalendarGroupsCalendarsEventsListMultiValueExtendedPropertiesRequest {
	r.skip = &skip
	return r
}
// Search items by search phrases
func (r ApiMeCalendarGroupsCalendarsEventsListMultiValueExtendedPropertiesRequest) Search(search string) ApiMeCalendarGroupsCalendarsEventsListMultiValueExtendedPropertiesRequest {
	r.search = &search
	return r
}
// Filter items by property values
func (r ApiMeCalendarGroupsCalendarsEventsListMultiValueExtendedPropertiesRequest) Filter(filter string) ApiMeCalendarGroupsCalendarsEventsListMultiValueExtendedPropertiesRequest {
	r.filter = &filter
	return r
}
// Include count of items
func (r ApiMeCalendarGroupsCalendarsEventsListMultiValueExtendedPropertiesRequest) Count(count bool) ApiMeCalendarGroupsCalendarsEventsListMultiValueExtendedPropertiesRequest {
	r.count = &count
	return r
}
// Order items by property values
func (r ApiMeCalendarGroupsCalendarsEventsListMultiValueExtendedPropertiesRequest) Orderby(orderby []string) ApiMeCalendarGroupsCalendarsEventsListMultiValueExtendedPropertiesRequest {
	r.orderby = &orderby
	return r
}
// Select properties to be returned
func (r ApiMeCalendarGroupsCalendarsEventsListMultiValueExtendedPropertiesRequest) Select_(select_ []string) ApiMeCalendarGroupsCalendarsEventsListMultiValueExtendedPropertiesRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiMeCalendarGroupsCalendarsEventsListMultiValueExtendedPropertiesRequest) Expand(expand []string) ApiMeCalendarGroupsCalendarsEventsListMultiValueExtendedPropertiesRequest {
	r.expand = &expand
	return r
}

func (r ApiMeCalendarGroupsCalendarsEventsListMultiValueExtendedPropertiesRequest) Execute() (CollectionOfMultiValueLegacyExtendedProperty, *_nethttp.Response, error) {
	return r.ApiService.MeCalendarGroupsCalendarsEventsListMultiValueExtendedPropertiesExecute(r)
}

/*
MeCalendarGroupsCalendarsEventsListMultiValueExtendedProperties Get multiValueExtendedProperties from me

The collection of multi-value extended properties defined for the event. Read-only. Nullable.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param calendarGroupId key: id of calendarGroup
 @param calendarId key: id of calendar
 @param eventId key: id of event
 @return ApiMeCalendarGroupsCalendarsEventsListMultiValueExtendedPropertiesRequest
*/
func (a *MeCalendarGroupApiService) MeCalendarGroupsCalendarsEventsListMultiValueExtendedProperties(ctx _context.Context, calendarGroupId string, calendarId string, eventId string) ApiMeCalendarGroupsCalendarsEventsListMultiValueExtendedPropertiesRequest {
	return ApiMeCalendarGroupsCalendarsEventsListMultiValueExtendedPropertiesRequest{
		ApiService: a,
		ctx: ctx,
		calendarGroupId: calendarGroupId,
		calendarId: calendarId,
		eventId: eventId,
	}
}

// Execute executes the request
//  @return CollectionOfMultiValueLegacyExtendedProperty
func (a *MeCalendarGroupApiService) MeCalendarGroupsCalendarsEventsListMultiValueExtendedPropertiesExecute(r ApiMeCalendarGroupsCalendarsEventsListMultiValueExtendedPropertiesRequest) (CollectionOfMultiValueLegacyExtendedProperty, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  CollectionOfMultiValueLegacyExtendedProperty
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MeCalendarGroupApiService.MeCalendarGroupsCalendarsEventsListMultiValueExtendedProperties")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/calendarGroups/{calendarGroup-id}/calendars/{calendar-id}/events/{event-id}/multiValueExtendedProperties"
	localVarPath = strings.Replace(localVarPath, "{"+"calendarGroup-id"+"}", _neturl.PathEscape(parameterToString(r.calendarGroupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"calendar-id"+"}", _neturl.PathEscape(parameterToString(r.calendarId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.top != nil {
		localVarQueryParams.Add("$top", parameterToString(*r.top, ""))
	}
	if r.skip != nil {
		localVarQueryParams.Add("$skip", parameterToString(*r.skip, ""))
	}
	if r.search != nil {
		localVarQueryParams.Add("$search", parameterToString(*r.search, ""))
	}
	if r.filter != nil {
		localVarQueryParams.Add("$filter", parameterToString(*r.filter, ""))
	}
	if r.count != nil {
		localVarQueryParams.Add("$count", parameterToString(*r.count, ""))
	}
	if r.orderby != nil {
		localVarQueryParams.Add("$orderby", parameterToString(*r.orderby, "csv"))
	}
	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMeCalendarGroupsCalendarsEventsListSingleValueExtendedPropertiesRequest struct {
	ctx _context.Context
	ApiService *MeCalendarGroupApiService
	calendarGroupId string
	calendarId string
	eventId string
	top *int32
	skip *int32
	search *string
	filter *string
	count *bool
	orderby *[]string
	select_ *[]string
	expand *[]string
}

// Show only the first n items
func (r ApiMeCalendarGroupsCalendarsEventsListSingleValueExtendedPropertiesRequest) Top(top int32) ApiMeCalendarGroupsCalendarsEventsListSingleValueExtendedPropertiesRequest {
	r.top = &top
	return r
}
// Skip the first n items
func (r ApiMeCalendarGroupsCalendarsEventsListSingleValueExtendedPropertiesRequest) Skip(skip int32) ApiMeCalendarGroupsCalendarsEventsListSingleValueExtendedPropertiesRequest {
	r.skip = &skip
	return r
}
// Search items by search phrases
func (r ApiMeCalendarGroupsCalendarsEventsListSingleValueExtendedPropertiesRequest) Search(search string) ApiMeCalendarGroupsCalendarsEventsListSingleValueExtendedPropertiesRequest {
	r.search = &search
	return r
}
// Filter items by property values
func (r ApiMeCalendarGroupsCalendarsEventsListSingleValueExtendedPropertiesRequest) Filter(filter string) ApiMeCalendarGroupsCalendarsEventsListSingleValueExtendedPropertiesRequest {
	r.filter = &filter
	return r
}
// Include count of items
func (r ApiMeCalendarGroupsCalendarsEventsListSingleValueExtendedPropertiesRequest) Count(count bool) ApiMeCalendarGroupsCalendarsEventsListSingleValueExtendedPropertiesRequest {
	r.count = &count
	return r
}
// Order items by property values
func (r ApiMeCalendarGroupsCalendarsEventsListSingleValueExtendedPropertiesRequest) Orderby(orderby []string) ApiMeCalendarGroupsCalendarsEventsListSingleValueExtendedPropertiesRequest {
	r.orderby = &orderby
	return r
}
// Select properties to be returned
func (r ApiMeCalendarGroupsCalendarsEventsListSingleValueExtendedPropertiesRequest) Select_(select_ []string) ApiMeCalendarGroupsCalendarsEventsListSingleValueExtendedPropertiesRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiMeCalendarGroupsCalendarsEventsListSingleValueExtendedPropertiesRequest) Expand(expand []string) ApiMeCalendarGroupsCalendarsEventsListSingleValueExtendedPropertiesRequest {
	r.expand = &expand
	return r
}

func (r ApiMeCalendarGroupsCalendarsEventsListSingleValueExtendedPropertiesRequest) Execute() (CollectionOfSingleValueLegacyExtendedProperty, *_nethttp.Response, error) {
	return r.ApiService.MeCalendarGroupsCalendarsEventsListSingleValueExtendedPropertiesExecute(r)
}

/*
MeCalendarGroupsCalendarsEventsListSingleValueExtendedProperties Get singleValueExtendedProperties from me

The collection of single-value extended properties defined for the event. Read-only. Nullable.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param calendarGroupId key: id of calendarGroup
 @param calendarId key: id of calendar
 @param eventId key: id of event
 @return ApiMeCalendarGroupsCalendarsEventsListSingleValueExtendedPropertiesRequest
*/
func (a *MeCalendarGroupApiService) MeCalendarGroupsCalendarsEventsListSingleValueExtendedProperties(ctx _context.Context, calendarGroupId string, calendarId string, eventId string) ApiMeCalendarGroupsCalendarsEventsListSingleValueExtendedPropertiesRequest {
	return ApiMeCalendarGroupsCalendarsEventsListSingleValueExtendedPropertiesRequest{
		ApiService: a,
		ctx: ctx,
		calendarGroupId: calendarGroupId,
		calendarId: calendarId,
		eventId: eventId,
	}
}

// Execute executes the request
//  @return CollectionOfSingleValueLegacyExtendedProperty
func (a *MeCalendarGroupApiService) MeCalendarGroupsCalendarsEventsListSingleValueExtendedPropertiesExecute(r ApiMeCalendarGroupsCalendarsEventsListSingleValueExtendedPropertiesRequest) (CollectionOfSingleValueLegacyExtendedProperty, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  CollectionOfSingleValueLegacyExtendedProperty
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MeCalendarGroupApiService.MeCalendarGroupsCalendarsEventsListSingleValueExtendedProperties")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/calendarGroups/{calendarGroup-id}/calendars/{calendar-id}/events/{event-id}/singleValueExtendedProperties"
	localVarPath = strings.Replace(localVarPath, "{"+"calendarGroup-id"+"}", _neturl.PathEscape(parameterToString(r.calendarGroupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"calendar-id"+"}", _neturl.PathEscape(parameterToString(r.calendarId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.top != nil {
		localVarQueryParams.Add("$top", parameterToString(*r.top, ""))
	}
	if r.skip != nil {
		localVarQueryParams.Add("$skip", parameterToString(*r.skip, ""))
	}
	if r.search != nil {
		localVarQueryParams.Add("$search", parameterToString(*r.search, ""))
	}
	if r.filter != nil {
		localVarQueryParams.Add("$filter", parameterToString(*r.filter, ""))
	}
	if r.count != nil {
		localVarQueryParams.Add("$count", parameterToString(*r.count, ""))
	}
	if r.orderby != nil {
		localVarQueryParams.Add("$orderby", parameterToString(*r.orderby, "csv"))
	}
	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMeCalendarGroupsCalendarsEventsUpdateAttachmentsRequest struct {
	ctx _context.Context
	ApiService *MeCalendarGroupApiService
	calendarGroupId string
	calendarId string
	eventId string
	attachmentId string
	microsoftGraphAttachment *MicrosoftGraphAttachment
}

// New navigation property values
func (r ApiMeCalendarGroupsCalendarsEventsUpdateAttachmentsRequest) MicrosoftGraphAttachment(microsoftGraphAttachment MicrosoftGraphAttachment) ApiMeCalendarGroupsCalendarsEventsUpdateAttachmentsRequest {
	r.microsoftGraphAttachment = &microsoftGraphAttachment
	return r
}

func (r ApiMeCalendarGroupsCalendarsEventsUpdateAttachmentsRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.MeCalendarGroupsCalendarsEventsUpdateAttachmentsExecute(r)
}

/*
MeCalendarGroupsCalendarsEventsUpdateAttachments Update the navigation property attachments in me

The collection of FileAttachment, ItemAttachment, and referenceAttachment attachments for the event. Navigation property. Read-only. Nullable.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param calendarGroupId key: id of calendarGroup
 @param calendarId key: id of calendar
 @param eventId key: id of event
 @param attachmentId key: id of attachment
 @return ApiMeCalendarGroupsCalendarsEventsUpdateAttachmentsRequest
*/
func (a *MeCalendarGroupApiService) MeCalendarGroupsCalendarsEventsUpdateAttachments(ctx _context.Context, calendarGroupId string, calendarId string, eventId string, attachmentId string) ApiMeCalendarGroupsCalendarsEventsUpdateAttachmentsRequest {
	return ApiMeCalendarGroupsCalendarsEventsUpdateAttachmentsRequest{
		ApiService: a,
		ctx: ctx,
		calendarGroupId: calendarGroupId,
		calendarId: calendarId,
		eventId: eventId,
		attachmentId: attachmentId,
	}
}

// Execute executes the request
func (a *MeCalendarGroupApiService) MeCalendarGroupsCalendarsEventsUpdateAttachmentsExecute(r ApiMeCalendarGroupsCalendarsEventsUpdateAttachmentsRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPatch
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MeCalendarGroupApiService.MeCalendarGroupsCalendarsEventsUpdateAttachments")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/calendarGroups/{calendarGroup-id}/calendars/{calendar-id}/events/{event-id}/attachments/{attachment-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"calendarGroup-id"+"}", _neturl.PathEscape(parameterToString(r.calendarGroupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"calendar-id"+"}", _neturl.PathEscape(parameterToString(r.calendarId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"attachment-id"+"}", _neturl.PathEscape(parameterToString(r.attachmentId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphAttachment == nil {
		return nil, reportError("microsoftGraphAttachment is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphAttachment
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiMeCalendarGroupsCalendarsEventsUpdateCalendarRequest struct {
	ctx _context.Context
	ApiService *MeCalendarGroupApiService
	calendarGroupId string
	calendarId string
	eventId string
	microsoftGraphCalendar *MicrosoftGraphCalendar
}

// New navigation property values
func (r ApiMeCalendarGroupsCalendarsEventsUpdateCalendarRequest) MicrosoftGraphCalendar(microsoftGraphCalendar MicrosoftGraphCalendar) ApiMeCalendarGroupsCalendarsEventsUpdateCalendarRequest {
	r.microsoftGraphCalendar = &microsoftGraphCalendar
	return r
}

func (r ApiMeCalendarGroupsCalendarsEventsUpdateCalendarRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.MeCalendarGroupsCalendarsEventsUpdateCalendarExecute(r)
}

/*
MeCalendarGroupsCalendarsEventsUpdateCalendar Update the navigation property calendar in me

The calendar that contains the event. Navigation property. Read-only.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param calendarGroupId key: id of calendarGroup
 @param calendarId key: id of calendar
 @param eventId key: id of event
 @return ApiMeCalendarGroupsCalendarsEventsUpdateCalendarRequest
*/
func (a *MeCalendarGroupApiService) MeCalendarGroupsCalendarsEventsUpdateCalendar(ctx _context.Context, calendarGroupId string, calendarId string, eventId string) ApiMeCalendarGroupsCalendarsEventsUpdateCalendarRequest {
	return ApiMeCalendarGroupsCalendarsEventsUpdateCalendarRequest{
		ApiService: a,
		ctx: ctx,
		calendarGroupId: calendarGroupId,
		calendarId: calendarId,
		eventId: eventId,
	}
}

// Execute executes the request
func (a *MeCalendarGroupApiService) MeCalendarGroupsCalendarsEventsUpdateCalendarExecute(r ApiMeCalendarGroupsCalendarsEventsUpdateCalendarRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPatch
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MeCalendarGroupApiService.MeCalendarGroupsCalendarsEventsUpdateCalendar")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/calendarGroups/{calendarGroup-id}/calendars/{calendar-id}/events/{event-id}/calendar"
	localVarPath = strings.Replace(localVarPath, "{"+"calendarGroup-id"+"}", _neturl.PathEscape(parameterToString(r.calendarGroupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"calendar-id"+"}", _neturl.PathEscape(parameterToString(r.calendarId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphCalendar == nil {
		return nil, reportError("microsoftGraphCalendar is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphCalendar
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiMeCalendarGroupsCalendarsEventsUpdateExtensionsRequest struct {
	ctx _context.Context
	ApiService *MeCalendarGroupApiService
	calendarGroupId string
	calendarId string
	eventId string
	extensionId string
	microsoftGraphExtension *MicrosoftGraphExtension
}

// New navigation property values
func (r ApiMeCalendarGroupsCalendarsEventsUpdateExtensionsRequest) MicrosoftGraphExtension(microsoftGraphExtension MicrosoftGraphExtension) ApiMeCalendarGroupsCalendarsEventsUpdateExtensionsRequest {
	r.microsoftGraphExtension = &microsoftGraphExtension
	return r
}

func (r ApiMeCalendarGroupsCalendarsEventsUpdateExtensionsRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.MeCalendarGroupsCalendarsEventsUpdateExtensionsExecute(r)
}

/*
MeCalendarGroupsCalendarsEventsUpdateExtensions Update the navigation property extensions in me

The collection of open extensions defined for the event. Nullable.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param calendarGroupId key: id of calendarGroup
 @param calendarId key: id of calendar
 @param eventId key: id of event
 @param extensionId key: id of extension
 @return ApiMeCalendarGroupsCalendarsEventsUpdateExtensionsRequest
*/
func (a *MeCalendarGroupApiService) MeCalendarGroupsCalendarsEventsUpdateExtensions(ctx _context.Context, calendarGroupId string, calendarId string, eventId string, extensionId string) ApiMeCalendarGroupsCalendarsEventsUpdateExtensionsRequest {
	return ApiMeCalendarGroupsCalendarsEventsUpdateExtensionsRequest{
		ApiService: a,
		ctx: ctx,
		calendarGroupId: calendarGroupId,
		calendarId: calendarId,
		eventId: eventId,
		extensionId: extensionId,
	}
}

// Execute executes the request
func (a *MeCalendarGroupApiService) MeCalendarGroupsCalendarsEventsUpdateExtensionsExecute(r ApiMeCalendarGroupsCalendarsEventsUpdateExtensionsRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPatch
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MeCalendarGroupApiService.MeCalendarGroupsCalendarsEventsUpdateExtensions")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/calendarGroups/{calendarGroup-id}/calendars/{calendar-id}/events/{event-id}/extensions/{extension-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"calendarGroup-id"+"}", _neturl.PathEscape(parameterToString(r.calendarGroupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"calendar-id"+"}", _neturl.PathEscape(parameterToString(r.calendarId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"extension-id"+"}", _neturl.PathEscape(parameterToString(r.extensionId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphExtension == nil {
		return nil, reportError("microsoftGraphExtension is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphExtension
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiMeCalendarGroupsCalendarsEventsUpdateInstancesRequest struct {
	ctx _context.Context
	ApiService *MeCalendarGroupApiService
	calendarGroupId string
	calendarId string
	eventId string
	eventId1 string
	microsoftGraphEvent *MicrosoftGraphEvent
}

// New navigation property values
func (r ApiMeCalendarGroupsCalendarsEventsUpdateInstancesRequest) MicrosoftGraphEvent(microsoftGraphEvent MicrosoftGraphEvent) ApiMeCalendarGroupsCalendarsEventsUpdateInstancesRequest {
	r.microsoftGraphEvent = &microsoftGraphEvent
	return r
}

func (r ApiMeCalendarGroupsCalendarsEventsUpdateInstancesRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.MeCalendarGroupsCalendarsEventsUpdateInstancesExecute(r)
}

/*
MeCalendarGroupsCalendarsEventsUpdateInstances Update the navigation property instances in me

The occurrences of a recurring series, if the event is a series master. This property includes occurrences that are part of the recurrence pattern, and exceptions that have been modified, but does not include occurrences that have been cancelled from the series. Navigation property. Read-only. Nullable.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param calendarGroupId key: id of calendarGroup
 @param calendarId key: id of calendar
 @param eventId key: id of event
 @param eventId1 key: id of event
 @return ApiMeCalendarGroupsCalendarsEventsUpdateInstancesRequest
*/
func (a *MeCalendarGroupApiService) MeCalendarGroupsCalendarsEventsUpdateInstances(ctx _context.Context, calendarGroupId string, calendarId string, eventId string, eventId1 string) ApiMeCalendarGroupsCalendarsEventsUpdateInstancesRequest {
	return ApiMeCalendarGroupsCalendarsEventsUpdateInstancesRequest{
		ApiService: a,
		ctx: ctx,
		calendarGroupId: calendarGroupId,
		calendarId: calendarId,
		eventId: eventId,
		eventId1: eventId1,
	}
}

// Execute executes the request
func (a *MeCalendarGroupApiService) MeCalendarGroupsCalendarsEventsUpdateInstancesExecute(r ApiMeCalendarGroupsCalendarsEventsUpdateInstancesRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPatch
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MeCalendarGroupApiService.MeCalendarGroupsCalendarsEventsUpdateInstances")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/calendarGroups/{calendarGroup-id}/calendars/{calendar-id}/events/{event-id}/instances/{event-id1}"
	localVarPath = strings.Replace(localVarPath, "{"+"calendarGroup-id"+"}", _neturl.PathEscape(parameterToString(r.calendarGroupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"calendar-id"+"}", _neturl.PathEscape(parameterToString(r.calendarId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id1"+"}", _neturl.PathEscape(parameterToString(r.eventId1, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphEvent == nil {
		return nil, reportError("microsoftGraphEvent is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphEvent
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiMeCalendarGroupsCalendarsEventsUpdateMultiValueExtendedPropertiesRequest struct {
	ctx _context.Context
	ApiService *MeCalendarGroupApiService
	calendarGroupId string
	calendarId string
	eventId string
	multiValueLegacyExtendedPropertyId string
	microsoftGraphMultiValueLegacyExtendedProperty *MicrosoftGraphMultiValueLegacyExtendedProperty
}

// New navigation property values
func (r ApiMeCalendarGroupsCalendarsEventsUpdateMultiValueExtendedPropertiesRequest) MicrosoftGraphMultiValueLegacyExtendedProperty(microsoftGraphMultiValueLegacyExtendedProperty MicrosoftGraphMultiValueLegacyExtendedProperty) ApiMeCalendarGroupsCalendarsEventsUpdateMultiValueExtendedPropertiesRequest {
	r.microsoftGraphMultiValueLegacyExtendedProperty = &microsoftGraphMultiValueLegacyExtendedProperty
	return r
}

func (r ApiMeCalendarGroupsCalendarsEventsUpdateMultiValueExtendedPropertiesRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.MeCalendarGroupsCalendarsEventsUpdateMultiValueExtendedPropertiesExecute(r)
}

/*
MeCalendarGroupsCalendarsEventsUpdateMultiValueExtendedProperties Update the navigation property multiValueExtendedProperties in me

The collection of multi-value extended properties defined for the event. Read-only. Nullable.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param calendarGroupId key: id of calendarGroup
 @param calendarId key: id of calendar
 @param eventId key: id of event
 @param multiValueLegacyExtendedPropertyId key: id of multiValueLegacyExtendedProperty
 @return ApiMeCalendarGroupsCalendarsEventsUpdateMultiValueExtendedPropertiesRequest
*/
func (a *MeCalendarGroupApiService) MeCalendarGroupsCalendarsEventsUpdateMultiValueExtendedProperties(ctx _context.Context, calendarGroupId string, calendarId string, eventId string, multiValueLegacyExtendedPropertyId string) ApiMeCalendarGroupsCalendarsEventsUpdateMultiValueExtendedPropertiesRequest {
	return ApiMeCalendarGroupsCalendarsEventsUpdateMultiValueExtendedPropertiesRequest{
		ApiService: a,
		ctx: ctx,
		calendarGroupId: calendarGroupId,
		calendarId: calendarId,
		eventId: eventId,
		multiValueLegacyExtendedPropertyId: multiValueLegacyExtendedPropertyId,
	}
}

// Execute executes the request
func (a *MeCalendarGroupApiService) MeCalendarGroupsCalendarsEventsUpdateMultiValueExtendedPropertiesExecute(r ApiMeCalendarGroupsCalendarsEventsUpdateMultiValueExtendedPropertiesRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPatch
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MeCalendarGroupApiService.MeCalendarGroupsCalendarsEventsUpdateMultiValueExtendedProperties")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/calendarGroups/{calendarGroup-id}/calendars/{calendar-id}/events/{event-id}/multiValueExtendedProperties/{multiValueLegacyExtendedProperty-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"calendarGroup-id"+"}", _neturl.PathEscape(parameterToString(r.calendarGroupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"calendar-id"+"}", _neturl.PathEscape(parameterToString(r.calendarId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"multiValueLegacyExtendedProperty-id"+"}", _neturl.PathEscape(parameterToString(r.multiValueLegacyExtendedPropertyId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphMultiValueLegacyExtendedProperty == nil {
		return nil, reportError("microsoftGraphMultiValueLegacyExtendedProperty is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphMultiValueLegacyExtendedProperty
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiMeCalendarGroupsCalendarsEventsUpdateSingleValueExtendedPropertiesRequest struct {
	ctx _context.Context
	ApiService *MeCalendarGroupApiService
	calendarGroupId string
	calendarId string
	eventId string
	singleValueLegacyExtendedPropertyId string
	microsoftGraphSingleValueLegacyExtendedProperty *MicrosoftGraphSingleValueLegacyExtendedProperty
}

// New navigation property values
func (r ApiMeCalendarGroupsCalendarsEventsUpdateSingleValueExtendedPropertiesRequest) MicrosoftGraphSingleValueLegacyExtendedProperty(microsoftGraphSingleValueLegacyExtendedProperty MicrosoftGraphSingleValueLegacyExtendedProperty) ApiMeCalendarGroupsCalendarsEventsUpdateSingleValueExtendedPropertiesRequest {
	r.microsoftGraphSingleValueLegacyExtendedProperty = &microsoftGraphSingleValueLegacyExtendedProperty
	return r
}

func (r ApiMeCalendarGroupsCalendarsEventsUpdateSingleValueExtendedPropertiesRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.MeCalendarGroupsCalendarsEventsUpdateSingleValueExtendedPropertiesExecute(r)
}

/*
MeCalendarGroupsCalendarsEventsUpdateSingleValueExtendedProperties Update the navigation property singleValueExtendedProperties in me

The collection of single-value extended properties defined for the event. Read-only. Nullable.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param calendarGroupId key: id of calendarGroup
 @param calendarId key: id of calendar
 @param eventId key: id of event
 @param singleValueLegacyExtendedPropertyId key: id of singleValueLegacyExtendedProperty
 @return ApiMeCalendarGroupsCalendarsEventsUpdateSingleValueExtendedPropertiesRequest
*/
func (a *MeCalendarGroupApiService) MeCalendarGroupsCalendarsEventsUpdateSingleValueExtendedProperties(ctx _context.Context, calendarGroupId string, calendarId string, eventId string, singleValueLegacyExtendedPropertyId string) ApiMeCalendarGroupsCalendarsEventsUpdateSingleValueExtendedPropertiesRequest {
	return ApiMeCalendarGroupsCalendarsEventsUpdateSingleValueExtendedPropertiesRequest{
		ApiService: a,
		ctx: ctx,
		calendarGroupId: calendarGroupId,
		calendarId: calendarId,
		eventId: eventId,
		singleValueLegacyExtendedPropertyId: singleValueLegacyExtendedPropertyId,
	}
}

// Execute executes the request
func (a *MeCalendarGroupApiService) MeCalendarGroupsCalendarsEventsUpdateSingleValueExtendedPropertiesExecute(r ApiMeCalendarGroupsCalendarsEventsUpdateSingleValueExtendedPropertiesRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPatch
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MeCalendarGroupApiService.MeCalendarGroupsCalendarsEventsUpdateSingleValueExtendedProperties")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/calendarGroups/{calendarGroup-id}/calendars/{calendar-id}/events/{event-id}/singleValueExtendedProperties/{singleValueLegacyExtendedProperty-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"calendarGroup-id"+"}", _neturl.PathEscape(parameterToString(r.calendarGroupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"calendar-id"+"}", _neturl.PathEscape(parameterToString(r.calendarId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"singleValueLegacyExtendedProperty-id"+"}", _neturl.PathEscape(parameterToString(r.singleValueLegacyExtendedPropertyId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphSingleValueLegacyExtendedProperty == nil {
		return nil, reportError("microsoftGraphSingleValueLegacyExtendedProperty is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphSingleValueLegacyExtendedProperty
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiMeCalendarGroupsCalendarsGetCalendarPermissionsRequest struct {
	ctx _context.Context
	ApiService *MeCalendarGroupApiService
	calendarGroupId string
	calendarId string
	calendarPermissionId string
	select_ *[]string
}

// Select properties to be returned
func (r ApiMeCalendarGroupsCalendarsGetCalendarPermissionsRequest) Select_(select_ []string) ApiMeCalendarGroupsCalendarsGetCalendarPermissionsRequest {
	r.select_ = &select_
	return r
}

func (r ApiMeCalendarGroupsCalendarsGetCalendarPermissionsRequest) Execute() (MicrosoftGraphCalendarPermission, *_nethttp.Response, error) {
	return r.ApiService.MeCalendarGroupsCalendarsGetCalendarPermissionsExecute(r)
}

/*
MeCalendarGroupsCalendarsGetCalendarPermissions Get calendarPermissions from me

The permissions of the users with whom the calendar is shared.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param calendarGroupId key: id of calendarGroup
 @param calendarId key: id of calendar
 @param calendarPermissionId key: id of calendarPermission
 @return ApiMeCalendarGroupsCalendarsGetCalendarPermissionsRequest
*/
func (a *MeCalendarGroupApiService) MeCalendarGroupsCalendarsGetCalendarPermissions(ctx _context.Context, calendarGroupId string, calendarId string, calendarPermissionId string) ApiMeCalendarGroupsCalendarsGetCalendarPermissionsRequest {
	return ApiMeCalendarGroupsCalendarsGetCalendarPermissionsRequest{
		ApiService: a,
		ctx: ctx,
		calendarGroupId: calendarGroupId,
		calendarId: calendarId,
		calendarPermissionId: calendarPermissionId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphCalendarPermission
func (a *MeCalendarGroupApiService) MeCalendarGroupsCalendarsGetCalendarPermissionsExecute(r ApiMeCalendarGroupsCalendarsGetCalendarPermissionsRequest) (MicrosoftGraphCalendarPermission, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphCalendarPermission
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MeCalendarGroupApiService.MeCalendarGroupsCalendarsGetCalendarPermissions")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/calendarGroups/{calendarGroup-id}/calendars/{calendar-id}/calendarPermissions/{calendarPermission-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"calendarGroup-id"+"}", _neturl.PathEscape(parameterToString(r.calendarGroupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"calendar-id"+"}", _neturl.PathEscape(parameterToString(r.calendarId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"calendarPermission-id"+"}", _neturl.PathEscape(parameterToString(r.calendarPermissionId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMeCalendarGroupsCalendarsGetCalendarViewRequest struct {
	ctx _context.Context
	ApiService *MeCalendarGroupApiService
	calendarGroupId string
	calendarId string
	eventId string
	select_ *[]string
}

// Select properties to be returned
func (r ApiMeCalendarGroupsCalendarsGetCalendarViewRequest) Select_(select_ []string) ApiMeCalendarGroupsCalendarsGetCalendarViewRequest {
	r.select_ = &select_
	return r
}

func (r ApiMeCalendarGroupsCalendarsGetCalendarViewRequest) Execute() (MicrosoftGraphEvent, *_nethttp.Response, error) {
	return r.ApiService.MeCalendarGroupsCalendarsGetCalendarViewExecute(r)
}

/*
MeCalendarGroupsCalendarsGetCalendarView Get calendarView from me

The calendar view for the calendar. Navigation property. Read-only.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param calendarGroupId key: id of calendarGroup
 @param calendarId key: id of calendar
 @param eventId key: id of event
 @return ApiMeCalendarGroupsCalendarsGetCalendarViewRequest
*/
func (a *MeCalendarGroupApiService) MeCalendarGroupsCalendarsGetCalendarView(ctx _context.Context, calendarGroupId string, calendarId string, eventId string) ApiMeCalendarGroupsCalendarsGetCalendarViewRequest {
	return ApiMeCalendarGroupsCalendarsGetCalendarViewRequest{
		ApiService: a,
		ctx: ctx,
		calendarGroupId: calendarGroupId,
		calendarId: calendarId,
		eventId: eventId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphEvent
func (a *MeCalendarGroupApiService) MeCalendarGroupsCalendarsGetCalendarViewExecute(r ApiMeCalendarGroupsCalendarsGetCalendarViewRequest) (MicrosoftGraphEvent, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphEvent
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MeCalendarGroupApiService.MeCalendarGroupsCalendarsGetCalendarView")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/calendarGroups/{calendarGroup-id}/calendars/{calendar-id}/calendarView/{event-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"calendarGroup-id"+"}", _neturl.PathEscape(parameterToString(r.calendarGroupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"calendar-id"+"}", _neturl.PathEscape(parameterToString(r.calendarId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMeCalendarGroupsCalendarsGetEventsRequest struct {
	ctx _context.Context
	ApiService *MeCalendarGroupApiService
	calendarGroupId string
	calendarId string
	eventId string
	select_ *[]string
}

// Select properties to be returned
func (r ApiMeCalendarGroupsCalendarsGetEventsRequest) Select_(select_ []string) ApiMeCalendarGroupsCalendarsGetEventsRequest {
	r.select_ = &select_
	return r
}

func (r ApiMeCalendarGroupsCalendarsGetEventsRequest) Execute() (MicrosoftGraphEvent, *_nethttp.Response, error) {
	return r.ApiService.MeCalendarGroupsCalendarsGetEventsExecute(r)
}

/*
MeCalendarGroupsCalendarsGetEvents Get events from me

The events in the calendar. Navigation property. Read-only.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param calendarGroupId key: id of calendarGroup
 @param calendarId key: id of calendar
 @param eventId key: id of event
 @return ApiMeCalendarGroupsCalendarsGetEventsRequest
*/
func (a *MeCalendarGroupApiService) MeCalendarGroupsCalendarsGetEvents(ctx _context.Context, calendarGroupId string, calendarId string, eventId string) ApiMeCalendarGroupsCalendarsGetEventsRequest {
	return ApiMeCalendarGroupsCalendarsGetEventsRequest{
		ApiService: a,
		ctx: ctx,
		calendarGroupId: calendarGroupId,
		calendarId: calendarId,
		eventId: eventId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphEvent
func (a *MeCalendarGroupApiService) MeCalendarGroupsCalendarsGetEventsExecute(r ApiMeCalendarGroupsCalendarsGetEventsRequest) (MicrosoftGraphEvent, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphEvent
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MeCalendarGroupApiService.MeCalendarGroupsCalendarsGetEvents")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/calendarGroups/{calendarGroup-id}/calendars/{calendar-id}/events/{event-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"calendarGroup-id"+"}", _neturl.PathEscape(parameterToString(r.calendarGroupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"calendar-id"+"}", _neturl.PathEscape(parameterToString(r.calendarId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMeCalendarGroupsCalendarsGetMultiValueExtendedPropertiesRequest struct {
	ctx _context.Context
	ApiService *MeCalendarGroupApiService
	calendarGroupId string
	calendarId string
	multiValueLegacyExtendedPropertyId string
	select_ *[]string
	expand *[]string
}

// Select properties to be returned
func (r ApiMeCalendarGroupsCalendarsGetMultiValueExtendedPropertiesRequest) Select_(select_ []string) ApiMeCalendarGroupsCalendarsGetMultiValueExtendedPropertiesRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiMeCalendarGroupsCalendarsGetMultiValueExtendedPropertiesRequest) Expand(expand []string) ApiMeCalendarGroupsCalendarsGetMultiValueExtendedPropertiesRequest {
	r.expand = &expand
	return r
}

func (r ApiMeCalendarGroupsCalendarsGetMultiValueExtendedPropertiesRequest) Execute() (MicrosoftGraphMultiValueLegacyExtendedProperty, *_nethttp.Response, error) {
	return r.ApiService.MeCalendarGroupsCalendarsGetMultiValueExtendedPropertiesExecute(r)
}

/*
MeCalendarGroupsCalendarsGetMultiValueExtendedProperties Get multiValueExtendedProperties from me

The collection of multi-value extended properties defined for the calendar. Read-only. Nullable.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param calendarGroupId key: id of calendarGroup
 @param calendarId key: id of calendar
 @param multiValueLegacyExtendedPropertyId key: id of multiValueLegacyExtendedProperty
 @return ApiMeCalendarGroupsCalendarsGetMultiValueExtendedPropertiesRequest
*/
func (a *MeCalendarGroupApiService) MeCalendarGroupsCalendarsGetMultiValueExtendedProperties(ctx _context.Context, calendarGroupId string, calendarId string, multiValueLegacyExtendedPropertyId string) ApiMeCalendarGroupsCalendarsGetMultiValueExtendedPropertiesRequest {
	return ApiMeCalendarGroupsCalendarsGetMultiValueExtendedPropertiesRequest{
		ApiService: a,
		ctx: ctx,
		calendarGroupId: calendarGroupId,
		calendarId: calendarId,
		multiValueLegacyExtendedPropertyId: multiValueLegacyExtendedPropertyId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphMultiValueLegacyExtendedProperty
func (a *MeCalendarGroupApiService) MeCalendarGroupsCalendarsGetMultiValueExtendedPropertiesExecute(r ApiMeCalendarGroupsCalendarsGetMultiValueExtendedPropertiesRequest) (MicrosoftGraphMultiValueLegacyExtendedProperty, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphMultiValueLegacyExtendedProperty
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MeCalendarGroupApiService.MeCalendarGroupsCalendarsGetMultiValueExtendedProperties")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/calendarGroups/{calendarGroup-id}/calendars/{calendar-id}/multiValueExtendedProperties/{multiValueLegacyExtendedProperty-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"calendarGroup-id"+"}", _neturl.PathEscape(parameterToString(r.calendarGroupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"calendar-id"+"}", _neturl.PathEscape(parameterToString(r.calendarId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"multiValueLegacyExtendedProperty-id"+"}", _neturl.PathEscape(parameterToString(r.multiValueLegacyExtendedPropertyId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMeCalendarGroupsCalendarsGetSingleValueExtendedPropertiesRequest struct {
	ctx _context.Context
	ApiService *MeCalendarGroupApiService
	calendarGroupId string
	calendarId string
	singleValueLegacyExtendedPropertyId string
	select_ *[]string
	expand *[]string
}

// Select properties to be returned
func (r ApiMeCalendarGroupsCalendarsGetSingleValueExtendedPropertiesRequest) Select_(select_ []string) ApiMeCalendarGroupsCalendarsGetSingleValueExtendedPropertiesRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiMeCalendarGroupsCalendarsGetSingleValueExtendedPropertiesRequest) Expand(expand []string) ApiMeCalendarGroupsCalendarsGetSingleValueExtendedPropertiesRequest {
	r.expand = &expand
	return r
}

func (r ApiMeCalendarGroupsCalendarsGetSingleValueExtendedPropertiesRequest) Execute() (MicrosoftGraphSingleValueLegacyExtendedProperty, *_nethttp.Response, error) {
	return r.ApiService.MeCalendarGroupsCalendarsGetSingleValueExtendedPropertiesExecute(r)
}

/*
MeCalendarGroupsCalendarsGetSingleValueExtendedProperties Get singleValueExtendedProperties from me

The collection of single-value extended properties defined for the calendar. Read-only. Nullable.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param calendarGroupId key: id of calendarGroup
 @param calendarId key: id of calendar
 @param singleValueLegacyExtendedPropertyId key: id of singleValueLegacyExtendedProperty
 @return ApiMeCalendarGroupsCalendarsGetSingleValueExtendedPropertiesRequest
*/
func (a *MeCalendarGroupApiService) MeCalendarGroupsCalendarsGetSingleValueExtendedProperties(ctx _context.Context, calendarGroupId string, calendarId string, singleValueLegacyExtendedPropertyId string) ApiMeCalendarGroupsCalendarsGetSingleValueExtendedPropertiesRequest {
	return ApiMeCalendarGroupsCalendarsGetSingleValueExtendedPropertiesRequest{
		ApiService: a,
		ctx: ctx,
		calendarGroupId: calendarGroupId,
		calendarId: calendarId,
		singleValueLegacyExtendedPropertyId: singleValueLegacyExtendedPropertyId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphSingleValueLegacyExtendedProperty
func (a *MeCalendarGroupApiService) MeCalendarGroupsCalendarsGetSingleValueExtendedPropertiesExecute(r ApiMeCalendarGroupsCalendarsGetSingleValueExtendedPropertiesRequest) (MicrosoftGraphSingleValueLegacyExtendedProperty, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphSingleValueLegacyExtendedProperty
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MeCalendarGroupApiService.MeCalendarGroupsCalendarsGetSingleValueExtendedProperties")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/calendarGroups/{calendarGroup-id}/calendars/{calendar-id}/singleValueExtendedProperties/{singleValueLegacyExtendedProperty-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"calendarGroup-id"+"}", _neturl.PathEscape(parameterToString(r.calendarGroupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"calendar-id"+"}", _neturl.PathEscape(parameterToString(r.calendarId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"singleValueLegacyExtendedProperty-id"+"}", _neturl.PathEscape(parameterToString(r.singleValueLegacyExtendedPropertyId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMeCalendarGroupsCalendarsListCalendarPermissionsRequest struct {
	ctx _context.Context
	ApiService *MeCalendarGroupApiService
	calendarGroupId string
	calendarId string
	top *int32
	skip *int32
	filter *string
	count *bool
	orderby *[]string
	select_ *[]string
}

// Show only the first n items
func (r ApiMeCalendarGroupsCalendarsListCalendarPermissionsRequest) Top(top int32) ApiMeCalendarGroupsCalendarsListCalendarPermissionsRequest {
	r.top = &top
	return r
}
// Skip the first n items
func (r ApiMeCalendarGroupsCalendarsListCalendarPermissionsRequest) Skip(skip int32) ApiMeCalendarGroupsCalendarsListCalendarPermissionsRequest {
	r.skip = &skip
	return r
}
// Filter items by property values
func (r ApiMeCalendarGroupsCalendarsListCalendarPermissionsRequest) Filter(filter string) ApiMeCalendarGroupsCalendarsListCalendarPermissionsRequest {
	r.filter = &filter
	return r
}
// Include count of items
func (r ApiMeCalendarGroupsCalendarsListCalendarPermissionsRequest) Count(count bool) ApiMeCalendarGroupsCalendarsListCalendarPermissionsRequest {
	r.count = &count
	return r
}
// Order items by property values
func (r ApiMeCalendarGroupsCalendarsListCalendarPermissionsRequest) Orderby(orderby []string) ApiMeCalendarGroupsCalendarsListCalendarPermissionsRequest {
	r.orderby = &orderby
	return r
}
// Select properties to be returned
func (r ApiMeCalendarGroupsCalendarsListCalendarPermissionsRequest) Select_(select_ []string) ApiMeCalendarGroupsCalendarsListCalendarPermissionsRequest {
	r.select_ = &select_
	return r
}

func (r ApiMeCalendarGroupsCalendarsListCalendarPermissionsRequest) Execute() (CollectionOfCalendarPermission, *_nethttp.Response, error) {
	return r.ApiService.MeCalendarGroupsCalendarsListCalendarPermissionsExecute(r)
}

/*
MeCalendarGroupsCalendarsListCalendarPermissions Get calendarPermissions from me

The permissions of the users with whom the calendar is shared.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param calendarGroupId key: id of calendarGroup
 @param calendarId key: id of calendar
 @return ApiMeCalendarGroupsCalendarsListCalendarPermissionsRequest
*/
func (a *MeCalendarGroupApiService) MeCalendarGroupsCalendarsListCalendarPermissions(ctx _context.Context, calendarGroupId string, calendarId string) ApiMeCalendarGroupsCalendarsListCalendarPermissionsRequest {
	return ApiMeCalendarGroupsCalendarsListCalendarPermissionsRequest{
		ApiService: a,
		ctx: ctx,
		calendarGroupId: calendarGroupId,
		calendarId: calendarId,
	}
}

// Execute executes the request
//  @return CollectionOfCalendarPermission
func (a *MeCalendarGroupApiService) MeCalendarGroupsCalendarsListCalendarPermissionsExecute(r ApiMeCalendarGroupsCalendarsListCalendarPermissionsRequest) (CollectionOfCalendarPermission, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  CollectionOfCalendarPermission
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MeCalendarGroupApiService.MeCalendarGroupsCalendarsListCalendarPermissions")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/calendarGroups/{calendarGroup-id}/calendars/{calendar-id}/calendarPermissions"
	localVarPath = strings.Replace(localVarPath, "{"+"calendarGroup-id"+"}", _neturl.PathEscape(parameterToString(r.calendarGroupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"calendar-id"+"}", _neturl.PathEscape(parameterToString(r.calendarId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.top != nil {
		localVarQueryParams.Add("$top", parameterToString(*r.top, ""))
	}
	if r.skip != nil {
		localVarQueryParams.Add("$skip", parameterToString(*r.skip, ""))
	}
	if r.filter != nil {
		localVarQueryParams.Add("$filter", parameterToString(*r.filter, ""))
	}
	if r.count != nil {
		localVarQueryParams.Add("$count", parameterToString(*r.count, ""))
	}
	if r.orderby != nil {
		localVarQueryParams.Add("$orderby", parameterToString(*r.orderby, "csv"))
	}
	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMeCalendarGroupsCalendarsListCalendarViewRequest struct {
	ctx _context.Context
	ApiService *MeCalendarGroupApiService
	calendarGroupId string
	calendarId string
	top *int32
	skip *int32
	filter *string
	count *bool
	orderby *[]string
	select_ *[]string
}

// Show only the first n items
func (r ApiMeCalendarGroupsCalendarsListCalendarViewRequest) Top(top int32) ApiMeCalendarGroupsCalendarsListCalendarViewRequest {
	r.top = &top
	return r
}
// Skip the first n items
func (r ApiMeCalendarGroupsCalendarsListCalendarViewRequest) Skip(skip int32) ApiMeCalendarGroupsCalendarsListCalendarViewRequest {
	r.skip = &skip
	return r
}
// Filter items by property values
func (r ApiMeCalendarGroupsCalendarsListCalendarViewRequest) Filter(filter string) ApiMeCalendarGroupsCalendarsListCalendarViewRequest {
	r.filter = &filter
	return r
}
// Include count of items
func (r ApiMeCalendarGroupsCalendarsListCalendarViewRequest) Count(count bool) ApiMeCalendarGroupsCalendarsListCalendarViewRequest {
	r.count = &count
	return r
}
// Order items by property values
func (r ApiMeCalendarGroupsCalendarsListCalendarViewRequest) Orderby(orderby []string) ApiMeCalendarGroupsCalendarsListCalendarViewRequest {
	r.orderby = &orderby
	return r
}
// Select properties to be returned
func (r ApiMeCalendarGroupsCalendarsListCalendarViewRequest) Select_(select_ []string) ApiMeCalendarGroupsCalendarsListCalendarViewRequest {
	r.select_ = &select_
	return r
}

func (r ApiMeCalendarGroupsCalendarsListCalendarViewRequest) Execute() (CollectionOfEvent, *_nethttp.Response, error) {
	return r.ApiService.MeCalendarGroupsCalendarsListCalendarViewExecute(r)
}

/*
MeCalendarGroupsCalendarsListCalendarView Get calendarView from me

The calendar view for the calendar. Navigation property. Read-only.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param calendarGroupId key: id of calendarGroup
 @param calendarId key: id of calendar
 @return ApiMeCalendarGroupsCalendarsListCalendarViewRequest
*/
func (a *MeCalendarGroupApiService) MeCalendarGroupsCalendarsListCalendarView(ctx _context.Context, calendarGroupId string, calendarId string) ApiMeCalendarGroupsCalendarsListCalendarViewRequest {
	return ApiMeCalendarGroupsCalendarsListCalendarViewRequest{
		ApiService: a,
		ctx: ctx,
		calendarGroupId: calendarGroupId,
		calendarId: calendarId,
	}
}

// Execute executes the request
//  @return CollectionOfEvent
func (a *MeCalendarGroupApiService) MeCalendarGroupsCalendarsListCalendarViewExecute(r ApiMeCalendarGroupsCalendarsListCalendarViewRequest) (CollectionOfEvent, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  CollectionOfEvent
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MeCalendarGroupApiService.MeCalendarGroupsCalendarsListCalendarView")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/calendarGroups/{calendarGroup-id}/calendars/{calendar-id}/calendarView"
	localVarPath = strings.Replace(localVarPath, "{"+"calendarGroup-id"+"}", _neturl.PathEscape(parameterToString(r.calendarGroupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"calendar-id"+"}", _neturl.PathEscape(parameterToString(r.calendarId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.top != nil {
		localVarQueryParams.Add("$top", parameterToString(*r.top, ""))
	}
	if r.skip != nil {
		localVarQueryParams.Add("$skip", parameterToString(*r.skip, ""))
	}
	if r.filter != nil {
		localVarQueryParams.Add("$filter", parameterToString(*r.filter, ""))
	}
	if r.count != nil {
		localVarQueryParams.Add("$count", parameterToString(*r.count, ""))
	}
	if r.orderby != nil {
		localVarQueryParams.Add("$orderby", parameterToString(*r.orderby, "csv"))
	}
	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMeCalendarGroupsCalendarsListEventsRequest struct {
	ctx _context.Context
	ApiService *MeCalendarGroupApiService
	calendarGroupId string
	calendarId string
	top *int32
	skip *int32
	filter *string
	count *bool
	orderby *[]string
	select_ *[]string
}

// Show only the first n items
func (r ApiMeCalendarGroupsCalendarsListEventsRequest) Top(top int32) ApiMeCalendarGroupsCalendarsListEventsRequest {
	r.top = &top
	return r
}
// Skip the first n items
func (r ApiMeCalendarGroupsCalendarsListEventsRequest) Skip(skip int32) ApiMeCalendarGroupsCalendarsListEventsRequest {
	r.skip = &skip
	return r
}
// Filter items by property values
func (r ApiMeCalendarGroupsCalendarsListEventsRequest) Filter(filter string) ApiMeCalendarGroupsCalendarsListEventsRequest {
	r.filter = &filter
	return r
}
// Include count of items
func (r ApiMeCalendarGroupsCalendarsListEventsRequest) Count(count bool) ApiMeCalendarGroupsCalendarsListEventsRequest {
	r.count = &count
	return r
}
// Order items by property values
func (r ApiMeCalendarGroupsCalendarsListEventsRequest) Orderby(orderby []string) ApiMeCalendarGroupsCalendarsListEventsRequest {
	r.orderby = &orderby
	return r
}
// Select properties to be returned
func (r ApiMeCalendarGroupsCalendarsListEventsRequest) Select_(select_ []string) ApiMeCalendarGroupsCalendarsListEventsRequest {
	r.select_ = &select_
	return r
}

func (r ApiMeCalendarGroupsCalendarsListEventsRequest) Execute() (CollectionOfEvent, *_nethttp.Response, error) {
	return r.ApiService.MeCalendarGroupsCalendarsListEventsExecute(r)
}

/*
MeCalendarGroupsCalendarsListEvents Get events from me

The events in the calendar. Navigation property. Read-only.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param calendarGroupId key: id of calendarGroup
 @param calendarId key: id of calendar
 @return ApiMeCalendarGroupsCalendarsListEventsRequest
*/
func (a *MeCalendarGroupApiService) MeCalendarGroupsCalendarsListEvents(ctx _context.Context, calendarGroupId string, calendarId string) ApiMeCalendarGroupsCalendarsListEventsRequest {
	return ApiMeCalendarGroupsCalendarsListEventsRequest{
		ApiService: a,
		ctx: ctx,
		calendarGroupId: calendarGroupId,
		calendarId: calendarId,
	}
}

// Execute executes the request
//  @return CollectionOfEvent
func (a *MeCalendarGroupApiService) MeCalendarGroupsCalendarsListEventsExecute(r ApiMeCalendarGroupsCalendarsListEventsRequest) (CollectionOfEvent, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  CollectionOfEvent
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MeCalendarGroupApiService.MeCalendarGroupsCalendarsListEvents")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/calendarGroups/{calendarGroup-id}/calendars/{calendar-id}/events"
	localVarPath = strings.Replace(localVarPath, "{"+"calendarGroup-id"+"}", _neturl.PathEscape(parameterToString(r.calendarGroupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"calendar-id"+"}", _neturl.PathEscape(parameterToString(r.calendarId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.top != nil {
		localVarQueryParams.Add("$top", parameterToString(*r.top, ""))
	}
	if r.skip != nil {
		localVarQueryParams.Add("$skip", parameterToString(*r.skip, ""))
	}
	if r.filter != nil {
		localVarQueryParams.Add("$filter", parameterToString(*r.filter, ""))
	}
	if r.count != nil {
		localVarQueryParams.Add("$count", parameterToString(*r.count, ""))
	}
	if r.orderby != nil {
		localVarQueryParams.Add("$orderby", parameterToString(*r.orderby, "csv"))
	}
	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMeCalendarGroupsCalendarsListMultiValueExtendedPropertiesRequest struct {
	ctx _context.Context
	ApiService *MeCalendarGroupApiService
	calendarGroupId string
	calendarId string
	top *int32
	skip *int32
	search *string
	filter *string
	count *bool
	orderby *[]string
	select_ *[]string
	expand *[]string
}

// Show only the first n items
func (r ApiMeCalendarGroupsCalendarsListMultiValueExtendedPropertiesRequest) Top(top int32) ApiMeCalendarGroupsCalendarsListMultiValueExtendedPropertiesRequest {
	r.top = &top
	return r
}
// Skip the first n items
func (r ApiMeCalendarGroupsCalendarsListMultiValueExtendedPropertiesRequest) Skip(skip int32) ApiMeCalendarGroupsCalendarsListMultiValueExtendedPropertiesRequest {
	r.skip = &skip
	return r
}
// Search items by search phrases
func (r ApiMeCalendarGroupsCalendarsListMultiValueExtendedPropertiesRequest) Search(search string) ApiMeCalendarGroupsCalendarsListMultiValueExtendedPropertiesRequest {
	r.search = &search
	return r
}
// Filter items by property values
func (r ApiMeCalendarGroupsCalendarsListMultiValueExtendedPropertiesRequest) Filter(filter string) ApiMeCalendarGroupsCalendarsListMultiValueExtendedPropertiesRequest {
	r.filter = &filter
	return r
}
// Include count of items
func (r ApiMeCalendarGroupsCalendarsListMultiValueExtendedPropertiesRequest) Count(count bool) ApiMeCalendarGroupsCalendarsListMultiValueExtendedPropertiesRequest {
	r.count = &count
	return r
}
// Order items by property values
func (r ApiMeCalendarGroupsCalendarsListMultiValueExtendedPropertiesRequest) Orderby(orderby []string) ApiMeCalendarGroupsCalendarsListMultiValueExtendedPropertiesRequest {
	r.orderby = &orderby
	return r
}
// Select properties to be returned
func (r ApiMeCalendarGroupsCalendarsListMultiValueExtendedPropertiesRequest) Select_(select_ []string) ApiMeCalendarGroupsCalendarsListMultiValueExtendedPropertiesRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiMeCalendarGroupsCalendarsListMultiValueExtendedPropertiesRequest) Expand(expand []string) ApiMeCalendarGroupsCalendarsListMultiValueExtendedPropertiesRequest {
	r.expand = &expand
	return r
}

func (r ApiMeCalendarGroupsCalendarsListMultiValueExtendedPropertiesRequest) Execute() (CollectionOfMultiValueLegacyExtendedProperty, *_nethttp.Response, error) {
	return r.ApiService.MeCalendarGroupsCalendarsListMultiValueExtendedPropertiesExecute(r)
}

/*
MeCalendarGroupsCalendarsListMultiValueExtendedProperties Get multiValueExtendedProperties from me

The collection of multi-value extended properties defined for the calendar. Read-only. Nullable.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param calendarGroupId key: id of calendarGroup
 @param calendarId key: id of calendar
 @return ApiMeCalendarGroupsCalendarsListMultiValueExtendedPropertiesRequest
*/
func (a *MeCalendarGroupApiService) MeCalendarGroupsCalendarsListMultiValueExtendedProperties(ctx _context.Context, calendarGroupId string, calendarId string) ApiMeCalendarGroupsCalendarsListMultiValueExtendedPropertiesRequest {
	return ApiMeCalendarGroupsCalendarsListMultiValueExtendedPropertiesRequest{
		ApiService: a,
		ctx: ctx,
		calendarGroupId: calendarGroupId,
		calendarId: calendarId,
	}
}

// Execute executes the request
//  @return CollectionOfMultiValueLegacyExtendedProperty
func (a *MeCalendarGroupApiService) MeCalendarGroupsCalendarsListMultiValueExtendedPropertiesExecute(r ApiMeCalendarGroupsCalendarsListMultiValueExtendedPropertiesRequest) (CollectionOfMultiValueLegacyExtendedProperty, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  CollectionOfMultiValueLegacyExtendedProperty
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MeCalendarGroupApiService.MeCalendarGroupsCalendarsListMultiValueExtendedProperties")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/calendarGroups/{calendarGroup-id}/calendars/{calendar-id}/multiValueExtendedProperties"
	localVarPath = strings.Replace(localVarPath, "{"+"calendarGroup-id"+"}", _neturl.PathEscape(parameterToString(r.calendarGroupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"calendar-id"+"}", _neturl.PathEscape(parameterToString(r.calendarId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.top != nil {
		localVarQueryParams.Add("$top", parameterToString(*r.top, ""))
	}
	if r.skip != nil {
		localVarQueryParams.Add("$skip", parameterToString(*r.skip, ""))
	}
	if r.search != nil {
		localVarQueryParams.Add("$search", parameterToString(*r.search, ""))
	}
	if r.filter != nil {
		localVarQueryParams.Add("$filter", parameterToString(*r.filter, ""))
	}
	if r.count != nil {
		localVarQueryParams.Add("$count", parameterToString(*r.count, ""))
	}
	if r.orderby != nil {
		localVarQueryParams.Add("$orderby", parameterToString(*r.orderby, "csv"))
	}
	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMeCalendarGroupsCalendarsListSingleValueExtendedPropertiesRequest struct {
	ctx _context.Context
	ApiService *MeCalendarGroupApiService
	calendarGroupId string
	calendarId string
	top *int32
	skip *int32
	search *string
	filter *string
	count *bool
	orderby *[]string
	select_ *[]string
	expand *[]string
}

// Show only the first n items
func (r ApiMeCalendarGroupsCalendarsListSingleValueExtendedPropertiesRequest) Top(top int32) ApiMeCalendarGroupsCalendarsListSingleValueExtendedPropertiesRequest {
	r.top = &top
	return r
}
// Skip the first n items
func (r ApiMeCalendarGroupsCalendarsListSingleValueExtendedPropertiesRequest) Skip(skip int32) ApiMeCalendarGroupsCalendarsListSingleValueExtendedPropertiesRequest {
	r.skip = &skip
	return r
}
// Search items by search phrases
func (r ApiMeCalendarGroupsCalendarsListSingleValueExtendedPropertiesRequest) Search(search string) ApiMeCalendarGroupsCalendarsListSingleValueExtendedPropertiesRequest {
	r.search = &search
	return r
}
// Filter items by property values
func (r ApiMeCalendarGroupsCalendarsListSingleValueExtendedPropertiesRequest) Filter(filter string) ApiMeCalendarGroupsCalendarsListSingleValueExtendedPropertiesRequest {
	r.filter = &filter
	return r
}
// Include count of items
func (r ApiMeCalendarGroupsCalendarsListSingleValueExtendedPropertiesRequest) Count(count bool) ApiMeCalendarGroupsCalendarsListSingleValueExtendedPropertiesRequest {
	r.count = &count
	return r
}
// Order items by property values
func (r ApiMeCalendarGroupsCalendarsListSingleValueExtendedPropertiesRequest) Orderby(orderby []string) ApiMeCalendarGroupsCalendarsListSingleValueExtendedPropertiesRequest {
	r.orderby = &orderby
	return r
}
// Select properties to be returned
func (r ApiMeCalendarGroupsCalendarsListSingleValueExtendedPropertiesRequest) Select_(select_ []string) ApiMeCalendarGroupsCalendarsListSingleValueExtendedPropertiesRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiMeCalendarGroupsCalendarsListSingleValueExtendedPropertiesRequest) Expand(expand []string) ApiMeCalendarGroupsCalendarsListSingleValueExtendedPropertiesRequest {
	r.expand = &expand
	return r
}

func (r ApiMeCalendarGroupsCalendarsListSingleValueExtendedPropertiesRequest) Execute() (CollectionOfSingleValueLegacyExtendedProperty, *_nethttp.Response, error) {
	return r.ApiService.MeCalendarGroupsCalendarsListSingleValueExtendedPropertiesExecute(r)
}

/*
MeCalendarGroupsCalendarsListSingleValueExtendedProperties Get singleValueExtendedProperties from me

The collection of single-value extended properties defined for the calendar. Read-only. Nullable.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param calendarGroupId key: id of calendarGroup
 @param calendarId key: id of calendar
 @return ApiMeCalendarGroupsCalendarsListSingleValueExtendedPropertiesRequest
*/
func (a *MeCalendarGroupApiService) MeCalendarGroupsCalendarsListSingleValueExtendedProperties(ctx _context.Context, calendarGroupId string, calendarId string) ApiMeCalendarGroupsCalendarsListSingleValueExtendedPropertiesRequest {
	return ApiMeCalendarGroupsCalendarsListSingleValueExtendedPropertiesRequest{
		ApiService: a,
		ctx: ctx,
		calendarGroupId: calendarGroupId,
		calendarId: calendarId,
	}
}

// Execute executes the request
//  @return CollectionOfSingleValueLegacyExtendedProperty
func (a *MeCalendarGroupApiService) MeCalendarGroupsCalendarsListSingleValueExtendedPropertiesExecute(r ApiMeCalendarGroupsCalendarsListSingleValueExtendedPropertiesRequest) (CollectionOfSingleValueLegacyExtendedProperty, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  CollectionOfSingleValueLegacyExtendedProperty
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MeCalendarGroupApiService.MeCalendarGroupsCalendarsListSingleValueExtendedProperties")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/calendarGroups/{calendarGroup-id}/calendars/{calendar-id}/singleValueExtendedProperties"
	localVarPath = strings.Replace(localVarPath, "{"+"calendarGroup-id"+"}", _neturl.PathEscape(parameterToString(r.calendarGroupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"calendar-id"+"}", _neturl.PathEscape(parameterToString(r.calendarId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.top != nil {
		localVarQueryParams.Add("$top", parameterToString(*r.top, ""))
	}
	if r.skip != nil {
		localVarQueryParams.Add("$skip", parameterToString(*r.skip, ""))
	}
	if r.search != nil {
		localVarQueryParams.Add("$search", parameterToString(*r.search, ""))
	}
	if r.filter != nil {
		localVarQueryParams.Add("$filter", parameterToString(*r.filter, ""))
	}
	if r.count != nil {
		localVarQueryParams.Add("$count", parameterToString(*r.count, ""))
	}
	if r.orderby != nil {
		localVarQueryParams.Add("$orderby", parameterToString(*r.orderby, "csv"))
	}
	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMeCalendarGroupsCalendarsUpdateCalendarPermissionsRequest struct {
	ctx _context.Context
	ApiService *MeCalendarGroupApiService
	calendarGroupId string
	calendarId string
	calendarPermissionId string
	microsoftGraphCalendarPermission *MicrosoftGraphCalendarPermission
}

// New navigation property values
func (r ApiMeCalendarGroupsCalendarsUpdateCalendarPermissionsRequest) MicrosoftGraphCalendarPermission(microsoftGraphCalendarPermission MicrosoftGraphCalendarPermission) ApiMeCalendarGroupsCalendarsUpdateCalendarPermissionsRequest {
	r.microsoftGraphCalendarPermission = &microsoftGraphCalendarPermission
	return r
}

func (r ApiMeCalendarGroupsCalendarsUpdateCalendarPermissionsRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.MeCalendarGroupsCalendarsUpdateCalendarPermissionsExecute(r)
}

/*
MeCalendarGroupsCalendarsUpdateCalendarPermissions Update the navigation property calendarPermissions in me

The permissions of the users with whom the calendar is shared.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param calendarGroupId key: id of calendarGroup
 @param calendarId key: id of calendar
 @param calendarPermissionId key: id of calendarPermission
 @return ApiMeCalendarGroupsCalendarsUpdateCalendarPermissionsRequest
*/
func (a *MeCalendarGroupApiService) MeCalendarGroupsCalendarsUpdateCalendarPermissions(ctx _context.Context, calendarGroupId string, calendarId string, calendarPermissionId string) ApiMeCalendarGroupsCalendarsUpdateCalendarPermissionsRequest {
	return ApiMeCalendarGroupsCalendarsUpdateCalendarPermissionsRequest{
		ApiService: a,
		ctx: ctx,
		calendarGroupId: calendarGroupId,
		calendarId: calendarId,
		calendarPermissionId: calendarPermissionId,
	}
}

// Execute executes the request
func (a *MeCalendarGroupApiService) MeCalendarGroupsCalendarsUpdateCalendarPermissionsExecute(r ApiMeCalendarGroupsCalendarsUpdateCalendarPermissionsRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPatch
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MeCalendarGroupApiService.MeCalendarGroupsCalendarsUpdateCalendarPermissions")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/calendarGroups/{calendarGroup-id}/calendars/{calendar-id}/calendarPermissions/{calendarPermission-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"calendarGroup-id"+"}", _neturl.PathEscape(parameterToString(r.calendarGroupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"calendar-id"+"}", _neturl.PathEscape(parameterToString(r.calendarId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"calendarPermission-id"+"}", _neturl.PathEscape(parameterToString(r.calendarPermissionId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphCalendarPermission == nil {
		return nil, reportError("microsoftGraphCalendarPermission is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphCalendarPermission
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiMeCalendarGroupsCalendarsUpdateCalendarViewRequest struct {
	ctx _context.Context
	ApiService *MeCalendarGroupApiService
	calendarGroupId string
	calendarId string
	eventId string
	microsoftGraphEvent *MicrosoftGraphEvent
}

// New navigation property values
func (r ApiMeCalendarGroupsCalendarsUpdateCalendarViewRequest) MicrosoftGraphEvent(microsoftGraphEvent MicrosoftGraphEvent) ApiMeCalendarGroupsCalendarsUpdateCalendarViewRequest {
	r.microsoftGraphEvent = &microsoftGraphEvent
	return r
}

func (r ApiMeCalendarGroupsCalendarsUpdateCalendarViewRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.MeCalendarGroupsCalendarsUpdateCalendarViewExecute(r)
}

/*
MeCalendarGroupsCalendarsUpdateCalendarView Update the navigation property calendarView in me

The calendar view for the calendar. Navigation property. Read-only.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param calendarGroupId key: id of calendarGroup
 @param calendarId key: id of calendar
 @param eventId key: id of event
 @return ApiMeCalendarGroupsCalendarsUpdateCalendarViewRequest
*/
func (a *MeCalendarGroupApiService) MeCalendarGroupsCalendarsUpdateCalendarView(ctx _context.Context, calendarGroupId string, calendarId string, eventId string) ApiMeCalendarGroupsCalendarsUpdateCalendarViewRequest {
	return ApiMeCalendarGroupsCalendarsUpdateCalendarViewRequest{
		ApiService: a,
		ctx: ctx,
		calendarGroupId: calendarGroupId,
		calendarId: calendarId,
		eventId: eventId,
	}
}

// Execute executes the request
func (a *MeCalendarGroupApiService) MeCalendarGroupsCalendarsUpdateCalendarViewExecute(r ApiMeCalendarGroupsCalendarsUpdateCalendarViewRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPatch
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MeCalendarGroupApiService.MeCalendarGroupsCalendarsUpdateCalendarView")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/calendarGroups/{calendarGroup-id}/calendars/{calendar-id}/calendarView/{event-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"calendarGroup-id"+"}", _neturl.PathEscape(parameterToString(r.calendarGroupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"calendar-id"+"}", _neturl.PathEscape(parameterToString(r.calendarId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphEvent == nil {
		return nil, reportError("microsoftGraphEvent is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphEvent
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiMeCalendarGroupsCalendarsUpdateEventsRequest struct {
	ctx _context.Context
	ApiService *MeCalendarGroupApiService
	calendarGroupId string
	calendarId string
	eventId string
	microsoftGraphEvent *MicrosoftGraphEvent
}

// New navigation property values
func (r ApiMeCalendarGroupsCalendarsUpdateEventsRequest) MicrosoftGraphEvent(microsoftGraphEvent MicrosoftGraphEvent) ApiMeCalendarGroupsCalendarsUpdateEventsRequest {
	r.microsoftGraphEvent = &microsoftGraphEvent
	return r
}

func (r ApiMeCalendarGroupsCalendarsUpdateEventsRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.MeCalendarGroupsCalendarsUpdateEventsExecute(r)
}

/*
MeCalendarGroupsCalendarsUpdateEvents Update the navigation property events in me

The events in the calendar. Navigation property. Read-only.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param calendarGroupId key: id of calendarGroup
 @param calendarId key: id of calendar
 @param eventId key: id of event
 @return ApiMeCalendarGroupsCalendarsUpdateEventsRequest
*/
func (a *MeCalendarGroupApiService) MeCalendarGroupsCalendarsUpdateEvents(ctx _context.Context, calendarGroupId string, calendarId string, eventId string) ApiMeCalendarGroupsCalendarsUpdateEventsRequest {
	return ApiMeCalendarGroupsCalendarsUpdateEventsRequest{
		ApiService: a,
		ctx: ctx,
		calendarGroupId: calendarGroupId,
		calendarId: calendarId,
		eventId: eventId,
	}
}

// Execute executes the request
func (a *MeCalendarGroupApiService) MeCalendarGroupsCalendarsUpdateEventsExecute(r ApiMeCalendarGroupsCalendarsUpdateEventsRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPatch
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MeCalendarGroupApiService.MeCalendarGroupsCalendarsUpdateEvents")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/calendarGroups/{calendarGroup-id}/calendars/{calendar-id}/events/{event-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"calendarGroup-id"+"}", _neturl.PathEscape(parameterToString(r.calendarGroupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"calendar-id"+"}", _neturl.PathEscape(parameterToString(r.calendarId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphEvent == nil {
		return nil, reportError("microsoftGraphEvent is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphEvent
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiMeCalendarGroupsCalendarsUpdateMultiValueExtendedPropertiesRequest struct {
	ctx _context.Context
	ApiService *MeCalendarGroupApiService
	calendarGroupId string
	calendarId string
	multiValueLegacyExtendedPropertyId string
	microsoftGraphMultiValueLegacyExtendedProperty *MicrosoftGraphMultiValueLegacyExtendedProperty
}

// New navigation property values
func (r ApiMeCalendarGroupsCalendarsUpdateMultiValueExtendedPropertiesRequest) MicrosoftGraphMultiValueLegacyExtendedProperty(microsoftGraphMultiValueLegacyExtendedProperty MicrosoftGraphMultiValueLegacyExtendedProperty) ApiMeCalendarGroupsCalendarsUpdateMultiValueExtendedPropertiesRequest {
	r.microsoftGraphMultiValueLegacyExtendedProperty = &microsoftGraphMultiValueLegacyExtendedProperty
	return r
}

func (r ApiMeCalendarGroupsCalendarsUpdateMultiValueExtendedPropertiesRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.MeCalendarGroupsCalendarsUpdateMultiValueExtendedPropertiesExecute(r)
}

/*
MeCalendarGroupsCalendarsUpdateMultiValueExtendedProperties Update the navigation property multiValueExtendedProperties in me

The collection of multi-value extended properties defined for the calendar. Read-only. Nullable.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param calendarGroupId key: id of calendarGroup
 @param calendarId key: id of calendar
 @param multiValueLegacyExtendedPropertyId key: id of multiValueLegacyExtendedProperty
 @return ApiMeCalendarGroupsCalendarsUpdateMultiValueExtendedPropertiesRequest
*/
func (a *MeCalendarGroupApiService) MeCalendarGroupsCalendarsUpdateMultiValueExtendedProperties(ctx _context.Context, calendarGroupId string, calendarId string, multiValueLegacyExtendedPropertyId string) ApiMeCalendarGroupsCalendarsUpdateMultiValueExtendedPropertiesRequest {
	return ApiMeCalendarGroupsCalendarsUpdateMultiValueExtendedPropertiesRequest{
		ApiService: a,
		ctx: ctx,
		calendarGroupId: calendarGroupId,
		calendarId: calendarId,
		multiValueLegacyExtendedPropertyId: multiValueLegacyExtendedPropertyId,
	}
}

// Execute executes the request
func (a *MeCalendarGroupApiService) MeCalendarGroupsCalendarsUpdateMultiValueExtendedPropertiesExecute(r ApiMeCalendarGroupsCalendarsUpdateMultiValueExtendedPropertiesRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPatch
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MeCalendarGroupApiService.MeCalendarGroupsCalendarsUpdateMultiValueExtendedProperties")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/calendarGroups/{calendarGroup-id}/calendars/{calendar-id}/multiValueExtendedProperties/{multiValueLegacyExtendedProperty-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"calendarGroup-id"+"}", _neturl.PathEscape(parameterToString(r.calendarGroupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"calendar-id"+"}", _neturl.PathEscape(parameterToString(r.calendarId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"multiValueLegacyExtendedProperty-id"+"}", _neturl.PathEscape(parameterToString(r.multiValueLegacyExtendedPropertyId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphMultiValueLegacyExtendedProperty == nil {
		return nil, reportError("microsoftGraphMultiValueLegacyExtendedProperty is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphMultiValueLegacyExtendedProperty
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiMeCalendarGroupsCalendarsUpdateSingleValueExtendedPropertiesRequest struct {
	ctx _context.Context
	ApiService *MeCalendarGroupApiService
	calendarGroupId string
	calendarId string
	singleValueLegacyExtendedPropertyId string
	microsoftGraphSingleValueLegacyExtendedProperty *MicrosoftGraphSingleValueLegacyExtendedProperty
}

// New navigation property values
func (r ApiMeCalendarGroupsCalendarsUpdateSingleValueExtendedPropertiesRequest) MicrosoftGraphSingleValueLegacyExtendedProperty(microsoftGraphSingleValueLegacyExtendedProperty MicrosoftGraphSingleValueLegacyExtendedProperty) ApiMeCalendarGroupsCalendarsUpdateSingleValueExtendedPropertiesRequest {
	r.microsoftGraphSingleValueLegacyExtendedProperty = &microsoftGraphSingleValueLegacyExtendedProperty
	return r
}

func (r ApiMeCalendarGroupsCalendarsUpdateSingleValueExtendedPropertiesRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.MeCalendarGroupsCalendarsUpdateSingleValueExtendedPropertiesExecute(r)
}

/*
MeCalendarGroupsCalendarsUpdateSingleValueExtendedProperties Update the navigation property singleValueExtendedProperties in me

The collection of single-value extended properties defined for the calendar. Read-only. Nullable.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param calendarGroupId key: id of calendarGroup
 @param calendarId key: id of calendar
 @param singleValueLegacyExtendedPropertyId key: id of singleValueLegacyExtendedProperty
 @return ApiMeCalendarGroupsCalendarsUpdateSingleValueExtendedPropertiesRequest
*/
func (a *MeCalendarGroupApiService) MeCalendarGroupsCalendarsUpdateSingleValueExtendedProperties(ctx _context.Context, calendarGroupId string, calendarId string, singleValueLegacyExtendedPropertyId string) ApiMeCalendarGroupsCalendarsUpdateSingleValueExtendedPropertiesRequest {
	return ApiMeCalendarGroupsCalendarsUpdateSingleValueExtendedPropertiesRequest{
		ApiService: a,
		ctx: ctx,
		calendarGroupId: calendarGroupId,
		calendarId: calendarId,
		singleValueLegacyExtendedPropertyId: singleValueLegacyExtendedPropertyId,
	}
}

// Execute executes the request
func (a *MeCalendarGroupApiService) MeCalendarGroupsCalendarsUpdateSingleValueExtendedPropertiesExecute(r ApiMeCalendarGroupsCalendarsUpdateSingleValueExtendedPropertiesRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPatch
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MeCalendarGroupApiService.MeCalendarGroupsCalendarsUpdateSingleValueExtendedProperties")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/calendarGroups/{calendarGroup-id}/calendars/{calendar-id}/singleValueExtendedProperties/{singleValueLegacyExtendedProperty-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"calendarGroup-id"+"}", _neturl.PathEscape(parameterToString(r.calendarGroupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"calendar-id"+"}", _neturl.PathEscape(parameterToString(r.calendarId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"singleValueLegacyExtendedProperty-id"+"}", _neturl.PathEscape(parameterToString(r.singleValueLegacyExtendedPropertyId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphSingleValueLegacyExtendedProperty == nil {
		return nil, reportError("microsoftGraphSingleValueLegacyExtendedProperty is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphSingleValueLegacyExtendedProperty
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiMeCalendarGroupsCreateCalendarsRequest struct {
	ctx _context.Context
	ApiService *MeCalendarGroupApiService
	calendarGroupId string
	microsoftGraphCalendar *MicrosoftGraphCalendar
}

// New navigation property
func (r ApiMeCalendarGroupsCreateCalendarsRequest) MicrosoftGraphCalendar(microsoftGraphCalendar MicrosoftGraphCalendar) ApiMeCalendarGroupsCreateCalendarsRequest {
	r.microsoftGraphCalendar = &microsoftGraphCalendar
	return r
}

func (r ApiMeCalendarGroupsCreateCalendarsRequest) Execute() (MicrosoftGraphCalendar, *_nethttp.Response, error) {
	return r.ApiService.MeCalendarGroupsCreateCalendarsExecute(r)
}

/*
MeCalendarGroupsCreateCalendars Create new navigation property to calendars for me

The calendars in the calendar group. Navigation property. Read-only. Nullable.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param calendarGroupId key: id of calendarGroup
 @return ApiMeCalendarGroupsCreateCalendarsRequest
*/
func (a *MeCalendarGroupApiService) MeCalendarGroupsCreateCalendars(ctx _context.Context, calendarGroupId string) ApiMeCalendarGroupsCreateCalendarsRequest {
	return ApiMeCalendarGroupsCreateCalendarsRequest{
		ApiService: a,
		ctx: ctx,
		calendarGroupId: calendarGroupId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphCalendar
func (a *MeCalendarGroupApiService) MeCalendarGroupsCreateCalendarsExecute(r ApiMeCalendarGroupsCreateCalendarsRequest) (MicrosoftGraphCalendar, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphCalendar
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MeCalendarGroupApiService.MeCalendarGroupsCreateCalendars")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/calendarGroups/{calendarGroup-id}/calendars"
	localVarPath = strings.Replace(localVarPath, "{"+"calendarGroup-id"+"}", _neturl.PathEscape(parameterToString(r.calendarGroupId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphCalendar == nil {
		return localVarReturnValue, nil, reportError("microsoftGraphCalendar is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphCalendar
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMeCalendarGroupsDeleteCalendarsRequest struct {
	ctx _context.Context
	ApiService *MeCalendarGroupApiService
	calendarGroupId string
	calendarId string
	ifMatch *string
}

// ETag
func (r ApiMeCalendarGroupsDeleteCalendarsRequest) IfMatch(ifMatch string) ApiMeCalendarGroupsDeleteCalendarsRequest {
	r.ifMatch = &ifMatch
	return r
}

func (r ApiMeCalendarGroupsDeleteCalendarsRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.MeCalendarGroupsDeleteCalendarsExecute(r)
}

/*
MeCalendarGroupsDeleteCalendars Delete navigation property calendars for me

The calendars in the calendar group. Navigation property. Read-only. Nullable.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param calendarGroupId key: id of calendarGroup
 @param calendarId key: id of calendar
 @return ApiMeCalendarGroupsDeleteCalendarsRequest
*/
func (a *MeCalendarGroupApiService) MeCalendarGroupsDeleteCalendars(ctx _context.Context, calendarGroupId string, calendarId string) ApiMeCalendarGroupsDeleteCalendarsRequest {
	return ApiMeCalendarGroupsDeleteCalendarsRequest{
		ApiService: a,
		ctx: ctx,
		calendarGroupId: calendarGroupId,
		calendarId: calendarId,
	}
}

// Execute executes the request
func (a *MeCalendarGroupApiService) MeCalendarGroupsDeleteCalendarsExecute(r ApiMeCalendarGroupsDeleteCalendarsRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MeCalendarGroupApiService.MeCalendarGroupsDeleteCalendars")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/calendarGroups/{calendarGroup-id}/calendars/{calendar-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"calendarGroup-id"+"}", _neturl.PathEscape(parameterToString(r.calendarGroupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"calendar-id"+"}", _neturl.PathEscape(parameterToString(r.calendarId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ifMatch != nil {
		localVarHeaderParams["If-Match"] = parameterToString(*r.ifMatch, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiMeCalendarGroupsGetCalendarsRequest struct {
	ctx _context.Context
	ApiService *MeCalendarGroupApiService
	calendarGroupId string
	calendarId string
	select_ *[]string
}

// Select properties to be returned
func (r ApiMeCalendarGroupsGetCalendarsRequest) Select_(select_ []string) ApiMeCalendarGroupsGetCalendarsRequest {
	r.select_ = &select_
	return r
}

func (r ApiMeCalendarGroupsGetCalendarsRequest) Execute() (MicrosoftGraphCalendar, *_nethttp.Response, error) {
	return r.ApiService.MeCalendarGroupsGetCalendarsExecute(r)
}

/*
MeCalendarGroupsGetCalendars Get calendars from me

The calendars in the calendar group. Navigation property. Read-only. Nullable.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param calendarGroupId key: id of calendarGroup
 @param calendarId key: id of calendar
 @return ApiMeCalendarGroupsGetCalendarsRequest
*/
func (a *MeCalendarGroupApiService) MeCalendarGroupsGetCalendars(ctx _context.Context, calendarGroupId string, calendarId string) ApiMeCalendarGroupsGetCalendarsRequest {
	return ApiMeCalendarGroupsGetCalendarsRequest{
		ApiService: a,
		ctx: ctx,
		calendarGroupId: calendarGroupId,
		calendarId: calendarId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphCalendar
func (a *MeCalendarGroupApiService) MeCalendarGroupsGetCalendarsExecute(r ApiMeCalendarGroupsGetCalendarsRequest) (MicrosoftGraphCalendar, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphCalendar
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MeCalendarGroupApiService.MeCalendarGroupsGetCalendars")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/calendarGroups/{calendarGroup-id}/calendars/{calendar-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"calendarGroup-id"+"}", _neturl.PathEscape(parameterToString(r.calendarGroupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"calendar-id"+"}", _neturl.PathEscape(parameterToString(r.calendarId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMeCalendarGroupsListCalendarsRequest struct {
	ctx _context.Context
	ApiService *MeCalendarGroupApiService
	calendarGroupId string
	top *int32
	skip *int32
	filter *string
	count *bool
	orderby *[]string
	select_ *[]string
}

// Show only the first n items
func (r ApiMeCalendarGroupsListCalendarsRequest) Top(top int32) ApiMeCalendarGroupsListCalendarsRequest {
	r.top = &top
	return r
}
// Skip the first n items
func (r ApiMeCalendarGroupsListCalendarsRequest) Skip(skip int32) ApiMeCalendarGroupsListCalendarsRequest {
	r.skip = &skip
	return r
}
// Filter items by property values
func (r ApiMeCalendarGroupsListCalendarsRequest) Filter(filter string) ApiMeCalendarGroupsListCalendarsRequest {
	r.filter = &filter
	return r
}
// Include count of items
func (r ApiMeCalendarGroupsListCalendarsRequest) Count(count bool) ApiMeCalendarGroupsListCalendarsRequest {
	r.count = &count
	return r
}
// Order items by property values
func (r ApiMeCalendarGroupsListCalendarsRequest) Orderby(orderby []string) ApiMeCalendarGroupsListCalendarsRequest {
	r.orderby = &orderby
	return r
}
// Select properties to be returned
func (r ApiMeCalendarGroupsListCalendarsRequest) Select_(select_ []string) ApiMeCalendarGroupsListCalendarsRequest {
	r.select_ = &select_
	return r
}

func (r ApiMeCalendarGroupsListCalendarsRequest) Execute() (CollectionOfCalendar, *_nethttp.Response, error) {
	return r.ApiService.MeCalendarGroupsListCalendarsExecute(r)
}

/*
MeCalendarGroupsListCalendars Get calendars from me

The calendars in the calendar group. Navigation property. Read-only. Nullable.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param calendarGroupId key: id of calendarGroup
 @return ApiMeCalendarGroupsListCalendarsRequest
*/
func (a *MeCalendarGroupApiService) MeCalendarGroupsListCalendars(ctx _context.Context, calendarGroupId string) ApiMeCalendarGroupsListCalendarsRequest {
	return ApiMeCalendarGroupsListCalendarsRequest{
		ApiService: a,
		ctx: ctx,
		calendarGroupId: calendarGroupId,
	}
}

// Execute executes the request
//  @return CollectionOfCalendar
func (a *MeCalendarGroupApiService) MeCalendarGroupsListCalendarsExecute(r ApiMeCalendarGroupsListCalendarsRequest) (CollectionOfCalendar, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  CollectionOfCalendar
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MeCalendarGroupApiService.MeCalendarGroupsListCalendars")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/calendarGroups/{calendarGroup-id}/calendars"
	localVarPath = strings.Replace(localVarPath, "{"+"calendarGroup-id"+"}", _neturl.PathEscape(parameterToString(r.calendarGroupId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.top != nil {
		localVarQueryParams.Add("$top", parameterToString(*r.top, ""))
	}
	if r.skip != nil {
		localVarQueryParams.Add("$skip", parameterToString(*r.skip, ""))
	}
	if r.filter != nil {
		localVarQueryParams.Add("$filter", parameterToString(*r.filter, ""))
	}
	if r.count != nil {
		localVarQueryParams.Add("$count", parameterToString(*r.count, ""))
	}
	if r.orderby != nil {
		localVarQueryParams.Add("$orderby", parameterToString(*r.orderby, "csv"))
	}
	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMeCalendarGroupsUpdateCalendarsRequest struct {
	ctx _context.Context
	ApiService *MeCalendarGroupApiService
	calendarGroupId string
	calendarId string
	microsoftGraphCalendar *MicrosoftGraphCalendar
}

// New navigation property values
func (r ApiMeCalendarGroupsUpdateCalendarsRequest) MicrosoftGraphCalendar(microsoftGraphCalendar MicrosoftGraphCalendar) ApiMeCalendarGroupsUpdateCalendarsRequest {
	r.microsoftGraphCalendar = &microsoftGraphCalendar
	return r
}

func (r ApiMeCalendarGroupsUpdateCalendarsRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.MeCalendarGroupsUpdateCalendarsExecute(r)
}

/*
MeCalendarGroupsUpdateCalendars Update the navigation property calendars in me

The calendars in the calendar group. Navigation property. Read-only. Nullable.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param calendarGroupId key: id of calendarGroup
 @param calendarId key: id of calendar
 @return ApiMeCalendarGroupsUpdateCalendarsRequest
*/
func (a *MeCalendarGroupApiService) MeCalendarGroupsUpdateCalendars(ctx _context.Context, calendarGroupId string, calendarId string) ApiMeCalendarGroupsUpdateCalendarsRequest {
	return ApiMeCalendarGroupsUpdateCalendarsRequest{
		ApiService: a,
		ctx: ctx,
		calendarGroupId: calendarGroupId,
		calendarId: calendarId,
	}
}

// Execute executes the request
func (a *MeCalendarGroupApiService) MeCalendarGroupsUpdateCalendarsExecute(r ApiMeCalendarGroupsUpdateCalendarsRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPatch
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MeCalendarGroupApiService.MeCalendarGroupsUpdateCalendars")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/calendarGroups/{calendarGroup-id}/calendars/{calendar-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"calendarGroup-id"+"}", _neturl.PathEscape(parameterToString(r.calendarGroupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"calendar-id"+"}", _neturl.PathEscape(parameterToString(r.calendarId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphCalendar == nil {
		return nil, reportError("microsoftGraphCalendar is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphCalendar
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiMeCreateCalendarGroupsRequest struct {
	ctx _context.Context
	ApiService *MeCalendarGroupApiService
	microsoftGraphCalendarGroup *MicrosoftGraphCalendarGroup
}

// New navigation property
func (r ApiMeCreateCalendarGroupsRequest) MicrosoftGraphCalendarGroup(microsoftGraphCalendarGroup MicrosoftGraphCalendarGroup) ApiMeCreateCalendarGroupsRequest {
	r.microsoftGraphCalendarGroup = &microsoftGraphCalendarGroup
	return r
}

func (r ApiMeCreateCalendarGroupsRequest) Execute() (MicrosoftGraphCalendarGroup, *_nethttp.Response, error) {
	return r.ApiService.MeCreateCalendarGroupsExecute(r)
}

/*
MeCreateCalendarGroups Create new navigation property to calendarGroups for me

The user's calendar groups. Read-only. Nullable.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiMeCreateCalendarGroupsRequest
*/
func (a *MeCalendarGroupApiService) MeCreateCalendarGroups(ctx _context.Context) ApiMeCreateCalendarGroupsRequest {
	return ApiMeCreateCalendarGroupsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return MicrosoftGraphCalendarGroup
func (a *MeCalendarGroupApiService) MeCreateCalendarGroupsExecute(r ApiMeCreateCalendarGroupsRequest) (MicrosoftGraphCalendarGroup, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphCalendarGroup
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MeCalendarGroupApiService.MeCreateCalendarGroups")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/calendarGroups"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphCalendarGroup == nil {
		return localVarReturnValue, nil, reportError("microsoftGraphCalendarGroup is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphCalendarGroup
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMeDeleteCalendarGroupsRequest struct {
	ctx _context.Context
	ApiService *MeCalendarGroupApiService
	calendarGroupId string
	ifMatch *string
}

// ETag
func (r ApiMeDeleteCalendarGroupsRequest) IfMatch(ifMatch string) ApiMeDeleteCalendarGroupsRequest {
	r.ifMatch = &ifMatch
	return r
}

func (r ApiMeDeleteCalendarGroupsRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.MeDeleteCalendarGroupsExecute(r)
}

/*
MeDeleteCalendarGroups Delete navigation property calendarGroups for me

The user's calendar groups. Read-only. Nullable.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param calendarGroupId key: id of calendarGroup
 @return ApiMeDeleteCalendarGroupsRequest
*/
func (a *MeCalendarGroupApiService) MeDeleteCalendarGroups(ctx _context.Context, calendarGroupId string) ApiMeDeleteCalendarGroupsRequest {
	return ApiMeDeleteCalendarGroupsRequest{
		ApiService: a,
		ctx: ctx,
		calendarGroupId: calendarGroupId,
	}
}

// Execute executes the request
func (a *MeCalendarGroupApiService) MeDeleteCalendarGroupsExecute(r ApiMeDeleteCalendarGroupsRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MeCalendarGroupApiService.MeDeleteCalendarGroups")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/calendarGroups/{calendarGroup-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"calendarGroup-id"+"}", _neturl.PathEscape(parameterToString(r.calendarGroupId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ifMatch != nil {
		localVarHeaderParams["If-Match"] = parameterToString(*r.ifMatch, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiMeGetCalendarGroupsRequest struct {
	ctx _context.Context
	ApiService *MeCalendarGroupApiService
	calendarGroupId string
	select_ *[]string
}

// Select properties to be returned
func (r ApiMeGetCalendarGroupsRequest) Select_(select_ []string) ApiMeGetCalendarGroupsRequest {
	r.select_ = &select_
	return r
}

func (r ApiMeGetCalendarGroupsRequest) Execute() (MicrosoftGraphCalendarGroup, *_nethttp.Response, error) {
	return r.ApiService.MeGetCalendarGroupsExecute(r)
}

/*
MeGetCalendarGroups Get calendarGroups from me

The user's calendar groups. Read-only. Nullable.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param calendarGroupId key: id of calendarGroup
 @return ApiMeGetCalendarGroupsRequest
*/
func (a *MeCalendarGroupApiService) MeGetCalendarGroups(ctx _context.Context, calendarGroupId string) ApiMeGetCalendarGroupsRequest {
	return ApiMeGetCalendarGroupsRequest{
		ApiService: a,
		ctx: ctx,
		calendarGroupId: calendarGroupId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphCalendarGroup
func (a *MeCalendarGroupApiService) MeGetCalendarGroupsExecute(r ApiMeGetCalendarGroupsRequest) (MicrosoftGraphCalendarGroup, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphCalendarGroup
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MeCalendarGroupApiService.MeGetCalendarGroups")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/calendarGroups/{calendarGroup-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"calendarGroup-id"+"}", _neturl.PathEscape(parameterToString(r.calendarGroupId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMeListCalendarGroupsRequest struct {
	ctx _context.Context
	ApiService *MeCalendarGroupApiService
	top *int32
	skip *int32
	filter *string
	count *bool
	orderby *[]string
	select_ *[]string
}

// Show only the first n items
func (r ApiMeListCalendarGroupsRequest) Top(top int32) ApiMeListCalendarGroupsRequest {
	r.top = &top
	return r
}
// Skip the first n items
func (r ApiMeListCalendarGroupsRequest) Skip(skip int32) ApiMeListCalendarGroupsRequest {
	r.skip = &skip
	return r
}
// Filter items by property values
func (r ApiMeListCalendarGroupsRequest) Filter(filter string) ApiMeListCalendarGroupsRequest {
	r.filter = &filter
	return r
}
// Include count of items
func (r ApiMeListCalendarGroupsRequest) Count(count bool) ApiMeListCalendarGroupsRequest {
	r.count = &count
	return r
}
// Order items by property values
func (r ApiMeListCalendarGroupsRequest) Orderby(orderby []string) ApiMeListCalendarGroupsRequest {
	r.orderby = &orderby
	return r
}
// Select properties to be returned
func (r ApiMeListCalendarGroupsRequest) Select_(select_ []string) ApiMeListCalendarGroupsRequest {
	r.select_ = &select_
	return r
}

func (r ApiMeListCalendarGroupsRequest) Execute() (CollectionOfCalendarGroup, *_nethttp.Response, error) {
	return r.ApiService.MeListCalendarGroupsExecute(r)
}

/*
MeListCalendarGroups Get calendarGroups from me

The user's calendar groups. Read-only. Nullable.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiMeListCalendarGroupsRequest
*/
func (a *MeCalendarGroupApiService) MeListCalendarGroups(ctx _context.Context) ApiMeListCalendarGroupsRequest {
	return ApiMeListCalendarGroupsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CollectionOfCalendarGroup
func (a *MeCalendarGroupApiService) MeListCalendarGroupsExecute(r ApiMeListCalendarGroupsRequest) (CollectionOfCalendarGroup, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  CollectionOfCalendarGroup
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MeCalendarGroupApiService.MeListCalendarGroups")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/calendarGroups"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.top != nil {
		localVarQueryParams.Add("$top", parameterToString(*r.top, ""))
	}
	if r.skip != nil {
		localVarQueryParams.Add("$skip", parameterToString(*r.skip, ""))
	}
	if r.filter != nil {
		localVarQueryParams.Add("$filter", parameterToString(*r.filter, ""))
	}
	if r.count != nil {
		localVarQueryParams.Add("$count", parameterToString(*r.count, ""))
	}
	if r.orderby != nil {
		localVarQueryParams.Add("$orderby", parameterToString(*r.orderby, "csv"))
	}
	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMeUpdateCalendarGroupsRequest struct {
	ctx _context.Context
	ApiService *MeCalendarGroupApiService
	calendarGroupId string
	microsoftGraphCalendarGroup *MicrosoftGraphCalendarGroup
}

// New navigation property values
func (r ApiMeUpdateCalendarGroupsRequest) MicrosoftGraphCalendarGroup(microsoftGraphCalendarGroup MicrosoftGraphCalendarGroup) ApiMeUpdateCalendarGroupsRequest {
	r.microsoftGraphCalendarGroup = &microsoftGraphCalendarGroup
	return r
}

func (r ApiMeUpdateCalendarGroupsRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.MeUpdateCalendarGroupsExecute(r)
}

/*
MeUpdateCalendarGroups Update the navigation property calendarGroups in me

The user's calendar groups. Read-only. Nullable.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param calendarGroupId key: id of calendarGroup
 @return ApiMeUpdateCalendarGroupsRequest
*/
func (a *MeCalendarGroupApiService) MeUpdateCalendarGroups(ctx _context.Context, calendarGroupId string) ApiMeUpdateCalendarGroupsRequest {
	return ApiMeUpdateCalendarGroupsRequest{
		ApiService: a,
		ctx: ctx,
		calendarGroupId: calendarGroupId,
	}
}

// Execute executes the request
func (a *MeCalendarGroupApiService) MeUpdateCalendarGroupsExecute(r ApiMeUpdateCalendarGroupsRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPatch
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MeCalendarGroupApiService.MeUpdateCalendarGroups")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/calendarGroups/{calendarGroup-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"calendarGroup-id"+"}", _neturl.PathEscape(parameterToString(r.calendarGroupId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphCalendarGroup == nil {
		return nil, reportError("microsoftGraphCalendarGroup is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphCalendarGroup
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}
