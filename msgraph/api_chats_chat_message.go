/*
Partial Graph API

No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

API version: v1.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package msgraph

import (
	"bytes"
	_context "context"
	_ioutil "io/ioutil"
	_nethttp "net/http"
	_neturl "net/url"
	"strings"
)

// Linger please
var (
	_ _context.Context
)

// ChatsChatMessageApiService ChatsChatMessageApi service
type ChatsChatMessageApiService service

type ApiChatsCreateMessagesRequest struct {
	ctx _context.Context
	ApiService *ChatsChatMessageApiService
	chatId string
	microsoftGraphChatMessage *MicrosoftGraphChatMessage
}

// New navigation property
func (r ApiChatsCreateMessagesRequest) MicrosoftGraphChatMessage(microsoftGraphChatMessage MicrosoftGraphChatMessage) ApiChatsCreateMessagesRequest {
	r.microsoftGraphChatMessage = &microsoftGraphChatMessage
	return r
}

func (r ApiChatsCreateMessagesRequest) Execute() (MicrosoftGraphChatMessage, *_nethttp.Response, error) {
	return r.ApiService.ChatsCreateMessagesExecute(r)
}

/*
ChatsCreateMessages Create new navigation property to messages for chats

A collection of all the messages in the chat. Nullable.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param chatId key: id of chat
 @return ApiChatsCreateMessagesRequest
*/
func (a *ChatsChatMessageApiService) ChatsCreateMessages(ctx _context.Context, chatId string) ApiChatsCreateMessagesRequest {
	return ApiChatsCreateMessagesRequest{
		ApiService: a,
		ctx: ctx,
		chatId: chatId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphChatMessage
func (a *ChatsChatMessageApiService) ChatsCreateMessagesExecute(r ApiChatsCreateMessagesRequest) (MicrosoftGraphChatMessage, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphChatMessage
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ChatsChatMessageApiService.ChatsCreateMessages")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/chats/{chat-id}/messages"
	localVarPath = strings.Replace(localVarPath, "{"+"chat-id"+"}", _neturl.PathEscape(parameterToString(r.chatId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphChatMessage == nil {
		return localVarReturnValue, nil, reportError("microsoftGraphChatMessage is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphChatMessage
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiChatsDeleteMessagesRequest struct {
	ctx _context.Context
	ApiService *ChatsChatMessageApiService
	chatId string
	chatMessageId string
	ifMatch *string
}

// ETag
func (r ApiChatsDeleteMessagesRequest) IfMatch(ifMatch string) ApiChatsDeleteMessagesRequest {
	r.ifMatch = &ifMatch
	return r
}

func (r ApiChatsDeleteMessagesRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.ChatsDeleteMessagesExecute(r)
}

/*
ChatsDeleteMessages Delete navigation property messages for chats

A collection of all the messages in the chat. Nullable.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param chatId key: id of chat
 @param chatMessageId key: id of chatMessage
 @return ApiChatsDeleteMessagesRequest
*/
func (a *ChatsChatMessageApiService) ChatsDeleteMessages(ctx _context.Context, chatId string, chatMessageId string) ApiChatsDeleteMessagesRequest {
	return ApiChatsDeleteMessagesRequest{
		ApiService: a,
		ctx: ctx,
		chatId: chatId,
		chatMessageId: chatMessageId,
	}
}

// Execute executes the request
func (a *ChatsChatMessageApiService) ChatsDeleteMessagesExecute(r ApiChatsDeleteMessagesRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ChatsChatMessageApiService.ChatsDeleteMessages")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/chats/{chat-id}/messages/{chatMessage-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"chat-id"+"}", _neturl.PathEscape(parameterToString(r.chatId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"chatMessage-id"+"}", _neturl.PathEscape(parameterToString(r.chatMessageId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ifMatch != nil {
		localVarHeaderParams["If-Match"] = parameterToString(*r.ifMatch, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiChatsGetMessagesRequest struct {
	ctx _context.Context
	ApiService *ChatsChatMessageApiService
	chatId string
	chatMessageId string
	select_ *[]string
	expand *[]string
}

// Select properties to be returned
func (r ApiChatsGetMessagesRequest) Select_(select_ []string) ApiChatsGetMessagesRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiChatsGetMessagesRequest) Expand(expand []string) ApiChatsGetMessagesRequest {
	r.expand = &expand
	return r
}

func (r ApiChatsGetMessagesRequest) Execute() (MicrosoftGraphChatMessage, *_nethttp.Response, error) {
	return r.ApiService.ChatsGetMessagesExecute(r)
}

/*
ChatsGetMessages Get messages from chats

A collection of all the messages in the chat. Nullable.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param chatId key: id of chat
 @param chatMessageId key: id of chatMessage
 @return ApiChatsGetMessagesRequest
*/
func (a *ChatsChatMessageApiService) ChatsGetMessages(ctx _context.Context, chatId string, chatMessageId string) ApiChatsGetMessagesRequest {
	return ApiChatsGetMessagesRequest{
		ApiService: a,
		ctx: ctx,
		chatId: chatId,
		chatMessageId: chatMessageId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphChatMessage
func (a *ChatsChatMessageApiService) ChatsGetMessagesExecute(r ApiChatsGetMessagesRequest) (MicrosoftGraphChatMessage, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphChatMessage
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ChatsChatMessageApiService.ChatsGetMessages")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/chats/{chat-id}/messages/{chatMessage-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"chat-id"+"}", _neturl.PathEscape(parameterToString(r.chatId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"chatMessage-id"+"}", _neturl.PathEscape(parameterToString(r.chatMessageId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiChatsListMessagesRequest struct {
	ctx _context.Context
	ApiService *ChatsChatMessageApiService
	chatId string
	top *int32
	skip *int32
	search *string
	filter *string
	count *bool
	orderby *[]string
	select_ *[]string
	expand *[]string
}

// Show only the first n items
func (r ApiChatsListMessagesRequest) Top(top int32) ApiChatsListMessagesRequest {
	r.top = &top
	return r
}
// Skip the first n items
func (r ApiChatsListMessagesRequest) Skip(skip int32) ApiChatsListMessagesRequest {
	r.skip = &skip
	return r
}
// Search items by search phrases
func (r ApiChatsListMessagesRequest) Search(search string) ApiChatsListMessagesRequest {
	r.search = &search
	return r
}
// Filter items by property values
func (r ApiChatsListMessagesRequest) Filter(filter string) ApiChatsListMessagesRequest {
	r.filter = &filter
	return r
}
// Include count of items
func (r ApiChatsListMessagesRequest) Count(count bool) ApiChatsListMessagesRequest {
	r.count = &count
	return r
}
// Order items by property values
func (r ApiChatsListMessagesRequest) Orderby(orderby []string) ApiChatsListMessagesRequest {
	r.orderby = &orderby
	return r
}
// Select properties to be returned
func (r ApiChatsListMessagesRequest) Select_(select_ []string) ApiChatsListMessagesRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiChatsListMessagesRequest) Expand(expand []string) ApiChatsListMessagesRequest {
	r.expand = &expand
	return r
}

func (r ApiChatsListMessagesRequest) Execute() (CollectionOfChatMessage, *_nethttp.Response, error) {
	return r.ApiService.ChatsListMessagesExecute(r)
}

/*
ChatsListMessages Get messages from chats

A collection of all the messages in the chat. Nullable.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param chatId key: id of chat
 @return ApiChatsListMessagesRequest
*/
func (a *ChatsChatMessageApiService) ChatsListMessages(ctx _context.Context, chatId string) ApiChatsListMessagesRequest {
	return ApiChatsListMessagesRequest{
		ApiService: a,
		ctx: ctx,
		chatId: chatId,
	}
}

// Execute executes the request
//  @return CollectionOfChatMessage
func (a *ChatsChatMessageApiService) ChatsListMessagesExecute(r ApiChatsListMessagesRequest) (CollectionOfChatMessage, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  CollectionOfChatMessage
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ChatsChatMessageApiService.ChatsListMessages")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/chats/{chat-id}/messages"
	localVarPath = strings.Replace(localVarPath, "{"+"chat-id"+"}", _neturl.PathEscape(parameterToString(r.chatId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.top != nil {
		localVarQueryParams.Add("$top", parameterToString(*r.top, ""))
	}
	if r.skip != nil {
		localVarQueryParams.Add("$skip", parameterToString(*r.skip, ""))
	}
	if r.search != nil {
		localVarQueryParams.Add("$search", parameterToString(*r.search, ""))
	}
	if r.filter != nil {
		localVarQueryParams.Add("$filter", parameterToString(*r.filter, ""))
	}
	if r.count != nil {
		localVarQueryParams.Add("$count", parameterToString(*r.count, ""))
	}
	if r.orderby != nil {
		localVarQueryParams.Add("$orderby", parameterToString(*r.orderby, "csv"))
	}
	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiChatsMessagesCreateHostedContentsRequest struct {
	ctx _context.Context
	ApiService *ChatsChatMessageApiService
	chatId string
	chatMessageId string
	microsoftGraphChatMessageHostedContent *MicrosoftGraphChatMessageHostedContent
}

// New navigation property
func (r ApiChatsMessagesCreateHostedContentsRequest) MicrosoftGraphChatMessageHostedContent(microsoftGraphChatMessageHostedContent MicrosoftGraphChatMessageHostedContent) ApiChatsMessagesCreateHostedContentsRequest {
	r.microsoftGraphChatMessageHostedContent = &microsoftGraphChatMessageHostedContent
	return r
}

func (r ApiChatsMessagesCreateHostedContentsRequest) Execute() (MicrosoftGraphChatMessageHostedContent, *_nethttp.Response, error) {
	return r.ApiService.ChatsMessagesCreateHostedContentsExecute(r)
}

/*
ChatsMessagesCreateHostedContents Create new navigation property to hostedContents for chats

Content in a message hosted by Microsoft Teams - for example, images or code snippets.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param chatId key: id of chat
 @param chatMessageId key: id of chatMessage
 @return ApiChatsMessagesCreateHostedContentsRequest
*/
func (a *ChatsChatMessageApiService) ChatsMessagesCreateHostedContents(ctx _context.Context, chatId string, chatMessageId string) ApiChatsMessagesCreateHostedContentsRequest {
	return ApiChatsMessagesCreateHostedContentsRequest{
		ApiService: a,
		ctx: ctx,
		chatId: chatId,
		chatMessageId: chatMessageId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphChatMessageHostedContent
func (a *ChatsChatMessageApiService) ChatsMessagesCreateHostedContentsExecute(r ApiChatsMessagesCreateHostedContentsRequest) (MicrosoftGraphChatMessageHostedContent, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphChatMessageHostedContent
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ChatsChatMessageApiService.ChatsMessagesCreateHostedContents")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/chats/{chat-id}/messages/{chatMessage-id}/hostedContents"
	localVarPath = strings.Replace(localVarPath, "{"+"chat-id"+"}", _neturl.PathEscape(parameterToString(r.chatId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"chatMessage-id"+"}", _neturl.PathEscape(parameterToString(r.chatMessageId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphChatMessageHostedContent == nil {
		return localVarReturnValue, nil, reportError("microsoftGraphChatMessageHostedContent is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphChatMessageHostedContent
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiChatsMessagesCreateRepliesRequest struct {
	ctx _context.Context
	ApiService *ChatsChatMessageApiService
	chatId string
	chatMessageId string
	microsoftGraphChatMessage *MicrosoftGraphChatMessage
}

// New navigation property
func (r ApiChatsMessagesCreateRepliesRequest) MicrosoftGraphChatMessage(microsoftGraphChatMessage MicrosoftGraphChatMessage) ApiChatsMessagesCreateRepliesRequest {
	r.microsoftGraphChatMessage = &microsoftGraphChatMessage
	return r
}

func (r ApiChatsMessagesCreateRepliesRequest) Execute() (MicrosoftGraphChatMessage, *_nethttp.Response, error) {
	return r.ApiService.ChatsMessagesCreateRepliesExecute(r)
}

/*
ChatsMessagesCreateReplies Create new navigation property to replies for chats

Replies for a specified message.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param chatId key: id of chat
 @param chatMessageId key: id of chatMessage
 @return ApiChatsMessagesCreateRepliesRequest
*/
func (a *ChatsChatMessageApiService) ChatsMessagesCreateReplies(ctx _context.Context, chatId string, chatMessageId string) ApiChatsMessagesCreateRepliesRequest {
	return ApiChatsMessagesCreateRepliesRequest{
		ApiService: a,
		ctx: ctx,
		chatId: chatId,
		chatMessageId: chatMessageId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphChatMessage
func (a *ChatsChatMessageApiService) ChatsMessagesCreateRepliesExecute(r ApiChatsMessagesCreateRepliesRequest) (MicrosoftGraphChatMessage, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphChatMessage
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ChatsChatMessageApiService.ChatsMessagesCreateReplies")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/chats/{chat-id}/messages/{chatMessage-id}/replies"
	localVarPath = strings.Replace(localVarPath, "{"+"chat-id"+"}", _neturl.PathEscape(parameterToString(r.chatId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"chatMessage-id"+"}", _neturl.PathEscape(parameterToString(r.chatMessageId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphChatMessage == nil {
		return localVarReturnValue, nil, reportError("microsoftGraphChatMessage is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphChatMessage
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiChatsMessagesDeleteHostedContentsRequest struct {
	ctx _context.Context
	ApiService *ChatsChatMessageApiService
	chatId string
	chatMessageId string
	chatMessageHostedContentId string
	ifMatch *string
}

// ETag
func (r ApiChatsMessagesDeleteHostedContentsRequest) IfMatch(ifMatch string) ApiChatsMessagesDeleteHostedContentsRequest {
	r.ifMatch = &ifMatch
	return r
}

func (r ApiChatsMessagesDeleteHostedContentsRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.ChatsMessagesDeleteHostedContentsExecute(r)
}

/*
ChatsMessagesDeleteHostedContents Delete navigation property hostedContents for chats

Content in a message hosted by Microsoft Teams - for example, images or code snippets.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param chatId key: id of chat
 @param chatMessageId key: id of chatMessage
 @param chatMessageHostedContentId key: id of chatMessageHostedContent
 @return ApiChatsMessagesDeleteHostedContentsRequest
*/
func (a *ChatsChatMessageApiService) ChatsMessagesDeleteHostedContents(ctx _context.Context, chatId string, chatMessageId string, chatMessageHostedContentId string) ApiChatsMessagesDeleteHostedContentsRequest {
	return ApiChatsMessagesDeleteHostedContentsRequest{
		ApiService: a,
		ctx: ctx,
		chatId: chatId,
		chatMessageId: chatMessageId,
		chatMessageHostedContentId: chatMessageHostedContentId,
	}
}

// Execute executes the request
func (a *ChatsChatMessageApiService) ChatsMessagesDeleteHostedContentsExecute(r ApiChatsMessagesDeleteHostedContentsRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ChatsChatMessageApiService.ChatsMessagesDeleteHostedContents")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/chats/{chat-id}/messages/{chatMessage-id}/hostedContents/{chatMessageHostedContent-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"chat-id"+"}", _neturl.PathEscape(parameterToString(r.chatId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"chatMessage-id"+"}", _neturl.PathEscape(parameterToString(r.chatMessageId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"chatMessageHostedContent-id"+"}", _neturl.PathEscape(parameterToString(r.chatMessageHostedContentId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ifMatch != nil {
		localVarHeaderParams["If-Match"] = parameterToString(*r.ifMatch, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiChatsMessagesDeleteRepliesRequest struct {
	ctx _context.Context
	ApiService *ChatsChatMessageApiService
	chatId string
	chatMessageId string
	chatMessageId1 string
	ifMatch *string
}

// ETag
func (r ApiChatsMessagesDeleteRepliesRequest) IfMatch(ifMatch string) ApiChatsMessagesDeleteRepliesRequest {
	r.ifMatch = &ifMatch
	return r
}

func (r ApiChatsMessagesDeleteRepliesRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.ChatsMessagesDeleteRepliesExecute(r)
}

/*
ChatsMessagesDeleteReplies Delete navigation property replies for chats

Replies for a specified message.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param chatId key: id of chat
 @param chatMessageId key: id of chatMessage
 @param chatMessageId1 key: id of chatMessage
 @return ApiChatsMessagesDeleteRepliesRequest
*/
func (a *ChatsChatMessageApiService) ChatsMessagesDeleteReplies(ctx _context.Context, chatId string, chatMessageId string, chatMessageId1 string) ApiChatsMessagesDeleteRepliesRequest {
	return ApiChatsMessagesDeleteRepliesRequest{
		ApiService: a,
		ctx: ctx,
		chatId: chatId,
		chatMessageId: chatMessageId,
		chatMessageId1: chatMessageId1,
	}
}

// Execute executes the request
func (a *ChatsChatMessageApiService) ChatsMessagesDeleteRepliesExecute(r ApiChatsMessagesDeleteRepliesRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ChatsChatMessageApiService.ChatsMessagesDeleteReplies")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/chats/{chat-id}/messages/{chatMessage-id}/replies/{chatMessage-id1}"
	localVarPath = strings.Replace(localVarPath, "{"+"chat-id"+"}", _neturl.PathEscape(parameterToString(r.chatId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"chatMessage-id"+"}", _neturl.PathEscape(parameterToString(r.chatMessageId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"chatMessage-id1"+"}", _neturl.PathEscape(parameterToString(r.chatMessageId1, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ifMatch != nil {
		localVarHeaderParams["If-Match"] = parameterToString(*r.ifMatch, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiChatsMessagesGetHostedContentsRequest struct {
	ctx _context.Context
	ApiService *ChatsChatMessageApiService
	chatId string
	chatMessageId string
	chatMessageHostedContentId string
	select_ *[]string
	expand *[]string
}

// Select properties to be returned
func (r ApiChatsMessagesGetHostedContentsRequest) Select_(select_ []string) ApiChatsMessagesGetHostedContentsRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiChatsMessagesGetHostedContentsRequest) Expand(expand []string) ApiChatsMessagesGetHostedContentsRequest {
	r.expand = &expand
	return r
}

func (r ApiChatsMessagesGetHostedContentsRequest) Execute() (MicrosoftGraphChatMessageHostedContent, *_nethttp.Response, error) {
	return r.ApiService.ChatsMessagesGetHostedContentsExecute(r)
}

/*
ChatsMessagesGetHostedContents Get hostedContents from chats

Content in a message hosted by Microsoft Teams - for example, images or code snippets.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param chatId key: id of chat
 @param chatMessageId key: id of chatMessage
 @param chatMessageHostedContentId key: id of chatMessageHostedContent
 @return ApiChatsMessagesGetHostedContentsRequest
*/
func (a *ChatsChatMessageApiService) ChatsMessagesGetHostedContents(ctx _context.Context, chatId string, chatMessageId string, chatMessageHostedContentId string) ApiChatsMessagesGetHostedContentsRequest {
	return ApiChatsMessagesGetHostedContentsRequest{
		ApiService: a,
		ctx: ctx,
		chatId: chatId,
		chatMessageId: chatMessageId,
		chatMessageHostedContentId: chatMessageHostedContentId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphChatMessageHostedContent
func (a *ChatsChatMessageApiService) ChatsMessagesGetHostedContentsExecute(r ApiChatsMessagesGetHostedContentsRequest) (MicrosoftGraphChatMessageHostedContent, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphChatMessageHostedContent
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ChatsChatMessageApiService.ChatsMessagesGetHostedContents")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/chats/{chat-id}/messages/{chatMessage-id}/hostedContents/{chatMessageHostedContent-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"chat-id"+"}", _neturl.PathEscape(parameterToString(r.chatId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"chatMessage-id"+"}", _neturl.PathEscape(parameterToString(r.chatMessageId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"chatMessageHostedContent-id"+"}", _neturl.PathEscape(parameterToString(r.chatMessageHostedContentId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiChatsMessagesGetRepliesRequest struct {
	ctx _context.Context
	ApiService *ChatsChatMessageApiService
	chatId string
	chatMessageId string
	chatMessageId1 string
	select_ *[]string
	expand *[]string
}

// Select properties to be returned
func (r ApiChatsMessagesGetRepliesRequest) Select_(select_ []string) ApiChatsMessagesGetRepliesRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiChatsMessagesGetRepliesRequest) Expand(expand []string) ApiChatsMessagesGetRepliesRequest {
	r.expand = &expand
	return r
}

func (r ApiChatsMessagesGetRepliesRequest) Execute() (MicrosoftGraphChatMessage, *_nethttp.Response, error) {
	return r.ApiService.ChatsMessagesGetRepliesExecute(r)
}

/*
ChatsMessagesGetReplies Get replies from chats

Replies for a specified message.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param chatId key: id of chat
 @param chatMessageId key: id of chatMessage
 @param chatMessageId1 key: id of chatMessage
 @return ApiChatsMessagesGetRepliesRequest
*/
func (a *ChatsChatMessageApiService) ChatsMessagesGetReplies(ctx _context.Context, chatId string, chatMessageId string, chatMessageId1 string) ApiChatsMessagesGetRepliesRequest {
	return ApiChatsMessagesGetRepliesRequest{
		ApiService: a,
		ctx: ctx,
		chatId: chatId,
		chatMessageId: chatMessageId,
		chatMessageId1: chatMessageId1,
	}
}

// Execute executes the request
//  @return MicrosoftGraphChatMessage
func (a *ChatsChatMessageApiService) ChatsMessagesGetRepliesExecute(r ApiChatsMessagesGetRepliesRequest) (MicrosoftGraphChatMessage, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphChatMessage
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ChatsChatMessageApiService.ChatsMessagesGetReplies")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/chats/{chat-id}/messages/{chatMessage-id}/replies/{chatMessage-id1}"
	localVarPath = strings.Replace(localVarPath, "{"+"chat-id"+"}", _neturl.PathEscape(parameterToString(r.chatId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"chatMessage-id"+"}", _neturl.PathEscape(parameterToString(r.chatMessageId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"chatMessage-id1"+"}", _neturl.PathEscape(parameterToString(r.chatMessageId1, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiChatsMessagesListHostedContentsRequest struct {
	ctx _context.Context
	ApiService *ChatsChatMessageApiService
	chatId string
	chatMessageId string
	top *int32
	skip *int32
	search *string
	filter *string
	count *bool
	orderby *[]string
	select_ *[]string
	expand *[]string
}

// Show only the first n items
func (r ApiChatsMessagesListHostedContentsRequest) Top(top int32) ApiChatsMessagesListHostedContentsRequest {
	r.top = &top
	return r
}
// Skip the first n items
func (r ApiChatsMessagesListHostedContentsRequest) Skip(skip int32) ApiChatsMessagesListHostedContentsRequest {
	r.skip = &skip
	return r
}
// Search items by search phrases
func (r ApiChatsMessagesListHostedContentsRequest) Search(search string) ApiChatsMessagesListHostedContentsRequest {
	r.search = &search
	return r
}
// Filter items by property values
func (r ApiChatsMessagesListHostedContentsRequest) Filter(filter string) ApiChatsMessagesListHostedContentsRequest {
	r.filter = &filter
	return r
}
// Include count of items
func (r ApiChatsMessagesListHostedContentsRequest) Count(count bool) ApiChatsMessagesListHostedContentsRequest {
	r.count = &count
	return r
}
// Order items by property values
func (r ApiChatsMessagesListHostedContentsRequest) Orderby(orderby []string) ApiChatsMessagesListHostedContentsRequest {
	r.orderby = &orderby
	return r
}
// Select properties to be returned
func (r ApiChatsMessagesListHostedContentsRequest) Select_(select_ []string) ApiChatsMessagesListHostedContentsRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiChatsMessagesListHostedContentsRequest) Expand(expand []string) ApiChatsMessagesListHostedContentsRequest {
	r.expand = &expand
	return r
}

func (r ApiChatsMessagesListHostedContentsRequest) Execute() (CollectionOfChatMessageHostedContent, *_nethttp.Response, error) {
	return r.ApiService.ChatsMessagesListHostedContentsExecute(r)
}

/*
ChatsMessagesListHostedContents Get hostedContents from chats

Content in a message hosted by Microsoft Teams - for example, images or code snippets.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param chatId key: id of chat
 @param chatMessageId key: id of chatMessage
 @return ApiChatsMessagesListHostedContentsRequest
*/
func (a *ChatsChatMessageApiService) ChatsMessagesListHostedContents(ctx _context.Context, chatId string, chatMessageId string) ApiChatsMessagesListHostedContentsRequest {
	return ApiChatsMessagesListHostedContentsRequest{
		ApiService: a,
		ctx: ctx,
		chatId: chatId,
		chatMessageId: chatMessageId,
	}
}

// Execute executes the request
//  @return CollectionOfChatMessageHostedContent
func (a *ChatsChatMessageApiService) ChatsMessagesListHostedContentsExecute(r ApiChatsMessagesListHostedContentsRequest) (CollectionOfChatMessageHostedContent, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  CollectionOfChatMessageHostedContent
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ChatsChatMessageApiService.ChatsMessagesListHostedContents")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/chats/{chat-id}/messages/{chatMessage-id}/hostedContents"
	localVarPath = strings.Replace(localVarPath, "{"+"chat-id"+"}", _neturl.PathEscape(parameterToString(r.chatId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"chatMessage-id"+"}", _neturl.PathEscape(parameterToString(r.chatMessageId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.top != nil {
		localVarQueryParams.Add("$top", parameterToString(*r.top, ""))
	}
	if r.skip != nil {
		localVarQueryParams.Add("$skip", parameterToString(*r.skip, ""))
	}
	if r.search != nil {
		localVarQueryParams.Add("$search", parameterToString(*r.search, ""))
	}
	if r.filter != nil {
		localVarQueryParams.Add("$filter", parameterToString(*r.filter, ""))
	}
	if r.count != nil {
		localVarQueryParams.Add("$count", parameterToString(*r.count, ""))
	}
	if r.orderby != nil {
		localVarQueryParams.Add("$orderby", parameterToString(*r.orderby, "csv"))
	}
	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiChatsMessagesListRepliesRequest struct {
	ctx _context.Context
	ApiService *ChatsChatMessageApiService
	chatId string
	chatMessageId string
	top *int32
	skip *int32
	search *string
	filter *string
	count *bool
	orderby *[]string
	select_ *[]string
	expand *[]string
}

// Show only the first n items
func (r ApiChatsMessagesListRepliesRequest) Top(top int32) ApiChatsMessagesListRepliesRequest {
	r.top = &top
	return r
}
// Skip the first n items
func (r ApiChatsMessagesListRepliesRequest) Skip(skip int32) ApiChatsMessagesListRepliesRequest {
	r.skip = &skip
	return r
}
// Search items by search phrases
func (r ApiChatsMessagesListRepliesRequest) Search(search string) ApiChatsMessagesListRepliesRequest {
	r.search = &search
	return r
}
// Filter items by property values
func (r ApiChatsMessagesListRepliesRequest) Filter(filter string) ApiChatsMessagesListRepliesRequest {
	r.filter = &filter
	return r
}
// Include count of items
func (r ApiChatsMessagesListRepliesRequest) Count(count bool) ApiChatsMessagesListRepliesRequest {
	r.count = &count
	return r
}
// Order items by property values
func (r ApiChatsMessagesListRepliesRequest) Orderby(orderby []string) ApiChatsMessagesListRepliesRequest {
	r.orderby = &orderby
	return r
}
// Select properties to be returned
func (r ApiChatsMessagesListRepliesRequest) Select_(select_ []string) ApiChatsMessagesListRepliesRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiChatsMessagesListRepliesRequest) Expand(expand []string) ApiChatsMessagesListRepliesRequest {
	r.expand = &expand
	return r
}

func (r ApiChatsMessagesListRepliesRequest) Execute() (CollectionOfChatMessage, *_nethttp.Response, error) {
	return r.ApiService.ChatsMessagesListRepliesExecute(r)
}

/*
ChatsMessagesListReplies Get replies from chats

Replies for a specified message.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param chatId key: id of chat
 @param chatMessageId key: id of chatMessage
 @return ApiChatsMessagesListRepliesRequest
*/
func (a *ChatsChatMessageApiService) ChatsMessagesListReplies(ctx _context.Context, chatId string, chatMessageId string) ApiChatsMessagesListRepliesRequest {
	return ApiChatsMessagesListRepliesRequest{
		ApiService: a,
		ctx: ctx,
		chatId: chatId,
		chatMessageId: chatMessageId,
	}
}

// Execute executes the request
//  @return CollectionOfChatMessage
func (a *ChatsChatMessageApiService) ChatsMessagesListRepliesExecute(r ApiChatsMessagesListRepliesRequest) (CollectionOfChatMessage, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  CollectionOfChatMessage
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ChatsChatMessageApiService.ChatsMessagesListReplies")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/chats/{chat-id}/messages/{chatMessage-id}/replies"
	localVarPath = strings.Replace(localVarPath, "{"+"chat-id"+"}", _neturl.PathEscape(parameterToString(r.chatId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"chatMessage-id"+"}", _neturl.PathEscape(parameterToString(r.chatMessageId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.top != nil {
		localVarQueryParams.Add("$top", parameterToString(*r.top, ""))
	}
	if r.skip != nil {
		localVarQueryParams.Add("$skip", parameterToString(*r.skip, ""))
	}
	if r.search != nil {
		localVarQueryParams.Add("$search", parameterToString(*r.search, ""))
	}
	if r.filter != nil {
		localVarQueryParams.Add("$filter", parameterToString(*r.filter, ""))
	}
	if r.count != nil {
		localVarQueryParams.Add("$count", parameterToString(*r.count, ""))
	}
	if r.orderby != nil {
		localVarQueryParams.Add("$orderby", parameterToString(*r.orderby, "csv"))
	}
	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiChatsMessagesUpdateHostedContentsRequest struct {
	ctx _context.Context
	ApiService *ChatsChatMessageApiService
	chatId string
	chatMessageId string
	chatMessageHostedContentId string
	microsoftGraphChatMessageHostedContent *MicrosoftGraphChatMessageHostedContent
}

// New navigation property values
func (r ApiChatsMessagesUpdateHostedContentsRequest) MicrosoftGraphChatMessageHostedContent(microsoftGraphChatMessageHostedContent MicrosoftGraphChatMessageHostedContent) ApiChatsMessagesUpdateHostedContentsRequest {
	r.microsoftGraphChatMessageHostedContent = &microsoftGraphChatMessageHostedContent
	return r
}

func (r ApiChatsMessagesUpdateHostedContentsRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.ChatsMessagesUpdateHostedContentsExecute(r)
}

/*
ChatsMessagesUpdateHostedContents Update the navigation property hostedContents in chats

Content in a message hosted by Microsoft Teams - for example, images or code snippets.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param chatId key: id of chat
 @param chatMessageId key: id of chatMessage
 @param chatMessageHostedContentId key: id of chatMessageHostedContent
 @return ApiChatsMessagesUpdateHostedContentsRequest
*/
func (a *ChatsChatMessageApiService) ChatsMessagesUpdateHostedContents(ctx _context.Context, chatId string, chatMessageId string, chatMessageHostedContentId string) ApiChatsMessagesUpdateHostedContentsRequest {
	return ApiChatsMessagesUpdateHostedContentsRequest{
		ApiService: a,
		ctx: ctx,
		chatId: chatId,
		chatMessageId: chatMessageId,
		chatMessageHostedContentId: chatMessageHostedContentId,
	}
}

// Execute executes the request
func (a *ChatsChatMessageApiService) ChatsMessagesUpdateHostedContentsExecute(r ApiChatsMessagesUpdateHostedContentsRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPatch
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ChatsChatMessageApiService.ChatsMessagesUpdateHostedContents")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/chats/{chat-id}/messages/{chatMessage-id}/hostedContents/{chatMessageHostedContent-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"chat-id"+"}", _neturl.PathEscape(parameterToString(r.chatId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"chatMessage-id"+"}", _neturl.PathEscape(parameterToString(r.chatMessageId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"chatMessageHostedContent-id"+"}", _neturl.PathEscape(parameterToString(r.chatMessageHostedContentId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphChatMessageHostedContent == nil {
		return nil, reportError("microsoftGraphChatMessageHostedContent is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphChatMessageHostedContent
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiChatsMessagesUpdateRepliesRequest struct {
	ctx _context.Context
	ApiService *ChatsChatMessageApiService
	chatId string
	chatMessageId string
	chatMessageId1 string
	microsoftGraphChatMessage *MicrosoftGraphChatMessage
}

// New navigation property values
func (r ApiChatsMessagesUpdateRepliesRequest) MicrosoftGraphChatMessage(microsoftGraphChatMessage MicrosoftGraphChatMessage) ApiChatsMessagesUpdateRepliesRequest {
	r.microsoftGraphChatMessage = &microsoftGraphChatMessage
	return r
}

func (r ApiChatsMessagesUpdateRepliesRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.ChatsMessagesUpdateRepliesExecute(r)
}

/*
ChatsMessagesUpdateReplies Update the navigation property replies in chats

Replies for a specified message.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param chatId key: id of chat
 @param chatMessageId key: id of chatMessage
 @param chatMessageId1 key: id of chatMessage
 @return ApiChatsMessagesUpdateRepliesRequest
*/
func (a *ChatsChatMessageApiService) ChatsMessagesUpdateReplies(ctx _context.Context, chatId string, chatMessageId string, chatMessageId1 string) ApiChatsMessagesUpdateRepliesRequest {
	return ApiChatsMessagesUpdateRepliesRequest{
		ApiService: a,
		ctx: ctx,
		chatId: chatId,
		chatMessageId: chatMessageId,
		chatMessageId1: chatMessageId1,
	}
}

// Execute executes the request
func (a *ChatsChatMessageApiService) ChatsMessagesUpdateRepliesExecute(r ApiChatsMessagesUpdateRepliesRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPatch
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ChatsChatMessageApiService.ChatsMessagesUpdateReplies")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/chats/{chat-id}/messages/{chatMessage-id}/replies/{chatMessage-id1}"
	localVarPath = strings.Replace(localVarPath, "{"+"chat-id"+"}", _neturl.PathEscape(parameterToString(r.chatId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"chatMessage-id"+"}", _neturl.PathEscape(parameterToString(r.chatMessageId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"chatMessage-id1"+"}", _neturl.PathEscape(parameterToString(r.chatMessageId1, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphChatMessage == nil {
		return nil, reportError("microsoftGraphChatMessage is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphChatMessage
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiChatsUpdateMessagesRequest struct {
	ctx _context.Context
	ApiService *ChatsChatMessageApiService
	chatId string
	chatMessageId string
	microsoftGraphChatMessage *MicrosoftGraphChatMessage
}

// New navigation property values
func (r ApiChatsUpdateMessagesRequest) MicrosoftGraphChatMessage(microsoftGraphChatMessage MicrosoftGraphChatMessage) ApiChatsUpdateMessagesRequest {
	r.microsoftGraphChatMessage = &microsoftGraphChatMessage
	return r
}

func (r ApiChatsUpdateMessagesRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.ChatsUpdateMessagesExecute(r)
}

/*
ChatsUpdateMessages Update the navigation property messages in chats

A collection of all the messages in the chat. Nullable.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param chatId key: id of chat
 @param chatMessageId key: id of chatMessage
 @return ApiChatsUpdateMessagesRequest
*/
func (a *ChatsChatMessageApiService) ChatsUpdateMessages(ctx _context.Context, chatId string, chatMessageId string) ApiChatsUpdateMessagesRequest {
	return ApiChatsUpdateMessagesRequest{
		ApiService: a,
		ctx: ctx,
		chatId: chatId,
		chatMessageId: chatMessageId,
	}
}

// Execute executes the request
func (a *ChatsChatMessageApiService) ChatsUpdateMessagesExecute(r ApiChatsUpdateMessagesRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPatch
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ChatsChatMessageApiService.ChatsUpdateMessages")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/chats/{chat-id}/messages/{chatMessage-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"chat-id"+"}", _neturl.PathEscape(parameterToString(r.chatId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"chatMessage-id"+"}", _neturl.PathEscape(parameterToString(r.chatMessageId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphChatMessage == nil {
		return nil, reportError("microsoftGraphChatMessage is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphChatMessage
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}
