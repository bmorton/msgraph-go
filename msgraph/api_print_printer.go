/*
Partial Graph API

No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

API version: v1.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package msgraph

import (
	"bytes"
	_context "context"
	_ioutil "io/ioutil"
	_nethttp "net/http"
	_neturl "net/url"
	"strings"
)

// Linger please
var (
	_ _context.Context
)

// PrintPrinterApiService PrintPrinterApi service
type PrintPrinterApiService service

type ApiPrintCreatePrintersRequest struct {
	ctx _context.Context
	ApiService *PrintPrinterApiService
	microsoftGraphPrinter *MicrosoftGraphPrinter
}

// New navigation property
func (r ApiPrintCreatePrintersRequest) MicrosoftGraphPrinter(microsoftGraphPrinter MicrosoftGraphPrinter) ApiPrintCreatePrintersRequest {
	r.microsoftGraphPrinter = &microsoftGraphPrinter
	return r
}

func (r ApiPrintCreatePrintersRequest) Execute() (MicrosoftGraphPrinter, *_nethttp.Response, error) {
	return r.ApiService.PrintCreatePrintersExecute(r)
}

/*
PrintCreatePrinters Create new navigation property to printers for print

The list of printers registered in the tenant.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPrintCreatePrintersRequest
*/
func (a *PrintPrinterApiService) PrintCreatePrinters(ctx _context.Context) ApiPrintCreatePrintersRequest {
	return ApiPrintCreatePrintersRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return MicrosoftGraphPrinter
func (a *PrintPrinterApiService) PrintCreatePrintersExecute(r ApiPrintCreatePrintersRequest) (MicrosoftGraphPrinter, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphPrinter
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PrintPrinterApiService.PrintCreatePrinters")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/print/printers"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphPrinter == nil {
		return localVarReturnValue, nil, reportError("microsoftGraphPrinter is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphPrinter
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPrintDeletePrintersRequest struct {
	ctx _context.Context
	ApiService *PrintPrinterApiService
	printerId string
	ifMatch *string
}

// ETag
func (r ApiPrintDeletePrintersRequest) IfMatch(ifMatch string) ApiPrintDeletePrintersRequest {
	r.ifMatch = &ifMatch
	return r
}

func (r ApiPrintDeletePrintersRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.PrintDeletePrintersExecute(r)
}

/*
PrintDeletePrinters Delete navigation property printers for print

The list of printers registered in the tenant.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param printerId key: id of printer
 @return ApiPrintDeletePrintersRequest
*/
func (a *PrintPrinterApiService) PrintDeletePrinters(ctx _context.Context, printerId string) ApiPrintDeletePrintersRequest {
	return ApiPrintDeletePrintersRequest{
		ApiService: a,
		ctx: ctx,
		printerId: printerId,
	}
}

// Execute executes the request
func (a *PrintPrinterApiService) PrintDeletePrintersExecute(r ApiPrintDeletePrintersRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PrintPrinterApiService.PrintDeletePrinters")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/print/printers/{printer-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"printer-id"+"}", _neturl.PathEscape(parameterToString(r.printerId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ifMatch != nil {
		localVarHeaderParams["If-Match"] = parameterToString(*r.ifMatch, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiPrintGetPrintersRequest struct {
	ctx _context.Context
	ApiService *PrintPrinterApiService
	printerId string
	select_ *[]string
	expand *[]string
}

// Select properties to be returned
func (r ApiPrintGetPrintersRequest) Select_(select_ []string) ApiPrintGetPrintersRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiPrintGetPrintersRequest) Expand(expand []string) ApiPrintGetPrintersRequest {
	r.expand = &expand
	return r
}

func (r ApiPrintGetPrintersRequest) Execute() (MicrosoftGraphPrinter, *_nethttp.Response, error) {
	return r.ApiService.PrintGetPrintersExecute(r)
}

/*
PrintGetPrinters Get printers from print

The list of printers registered in the tenant.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param printerId key: id of printer
 @return ApiPrintGetPrintersRequest
*/
func (a *PrintPrinterApiService) PrintGetPrinters(ctx _context.Context, printerId string) ApiPrintGetPrintersRequest {
	return ApiPrintGetPrintersRequest{
		ApiService: a,
		ctx: ctx,
		printerId: printerId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphPrinter
func (a *PrintPrinterApiService) PrintGetPrintersExecute(r ApiPrintGetPrintersRequest) (MicrosoftGraphPrinter, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphPrinter
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PrintPrinterApiService.PrintGetPrinters")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/print/printers/{printer-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"printer-id"+"}", _neturl.PathEscape(parameterToString(r.printerId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPrintListPrintersRequest struct {
	ctx _context.Context
	ApiService *PrintPrinterApiService
	top *int32
	skip *int32
	search *string
	filter *string
	count *bool
	orderby *[]string
	select_ *[]string
	expand *[]string
}

// Show only the first n items
func (r ApiPrintListPrintersRequest) Top(top int32) ApiPrintListPrintersRequest {
	r.top = &top
	return r
}
// Skip the first n items
func (r ApiPrintListPrintersRequest) Skip(skip int32) ApiPrintListPrintersRequest {
	r.skip = &skip
	return r
}
// Search items by search phrases
func (r ApiPrintListPrintersRequest) Search(search string) ApiPrintListPrintersRequest {
	r.search = &search
	return r
}
// Filter items by property values
func (r ApiPrintListPrintersRequest) Filter(filter string) ApiPrintListPrintersRequest {
	r.filter = &filter
	return r
}
// Include count of items
func (r ApiPrintListPrintersRequest) Count(count bool) ApiPrintListPrintersRequest {
	r.count = &count
	return r
}
// Order items by property values
func (r ApiPrintListPrintersRequest) Orderby(orderby []string) ApiPrintListPrintersRequest {
	r.orderby = &orderby
	return r
}
// Select properties to be returned
func (r ApiPrintListPrintersRequest) Select_(select_ []string) ApiPrintListPrintersRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiPrintListPrintersRequest) Expand(expand []string) ApiPrintListPrintersRequest {
	r.expand = &expand
	return r
}

func (r ApiPrintListPrintersRequest) Execute() (CollectionOfPrinter, *_nethttp.Response, error) {
	return r.ApiService.PrintListPrintersExecute(r)
}

/*
PrintListPrinters Get printers from print

The list of printers registered in the tenant.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPrintListPrintersRequest
*/
func (a *PrintPrinterApiService) PrintListPrinters(ctx _context.Context) ApiPrintListPrintersRequest {
	return ApiPrintListPrintersRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CollectionOfPrinter
func (a *PrintPrinterApiService) PrintListPrintersExecute(r ApiPrintListPrintersRequest) (CollectionOfPrinter, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  CollectionOfPrinter
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PrintPrinterApiService.PrintListPrinters")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/print/printers"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.top != nil {
		localVarQueryParams.Add("$top", parameterToString(*r.top, ""))
	}
	if r.skip != nil {
		localVarQueryParams.Add("$skip", parameterToString(*r.skip, ""))
	}
	if r.search != nil {
		localVarQueryParams.Add("$search", parameterToString(*r.search, ""))
	}
	if r.filter != nil {
		localVarQueryParams.Add("$filter", parameterToString(*r.filter, ""))
	}
	if r.count != nil {
		localVarQueryParams.Add("$count", parameterToString(*r.count, ""))
	}
	if r.orderby != nil {
		localVarQueryParams.Add("$orderby", parameterToString(*r.orderby, "csv"))
	}
	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPrintPrintersCreateRefConnectorsRequest struct {
	ctx _context.Context
	ApiService *PrintPrinterApiService
	printerId string
	requestBody *map[string]map[string]interface{}
}

// New navigation property ref value
func (r ApiPrintPrintersCreateRefConnectorsRequest) RequestBody(requestBody map[string]map[string]interface{}) ApiPrintPrintersCreateRefConnectorsRequest {
	r.requestBody = &requestBody
	return r
}

func (r ApiPrintPrintersCreateRefConnectorsRequest) Execute() (map[string]interface{}, *_nethttp.Response, error) {
	return r.ApiService.PrintPrintersCreateRefConnectorsExecute(r)
}

/*
PrintPrintersCreateRefConnectors Create new navigation property ref to connectors for print

The connectors that are associated with the printer.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param printerId key: id of printer
 @return ApiPrintPrintersCreateRefConnectorsRequest
*/
func (a *PrintPrinterApiService) PrintPrintersCreateRefConnectors(ctx _context.Context, printerId string) ApiPrintPrintersCreateRefConnectorsRequest {
	return ApiPrintPrintersCreateRefConnectorsRequest{
		ApiService: a,
		ctx: ctx,
		printerId: printerId,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *PrintPrinterApiService) PrintPrintersCreateRefConnectorsExecute(r ApiPrintPrintersCreateRefConnectorsRequest) (map[string]interface{}, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PrintPrinterApiService.PrintPrintersCreateRefConnectors")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/print/printers/{printer-id}/connectors/$ref"
	localVarPath = strings.Replace(localVarPath, "{"+"printer-id"+"}", _neturl.PathEscape(parameterToString(r.printerId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.requestBody == nil {
		return localVarReturnValue, nil, reportError("requestBody is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.requestBody
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPrintPrintersCreateRefSharesRequest struct {
	ctx _context.Context
	ApiService *PrintPrinterApiService
	printerId string
	requestBody *map[string]map[string]interface{}
}

// New navigation property ref value
func (r ApiPrintPrintersCreateRefSharesRequest) RequestBody(requestBody map[string]map[string]interface{}) ApiPrintPrintersCreateRefSharesRequest {
	r.requestBody = &requestBody
	return r
}

func (r ApiPrintPrintersCreateRefSharesRequest) Execute() (map[string]interface{}, *_nethttp.Response, error) {
	return r.ApiService.PrintPrintersCreateRefSharesExecute(r)
}

/*
PrintPrintersCreateRefShares Create new navigation property ref to shares for print

The list of printerShares that are associated with the printer. Currently, only one printerShare can be associated with the printer. Read-only. Nullable.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param printerId key: id of printer
 @return ApiPrintPrintersCreateRefSharesRequest
*/
func (a *PrintPrinterApiService) PrintPrintersCreateRefShares(ctx _context.Context, printerId string) ApiPrintPrintersCreateRefSharesRequest {
	return ApiPrintPrintersCreateRefSharesRequest{
		ApiService: a,
		ctx: ctx,
		printerId: printerId,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *PrintPrinterApiService) PrintPrintersCreateRefSharesExecute(r ApiPrintPrintersCreateRefSharesRequest) (map[string]interface{}, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PrintPrinterApiService.PrintPrintersCreateRefShares")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/print/printers/{printer-id}/shares/$ref"
	localVarPath = strings.Replace(localVarPath, "{"+"printer-id"+"}", _neturl.PathEscape(parameterToString(r.printerId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.requestBody == nil {
		return localVarReturnValue, nil, reportError("requestBody is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.requestBody
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPrintPrintersCreateTaskTriggersRequest struct {
	ctx _context.Context
	ApiService *PrintPrinterApiService
	printerId string
	microsoftGraphPrintTaskTrigger *MicrosoftGraphPrintTaskTrigger
}

// New navigation property
func (r ApiPrintPrintersCreateTaskTriggersRequest) MicrosoftGraphPrintTaskTrigger(microsoftGraphPrintTaskTrigger MicrosoftGraphPrintTaskTrigger) ApiPrintPrintersCreateTaskTriggersRequest {
	r.microsoftGraphPrintTaskTrigger = &microsoftGraphPrintTaskTrigger
	return r
}

func (r ApiPrintPrintersCreateTaskTriggersRequest) Execute() (MicrosoftGraphPrintTaskTrigger, *_nethttp.Response, error) {
	return r.ApiService.PrintPrintersCreateTaskTriggersExecute(r)
}

/*
PrintPrintersCreateTaskTriggers Create new navigation property to taskTriggers for print

A list of task triggers that are associated with the printer.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param printerId key: id of printer
 @return ApiPrintPrintersCreateTaskTriggersRequest
*/
func (a *PrintPrinterApiService) PrintPrintersCreateTaskTriggers(ctx _context.Context, printerId string) ApiPrintPrintersCreateTaskTriggersRequest {
	return ApiPrintPrintersCreateTaskTriggersRequest{
		ApiService: a,
		ctx: ctx,
		printerId: printerId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphPrintTaskTrigger
func (a *PrintPrinterApiService) PrintPrintersCreateTaskTriggersExecute(r ApiPrintPrintersCreateTaskTriggersRequest) (MicrosoftGraphPrintTaskTrigger, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphPrintTaskTrigger
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PrintPrinterApiService.PrintPrintersCreateTaskTriggers")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/print/printers/{printer-id}/taskTriggers"
	localVarPath = strings.Replace(localVarPath, "{"+"printer-id"+"}", _neturl.PathEscape(parameterToString(r.printerId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphPrintTaskTrigger == nil {
		return localVarReturnValue, nil, reportError("microsoftGraphPrintTaskTrigger is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphPrintTaskTrigger
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPrintPrintersDeleteTaskTriggersRequest struct {
	ctx _context.Context
	ApiService *PrintPrinterApiService
	printerId string
	printTaskTriggerId string
	ifMatch *string
}

// ETag
func (r ApiPrintPrintersDeleteTaskTriggersRequest) IfMatch(ifMatch string) ApiPrintPrintersDeleteTaskTriggersRequest {
	r.ifMatch = &ifMatch
	return r
}

func (r ApiPrintPrintersDeleteTaskTriggersRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.PrintPrintersDeleteTaskTriggersExecute(r)
}

/*
PrintPrintersDeleteTaskTriggers Delete navigation property taskTriggers for print

A list of task triggers that are associated with the printer.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param printerId key: id of printer
 @param printTaskTriggerId key: id of printTaskTrigger
 @return ApiPrintPrintersDeleteTaskTriggersRequest
*/
func (a *PrintPrinterApiService) PrintPrintersDeleteTaskTriggers(ctx _context.Context, printerId string, printTaskTriggerId string) ApiPrintPrintersDeleteTaskTriggersRequest {
	return ApiPrintPrintersDeleteTaskTriggersRequest{
		ApiService: a,
		ctx: ctx,
		printerId: printerId,
		printTaskTriggerId: printTaskTriggerId,
	}
}

// Execute executes the request
func (a *PrintPrinterApiService) PrintPrintersDeleteTaskTriggersExecute(r ApiPrintPrintersDeleteTaskTriggersRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PrintPrinterApiService.PrintPrintersDeleteTaskTriggers")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/print/printers/{printer-id}/taskTriggers/{printTaskTrigger-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"printer-id"+"}", _neturl.PathEscape(parameterToString(r.printerId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"printTaskTrigger-id"+"}", _neturl.PathEscape(parameterToString(r.printTaskTriggerId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ifMatch != nil {
		localVarHeaderParams["If-Match"] = parameterToString(*r.ifMatch, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiPrintPrintersGetTaskTriggersRequest struct {
	ctx _context.Context
	ApiService *PrintPrinterApiService
	printerId string
	printTaskTriggerId string
	select_ *[]string
	expand *[]string
}

// Select properties to be returned
func (r ApiPrintPrintersGetTaskTriggersRequest) Select_(select_ []string) ApiPrintPrintersGetTaskTriggersRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiPrintPrintersGetTaskTriggersRequest) Expand(expand []string) ApiPrintPrintersGetTaskTriggersRequest {
	r.expand = &expand
	return r
}

func (r ApiPrintPrintersGetTaskTriggersRequest) Execute() (MicrosoftGraphPrintTaskTrigger, *_nethttp.Response, error) {
	return r.ApiService.PrintPrintersGetTaskTriggersExecute(r)
}

/*
PrintPrintersGetTaskTriggers Get taskTriggers from print

A list of task triggers that are associated with the printer.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param printerId key: id of printer
 @param printTaskTriggerId key: id of printTaskTrigger
 @return ApiPrintPrintersGetTaskTriggersRequest
*/
func (a *PrintPrinterApiService) PrintPrintersGetTaskTriggers(ctx _context.Context, printerId string, printTaskTriggerId string) ApiPrintPrintersGetTaskTriggersRequest {
	return ApiPrintPrintersGetTaskTriggersRequest{
		ApiService: a,
		ctx: ctx,
		printerId: printerId,
		printTaskTriggerId: printTaskTriggerId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphPrintTaskTrigger
func (a *PrintPrinterApiService) PrintPrintersGetTaskTriggersExecute(r ApiPrintPrintersGetTaskTriggersRequest) (MicrosoftGraphPrintTaskTrigger, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphPrintTaskTrigger
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PrintPrinterApiService.PrintPrintersGetTaskTriggers")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/print/printers/{printer-id}/taskTriggers/{printTaskTrigger-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"printer-id"+"}", _neturl.PathEscape(parameterToString(r.printerId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"printTaskTrigger-id"+"}", _neturl.PathEscape(parameterToString(r.printTaskTriggerId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPrintPrintersListConnectorsRequest struct {
	ctx _context.Context
	ApiService *PrintPrinterApiService
	printerId string
	top *int32
	skip *int32
	search *string
	filter *string
	count *bool
	orderby *[]string
	select_ *[]string
	expand *[]string
}

// Show only the first n items
func (r ApiPrintPrintersListConnectorsRequest) Top(top int32) ApiPrintPrintersListConnectorsRequest {
	r.top = &top
	return r
}
// Skip the first n items
func (r ApiPrintPrintersListConnectorsRequest) Skip(skip int32) ApiPrintPrintersListConnectorsRequest {
	r.skip = &skip
	return r
}
// Search items by search phrases
func (r ApiPrintPrintersListConnectorsRequest) Search(search string) ApiPrintPrintersListConnectorsRequest {
	r.search = &search
	return r
}
// Filter items by property values
func (r ApiPrintPrintersListConnectorsRequest) Filter(filter string) ApiPrintPrintersListConnectorsRequest {
	r.filter = &filter
	return r
}
// Include count of items
func (r ApiPrintPrintersListConnectorsRequest) Count(count bool) ApiPrintPrintersListConnectorsRequest {
	r.count = &count
	return r
}
// Order items by property values
func (r ApiPrintPrintersListConnectorsRequest) Orderby(orderby []string) ApiPrintPrintersListConnectorsRequest {
	r.orderby = &orderby
	return r
}
// Select properties to be returned
func (r ApiPrintPrintersListConnectorsRequest) Select_(select_ []string) ApiPrintPrintersListConnectorsRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiPrintPrintersListConnectorsRequest) Expand(expand []string) ApiPrintPrintersListConnectorsRequest {
	r.expand = &expand
	return r
}

func (r ApiPrintPrintersListConnectorsRequest) Execute() (CollectionOfPrintConnector, *_nethttp.Response, error) {
	return r.ApiService.PrintPrintersListConnectorsExecute(r)
}

/*
PrintPrintersListConnectors Get connectors from print

The connectors that are associated with the printer.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param printerId key: id of printer
 @return ApiPrintPrintersListConnectorsRequest
*/
func (a *PrintPrinterApiService) PrintPrintersListConnectors(ctx _context.Context, printerId string) ApiPrintPrintersListConnectorsRequest {
	return ApiPrintPrintersListConnectorsRequest{
		ApiService: a,
		ctx: ctx,
		printerId: printerId,
	}
}

// Execute executes the request
//  @return CollectionOfPrintConnector
func (a *PrintPrinterApiService) PrintPrintersListConnectorsExecute(r ApiPrintPrintersListConnectorsRequest) (CollectionOfPrintConnector, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  CollectionOfPrintConnector
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PrintPrinterApiService.PrintPrintersListConnectors")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/print/printers/{printer-id}/connectors"
	localVarPath = strings.Replace(localVarPath, "{"+"printer-id"+"}", _neturl.PathEscape(parameterToString(r.printerId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.top != nil {
		localVarQueryParams.Add("$top", parameterToString(*r.top, ""))
	}
	if r.skip != nil {
		localVarQueryParams.Add("$skip", parameterToString(*r.skip, ""))
	}
	if r.search != nil {
		localVarQueryParams.Add("$search", parameterToString(*r.search, ""))
	}
	if r.filter != nil {
		localVarQueryParams.Add("$filter", parameterToString(*r.filter, ""))
	}
	if r.count != nil {
		localVarQueryParams.Add("$count", parameterToString(*r.count, ""))
	}
	if r.orderby != nil {
		localVarQueryParams.Add("$orderby", parameterToString(*r.orderby, "csv"))
	}
	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPrintPrintersListRefConnectorsRequest struct {
	ctx _context.Context
	ApiService *PrintPrinterApiService
	printerId string
	top *int32
	skip *int32
	search *string
	filter *string
	count *bool
	orderby *[]string
}

// Show only the first n items
func (r ApiPrintPrintersListRefConnectorsRequest) Top(top int32) ApiPrintPrintersListRefConnectorsRequest {
	r.top = &top
	return r
}
// Skip the first n items
func (r ApiPrintPrintersListRefConnectorsRequest) Skip(skip int32) ApiPrintPrintersListRefConnectorsRequest {
	r.skip = &skip
	return r
}
// Search items by search phrases
func (r ApiPrintPrintersListRefConnectorsRequest) Search(search string) ApiPrintPrintersListRefConnectorsRequest {
	r.search = &search
	return r
}
// Filter items by property values
func (r ApiPrintPrintersListRefConnectorsRequest) Filter(filter string) ApiPrintPrintersListRefConnectorsRequest {
	r.filter = &filter
	return r
}
// Include count of items
func (r ApiPrintPrintersListRefConnectorsRequest) Count(count bool) ApiPrintPrintersListRefConnectorsRequest {
	r.count = &count
	return r
}
// Order items by property values
func (r ApiPrintPrintersListRefConnectorsRequest) Orderby(orderby []string) ApiPrintPrintersListRefConnectorsRequest {
	r.orderby = &orderby
	return r
}

func (r ApiPrintPrintersListRefConnectorsRequest) Execute() (CollectionOfLinksOfPrintConnector, *_nethttp.Response, error) {
	return r.ApiService.PrintPrintersListRefConnectorsExecute(r)
}

/*
PrintPrintersListRefConnectors Get ref of connectors from print

The connectors that are associated with the printer.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param printerId key: id of printer
 @return ApiPrintPrintersListRefConnectorsRequest
*/
func (a *PrintPrinterApiService) PrintPrintersListRefConnectors(ctx _context.Context, printerId string) ApiPrintPrintersListRefConnectorsRequest {
	return ApiPrintPrintersListRefConnectorsRequest{
		ApiService: a,
		ctx: ctx,
		printerId: printerId,
	}
}

// Execute executes the request
//  @return CollectionOfLinksOfPrintConnector
func (a *PrintPrinterApiService) PrintPrintersListRefConnectorsExecute(r ApiPrintPrintersListRefConnectorsRequest) (CollectionOfLinksOfPrintConnector, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  CollectionOfLinksOfPrintConnector
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PrintPrinterApiService.PrintPrintersListRefConnectors")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/print/printers/{printer-id}/connectors/$ref"
	localVarPath = strings.Replace(localVarPath, "{"+"printer-id"+"}", _neturl.PathEscape(parameterToString(r.printerId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.top != nil {
		localVarQueryParams.Add("$top", parameterToString(*r.top, ""))
	}
	if r.skip != nil {
		localVarQueryParams.Add("$skip", parameterToString(*r.skip, ""))
	}
	if r.search != nil {
		localVarQueryParams.Add("$search", parameterToString(*r.search, ""))
	}
	if r.filter != nil {
		localVarQueryParams.Add("$filter", parameterToString(*r.filter, ""))
	}
	if r.count != nil {
		localVarQueryParams.Add("$count", parameterToString(*r.count, ""))
	}
	if r.orderby != nil {
		localVarQueryParams.Add("$orderby", parameterToString(*r.orderby, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPrintPrintersListRefSharesRequest struct {
	ctx _context.Context
	ApiService *PrintPrinterApiService
	printerId string
	top *int32
	skip *int32
	search *string
	filter *string
	count *bool
	orderby *[]string
}

// Show only the first n items
func (r ApiPrintPrintersListRefSharesRequest) Top(top int32) ApiPrintPrintersListRefSharesRequest {
	r.top = &top
	return r
}
// Skip the first n items
func (r ApiPrintPrintersListRefSharesRequest) Skip(skip int32) ApiPrintPrintersListRefSharesRequest {
	r.skip = &skip
	return r
}
// Search items by search phrases
func (r ApiPrintPrintersListRefSharesRequest) Search(search string) ApiPrintPrintersListRefSharesRequest {
	r.search = &search
	return r
}
// Filter items by property values
func (r ApiPrintPrintersListRefSharesRequest) Filter(filter string) ApiPrintPrintersListRefSharesRequest {
	r.filter = &filter
	return r
}
// Include count of items
func (r ApiPrintPrintersListRefSharesRequest) Count(count bool) ApiPrintPrintersListRefSharesRequest {
	r.count = &count
	return r
}
// Order items by property values
func (r ApiPrintPrintersListRefSharesRequest) Orderby(orderby []string) ApiPrintPrintersListRefSharesRequest {
	r.orderby = &orderby
	return r
}

func (r ApiPrintPrintersListRefSharesRequest) Execute() (CollectionOfLinksOfPrinterShare, *_nethttp.Response, error) {
	return r.ApiService.PrintPrintersListRefSharesExecute(r)
}

/*
PrintPrintersListRefShares Get ref of shares from print

The list of printerShares that are associated with the printer. Currently, only one printerShare can be associated with the printer. Read-only. Nullable.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param printerId key: id of printer
 @return ApiPrintPrintersListRefSharesRequest
*/
func (a *PrintPrinterApiService) PrintPrintersListRefShares(ctx _context.Context, printerId string) ApiPrintPrintersListRefSharesRequest {
	return ApiPrintPrintersListRefSharesRequest{
		ApiService: a,
		ctx: ctx,
		printerId: printerId,
	}
}

// Execute executes the request
//  @return CollectionOfLinksOfPrinterShare
func (a *PrintPrinterApiService) PrintPrintersListRefSharesExecute(r ApiPrintPrintersListRefSharesRequest) (CollectionOfLinksOfPrinterShare, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  CollectionOfLinksOfPrinterShare
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PrintPrinterApiService.PrintPrintersListRefShares")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/print/printers/{printer-id}/shares/$ref"
	localVarPath = strings.Replace(localVarPath, "{"+"printer-id"+"}", _neturl.PathEscape(parameterToString(r.printerId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.top != nil {
		localVarQueryParams.Add("$top", parameterToString(*r.top, ""))
	}
	if r.skip != nil {
		localVarQueryParams.Add("$skip", parameterToString(*r.skip, ""))
	}
	if r.search != nil {
		localVarQueryParams.Add("$search", parameterToString(*r.search, ""))
	}
	if r.filter != nil {
		localVarQueryParams.Add("$filter", parameterToString(*r.filter, ""))
	}
	if r.count != nil {
		localVarQueryParams.Add("$count", parameterToString(*r.count, ""))
	}
	if r.orderby != nil {
		localVarQueryParams.Add("$orderby", parameterToString(*r.orderby, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPrintPrintersListSharesRequest struct {
	ctx _context.Context
	ApiService *PrintPrinterApiService
	printerId string
	top *int32
	skip *int32
	search *string
	filter *string
	count *bool
	orderby *[]string
	select_ *[]string
	expand *[]string
}

// Show only the first n items
func (r ApiPrintPrintersListSharesRequest) Top(top int32) ApiPrintPrintersListSharesRequest {
	r.top = &top
	return r
}
// Skip the first n items
func (r ApiPrintPrintersListSharesRequest) Skip(skip int32) ApiPrintPrintersListSharesRequest {
	r.skip = &skip
	return r
}
// Search items by search phrases
func (r ApiPrintPrintersListSharesRequest) Search(search string) ApiPrintPrintersListSharesRequest {
	r.search = &search
	return r
}
// Filter items by property values
func (r ApiPrintPrintersListSharesRequest) Filter(filter string) ApiPrintPrintersListSharesRequest {
	r.filter = &filter
	return r
}
// Include count of items
func (r ApiPrintPrintersListSharesRequest) Count(count bool) ApiPrintPrintersListSharesRequest {
	r.count = &count
	return r
}
// Order items by property values
func (r ApiPrintPrintersListSharesRequest) Orderby(orderby []string) ApiPrintPrintersListSharesRequest {
	r.orderby = &orderby
	return r
}
// Select properties to be returned
func (r ApiPrintPrintersListSharesRequest) Select_(select_ []string) ApiPrintPrintersListSharesRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiPrintPrintersListSharesRequest) Expand(expand []string) ApiPrintPrintersListSharesRequest {
	r.expand = &expand
	return r
}

func (r ApiPrintPrintersListSharesRequest) Execute() (CollectionOfPrinterShare, *_nethttp.Response, error) {
	return r.ApiService.PrintPrintersListSharesExecute(r)
}

/*
PrintPrintersListShares Get shares from print

The list of printerShares that are associated with the printer. Currently, only one printerShare can be associated with the printer. Read-only. Nullable.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param printerId key: id of printer
 @return ApiPrintPrintersListSharesRequest
*/
func (a *PrintPrinterApiService) PrintPrintersListShares(ctx _context.Context, printerId string) ApiPrintPrintersListSharesRequest {
	return ApiPrintPrintersListSharesRequest{
		ApiService: a,
		ctx: ctx,
		printerId: printerId,
	}
}

// Execute executes the request
//  @return CollectionOfPrinterShare
func (a *PrintPrinterApiService) PrintPrintersListSharesExecute(r ApiPrintPrintersListSharesRequest) (CollectionOfPrinterShare, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  CollectionOfPrinterShare
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PrintPrinterApiService.PrintPrintersListShares")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/print/printers/{printer-id}/shares"
	localVarPath = strings.Replace(localVarPath, "{"+"printer-id"+"}", _neturl.PathEscape(parameterToString(r.printerId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.top != nil {
		localVarQueryParams.Add("$top", parameterToString(*r.top, ""))
	}
	if r.skip != nil {
		localVarQueryParams.Add("$skip", parameterToString(*r.skip, ""))
	}
	if r.search != nil {
		localVarQueryParams.Add("$search", parameterToString(*r.search, ""))
	}
	if r.filter != nil {
		localVarQueryParams.Add("$filter", parameterToString(*r.filter, ""))
	}
	if r.count != nil {
		localVarQueryParams.Add("$count", parameterToString(*r.count, ""))
	}
	if r.orderby != nil {
		localVarQueryParams.Add("$orderby", parameterToString(*r.orderby, "csv"))
	}
	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPrintPrintersListTaskTriggersRequest struct {
	ctx _context.Context
	ApiService *PrintPrinterApiService
	printerId string
	top *int32
	skip *int32
	search *string
	filter *string
	count *bool
	orderby *[]string
	select_ *[]string
	expand *[]string
}

// Show only the first n items
func (r ApiPrintPrintersListTaskTriggersRequest) Top(top int32) ApiPrintPrintersListTaskTriggersRequest {
	r.top = &top
	return r
}
// Skip the first n items
func (r ApiPrintPrintersListTaskTriggersRequest) Skip(skip int32) ApiPrintPrintersListTaskTriggersRequest {
	r.skip = &skip
	return r
}
// Search items by search phrases
func (r ApiPrintPrintersListTaskTriggersRequest) Search(search string) ApiPrintPrintersListTaskTriggersRequest {
	r.search = &search
	return r
}
// Filter items by property values
func (r ApiPrintPrintersListTaskTriggersRequest) Filter(filter string) ApiPrintPrintersListTaskTriggersRequest {
	r.filter = &filter
	return r
}
// Include count of items
func (r ApiPrintPrintersListTaskTriggersRequest) Count(count bool) ApiPrintPrintersListTaskTriggersRequest {
	r.count = &count
	return r
}
// Order items by property values
func (r ApiPrintPrintersListTaskTriggersRequest) Orderby(orderby []string) ApiPrintPrintersListTaskTriggersRequest {
	r.orderby = &orderby
	return r
}
// Select properties to be returned
func (r ApiPrintPrintersListTaskTriggersRequest) Select_(select_ []string) ApiPrintPrintersListTaskTriggersRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiPrintPrintersListTaskTriggersRequest) Expand(expand []string) ApiPrintPrintersListTaskTriggersRequest {
	r.expand = &expand
	return r
}

func (r ApiPrintPrintersListTaskTriggersRequest) Execute() (CollectionOfPrintTaskTrigger, *_nethttp.Response, error) {
	return r.ApiService.PrintPrintersListTaskTriggersExecute(r)
}

/*
PrintPrintersListTaskTriggers Get taskTriggers from print

A list of task triggers that are associated with the printer.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param printerId key: id of printer
 @return ApiPrintPrintersListTaskTriggersRequest
*/
func (a *PrintPrinterApiService) PrintPrintersListTaskTriggers(ctx _context.Context, printerId string) ApiPrintPrintersListTaskTriggersRequest {
	return ApiPrintPrintersListTaskTriggersRequest{
		ApiService: a,
		ctx: ctx,
		printerId: printerId,
	}
}

// Execute executes the request
//  @return CollectionOfPrintTaskTrigger
func (a *PrintPrinterApiService) PrintPrintersListTaskTriggersExecute(r ApiPrintPrintersListTaskTriggersRequest) (CollectionOfPrintTaskTrigger, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  CollectionOfPrintTaskTrigger
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PrintPrinterApiService.PrintPrintersListTaskTriggers")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/print/printers/{printer-id}/taskTriggers"
	localVarPath = strings.Replace(localVarPath, "{"+"printer-id"+"}", _neturl.PathEscape(parameterToString(r.printerId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.top != nil {
		localVarQueryParams.Add("$top", parameterToString(*r.top, ""))
	}
	if r.skip != nil {
		localVarQueryParams.Add("$skip", parameterToString(*r.skip, ""))
	}
	if r.search != nil {
		localVarQueryParams.Add("$search", parameterToString(*r.search, ""))
	}
	if r.filter != nil {
		localVarQueryParams.Add("$filter", parameterToString(*r.filter, ""))
	}
	if r.count != nil {
		localVarQueryParams.Add("$count", parameterToString(*r.count, ""))
	}
	if r.orderby != nil {
		localVarQueryParams.Add("$orderby", parameterToString(*r.orderby, "csv"))
	}
	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPrintPrintersTaskTriggersDeleteRefDefinitionRequest struct {
	ctx _context.Context
	ApiService *PrintPrinterApiService
	printerId string
	printTaskTriggerId string
	ifMatch *string
}

// ETag
func (r ApiPrintPrintersTaskTriggersDeleteRefDefinitionRequest) IfMatch(ifMatch string) ApiPrintPrintersTaskTriggersDeleteRefDefinitionRequest {
	r.ifMatch = &ifMatch
	return r
}

func (r ApiPrintPrintersTaskTriggersDeleteRefDefinitionRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.PrintPrintersTaskTriggersDeleteRefDefinitionExecute(r)
}

/*
PrintPrintersTaskTriggersDeleteRefDefinition Delete ref of navigation property definition for print

An abstract definition that will be used to create a printTask when triggered by a print event. Read-only.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param printerId key: id of printer
 @param printTaskTriggerId key: id of printTaskTrigger
 @return ApiPrintPrintersTaskTriggersDeleteRefDefinitionRequest
*/
func (a *PrintPrinterApiService) PrintPrintersTaskTriggersDeleteRefDefinition(ctx _context.Context, printerId string, printTaskTriggerId string) ApiPrintPrintersTaskTriggersDeleteRefDefinitionRequest {
	return ApiPrintPrintersTaskTriggersDeleteRefDefinitionRequest{
		ApiService: a,
		ctx: ctx,
		printerId: printerId,
		printTaskTriggerId: printTaskTriggerId,
	}
}

// Execute executes the request
func (a *PrintPrinterApiService) PrintPrintersTaskTriggersDeleteRefDefinitionExecute(r ApiPrintPrintersTaskTriggersDeleteRefDefinitionRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PrintPrinterApiService.PrintPrintersTaskTriggersDeleteRefDefinition")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/print/printers/{printer-id}/taskTriggers/{printTaskTrigger-id}/definition/$ref"
	localVarPath = strings.Replace(localVarPath, "{"+"printer-id"+"}", _neturl.PathEscape(parameterToString(r.printerId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"printTaskTrigger-id"+"}", _neturl.PathEscape(parameterToString(r.printTaskTriggerId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ifMatch != nil {
		localVarHeaderParams["If-Match"] = parameterToString(*r.ifMatch, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiPrintPrintersTaskTriggersGetDefinitionRequest struct {
	ctx _context.Context
	ApiService *PrintPrinterApiService
	printerId string
	printTaskTriggerId string
	select_ *[]string
	expand *[]string
}

// Select properties to be returned
func (r ApiPrintPrintersTaskTriggersGetDefinitionRequest) Select_(select_ []string) ApiPrintPrintersTaskTriggersGetDefinitionRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiPrintPrintersTaskTriggersGetDefinitionRequest) Expand(expand []string) ApiPrintPrintersTaskTriggersGetDefinitionRequest {
	r.expand = &expand
	return r
}

func (r ApiPrintPrintersTaskTriggersGetDefinitionRequest) Execute() (MicrosoftGraphPrintTaskDefinition, *_nethttp.Response, error) {
	return r.ApiService.PrintPrintersTaskTriggersGetDefinitionExecute(r)
}

/*
PrintPrintersTaskTriggersGetDefinition Get definition from print

An abstract definition that will be used to create a printTask when triggered by a print event. Read-only.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param printerId key: id of printer
 @param printTaskTriggerId key: id of printTaskTrigger
 @return ApiPrintPrintersTaskTriggersGetDefinitionRequest
*/
func (a *PrintPrinterApiService) PrintPrintersTaskTriggersGetDefinition(ctx _context.Context, printerId string, printTaskTriggerId string) ApiPrintPrintersTaskTriggersGetDefinitionRequest {
	return ApiPrintPrintersTaskTriggersGetDefinitionRequest{
		ApiService: a,
		ctx: ctx,
		printerId: printerId,
		printTaskTriggerId: printTaskTriggerId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphPrintTaskDefinition
func (a *PrintPrinterApiService) PrintPrintersTaskTriggersGetDefinitionExecute(r ApiPrintPrintersTaskTriggersGetDefinitionRequest) (MicrosoftGraphPrintTaskDefinition, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphPrintTaskDefinition
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PrintPrinterApiService.PrintPrintersTaskTriggersGetDefinition")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/print/printers/{printer-id}/taskTriggers/{printTaskTrigger-id}/definition"
	localVarPath = strings.Replace(localVarPath, "{"+"printer-id"+"}", _neturl.PathEscape(parameterToString(r.printerId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"printTaskTrigger-id"+"}", _neturl.PathEscape(parameterToString(r.printTaskTriggerId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPrintPrintersTaskTriggersGetRefDefinitionRequest struct {
	ctx _context.Context
	ApiService *PrintPrinterApiService
	printerId string
	printTaskTriggerId string
}


func (r ApiPrintPrintersTaskTriggersGetRefDefinitionRequest) Execute() (string, *_nethttp.Response, error) {
	return r.ApiService.PrintPrintersTaskTriggersGetRefDefinitionExecute(r)
}

/*
PrintPrintersTaskTriggersGetRefDefinition Get ref of definition from print

An abstract definition that will be used to create a printTask when triggered by a print event. Read-only.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param printerId key: id of printer
 @param printTaskTriggerId key: id of printTaskTrigger
 @return ApiPrintPrintersTaskTriggersGetRefDefinitionRequest
*/
func (a *PrintPrinterApiService) PrintPrintersTaskTriggersGetRefDefinition(ctx _context.Context, printerId string, printTaskTriggerId string) ApiPrintPrintersTaskTriggersGetRefDefinitionRequest {
	return ApiPrintPrintersTaskTriggersGetRefDefinitionRequest{
		ApiService: a,
		ctx: ctx,
		printerId: printerId,
		printTaskTriggerId: printTaskTriggerId,
	}
}

// Execute executes the request
//  @return string
func (a *PrintPrinterApiService) PrintPrintersTaskTriggersGetRefDefinitionExecute(r ApiPrintPrintersTaskTriggersGetRefDefinitionRequest) (string, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  string
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PrintPrinterApiService.PrintPrintersTaskTriggersGetRefDefinition")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/print/printers/{printer-id}/taskTriggers/{printTaskTrigger-id}/definition/$ref"
	localVarPath = strings.Replace(localVarPath, "{"+"printer-id"+"}", _neturl.PathEscape(parameterToString(r.printerId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"printTaskTrigger-id"+"}", _neturl.PathEscape(parameterToString(r.printTaskTriggerId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPrintPrintersTaskTriggersUpdateRefDefinitionRequest struct {
	ctx _context.Context
	ApiService *PrintPrinterApiService
	printerId string
	printTaskTriggerId string
	requestBody *map[string]map[string]interface{}
}

// New navigation property ref values
func (r ApiPrintPrintersTaskTriggersUpdateRefDefinitionRequest) RequestBody(requestBody map[string]map[string]interface{}) ApiPrintPrintersTaskTriggersUpdateRefDefinitionRequest {
	r.requestBody = &requestBody
	return r
}

func (r ApiPrintPrintersTaskTriggersUpdateRefDefinitionRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.PrintPrintersTaskTriggersUpdateRefDefinitionExecute(r)
}

/*
PrintPrintersTaskTriggersUpdateRefDefinition Update the ref of navigation property definition in print

An abstract definition that will be used to create a printTask when triggered by a print event. Read-only.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param printerId key: id of printer
 @param printTaskTriggerId key: id of printTaskTrigger
 @return ApiPrintPrintersTaskTriggersUpdateRefDefinitionRequest
*/
func (a *PrintPrinterApiService) PrintPrintersTaskTriggersUpdateRefDefinition(ctx _context.Context, printerId string, printTaskTriggerId string) ApiPrintPrintersTaskTriggersUpdateRefDefinitionRequest {
	return ApiPrintPrintersTaskTriggersUpdateRefDefinitionRequest{
		ApiService: a,
		ctx: ctx,
		printerId: printerId,
		printTaskTriggerId: printTaskTriggerId,
	}
}

// Execute executes the request
func (a *PrintPrinterApiService) PrintPrintersTaskTriggersUpdateRefDefinitionExecute(r ApiPrintPrintersTaskTriggersUpdateRefDefinitionRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPut
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PrintPrinterApiService.PrintPrintersTaskTriggersUpdateRefDefinition")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/print/printers/{printer-id}/taskTriggers/{printTaskTrigger-id}/definition/$ref"
	localVarPath = strings.Replace(localVarPath, "{"+"printer-id"+"}", _neturl.PathEscape(parameterToString(r.printerId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"printTaskTrigger-id"+"}", _neturl.PathEscape(parameterToString(r.printTaskTriggerId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.requestBody == nil {
		return nil, reportError("requestBody is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.requestBody
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiPrintPrintersUpdateTaskTriggersRequest struct {
	ctx _context.Context
	ApiService *PrintPrinterApiService
	printerId string
	printTaskTriggerId string
	microsoftGraphPrintTaskTrigger *MicrosoftGraphPrintTaskTrigger
}

// New navigation property values
func (r ApiPrintPrintersUpdateTaskTriggersRequest) MicrosoftGraphPrintTaskTrigger(microsoftGraphPrintTaskTrigger MicrosoftGraphPrintTaskTrigger) ApiPrintPrintersUpdateTaskTriggersRequest {
	r.microsoftGraphPrintTaskTrigger = &microsoftGraphPrintTaskTrigger
	return r
}

func (r ApiPrintPrintersUpdateTaskTriggersRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.PrintPrintersUpdateTaskTriggersExecute(r)
}

/*
PrintPrintersUpdateTaskTriggers Update the navigation property taskTriggers in print

A list of task triggers that are associated with the printer.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param printerId key: id of printer
 @param printTaskTriggerId key: id of printTaskTrigger
 @return ApiPrintPrintersUpdateTaskTriggersRequest
*/
func (a *PrintPrinterApiService) PrintPrintersUpdateTaskTriggers(ctx _context.Context, printerId string, printTaskTriggerId string) ApiPrintPrintersUpdateTaskTriggersRequest {
	return ApiPrintPrintersUpdateTaskTriggersRequest{
		ApiService: a,
		ctx: ctx,
		printerId: printerId,
		printTaskTriggerId: printTaskTriggerId,
	}
}

// Execute executes the request
func (a *PrintPrinterApiService) PrintPrintersUpdateTaskTriggersExecute(r ApiPrintPrintersUpdateTaskTriggersRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPatch
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PrintPrinterApiService.PrintPrintersUpdateTaskTriggers")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/print/printers/{printer-id}/taskTriggers/{printTaskTrigger-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"printer-id"+"}", _neturl.PathEscape(parameterToString(r.printerId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"printTaskTrigger-id"+"}", _neturl.PathEscape(parameterToString(r.printTaskTriggerId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphPrintTaskTrigger == nil {
		return nil, reportError("microsoftGraphPrintTaskTrigger is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphPrintTaskTrigger
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiPrintUpdatePrintersRequest struct {
	ctx _context.Context
	ApiService *PrintPrinterApiService
	printerId string
	microsoftGraphPrinter *MicrosoftGraphPrinter
}

// New navigation property values
func (r ApiPrintUpdatePrintersRequest) MicrosoftGraphPrinter(microsoftGraphPrinter MicrosoftGraphPrinter) ApiPrintUpdatePrintersRequest {
	r.microsoftGraphPrinter = &microsoftGraphPrinter
	return r
}

func (r ApiPrintUpdatePrintersRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.PrintUpdatePrintersExecute(r)
}

/*
PrintUpdatePrinters Update the navigation property printers in print

The list of printers registered in the tenant.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param printerId key: id of printer
 @return ApiPrintUpdatePrintersRequest
*/
func (a *PrintPrinterApiService) PrintUpdatePrinters(ctx _context.Context, printerId string) ApiPrintUpdatePrintersRequest {
	return ApiPrintUpdatePrintersRequest{
		ApiService: a,
		ctx: ctx,
		printerId: printerId,
	}
}

// Execute executes the request
func (a *PrintPrinterApiService) PrintUpdatePrintersExecute(r ApiPrintUpdatePrintersRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPatch
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PrintPrinterApiService.PrintUpdatePrinters")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/print/printers/{printer-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"printer-id"+"}", _neturl.PathEscape(parameterToString(r.printerId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphPrinter == nil {
		return nil, reportError("microsoftGraphPrinter is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphPrinter
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}
