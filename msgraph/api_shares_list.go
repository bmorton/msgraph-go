/*
Partial Graph API

No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

API version: v1.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package msgraph

import (
	"bytes"
	_context "context"
	_ioutil "io/ioutil"
	_nethttp "net/http"
	_neturl "net/url"
	"strings"
	"os"
)

// Linger please
var (
	_ _context.Context
)

// SharesListApiService SharesListApi service
type SharesListApiService service

type ApiSharesDeleteListRequest struct {
	ctx _context.Context
	ApiService *SharesListApiService
	sharedDriveItemId string
	ifMatch *string
}

// ETag
func (r ApiSharesDeleteListRequest) IfMatch(ifMatch string) ApiSharesDeleteListRequest {
	r.ifMatch = &ifMatch
	return r
}

func (r ApiSharesDeleteListRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.SharesDeleteListExecute(r)
}

/*
SharesDeleteList Delete navigation property list for shares

Used to access the underlying list

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param sharedDriveItemId key: id of sharedDriveItem
 @return ApiSharesDeleteListRequest
*/
func (a *SharesListApiService) SharesDeleteList(ctx _context.Context, sharedDriveItemId string) ApiSharesDeleteListRequest {
	return ApiSharesDeleteListRequest{
		ApiService: a,
		ctx: ctx,
		sharedDriveItemId: sharedDriveItemId,
	}
}

// Execute executes the request
func (a *SharesListApiService) SharesDeleteListExecute(r ApiSharesDeleteListRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SharesListApiService.SharesDeleteList")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/shares/{sharedDriveItem-id}/list"
	localVarPath = strings.Replace(localVarPath, "{"+"sharedDriveItem-id"+"}", _neturl.PathEscape(parameterToString(r.sharedDriveItemId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ifMatch != nil {
		localVarHeaderParams["If-Match"] = parameterToString(*r.ifMatch, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiSharesGetListRequest struct {
	ctx _context.Context
	ApiService *SharesListApiService
	sharedDriveItemId string
	select_ *[]string
	expand *[]string
}

// Select properties to be returned
func (r ApiSharesGetListRequest) Select_(select_ []string) ApiSharesGetListRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiSharesGetListRequest) Expand(expand []string) ApiSharesGetListRequest {
	r.expand = &expand
	return r
}

func (r ApiSharesGetListRequest) Execute() (MicrosoftGraphList, *_nethttp.Response, error) {
	return r.ApiService.SharesGetListExecute(r)
}

/*
SharesGetList Get list from shares

Used to access the underlying list

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param sharedDriveItemId key: id of sharedDriveItem
 @return ApiSharesGetListRequest
*/
func (a *SharesListApiService) SharesGetList(ctx _context.Context, sharedDriveItemId string) ApiSharesGetListRequest {
	return ApiSharesGetListRequest{
		ApiService: a,
		ctx: ctx,
		sharedDriveItemId: sharedDriveItemId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphList
func (a *SharesListApiService) SharesGetListExecute(r ApiSharesGetListRequest) (MicrosoftGraphList, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SharesListApiService.SharesGetList")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/shares/{sharedDriveItem-id}/list"
	localVarPath = strings.Replace(localVarPath, "{"+"sharedDriveItem-id"+"}", _neturl.PathEscape(parameterToString(r.sharedDriveItemId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSharesListColumnsDeleteRefSourceColumnRequest struct {
	ctx _context.Context
	ApiService *SharesListApiService
	sharedDriveItemId string
	columnDefinitionId string
	ifMatch *string
}

// ETag
func (r ApiSharesListColumnsDeleteRefSourceColumnRequest) IfMatch(ifMatch string) ApiSharesListColumnsDeleteRefSourceColumnRequest {
	r.ifMatch = &ifMatch
	return r
}

func (r ApiSharesListColumnsDeleteRefSourceColumnRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.SharesListColumnsDeleteRefSourceColumnExecute(r)
}

/*
SharesListColumnsDeleteRefSourceColumn Delete ref of navigation property sourceColumn for shares

The source column for the content type column.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param sharedDriveItemId key: id of sharedDriveItem
 @param columnDefinitionId key: id of columnDefinition
 @return ApiSharesListColumnsDeleteRefSourceColumnRequest
*/
func (a *SharesListApiService) SharesListColumnsDeleteRefSourceColumn(ctx _context.Context, sharedDriveItemId string, columnDefinitionId string) ApiSharesListColumnsDeleteRefSourceColumnRequest {
	return ApiSharesListColumnsDeleteRefSourceColumnRequest{
		ApiService: a,
		ctx: ctx,
		sharedDriveItemId: sharedDriveItemId,
		columnDefinitionId: columnDefinitionId,
	}
}

// Execute executes the request
func (a *SharesListApiService) SharesListColumnsDeleteRefSourceColumnExecute(r ApiSharesListColumnsDeleteRefSourceColumnRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SharesListApiService.SharesListColumnsDeleteRefSourceColumn")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/shares/{sharedDriveItem-id}/list/columns/{columnDefinition-id}/sourceColumn/$ref"
	localVarPath = strings.Replace(localVarPath, "{"+"sharedDriveItem-id"+"}", _neturl.PathEscape(parameterToString(r.sharedDriveItemId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"columnDefinition-id"+"}", _neturl.PathEscape(parameterToString(r.columnDefinitionId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ifMatch != nil {
		localVarHeaderParams["If-Match"] = parameterToString(*r.ifMatch, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiSharesListColumnsGetRefSourceColumnRequest struct {
	ctx _context.Context
	ApiService *SharesListApiService
	sharedDriveItemId string
	columnDefinitionId string
}


func (r ApiSharesListColumnsGetRefSourceColumnRequest) Execute() (string, *_nethttp.Response, error) {
	return r.ApiService.SharesListColumnsGetRefSourceColumnExecute(r)
}

/*
SharesListColumnsGetRefSourceColumn Get ref of sourceColumn from shares

The source column for the content type column.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param sharedDriveItemId key: id of sharedDriveItem
 @param columnDefinitionId key: id of columnDefinition
 @return ApiSharesListColumnsGetRefSourceColumnRequest
*/
func (a *SharesListApiService) SharesListColumnsGetRefSourceColumn(ctx _context.Context, sharedDriveItemId string, columnDefinitionId string) ApiSharesListColumnsGetRefSourceColumnRequest {
	return ApiSharesListColumnsGetRefSourceColumnRequest{
		ApiService: a,
		ctx: ctx,
		sharedDriveItemId: sharedDriveItemId,
		columnDefinitionId: columnDefinitionId,
	}
}

// Execute executes the request
//  @return string
func (a *SharesListApiService) SharesListColumnsGetRefSourceColumnExecute(r ApiSharesListColumnsGetRefSourceColumnRequest) (string, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  string
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SharesListApiService.SharesListColumnsGetRefSourceColumn")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/shares/{sharedDriveItem-id}/list/columns/{columnDefinition-id}/sourceColumn/$ref"
	localVarPath = strings.Replace(localVarPath, "{"+"sharedDriveItem-id"+"}", _neturl.PathEscape(parameterToString(r.sharedDriveItemId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"columnDefinition-id"+"}", _neturl.PathEscape(parameterToString(r.columnDefinitionId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSharesListColumnsGetSourceColumnRequest struct {
	ctx _context.Context
	ApiService *SharesListApiService
	sharedDriveItemId string
	columnDefinitionId string
	select_ *[]string
	expand *[]string
}

// Select properties to be returned
func (r ApiSharesListColumnsGetSourceColumnRequest) Select_(select_ []string) ApiSharesListColumnsGetSourceColumnRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiSharesListColumnsGetSourceColumnRequest) Expand(expand []string) ApiSharesListColumnsGetSourceColumnRequest {
	r.expand = &expand
	return r
}

func (r ApiSharesListColumnsGetSourceColumnRequest) Execute() (MicrosoftGraphColumnDefinition, *_nethttp.Response, error) {
	return r.ApiService.SharesListColumnsGetSourceColumnExecute(r)
}

/*
SharesListColumnsGetSourceColumn Get sourceColumn from shares

The source column for the content type column.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param sharedDriveItemId key: id of sharedDriveItem
 @param columnDefinitionId key: id of columnDefinition
 @return ApiSharesListColumnsGetSourceColumnRequest
*/
func (a *SharesListApiService) SharesListColumnsGetSourceColumn(ctx _context.Context, sharedDriveItemId string, columnDefinitionId string) ApiSharesListColumnsGetSourceColumnRequest {
	return ApiSharesListColumnsGetSourceColumnRequest{
		ApiService: a,
		ctx: ctx,
		sharedDriveItemId: sharedDriveItemId,
		columnDefinitionId: columnDefinitionId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphColumnDefinition
func (a *SharesListApiService) SharesListColumnsGetSourceColumnExecute(r ApiSharesListColumnsGetSourceColumnRequest) (MicrosoftGraphColumnDefinition, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphColumnDefinition
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SharesListApiService.SharesListColumnsGetSourceColumn")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/shares/{sharedDriveItem-id}/list/columns/{columnDefinition-id}/sourceColumn"
	localVarPath = strings.Replace(localVarPath, "{"+"sharedDriveItem-id"+"}", _neturl.PathEscape(parameterToString(r.sharedDriveItemId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"columnDefinition-id"+"}", _neturl.PathEscape(parameterToString(r.columnDefinitionId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSharesListColumnsUpdateRefSourceColumnRequest struct {
	ctx _context.Context
	ApiService *SharesListApiService
	sharedDriveItemId string
	columnDefinitionId string
	requestBody *map[string]map[string]interface{}
}

// New navigation property ref values
func (r ApiSharesListColumnsUpdateRefSourceColumnRequest) RequestBody(requestBody map[string]map[string]interface{}) ApiSharesListColumnsUpdateRefSourceColumnRequest {
	r.requestBody = &requestBody
	return r
}

func (r ApiSharesListColumnsUpdateRefSourceColumnRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.SharesListColumnsUpdateRefSourceColumnExecute(r)
}

/*
SharesListColumnsUpdateRefSourceColumn Update the ref of navigation property sourceColumn in shares

The source column for the content type column.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param sharedDriveItemId key: id of sharedDriveItem
 @param columnDefinitionId key: id of columnDefinition
 @return ApiSharesListColumnsUpdateRefSourceColumnRequest
*/
func (a *SharesListApiService) SharesListColumnsUpdateRefSourceColumn(ctx _context.Context, sharedDriveItemId string, columnDefinitionId string) ApiSharesListColumnsUpdateRefSourceColumnRequest {
	return ApiSharesListColumnsUpdateRefSourceColumnRequest{
		ApiService: a,
		ctx: ctx,
		sharedDriveItemId: sharedDriveItemId,
		columnDefinitionId: columnDefinitionId,
	}
}

// Execute executes the request
func (a *SharesListApiService) SharesListColumnsUpdateRefSourceColumnExecute(r ApiSharesListColumnsUpdateRefSourceColumnRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPut
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SharesListApiService.SharesListColumnsUpdateRefSourceColumn")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/shares/{sharedDriveItem-id}/list/columns/{columnDefinition-id}/sourceColumn/$ref"
	localVarPath = strings.Replace(localVarPath, "{"+"sharedDriveItem-id"+"}", _neturl.PathEscape(parameterToString(r.sharedDriveItemId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"columnDefinition-id"+"}", _neturl.PathEscape(parameterToString(r.columnDefinitionId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.requestBody == nil {
		return nil, reportError("requestBody is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.requestBody
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiSharesListContentTypesColumnsDeleteRefSourceColumnRequest struct {
	ctx _context.Context
	ApiService *SharesListApiService
	sharedDriveItemId string
	contentTypeId string
	columnDefinitionId string
	ifMatch *string
}

// ETag
func (r ApiSharesListContentTypesColumnsDeleteRefSourceColumnRequest) IfMatch(ifMatch string) ApiSharesListContentTypesColumnsDeleteRefSourceColumnRequest {
	r.ifMatch = &ifMatch
	return r
}

func (r ApiSharesListContentTypesColumnsDeleteRefSourceColumnRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.SharesListContentTypesColumnsDeleteRefSourceColumnExecute(r)
}

/*
SharesListContentTypesColumnsDeleteRefSourceColumn Delete ref of navigation property sourceColumn for shares

The source column for the content type column.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param sharedDriveItemId key: id of sharedDriveItem
 @param contentTypeId key: id of contentType
 @param columnDefinitionId key: id of columnDefinition
 @return ApiSharesListContentTypesColumnsDeleteRefSourceColumnRequest
*/
func (a *SharesListApiService) SharesListContentTypesColumnsDeleteRefSourceColumn(ctx _context.Context, sharedDriveItemId string, contentTypeId string, columnDefinitionId string) ApiSharesListContentTypesColumnsDeleteRefSourceColumnRequest {
	return ApiSharesListContentTypesColumnsDeleteRefSourceColumnRequest{
		ApiService: a,
		ctx: ctx,
		sharedDriveItemId: sharedDriveItemId,
		contentTypeId: contentTypeId,
		columnDefinitionId: columnDefinitionId,
	}
}

// Execute executes the request
func (a *SharesListApiService) SharesListContentTypesColumnsDeleteRefSourceColumnExecute(r ApiSharesListContentTypesColumnsDeleteRefSourceColumnRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SharesListApiService.SharesListContentTypesColumnsDeleteRefSourceColumn")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/shares/{sharedDriveItem-id}/list/contentTypes/{contentType-id}/columns/{columnDefinition-id}/sourceColumn/$ref"
	localVarPath = strings.Replace(localVarPath, "{"+"sharedDriveItem-id"+"}", _neturl.PathEscape(parameterToString(r.sharedDriveItemId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"contentType-id"+"}", _neturl.PathEscape(parameterToString(r.contentTypeId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"columnDefinition-id"+"}", _neturl.PathEscape(parameterToString(r.columnDefinitionId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ifMatch != nil {
		localVarHeaderParams["If-Match"] = parameterToString(*r.ifMatch, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiSharesListContentTypesColumnsGetRefSourceColumnRequest struct {
	ctx _context.Context
	ApiService *SharesListApiService
	sharedDriveItemId string
	contentTypeId string
	columnDefinitionId string
}


func (r ApiSharesListContentTypesColumnsGetRefSourceColumnRequest) Execute() (string, *_nethttp.Response, error) {
	return r.ApiService.SharesListContentTypesColumnsGetRefSourceColumnExecute(r)
}

/*
SharesListContentTypesColumnsGetRefSourceColumn Get ref of sourceColumn from shares

The source column for the content type column.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param sharedDriveItemId key: id of sharedDriveItem
 @param contentTypeId key: id of contentType
 @param columnDefinitionId key: id of columnDefinition
 @return ApiSharesListContentTypesColumnsGetRefSourceColumnRequest
*/
func (a *SharesListApiService) SharesListContentTypesColumnsGetRefSourceColumn(ctx _context.Context, sharedDriveItemId string, contentTypeId string, columnDefinitionId string) ApiSharesListContentTypesColumnsGetRefSourceColumnRequest {
	return ApiSharesListContentTypesColumnsGetRefSourceColumnRequest{
		ApiService: a,
		ctx: ctx,
		sharedDriveItemId: sharedDriveItemId,
		contentTypeId: contentTypeId,
		columnDefinitionId: columnDefinitionId,
	}
}

// Execute executes the request
//  @return string
func (a *SharesListApiService) SharesListContentTypesColumnsGetRefSourceColumnExecute(r ApiSharesListContentTypesColumnsGetRefSourceColumnRequest) (string, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  string
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SharesListApiService.SharesListContentTypesColumnsGetRefSourceColumn")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/shares/{sharedDriveItem-id}/list/contentTypes/{contentType-id}/columns/{columnDefinition-id}/sourceColumn/$ref"
	localVarPath = strings.Replace(localVarPath, "{"+"sharedDriveItem-id"+"}", _neturl.PathEscape(parameterToString(r.sharedDriveItemId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"contentType-id"+"}", _neturl.PathEscape(parameterToString(r.contentTypeId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"columnDefinition-id"+"}", _neturl.PathEscape(parameterToString(r.columnDefinitionId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSharesListContentTypesColumnsGetSourceColumnRequest struct {
	ctx _context.Context
	ApiService *SharesListApiService
	sharedDriveItemId string
	contentTypeId string
	columnDefinitionId string
	select_ *[]string
	expand *[]string
}

// Select properties to be returned
func (r ApiSharesListContentTypesColumnsGetSourceColumnRequest) Select_(select_ []string) ApiSharesListContentTypesColumnsGetSourceColumnRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiSharesListContentTypesColumnsGetSourceColumnRequest) Expand(expand []string) ApiSharesListContentTypesColumnsGetSourceColumnRequest {
	r.expand = &expand
	return r
}

func (r ApiSharesListContentTypesColumnsGetSourceColumnRequest) Execute() (MicrosoftGraphColumnDefinition, *_nethttp.Response, error) {
	return r.ApiService.SharesListContentTypesColumnsGetSourceColumnExecute(r)
}

/*
SharesListContentTypesColumnsGetSourceColumn Get sourceColumn from shares

The source column for the content type column.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param sharedDriveItemId key: id of sharedDriveItem
 @param contentTypeId key: id of contentType
 @param columnDefinitionId key: id of columnDefinition
 @return ApiSharesListContentTypesColumnsGetSourceColumnRequest
*/
func (a *SharesListApiService) SharesListContentTypesColumnsGetSourceColumn(ctx _context.Context, sharedDriveItemId string, contentTypeId string, columnDefinitionId string) ApiSharesListContentTypesColumnsGetSourceColumnRequest {
	return ApiSharesListContentTypesColumnsGetSourceColumnRequest{
		ApiService: a,
		ctx: ctx,
		sharedDriveItemId: sharedDriveItemId,
		contentTypeId: contentTypeId,
		columnDefinitionId: columnDefinitionId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphColumnDefinition
func (a *SharesListApiService) SharesListContentTypesColumnsGetSourceColumnExecute(r ApiSharesListContentTypesColumnsGetSourceColumnRequest) (MicrosoftGraphColumnDefinition, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphColumnDefinition
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SharesListApiService.SharesListContentTypesColumnsGetSourceColumn")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/shares/{sharedDriveItem-id}/list/contentTypes/{contentType-id}/columns/{columnDefinition-id}/sourceColumn"
	localVarPath = strings.Replace(localVarPath, "{"+"sharedDriveItem-id"+"}", _neturl.PathEscape(parameterToString(r.sharedDriveItemId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"contentType-id"+"}", _neturl.PathEscape(parameterToString(r.contentTypeId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"columnDefinition-id"+"}", _neturl.PathEscape(parameterToString(r.columnDefinitionId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSharesListContentTypesColumnsUpdateRefSourceColumnRequest struct {
	ctx _context.Context
	ApiService *SharesListApiService
	sharedDriveItemId string
	contentTypeId string
	columnDefinitionId string
	requestBody *map[string]map[string]interface{}
}

// New navigation property ref values
func (r ApiSharesListContentTypesColumnsUpdateRefSourceColumnRequest) RequestBody(requestBody map[string]map[string]interface{}) ApiSharesListContentTypesColumnsUpdateRefSourceColumnRequest {
	r.requestBody = &requestBody
	return r
}

func (r ApiSharesListContentTypesColumnsUpdateRefSourceColumnRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.SharesListContentTypesColumnsUpdateRefSourceColumnExecute(r)
}

/*
SharesListContentTypesColumnsUpdateRefSourceColumn Update the ref of navigation property sourceColumn in shares

The source column for the content type column.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param sharedDriveItemId key: id of sharedDriveItem
 @param contentTypeId key: id of contentType
 @param columnDefinitionId key: id of columnDefinition
 @return ApiSharesListContentTypesColumnsUpdateRefSourceColumnRequest
*/
func (a *SharesListApiService) SharesListContentTypesColumnsUpdateRefSourceColumn(ctx _context.Context, sharedDriveItemId string, contentTypeId string, columnDefinitionId string) ApiSharesListContentTypesColumnsUpdateRefSourceColumnRequest {
	return ApiSharesListContentTypesColumnsUpdateRefSourceColumnRequest{
		ApiService: a,
		ctx: ctx,
		sharedDriveItemId: sharedDriveItemId,
		contentTypeId: contentTypeId,
		columnDefinitionId: columnDefinitionId,
	}
}

// Execute executes the request
func (a *SharesListApiService) SharesListContentTypesColumnsUpdateRefSourceColumnExecute(r ApiSharesListContentTypesColumnsUpdateRefSourceColumnRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPut
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SharesListApiService.SharesListContentTypesColumnsUpdateRefSourceColumn")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/shares/{sharedDriveItem-id}/list/contentTypes/{contentType-id}/columns/{columnDefinition-id}/sourceColumn/$ref"
	localVarPath = strings.Replace(localVarPath, "{"+"sharedDriveItem-id"+"}", _neturl.PathEscape(parameterToString(r.sharedDriveItemId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"contentType-id"+"}", _neturl.PathEscape(parameterToString(r.contentTypeId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"columnDefinition-id"+"}", _neturl.PathEscape(parameterToString(r.columnDefinitionId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.requestBody == nil {
		return nil, reportError("requestBody is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.requestBody
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiSharesListContentTypesCreateColumnLinksRequest struct {
	ctx _context.Context
	ApiService *SharesListApiService
	sharedDriveItemId string
	contentTypeId string
	microsoftGraphColumnLink *MicrosoftGraphColumnLink
}

// New navigation property
func (r ApiSharesListContentTypesCreateColumnLinksRequest) MicrosoftGraphColumnLink(microsoftGraphColumnLink MicrosoftGraphColumnLink) ApiSharesListContentTypesCreateColumnLinksRequest {
	r.microsoftGraphColumnLink = &microsoftGraphColumnLink
	return r
}

func (r ApiSharesListContentTypesCreateColumnLinksRequest) Execute() (MicrosoftGraphColumnLink, *_nethttp.Response, error) {
	return r.ApiService.SharesListContentTypesCreateColumnLinksExecute(r)
}

/*
SharesListContentTypesCreateColumnLinks Create new navigation property to columnLinks for shares

The collection of columns that are required by this content type.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param sharedDriveItemId key: id of sharedDriveItem
 @param contentTypeId key: id of contentType
 @return ApiSharesListContentTypesCreateColumnLinksRequest
*/
func (a *SharesListApiService) SharesListContentTypesCreateColumnLinks(ctx _context.Context, sharedDriveItemId string, contentTypeId string) ApiSharesListContentTypesCreateColumnLinksRequest {
	return ApiSharesListContentTypesCreateColumnLinksRequest{
		ApiService: a,
		ctx: ctx,
		sharedDriveItemId: sharedDriveItemId,
		contentTypeId: contentTypeId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphColumnLink
func (a *SharesListApiService) SharesListContentTypesCreateColumnLinksExecute(r ApiSharesListContentTypesCreateColumnLinksRequest) (MicrosoftGraphColumnLink, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphColumnLink
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SharesListApiService.SharesListContentTypesCreateColumnLinks")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/shares/{sharedDriveItem-id}/list/contentTypes/{contentType-id}/columnLinks"
	localVarPath = strings.Replace(localVarPath, "{"+"sharedDriveItem-id"+"}", _neturl.PathEscape(parameterToString(r.sharedDriveItemId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"contentType-id"+"}", _neturl.PathEscape(parameterToString(r.contentTypeId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphColumnLink == nil {
		return localVarReturnValue, nil, reportError("microsoftGraphColumnLink is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphColumnLink
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSharesListContentTypesCreateColumnsRequest struct {
	ctx _context.Context
	ApiService *SharesListApiService
	sharedDriveItemId string
	contentTypeId string
	microsoftGraphColumnDefinition *MicrosoftGraphColumnDefinition
}

// New navigation property
func (r ApiSharesListContentTypesCreateColumnsRequest) MicrosoftGraphColumnDefinition(microsoftGraphColumnDefinition MicrosoftGraphColumnDefinition) ApiSharesListContentTypesCreateColumnsRequest {
	r.microsoftGraphColumnDefinition = &microsoftGraphColumnDefinition
	return r
}

func (r ApiSharesListContentTypesCreateColumnsRequest) Execute() (MicrosoftGraphColumnDefinition, *_nethttp.Response, error) {
	return r.ApiService.SharesListContentTypesCreateColumnsExecute(r)
}

/*
SharesListContentTypesCreateColumns Create new navigation property to columns for shares

The collection of column definitions for this contentType.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param sharedDriveItemId key: id of sharedDriveItem
 @param contentTypeId key: id of contentType
 @return ApiSharesListContentTypesCreateColumnsRequest
*/
func (a *SharesListApiService) SharesListContentTypesCreateColumns(ctx _context.Context, sharedDriveItemId string, contentTypeId string) ApiSharesListContentTypesCreateColumnsRequest {
	return ApiSharesListContentTypesCreateColumnsRequest{
		ApiService: a,
		ctx: ctx,
		sharedDriveItemId: sharedDriveItemId,
		contentTypeId: contentTypeId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphColumnDefinition
func (a *SharesListApiService) SharesListContentTypesCreateColumnsExecute(r ApiSharesListContentTypesCreateColumnsRequest) (MicrosoftGraphColumnDefinition, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphColumnDefinition
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SharesListApiService.SharesListContentTypesCreateColumns")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/shares/{sharedDriveItem-id}/list/contentTypes/{contentType-id}/columns"
	localVarPath = strings.Replace(localVarPath, "{"+"sharedDriveItem-id"+"}", _neturl.PathEscape(parameterToString(r.sharedDriveItemId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"contentType-id"+"}", _neturl.PathEscape(parameterToString(r.contentTypeId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphColumnDefinition == nil {
		return localVarReturnValue, nil, reportError("microsoftGraphColumnDefinition is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphColumnDefinition
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSharesListContentTypesCreateRefBaseTypesRequest struct {
	ctx _context.Context
	ApiService *SharesListApiService
	sharedDriveItemId string
	contentTypeId string
	requestBody *map[string]map[string]interface{}
}

// New navigation property ref value
func (r ApiSharesListContentTypesCreateRefBaseTypesRequest) RequestBody(requestBody map[string]map[string]interface{}) ApiSharesListContentTypesCreateRefBaseTypesRequest {
	r.requestBody = &requestBody
	return r
}

func (r ApiSharesListContentTypesCreateRefBaseTypesRequest) Execute() (map[string]interface{}, *_nethttp.Response, error) {
	return r.ApiService.SharesListContentTypesCreateRefBaseTypesExecute(r)
}

/*
SharesListContentTypesCreateRefBaseTypes Create new navigation property ref to baseTypes for shares

The collection of content types that are ancestors of this content type.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param sharedDriveItemId key: id of sharedDriveItem
 @param contentTypeId key: id of contentType
 @return ApiSharesListContentTypesCreateRefBaseTypesRequest
*/
func (a *SharesListApiService) SharesListContentTypesCreateRefBaseTypes(ctx _context.Context, sharedDriveItemId string, contentTypeId string) ApiSharesListContentTypesCreateRefBaseTypesRequest {
	return ApiSharesListContentTypesCreateRefBaseTypesRequest{
		ApiService: a,
		ctx: ctx,
		sharedDriveItemId: sharedDriveItemId,
		contentTypeId: contentTypeId,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *SharesListApiService) SharesListContentTypesCreateRefBaseTypesExecute(r ApiSharesListContentTypesCreateRefBaseTypesRequest) (map[string]interface{}, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SharesListApiService.SharesListContentTypesCreateRefBaseTypes")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/shares/{sharedDriveItem-id}/list/contentTypes/{contentType-id}/baseTypes/$ref"
	localVarPath = strings.Replace(localVarPath, "{"+"sharedDriveItem-id"+"}", _neturl.PathEscape(parameterToString(r.sharedDriveItemId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"contentType-id"+"}", _neturl.PathEscape(parameterToString(r.contentTypeId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.requestBody == nil {
		return localVarReturnValue, nil, reportError("requestBody is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.requestBody
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSharesListContentTypesCreateRefColumnPositionsRequest struct {
	ctx _context.Context
	ApiService *SharesListApiService
	sharedDriveItemId string
	contentTypeId string
	requestBody *map[string]map[string]interface{}
}

// New navigation property ref value
func (r ApiSharesListContentTypesCreateRefColumnPositionsRequest) RequestBody(requestBody map[string]map[string]interface{}) ApiSharesListContentTypesCreateRefColumnPositionsRequest {
	r.requestBody = &requestBody
	return r
}

func (r ApiSharesListContentTypesCreateRefColumnPositionsRequest) Execute() (map[string]interface{}, *_nethttp.Response, error) {
	return r.ApiService.SharesListContentTypesCreateRefColumnPositionsExecute(r)
}

/*
SharesListContentTypesCreateRefColumnPositions Create new navigation property ref to columnPositions for shares

Column order information in a content type.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param sharedDriveItemId key: id of sharedDriveItem
 @param contentTypeId key: id of contentType
 @return ApiSharesListContentTypesCreateRefColumnPositionsRequest
*/
func (a *SharesListApiService) SharesListContentTypesCreateRefColumnPositions(ctx _context.Context, sharedDriveItemId string, contentTypeId string) ApiSharesListContentTypesCreateRefColumnPositionsRequest {
	return ApiSharesListContentTypesCreateRefColumnPositionsRequest{
		ApiService: a,
		ctx: ctx,
		sharedDriveItemId: sharedDriveItemId,
		contentTypeId: contentTypeId,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *SharesListApiService) SharesListContentTypesCreateRefColumnPositionsExecute(r ApiSharesListContentTypesCreateRefColumnPositionsRequest) (map[string]interface{}, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SharesListApiService.SharesListContentTypesCreateRefColumnPositions")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/shares/{sharedDriveItem-id}/list/contentTypes/{contentType-id}/columnPositions/$ref"
	localVarPath = strings.Replace(localVarPath, "{"+"sharedDriveItem-id"+"}", _neturl.PathEscape(parameterToString(r.sharedDriveItemId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"contentType-id"+"}", _neturl.PathEscape(parameterToString(r.contentTypeId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.requestBody == nil {
		return localVarReturnValue, nil, reportError("requestBody is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.requestBody
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSharesListContentTypesDeleteColumnLinksRequest struct {
	ctx _context.Context
	ApiService *SharesListApiService
	sharedDriveItemId string
	contentTypeId string
	columnLinkId string
	ifMatch *string
}

// ETag
func (r ApiSharesListContentTypesDeleteColumnLinksRequest) IfMatch(ifMatch string) ApiSharesListContentTypesDeleteColumnLinksRequest {
	r.ifMatch = &ifMatch
	return r
}

func (r ApiSharesListContentTypesDeleteColumnLinksRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.SharesListContentTypesDeleteColumnLinksExecute(r)
}

/*
SharesListContentTypesDeleteColumnLinks Delete navigation property columnLinks for shares

The collection of columns that are required by this content type.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param sharedDriveItemId key: id of sharedDriveItem
 @param contentTypeId key: id of contentType
 @param columnLinkId key: id of columnLink
 @return ApiSharesListContentTypesDeleteColumnLinksRequest
*/
func (a *SharesListApiService) SharesListContentTypesDeleteColumnLinks(ctx _context.Context, sharedDriveItemId string, contentTypeId string, columnLinkId string) ApiSharesListContentTypesDeleteColumnLinksRequest {
	return ApiSharesListContentTypesDeleteColumnLinksRequest{
		ApiService: a,
		ctx: ctx,
		sharedDriveItemId: sharedDriveItemId,
		contentTypeId: contentTypeId,
		columnLinkId: columnLinkId,
	}
}

// Execute executes the request
func (a *SharesListApiService) SharesListContentTypesDeleteColumnLinksExecute(r ApiSharesListContentTypesDeleteColumnLinksRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SharesListApiService.SharesListContentTypesDeleteColumnLinks")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/shares/{sharedDriveItem-id}/list/contentTypes/{contentType-id}/columnLinks/{columnLink-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"sharedDriveItem-id"+"}", _neturl.PathEscape(parameterToString(r.sharedDriveItemId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"contentType-id"+"}", _neturl.PathEscape(parameterToString(r.contentTypeId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"columnLink-id"+"}", _neturl.PathEscape(parameterToString(r.columnLinkId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ifMatch != nil {
		localVarHeaderParams["If-Match"] = parameterToString(*r.ifMatch, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiSharesListContentTypesDeleteColumnsRequest struct {
	ctx _context.Context
	ApiService *SharesListApiService
	sharedDriveItemId string
	contentTypeId string
	columnDefinitionId string
	ifMatch *string
}

// ETag
func (r ApiSharesListContentTypesDeleteColumnsRequest) IfMatch(ifMatch string) ApiSharesListContentTypesDeleteColumnsRequest {
	r.ifMatch = &ifMatch
	return r
}

func (r ApiSharesListContentTypesDeleteColumnsRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.SharesListContentTypesDeleteColumnsExecute(r)
}

/*
SharesListContentTypesDeleteColumns Delete navigation property columns for shares

The collection of column definitions for this contentType.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param sharedDriveItemId key: id of sharedDriveItem
 @param contentTypeId key: id of contentType
 @param columnDefinitionId key: id of columnDefinition
 @return ApiSharesListContentTypesDeleteColumnsRequest
*/
func (a *SharesListApiService) SharesListContentTypesDeleteColumns(ctx _context.Context, sharedDriveItemId string, contentTypeId string, columnDefinitionId string) ApiSharesListContentTypesDeleteColumnsRequest {
	return ApiSharesListContentTypesDeleteColumnsRequest{
		ApiService: a,
		ctx: ctx,
		sharedDriveItemId: sharedDriveItemId,
		contentTypeId: contentTypeId,
		columnDefinitionId: columnDefinitionId,
	}
}

// Execute executes the request
func (a *SharesListApiService) SharesListContentTypesDeleteColumnsExecute(r ApiSharesListContentTypesDeleteColumnsRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SharesListApiService.SharesListContentTypesDeleteColumns")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/shares/{sharedDriveItem-id}/list/contentTypes/{contentType-id}/columns/{columnDefinition-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"sharedDriveItem-id"+"}", _neturl.PathEscape(parameterToString(r.sharedDriveItemId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"contentType-id"+"}", _neturl.PathEscape(parameterToString(r.contentTypeId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"columnDefinition-id"+"}", _neturl.PathEscape(parameterToString(r.columnDefinitionId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ifMatch != nil {
		localVarHeaderParams["If-Match"] = parameterToString(*r.ifMatch, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiSharesListContentTypesDeleteRefBaseRequest struct {
	ctx _context.Context
	ApiService *SharesListApiService
	sharedDriveItemId string
	contentTypeId string
	ifMatch *string
}

// ETag
func (r ApiSharesListContentTypesDeleteRefBaseRequest) IfMatch(ifMatch string) ApiSharesListContentTypesDeleteRefBaseRequest {
	r.ifMatch = &ifMatch
	return r
}

func (r ApiSharesListContentTypesDeleteRefBaseRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.SharesListContentTypesDeleteRefBaseExecute(r)
}

/*
SharesListContentTypesDeleteRefBase Delete ref of navigation property base for shares

Parent contentType from which this content type is derived.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param sharedDriveItemId key: id of sharedDriveItem
 @param contentTypeId key: id of contentType
 @return ApiSharesListContentTypesDeleteRefBaseRequest
*/
func (a *SharesListApiService) SharesListContentTypesDeleteRefBase(ctx _context.Context, sharedDriveItemId string, contentTypeId string) ApiSharesListContentTypesDeleteRefBaseRequest {
	return ApiSharesListContentTypesDeleteRefBaseRequest{
		ApiService: a,
		ctx: ctx,
		sharedDriveItemId: sharedDriveItemId,
		contentTypeId: contentTypeId,
	}
}

// Execute executes the request
func (a *SharesListApiService) SharesListContentTypesDeleteRefBaseExecute(r ApiSharesListContentTypesDeleteRefBaseRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SharesListApiService.SharesListContentTypesDeleteRefBase")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/shares/{sharedDriveItem-id}/list/contentTypes/{contentType-id}/base/$ref"
	localVarPath = strings.Replace(localVarPath, "{"+"sharedDriveItem-id"+"}", _neturl.PathEscape(parameterToString(r.sharedDriveItemId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"contentType-id"+"}", _neturl.PathEscape(parameterToString(r.contentTypeId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ifMatch != nil {
		localVarHeaderParams["If-Match"] = parameterToString(*r.ifMatch, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiSharesListContentTypesGetBaseRequest struct {
	ctx _context.Context
	ApiService *SharesListApiService
	sharedDriveItemId string
	contentTypeId string
	select_ *[]string
	expand *[]string
}

// Select properties to be returned
func (r ApiSharesListContentTypesGetBaseRequest) Select_(select_ []string) ApiSharesListContentTypesGetBaseRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiSharesListContentTypesGetBaseRequest) Expand(expand []string) ApiSharesListContentTypesGetBaseRequest {
	r.expand = &expand
	return r
}

func (r ApiSharesListContentTypesGetBaseRequest) Execute() (MicrosoftGraphContentType, *_nethttp.Response, error) {
	return r.ApiService.SharesListContentTypesGetBaseExecute(r)
}

/*
SharesListContentTypesGetBase Get base from shares

Parent contentType from which this content type is derived.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param sharedDriveItemId key: id of sharedDriveItem
 @param contentTypeId key: id of contentType
 @return ApiSharesListContentTypesGetBaseRequest
*/
func (a *SharesListApiService) SharesListContentTypesGetBase(ctx _context.Context, sharedDriveItemId string, contentTypeId string) ApiSharesListContentTypesGetBaseRequest {
	return ApiSharesListContentTypesGetBaseRequest{
		ApiService: a,
		ctx: ctx,
		sharedDriveItemId: sharedDriveItemId,
		contentTypeId: contentTypeId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphContentType
func (a *SharesListApiService) SharesListContentTypesGetBaseExecute(r ApiSharesListContentTypesGetBaseRequest) (MicrosoftGraphContentType, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphContentType
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SharesListApiService.SharesListContentTypesGetBase")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/shares/{sharedDriveItem-id}/list/contentTypes/{contentType-id}/base"
	localVarPath = strings.Replace(localVarPath, "{"+"sharedDriveItem-id"+"}", _neturl.PathEscape(parameterToString(r.sharedDriveItemId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"contentType-id"+"}", _neturl.PathEscape(parameterToString(r.contentTypeId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSharesListContentTypesGetColumnLinksRequest struct {
	ctx _context.Context
	ApiService *SharesListApiService
	sharedDriveItemId string
	contentTypeId string
	columnLinkId string
	select_ *[]string
	expand *[]string
}

// Select properties to be returned
func (r ApiSharesListContentTypesGetColumnLinksRequest) Select_(select_ []string) ApiSharesListContentTypesGetColumnLinksRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiSharesListContentTypesGetColumnLinksRequest) Expand(expand []string) ApiSharesListContentTypesGetColumnLinksRequest {
	r.expand = &expand
	return r
}

func (r ApiSharesListContentTypesGetColumnLinksRequest) Execute() (MicrosoftGraphColumnLink, *_nethttp.Response, error) {
	return r.ApiService.SharesListContentTypesGetColumnLinksExecute(r)
}

/*
SharesListContentTypesGetColumnLinks Get columnLinks from shares

The collection of columns that are required by this content type.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param sharedDriveItemId key: id of sharedDriveItem
 @param contentTypeId key: id of contentType
 @param columnLinkId key: id of columnLink
 @return ApiSharesListContentTypesGetColumnLinksRequest
*/
func (a *SharesListApiService) SharesListContentTypesGetColumnLinks(ctx _context.Context, sharedDriveItemId string, contentTypeId string, columnLinkId string) ApiSharesListContentTypesGetColumnLinksRequest {
	return ApiSharesListContentTypesGetColumnLinksRequest{
		ApiService: a,
		ctx: ctx,
		sharedDriveItemId: sharedDriveItemId,
		contentTypeId: contentTypeId,
		columnLinkId: columnLinkId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphColumnLink
func (a *SharesListApiService) SharesListContentTypesGetColumnLinksExecute(r ApiSharesListContentTypesGetColumnLinksRequest) (MicrosoftGraphColumnLink, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphColumnLink
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SharesListApiService.SharesListContentTypesGetColumnLinks")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/shares/{sharedDriveItem-id}/list/contentTypes/{contentType-id}/columnLinks/{columnLink-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"sharedDriveItem-id"+"}", _neturl.PathEscape(parameterToString(r.sharedDriveItemId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"contentType-id"+"}", _neturl.PathEscape(parameterToString(r.contentTypeId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"columnLink-id"+"}", _neturl.PathEscape(parameterToString(r.columnLinkId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSharesListContentTypesGetColumnsRequest struct {
	ctx _context.Context
	ApiService *SharesListApiService
	sharedDriveItemId string
	contentTypeId string
	columnDefinitionId string
	select_ *[]string
	expand *[]string
}

// Select properties to be returned
func (r ApiSharesListContentTypesGetColumnsRequest) Select_(select_ []string) ApiSharesListContentTypesGetColumnsRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiSharesListContentTypesGetColumnsRequest) Expand(expand []string) ApiSharesListContentTypesGetColumnsRequest {
	r.expand = &expand
	return r
}

func (r ApiSharesListContentTypesGetColumnsRequest) Execute() (MicrosoftGraphColumnDefinition, *_nethttp.Response, error) {
	return r.ApiService.SharesListContentTypesGetColumnsExecute(r)
}

/*
SharesListContentTypesGetColumns Get columns from shares

The collection of column definitions for this contentType.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param sharedDriveItemId key: id of sharedDriveItem
 @param contentTypeId key: id of contentType
 @param columnDefinitionId key: id of columnDefinition
 @return ApiSharesListContentTypesGetColumnsRequest
*/
func (a *SharesListApiService) SharesListContentTypesGetColumns(ctx _context.Context, sharedDriveItemId string, contentTypeId string, columnDefinitionId string) ApiSharesListContentTypesGetColumnsRequest {
	return ApiSharesListContentTypesGetColumnsRequest{
		ApiService: a,
		ctx: ctx,
		sharedDriveItemId: sharedDriveItemId,
		contentTypeId: contentTypeId,
		columnDefinitionId: columnDefinitionId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphColumnDefinition
func (a *SharesListApiService) SharesListContentTypesGetColumnsExecute(r ApiSharesListContentTypesGetColumnsRequest) (MicrosoftGraphColumnDefinition, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphColumnDefinition
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SharesListApiService.SharesListContentTypesGetColumns")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/shares/{sharedDriveItem-id}/list/contentTypes/{contentType-id}/columns/{columnDefinition-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"sharedDriveItem-id"+"}", _neturl.PathEscape(parameterToString(r.sharedDriveItemId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"contentType-id"+"}", _neturl.PathEscape(parameterToString(r.contentTypeId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"columnDefinition-id"+"}", _neturl.PathEscape(parameterToString(r.columnDefinitionId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSharesListContentTypesGetRefBaseRequest struct {
	ctx _context.Context
	ApiService *SharesListApiService
	sharedDriveItemId string
	contentTypeId string
}


func (r ApiSharesListContentTypesGetRefBaseRequest) Execute() (string, *_nethttp.Response, error) {
	return r.ApiService.SharesListContentTypesGetRefBaseExecute(r)
}

/*
SharesListContentTypesGetRefBase Get ref of base from shares

Parent contentType from which this content type is derived.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param sharedDriveItemId key: id of sharedDriveItem
 @param contentTypeId key: id of contentType
 @return ApiSharesListContentTypesGetRefBaseRequest
*/
func (a *SharesListApiService) SharesListContentTypesGetRefBase(ctx _context.Context, sharedDriveItemId string, contentTypeId string) ApiSharesListContentTypesGetRefBaseRequest {
	return ApiSharesListContentTypesGetRefBaseRequest{
		ApiService: a,
		ctx: ctx,
		sharedDriveItemId: sharedDriveItemId,
		contentTypeId: contentTypeId,
	}
}

// Execute executes the request
//  @return string
func (a *SharesListApiService) SharesListContentTypesGetRefBaseExecute(r ApiSharesListContentTypesGetRefBaseRequest) (string, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  string
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SharesListApiService.SharesListContentTypesGetRefBase")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/shares/{sharedDriveItem-id}/list/contentTypes/{contentType-id}/base/$ref"
	localVarPath = strings.Replace(localVarPath, "{"+"sharedDriveItem-id"+"}", _neturl.PathEscape(parameterToString(r.sharedDriveItemId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"contentType-id"+"}", _neturl.PathEscape(parameterToString(r.contentTypeId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSharesListContentTypesListBaseTypesRequest struct {
	ctx _context.Context
	ApiService *SharesListApiService
	sharedDriveItemId string
	contentTypeId string
	top *int32
	skip *int32
	search *string
	filter *string
	count *bool
	orderby *[]string
	select_ *[]string
	expand *[]string
}

// Show only the first n items
func (r ApiSharesListContentTypesListBaseTypesRequest) Top(top int32) ApiSharesListContentTypesListBaseTypesRequest {
	r.top = &top
	return r
}
// Skip the first n items
func (r ApiSharesListContentTypesListBaseTypesRequest) Skip(skip int32) ApiSharesListContentTypesListBaseTypesRequest {
	r.skip = &skip
	return r
}
// Search items by search phrases
func (r ApiSharesListContentTypesListBaseTypesRequest) Search(search string) ApiSharesListContentTypesListBaseTypesRequest {
	r.search = &search
	return r
}
// Filter items by property values
func (r ApiSharesListContentTypesListBaseTypesRequest) Filter(filter string) ApiSharesListContentTypesListBaseTypesRequest {
	r.filter = &filter
	return r
}
// Include count of items
func (r ApiSharesListContentTypesListBaseTypesRequest) Count(count bool) ApiSharesListContentTypesListBaseTypesRequest {
	r.count = &count
	return r
}
// Order items by property values
func (r ApiSharesListContentTypesListBaseTypesRequest) Orderby(orderby []string) ApiSharesListContentTypesListBaseTypesRequest {
	r.orderby = &orderby
	return r
}
// Select properties to be returned
func (r ApiSharesListContentTypesListBaseTypesRequest) Select_(select_ []string) ApiSharesListContentTypesListBaseTypesRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiSharesListContentTypesListBaseTypesRequest) Expand(expand []string) ApiSharesListContentTypesListBaseTypesRequest {
	r.expand = &expand
	return r
}

func (r ApiSharesListContentTypesListBaseTypesRequest) Execute() (CollectionOfContentType, *_nethttp.Response, error) {
	return r.ApiService.SharesListContentTypesListBaseTypesExecute(r)
}

/*
SharesListContentTypesListBaseTypes Get baseTypes from shares

The collection of content types that are ancestors of this content type.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param sharedDriveItemId key: id of sharedDriveItem
 @param contentTypeId key: id of contentType
 @return ApiSharesListContentTypesListBaseTypesRequest
*/
func (a *SharesListApiService) SharesListContentTypesListBaseTypes(ctx _context.Context, sharedDriveItemId string, contentTypeId string) ApiSharesListContentTypesListBaseTypesRequest {
	return ApiSharesListContentTypesListBaseTypesRequest{
		ApiService: a,
		ctx: ctx,
		sharedDriveItemId: sharedDriveItemId,
		contentTypeId: contentTypeId,
	}
}

// Execute executes the request
//  @return CollectionOfContentType
func (a *SharesListApiService) SharesListContentTypesListBaseTypesExecute(r ApiSharesListContentTypesListBaseTypesRequest) (CollectionOfContentType, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  CollectionOfContentType
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SharesListApiService.SharesListContentTypesListBaseTypes")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/shares/{sharedDriveItem-id}/list/contentTypes/{contentType-id}/baseTypes"
	localVarPath = strings.Replace(localVarPath, "{"+"sharedDriveItem-id"+"}", _neturl.PathEscape(parameterToString(r.sharedDriveItemId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"contentType-id"+"}", _neturl.PathEscape(parameterToString(r.contentTypeId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.top != nil {
		localVarQueryParams.Add("$top", parameterToString(*r.top, ""))
	}
	if r.skip != nil {
		localVarQueryParams.Add("$skip", parameterToString(*r.skip, ""))
	}
	if r.search != nil {
		localVarQueryParams.Add("$search", parameterToString(*r.search, ""))
	}
	if r.filter != nil {
		localVarQueryParams.Add("$filter", parameterToString(*r.filter, ""))
	}
	if r.count != nil {
		localVarQueryParams.Add("$count", parameterToString(*r.count, ""))
	}
	if r.orderby != nil {
		localVarQueryParams.Add("$orderby", parameterToString(*r.orderby, "csv"))
	}
	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSharesListContentTypesListColumnLinksRequest struct {
	ctx _context.Context
	ApiService *SharesListApiService
	sharedDriveItemId string
	contentTypeId string
	top *int32
	skip *int32
	search *string
	filter *string
	count *bool
	orderby *[]string
	select_ *[]string
	expand *[]string
}

// Show only the first n items
func (r ApiSharesListContentTypesListColumnLinksRequest) Top(top int32) ApiSharesListContentTypesListColumnLinksRequest {
	r.top = &top
	return r
}
// Skip the first n items
func (r ApiSharesListContentTypesListColumnLinksRequest) Skip(skip int32) ApiSharesListContentTypesListColumnLinksRequest {
	r.skip = &skip
	return r
}
// Search items by search phrases
func (r ApiSharesListContentTypesListColumnLinksRequest) Search(search string) ApiSharesListContentTypesListColumnLinksRequest {
	r.search = &search
	return r
}
// Filter items by property values
func (r ApiSharesListContentTypesListColumnLinksRequest) Filter(filter string) ApiSharesListContentTypesListColumnLinksRequest {
	r.filter = &filter
	return r
}
// Include count of items
func (r ApiSharesListContentTypesListColumnLinksRequest) Count(count bool) ApiSharesListContentTypesListColumnLinksRequest {
	r.count = &count
	return r
}
// Order items by property values
func (r ApiSharesListContentTypesListColumnLinksRequest) Orderby(orderby []string) ApiSharesListContentTypesListColumnLinksRequest {
	r.orderby = &orderby
	return r
}
// Select properties to be returned
func (r ApiSharesListContentTypesListColumnLinksRequest) Select_(select_ []string) ApiSharesListContentTypesListColumnLinksRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiSharesListContentTypesListColumnLinksRequest) Expand(expand []string) ApiSharesListContentTypesListColumnLinksRequest {
	r.expand = &expand
	return r
}

func (r ApiSharesListContentTypesListColumnLinksRequest) Execute() (CollectionOfColumnLink, *_nethttp.Response, error) {
	return r.ApiService.SharesListContentTypesListColumnLinksExecute(r)
}

/*
SharesListContentTypesListColumnLinks Get columnLinks from shares

The collection of columns that are required by this content type.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param sharedDriveItemId key: id of sharedDriveItem
 @param contentTypeId key: id of contentType
 @return ApiSharesListContentTypesListColumnLinksRequest
*/
func (a *SharesListApiService) SharesListContentTypesListColumnLinks(ctx _context.Context, sharedDriveItemId string, contentTypeId string) ApiSharesListContentTypesListColumnLinksRequest {
	return ApiSharesListContentTypesListColumnLinksRequest{
		ApiService: a,
		ctx: ctx,
		sharedDriveItemId: sharedDriveItemId,
		contentTypeId: contentTypeId,
	}
}

// Execute executes the request
//  @return CollectionOfColumnLink
func (a *SharesListApiService) SharesListContentTypesListColumnLinksExecute(r ApiSharesListContentTypesListColumnLinksRequest) (CollectionOfColumnLink, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  CollectionOfColumnLink
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SharesListApiService.SharesListContentTypesListColumnLinks")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/shares/{sharedDriveItem-id}/list/contentTypes/{contentType-id}/columnLinks"
	localVarPath = strings.Replace(localVarPath, "{"+"sharedDriveItem-id"+"}", _neturl.PathEscape(parameterToString(r.sharedDriveItemId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"contentType-id"+"}", _neturl.PathEscape(parameterToString(r.contentTypeId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.top != nil {
		localVarQueryParams.Add("$top", parameterToString(*r.top, ""))
	}
	if r.skip != nil {
		localVarQueryParams.Add("$skip", parameterToString(*r.skip, ""))
	}
	if r.search != nil {
		localVarQueryParams.Add("$search", parameterToString(*r.search, ""))
	}
	if r.filter != nil {
		localVarQueryParams.Add("$filter", parameterToString(*r.filter, ""))
	}
	if r.count != nil {
		localVarQueryParams.Add("$count", parameterToString(*r.count, ""))
	}
	if r.orderby != nil {
		localVarQueryParams.Add("$orderby", parameterToString(*r.orderby, "csv"))
	}
	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSharesListContentTypesListColumnPositionsRequest struct {
	ctx _context.Context
	ApiService *SharesListApiService
	sharedDriveItemId string
	contentTypeId string
	top *int32
	skip *int32
	search *string
	filter *string
	count *bool
	orderby *[]string
	select_ *[]string
	expand *[]string
}

// Show only the first n items
func (r ApiSharesListContentTypesListColumnPositionsRequest) Top(top int32) ApiSharesListContentTypesListColumnPositionsRequest {
	r.top = &top
	return r
}
// Skip the first n items
func (r ApiSharesListContentTypesListColumnPositionsRequest) Skip(skip int32) ApiSharesListContentTypesListColumnPositionsRequest {
	r.skip = &skip
	return r
}
// Search items by search phrases
func (r ApiSharesListContentTypesListColumnPositionsRequest) Search(search string) ApiSharesListContentTypesListColumnPositionsRequest {
	r.search = &search
	return r
}
// Filter items by property values
func (r ApiSharesListContentTypesListColumnPositionsRequest) Filter(filter string) ApiSharesListContentTypesListColumnPositionsRequest {
	r.filter = &filter
	return r
}
// Include count of items
func (r ApiSharesListContentTypesListColumnPositionsRequest) Count(count bool) ApiSharesListContentTypesListColumnPositionsRequest {
	r.count = &count
	return r
}
// Order items by property values
func (r ApiSharesListContentTypesListColumnPositionsRequest) Orderby(orderby []string) ApiSharesListContentTypesListColumnPositionsRequest {
	r.orderby = &orderby
	return r
}
// Select properties to be returned
func (r ApiSharesListContentTypesListColumnPositionsRequest) Select_(select_ []string) ApiSharesListContentTypesListColumnPositionsRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiSharesListContentTypesListColumnPositionsRequest) Expand(expand []string) ApiSharesListContentTypesListColumnPositionsRequest {
	r.expand = &expand
	return r
}

func (r ApiSharesListContentTypesListColumnPositionsRequest) Execute() (CollectionOfColumnDefinition, *_nethttp.Response, error) {
	return r.ApiService.SharesListContentTypesListColumnPositionsExecute(r)
}

/*
SharesListContentTypesListColumnPositions Get columnPositions from shares

Column order information in a content type.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param sharedDriveItemId key: id of sharedDriveItem
 @param contentTypeId key: id of contentType
 @return ApiSharesListContentTypesListColumnPositionsRequest
*/
func (a *SharesListApiService) SharesListContentTypesListColumnPositions(ctx _context.Context, sharedDriveItemId string, contentTypeId string) ApiSharesListContentTypesListColumnPositionsRequest {
	return ApiSharesListContentTypesListColumnPositionsRequest{
		ApiService: a,
		ctx: ctx,
		sharedDriveItemId: sharedDriveItemId,
		contentTypeId: contentTypeId,
	}
}

// Execute executes the request
//  @return CollectionOfColumnDefinition
func (a *SharesListApiService) SharesListContentTypesListColumnPositionsExecute(r ApiSharesListContentTypesListColumnPositionsRequest) (CollectionOfColumnDefinition, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  CollectionOfColumnDefinition
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SharesListApiService.SharesListContentTypesListColumnPositions")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/shares/{sharedDriveItem-id}/list/contentTypes/{contentType-id}/columnPositions"
	localVarPath = strings.Replace(localVarPath, "{"+"sharedDriveItem-id"+"}", _neturl.PathEscape(parameterToString(r.sharedDriveItemId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"contentType-id"+"}", _neturl.PathEscape(parameterToString(r.contentTypeId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.top != nil {
		localVarQueryParams.Add("$top", parameterToString(*r.top, ""))
	}
	if r.skip != nil {
		localVarQueryParams.Add("$skip", parameterToString(*r.skip, ""))
	}
	if r.search != nil {
		localVarQueryParams.Add("$search", parameterToString(*r.search, ""))
	}
	if r.filter != nil {
		localVarQueryParams.Add("$filter", parameterToString(*r.filter, ""))
	}
	if r.count != nil {
		localVarQueryParams.Add("$count", parameterToString(*r.count, ""))
	}
	if r.orderby != nil {
		localVarQueryParams.Add("$orderby", parameterToString(*r.orderby, "csv"))
	}
	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSharesListContentTypesListColumnsRequest struct {
	ctx _context.Context
	ApiService *SharesListApiService
	sharedDriveItemId string
	contentTypeId string
	top *int32
	skip *int32
	search *string
	filter *string
	count *bool
	orderby *[]string
	select_ *[]string
	expand *[]string
}

// Show only the first n items
func (r ApiSharesListContentTypesListColumnsRequest) Top(top int32) ApiSharesListContentTypesListColumnsRequest {
	r.top = &top
	return r
}
// Skip the first n items
func (r ApiSharesListContentTypesListColumnsRequest) Skip(skip int32) ApiSharesListContentTypesListColumnsRequest {
	r.skip = &skip
	return r
}
// Search items by search phrases
func (r ApiSharesListContentTypesListColumnsRequest) Search(search string) ApiSharesListContentTypesListColumnsRequest {
	r.search = &search
	return r
}
// Filter items by property values
func (r ApiSharesListContentTypesListColumnsRequest) Filter(filter string) ApiSharesListContentTypesListColumnsRequest {
	r.filter = &filter
	return r
}
// Include count of items
func (r ApiSharesListContentTypesListColumnsRequest) Count(count bool) ApiSharesListContentTypesListColumnsRequest {
	r.count = &count
	return r
}
// Order items by property values
func (r ApiSharesListContentTypesListColumnsRequest) Orderby(orderby []string) ApiSharesListContentTypesListColumnsRequest {
	r.orderby = &orderby
	return r
}
// Select properties to be returned
func (r ApiSharesListContentTypesListColumnsRequest) Select_(select_ []string) ApiSharesListContentTypesListColumnsRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiSharesListContentTypesListColumnsRequest) Expand(expand []string) ApiSharesListContentTypesListColumnsRequest {
	r.expand = &expand
	return r
}

func (r ApiSharesListContentTypesListColumnsRequest) Execute() (CollectionOfColumnDefinition, *_nethttp.Response, error) {
	return r.ApiService.SharesListContentTypesListColumnsExecute(r)
}

/*
SharesListContentTypesListColumns Get columns from shares

The collection of column definitions for this contentType.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param sharedDriveItemId key: id of sharedDriveItem
 @param contentTypeId key: id of contentType
 @return ApiSharesListContentTypesListColumnsRequest
*/
func (a *SharesListApiService) SharesListContentTypesListColumns(ctx _context.Context, sharedDriveItemId string, contentTypeId string) ApiSharesListContentTypesListColumnsRequest {
	return ApiSharesListContentTypesListColumnsRequest{
		ApiService: a,
		ctx: ctx,
		sharedDriveItemId: sharedDriveItemId,
		contentTypeId: contentTypeId,
	}
}

// Execute executes the request
//  @return CollectionOfColumnDefinition
func (a *SharesListApiService) SharesListContentTypesListColumnsExecute(r ApiSharesListContentTypesListColumnsRequest) (CollectionOfColumnDefinition, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  CollectionOfColumnDefinition
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SharesListApiService.SharesListContentTypesListColumns")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/shares/{sharedDriveItem-id}/list/contentTypes/{contentType-id}/columns"
	localVarPath = strings.Replace(localVarPath, "{"+"sharedDriveItem-id"+"}", _neturl.PathEscape(parameterToString(r.sharedDriveItemId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"contentType-id"+"}", _neturl.PathEscape(parameterToString(r.contentTypeId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.top != nil {
		localVarQueryParams.Add("$top", parameterToString(*r.top, ""))
	}
	if r.skip != nil {
		localVarQueryParams.Add("$skip", parameterToString(*r.skip, ""))
	}
	if r.search != nil {
		localVarQueryParams.Add("$search", parameterToString(*r.search, ""))
	}
	if r.filter != nil {
		localVarQueryParams.Add("$filter", parameterToString(*r.filter, ""))
	}
	if r.count != nil {
		localVarQueryParams.Add("$count", parameterToString(*r.count, ""))
	}
	if r.orderby != nil {
		localVarQueryParams.Add("$orderby", parameterToString(*r.orderby, "csv"))
	}
	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSharesListContentTypesListRefBaseTypesRequest struct {
	ctx _context.Context
	ApiService *SharesListApiService
	sharedDriveItemId string
	contentTypeId string
	top *int32
	skip *int32
	search *string
	filter *string
	count *bool
	orderby *[]string
}

// Show only the first n items
func (r ApiSharesListContentTypesListRefBaseTypesRequest) Top(top int32) ApiSharesListContentTypesListRefBaseTypesRequest {
	r.top = &top
	return r
}
// Skip the first n items
func (r ApiSharesListContentTypesListRefBaseTypesRequest) Skip(skip int32) ApiSharesListContentTypesListRefBaseTypesRequest {
	r.skip = &skip
	return r
}
// Search items by search phrases
func (r ApiSharesListContentTypesListRefBaseTypesRequest) Search(search string) ApiSharesListContentTypesListRefBaseTypesRequest {
	r.search = &search
	return r
}
// Filter items by property values
func (r ApiSharesListContentTypesListRefBaseTypesRequest) Filter(filter string) ApiSharesListContentTypesListRefBaseTypesRequest {
	r.filter = &filter
	return r
}
// Include count of items
func (r ApiSharesListContentTypesListRefBaseTypesRequest) Count(count bool) ApiSharesListContentTypesListRefBaseTypesRequest {
	r.count = &count
	return r
}
// Order items by property values
func (r ApiSharesListContentTypesListRefBaseTypesRequest) Orderby(orderby []string) ApiSharesListContentTypesListRefBaseTypesRequest {
	r.orderby = &orderby
	return r
}

func (r ApiSharesListContentTypesListRefBaseTypesRequest) Execute() (CollectionOfLinksOfContentType, *_nethttp.Response, error) {
	return r.ApiService.SharesListContentTypesListRefBaseTypesExecute(r)
}

/*
SharesListContentTypesListRefBaseTypes Get ref of baseTypes from shares

The collection of content types that are ancestors of this content type.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param sharedDriveItemId key: id of sharedDriveItem
 @param contentTypeId key: id of contentType
 @return ApiSharesListContentTypesListRefBaseTypesRequest
*/
func (a *SharesListApiService) SharesListContentTypesListRefBaseTypes(ctx _context.Context, sharedDriveItemId string, contentTypeId string) ApiSharesListContentTypesListRefBaseTypesRequest {
	return ApiSharesListContentTypesListRefBaseTypesRequest{
		ApiService: a,
		ctx: ctx,
		sharedDriveItemId: sharedDriveItemId,
		contentTypeId: contentTypeId,
	}
}

// Execute executes the request
//  @return CollectionOfLinksOfContentType
func (a *SharesListApiService) SharesListContentTypesListRefBaseTypesExecute(r ApiSharesListContentTypesListRefBaseTypesRequest) (CollectionOfLinksOfContentType, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  CollectionOfLinksOfContentType
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SharesListApiService.SharesListContentTypesListRefBaseTypes")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/shares/{sharedDriveItem-id}/list/contentTypes/{contentType-id}/baseTypes/$ref"
	localVarPath = strings.Replace(localVarPath, "{"+"sharedDriveItem-id"+"}", _neturl.PathEscape(parameterToString(r.sharedDriveItemId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"contentType-id"+"}", _neturl.PathEscape(parameterToString(r.contentTypeId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.top != nil {
		localVarQueryParams.Add("$top", parameterToString(*r.top, ""))
	}
	if r.skip != nil {
		localVarQueryParams.Add("$skip", parameterToString(*r.skip, ""))
	}
	if r.search != nil {
		localVarQueryParams.Add("$search", parameterToString(*r.search, ""))
	}
	if r.filter != nil {
		localVarQueryParams.Add("$filter", parameterToString(*r.filter, ""))
	}
	if r.count != nil {
		localVarQueryParams.Add("$count", parameterToString(*r.count, ""))
	}
	if r.orderby != nil {
		localVarQueryParams.Add("$orderby", parameterToString(*r.orderby, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSharesListContentTypesListRefColumnPositionsRequest struct {
	ctx _context.Context
	ApiService *SharesListApiService
	sharedDriveItemId string
	contentTypeId string
	top *int32
	skip *int32
	search *string
	filter *string
	count *bool
	orderby *[]string
}

// Show only the first n items
func (r ApiSharesListContentTypesListRefColumnPositionsRequest) Top(top int32) ApiSharesListContentTypesListRefColumnPositionsRequest {
	r.top = &top
	return r
}
// Skip the first n items
func (r ApiSharesListContentTypesListRefColumnPositionsRequest) Skip(skip int32) ApiSharesListContentTypesListRefColumnPositionsRequest {
	r.skip = &skip
	return r
}
// Search items by search phrases
func (r ApiSharesListContentTypesListRefColumnPositionsRequest) Search(search string) ApiSharesListContentTypesListRefColumnPositionsRequest {
	r.search = &search
	return r
}
// Filter items by property values
func (r ApiSharesListContentTypesListRefColumnPositionsRequest) Filter(filter string) ApiSharesListContentTypesListRefColumnPositionsRequest {
	r.filter = &filter
	return r
}
// Include count of items
func (r ApiSharesListContentTypesListRefColumnPositionsRequest) Count(count bool) ApiSharesListContentTypesListRefColumnPositionsRequest {
	r.count = &count
	return r
}
// Order items by property values
func (r ApiSharesListContentTypesListRefColumnPositionsRequest) Orderby(orderby []string) ApiSharesListContentTypesListRefColumnPositionsRequest {
	r.orderby = &orderby
	return r
}

func (r ApiSharesListContentTypesListRefColumnPositionsRequest) Execute() (CollectionOfLinksOfColumnDefinition, *_nethttp.Response, error) {
	return r.ApiService.SharesListContentTypesListRefColumnPositionsExecute(r)
}

/*
SharesListContentTypesListRefColumnPositions Get ref of columnPositions from shares

Column order information in a content type.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param sharedDriveItemId key: id of sharedDriveItem
 @param contentTypeId key: id of contentType
 @return ApiSharesListContentTypesListRefColumnPositionsRequest
*/
func (a *SharesListApiService) SharesListContentTypesListRefColumnPositions(ctx _context.Context, sharedDriveItemId string, contentTypeId string) ApiSharesListContentTypesListRefColumnPositionsRequest {
	return ApiSharesListContentTypesListRefColumnPositionsRequest{
		ApiService: a,
		ctx: ctx,
		sharedDriveItemId: sharedDriveItemId,
		contentTypeId: contentTypeId,
	}
}

// Execute executes the request
//  @return CollectionOfLinksOfColumnDefinition
func (a *SharesListApiService) SharesListContentTypesListRefColumnPositionsExecute(r ApiSharesListContentTypesListRefColumnPositionsRequest) (CollectionOfLinksOfColumnDefinition, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  CollectionOfLinksOfColumnDefinition
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SharesListApiService.SharesListContentTypesListRefColumnPositions")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/shares/{sharedDriveItem-id}/list/contentTypes/{contentType-id}/columnPositions/$ref"
	localVarPath = strings.Replace(localVarPath, "{"+"sharedDriveItem-id"+"}", _neturl.PathEscape(parameterToString(r.sharedDriveItemId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"contentType-id"+"}", _neturl.PathEscape(parameterToString(r.contentTypeId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.top != nil {
		localVarQueryParams.Add("$top", parameterToString(*r.top, ""))
	}
	if r.skip != nil {
		localVarQueryParams.Add("$skip", parameterToString(*r.skip, ""))
	}
	if r.search != nil {
		localVarQueryParams.Add("$search", parameterToString(*r.search, ""))
	}
	if r.filter != nil {
		localVarQueryParams.Add("$filter", parameterToString(*r.filter, ""))
	}
	if r.count != nil {
		localVarQueryParams.Add("$count", parameterToString(*r.count, ""))
	}
	if r.orderby != nil {
		localVarQueryParams.Add("$orderby", parameterToString(*r.orderby, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSharesListContentTypesUpdateColumnLinksRequest struct {
	ctx _context.Context
	ApiService *SharesListApiService
	sharedDriveItemId string
	contentTypeId string
	columnLinkId string
	microsoftGraphColumnLink *MicrosoftGraphColumnLink
}

// New navigation property values
func (r ApiSharesListContentTypesUpdateColumnLinksRequest) MicrosoftGraphColumnLink(microsoftGraphColumnLink MicrosoftGraphColumnLink) ApiSharesListContentTypesUpdateColumnLinksRequest {
	r.microsoftGraphColumnLink = &microsoftGraphColumnLink
	return r
}

func (r ApiSharesListContentTypesUpdateColumnLinksRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.SharesListContentTypesUpdateColumnLinksExecute(r)
}

/*
SharesListContentTypesUpdateColumnLinks Update the navigation property columnLinks in shares

The collection of columns that are required by this content type.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param sharedDriveItemId key: id of sharedDriveItem
 @param contentTypeId key: id of contentType
 @param columnLinkId key: id of columnLink
 @return ApiSharesListContentTypesUpdateColumnLinksRequest
*/
func (a *SharesListApiService) SharesListContentTypesUpdateColumnLinks(ctx _context.Context, sharedDriveItemId string, contentTypeId string, columnLinkId string) ApiSharesListContentTypesUpdateColumnLinksRequest {
	return ApiSharesListContentTypesUpdateColumnLinksRequest{
		ApiService: a,
		ctx: ctx,
		sharedDriveItemId: sharedDriveItemId,
		contentTypeId: contentTypeId,
		columnLinkId: columnLinkId,
	}
}

// Execute executes the request
func (a *SharesListApiService) SharesListContentTypesUpdateColumnLinksExecute(r ApiSharesListContentTypesUpdateColumnLinksRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPatch
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SharesListApiService.SharesListContentTypesUpdateColumnLinks")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/shares/{sharedDriveItem-id}/list/contentTypes/{contentType-id}/columnLinks/{columnLink-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"sharedDriveItem-id"+"}", _neturl.PathEscape(parameterToString(r.sharedDriveItemId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"contentType-id"+"}", _neturl.PathEscape(parameterToString(r.contentTypeId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"columnLink-id"+"}", _neturl.PathEscape(parameterToString(r.columnLinkId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphColumnLink == nil {
		return nil, reportError("microsoftGraphColumnLink is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphColumnLink
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiSharesListContentTypesUpdateColumnsRequest struct {
	ctx _context.Context
	ApiService *SharesListApiService
	sharedDriveItemId string
	contentTypeId string
	columnDefinitionId string
	microsoftGraphColumnDefinition *MicrosoftGraphColumnDefinition
}

// New navigation property values
func (r ApiSharesListContentTypesUpdateColumnsRequest) MicrosoftGraphColumnDefinition(microsoftGraphColumnDefinition MicrosoftGraphColumnDefinition) ApiSharesListContentTypesUpdateColumnsRequest {
	r.microsoftGraphColumnDefinition = &microsoftGraphColumnDefinition
	return r
}

func (r ApiSharesListContentTypesUpdateColumnsRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.SharesListContentTypesUpdateColumnsExecute(r)
}

/*
SharesListContentTypesUpdateColumns Update the navigation property columns in shares

The collection of column definitions for this contentType.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param sharedDriveItemId key: id of sharedDriveItem
 @param contentTypeId key: id of contentType
 @param columnDefinitionId key: id of columnDefinition
 @return ApiSharesListContentTypesUpdateColumnsRequest
*/
func (a *SharesListApiService) SharesListContentTypesUpdateColumns(ctx _context.Context, sharedDriveItemId string, contentTypeId string, columnDefinitionId string) ApiSharesListContentTypesUpdateColumnsRequest {
	return ApiSharesListContentTypesUpdateColumnsRequest{
		ApiService: a,
		ctx: ctx,
		sharedDriveItemId: sharedDriveItemId,
		contentTypeId: contentTypeId,
		columnDefinitionId: columnDefinitionId,
	}
}

// Execute executes the request
func (a *SharesListApiService) SharesListContentTypesUpdateColumnsExecute(r ApiSharesListContentTypesUpdateColumnsRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPatch
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SharesListApiService.SharesListContentTypesUpdateColumns")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/shares/{sharedDriveItem-id}/list/contentTypes/{contentType-id}/columns/{columnDefinition-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"sharedDriveItem-id"+"}", _neturl.PathEscape(parameterToString(r.sharedDriveItemId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"contentType-id"+"}", _neturl.PathEscape(parameterToString(r.contentTypeId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"columnDefinition-id"+"}", _neturl.PathEscape(parameterToString(r.columnDefinitionId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphColumnDefinition == nil {
		return nil, reportError("microsoftGraphColumnDefinition is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphColumnDefinition
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiSharesListContentTypesUpdateRefBaseRequest struct {
	ctx _context.Context
	ApiService *SharesListApiService
	sharedDriveItemId string
	contentTypeId string
	requestBody *map[string]map[string]interface{}
}

// New navigation property ref values
func (r ApiSharesListContentTypesUpdateRefBaseRequest) RequestBody(requestBody map[string]map[string]interface{}) ApiSharesListContentTypesUpdateRefBaseRequest {
	r.requestBody = &requestBody
	return r
}

func (r ApiSharesListContentTypesUpdateRefBaseRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.SharesListContentTypesUpdateRefBaseExecute(r)
}

/*
SharesListContentTypesUpdateRefBase Update the ref of navigation property base in shares

Parent contentType from which this content type is derived.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param sharedDriveItemId key: id of sharedDriveItem
 @param contentTypeId key: id of contentType
 @return ApiSharesListContentTypesUpdateRefBaseRequest
*/
func (a *SharesListApiService) SharesListContentTypesUpdateRefBase(ctx _context.Context, sharedDriveItemId string, contentTypeId string) ApiSharesListContentTypesUpdateRefBaseRequest {
	return ApiSharesListContentTypesUpdateRefBaseRequest{
		ApiService: a,
		ctx: ctx,
		sharedDriveItemId: sharedDriveItemId,
		contentTypeId: contentTypeId,
	}
}

// Execute executes the request
func (a *SharesListApiService) SharesListContentTypesUpdateRefBaseExecute(r ApiSharesListContentTypesUpdateRefBaseRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPut
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SharesListApiService.SharesListContentTypesUpdateRefBase")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/shares/{sharedDriveItem-id}/list/contentTypes/{contentType-id}/base/$ref"
	localVarPath = strings.Replace(localVarPath, "{"+"sharedDriveItem-id"+"}", _neturl.PathEscape(parameterToString(r.sharedDriveItemId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"contentType-id"+"}", _neturl.PathEscape(parameterToString(r.contentTypeId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.requestBody == nil {
		return nil, reportError("requestBody is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.requestBody
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiSharesListCreateColumnsRequest struct {
	ctx _context.Context
	ApiService *SharesListApiService
	sharedDriveItemId string
	microsoftGraphColumnDefinition *MicrosoftGraphColumnDefinition
}

// New navigation property
func (r ApiSharesListCreateColumnsRequest) MicrosoftGraphColumnDefinition(microsoftGraphColumnDefinition MicrosoftGraphColumnDefinition) ApiSharesListCreateColumnsRequest {
	r.microsoftGraphColumnDefinition = &microsoftGraphColumnDefinition
	return r
}

func (r ApiSharesListCreateColumnsRequest) Execute() (MicrosoftGraphColumnDefinition, *_nethttp.Response, error) {
	return r.ApiService.SharesListCreateColumnsExecute(r)
}

/*
SharesListCreateColumns Create new navigation property to columns for shares

The collection of field definitions for this list.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param sharedDriveItemId key: id of sharedDriveItem
 @return ApiSharesListCreateColumnsRequest
*/
func (a *SharesListApiService) SharesListCreateColumns(ctx _context.Context, sharedDriveItemId string) ApiSharesListCreateColumnsRequest {
	return ApiSharesListCreateColumnsRequest{
		ApiService: a,
		ctx: ctx,
		sharedDriveItemId: sharedDriveItemId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphColumnDefinition
func (a *SharesListApiService) SharesListCreateColumnsExecute(r ApiSharesListCreateColumnsRequest) (MicrosoftGraphColumnDefinition, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphColumnDefinition
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SharesListApiService.SharesListCreateColumns")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/shares/{sharedDriveItem-id}/list/columns"
	localVarPath = strings.Replace(localVarPath, "{"+"sharedDriveItem-id"+"}", _neturl.PathEscape(parameterToString(r.sharedDriveItemId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphColumnDefinition == nil {
		return localVarReturnValue, nil, reportError("microsoftGraphColumnDefinition is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphColumnDefinition
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSharesListCreateContentTypesRequest struct {
	ctx _context.Context
	ApiService *SharesListApiService
	sharedDriveItemId string
	microsoftGraphContentType *MicrosoftGraphContentType
}

// New navigation property
func (r ApiSharesListCreateContentTypesRequest) MicrosoftGraphContentType(microsoftGraphContentType MicrosoftGraphContentType) ApiSharesListCreateContentTypesRequest {
	r.microsoftGraphContentType = &microsoftGraphContentType
	return r
}

func (r ApiSharesListCreateContentTypesRequest) Execute() (MicrosoftGraphContentType, *_nethttp.Response, error) {
	return r.ApiService.SharesListCreateContentTypesExecute(r)
}

/*
SharesListCreateContentTypes Create new navigation property to contentTypes for shares

The collection of content types present in this list.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param sharedDriveItemId key: id of sharedDriveItem
 @return ApiSharesListCreateContentTypesRequest
*/
func (a *SharesListApiService) SharesListCreateContentTypes(ctx _context.Context, sharedDriveItemId string) ApiSharesListCreateContentTypesRequest {
	return ApiSharesListCreateContentTypesRequest{
		ApiService: a,
		ctx: ctx,
		sharedDriveItemId: sharedDriveItemId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphContentType
func (a *SharesListApiService) SharesListCreateContentTypesExecute(r ApiSharesListCreateContentTypesRequest) (MicrosoftGraphContentType, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphContentType
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SharesListApiService.SharesListCreateContentTypes")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/shares/{sharedDriveItem-id}/list/contentTypes"
	localVarPath = strings.Replace(localVarPath, "{"+"sharedDriveItem-id"+"}", _neturl.PathEscape(parameterToString(r.sharedDriveItemId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphContentType == nil {
		return localVarReturnValue, nil, reportError("microsoftGraphContentType is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphContentType
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSharesListCreateItemsRequest struct {
	ctx _context.Context
	ApiService *SharesListApiService
	sharedDriveItemId string
	microsoftGraphListItem *MicrosoftGraphListItem
}

// New navigation property
func (r ApiSharesListCreateItemsRequest) MicrosoftGraphListItem(microsoftGraphListItem MicrosoftGraphListItem) ApiSharesListCreateItemsRequest {
	r.microsoftGraphListItem = &microsoftGraphListItem
	return r
}

func (r ApiSharesListCreateItemsRequest) Execute() (MicrosoftGraphListItem, *_nethttp.Response, error) {
	return r.ApiService.SharesListCreateItemsExecute(r)
}

/*
SharesListCreateItems Create new navigation property to items for shares

All items contained in the list.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param sharedDriveItemId key: id of sharedDriveItem
 @return ApiSharesListCreateItemsRequest
*/
func (a *SharesListApiService) SharesListCreateItems(ctx _context.Context, sharedDriveItemId string) ApiSharesListCreateItemsRequest {
	return ApiSharesListCreateItemsRequest{
		ApiService: a,
		ctx: ctx,
		sharedDriveItemId: sharedDriveItemId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphListItem
func (a *SharesListApiService) SharesListCreateItemsExecute(r ApiSharesListCreateItemsRequest) (MicrosoftGraphListItem, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphListItem
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SharesListApiService.SharesListCreateItems")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/shares/{sharedDriveItem-id}/list/items"
	localVarPath = strings.Replace(localVarPath, "{"+"sharedDriveItem-id"+"}", _neturl.PathEscape(parameterToString(r.sharedDriveItemId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphListItem == nil {
		return localVarReturnValue, nil, reportError("microsoftGraphListItem is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphListItem
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSharesListCreateSubscriptionsRequest struct {
	ctx _context.Context
	ApiService *SharesListApiService
	sharedDriveItemId string
	microsoftGraphSubscription *MicrosoftGraphSubscription
}

// New navigation property
func (r ApiSharesListCreateSubscriptionsRequest) MicrosoftGraphSubscription(microsoftGraphSubscription MicrosoftGraphSubscription) ApiSharesListCreateSubscriptionsRequest {
	r.microsoftGraphSubscription = &microsoftGraphSubscription
	return r
}

func (r ApiSharesListCreateSubscriptionsRequest) Execute() (MicrosoftGraphSubscription, *_nethttp.Response, error) {
	return r.ApiService.SharesListCreateSubscriptionsExecute(r)
}

/*
SharesListCreateSubscriptions Create new navigation property to subscriptions for shares

The set of subscriptions on the list.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param sharedDriveItemId key: id of sharedDriveItem
 @return ApiSharesListCreateSubscriptionsRequest
*/
func (a *SharesListApiService) SharesListCreateSubscriptions(ctx _context.Context, sharedDriveItemId string) ApiSharesListCreateSubscriptionsRequest {
	return ApiSharesListCreateSubscriptionsRequest{
		ApiService: a,
		ctx: ctx,
		sharedDriveItemId: sharedDriveItemId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphSubscription
func (a *SharesListApiService) SharesListCreateSubscriptionsExecute(r ApiSharesListCreateSubscriptionsRequest) (MicrosoftGraphSubscription, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphSubscription
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SharesListApiService.SharesListCreateSubscriptions")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/shares/{sharedDriveItem-id}/list/subscriptions"
	localVarPath = strings.Replace(localVarPath, "{"+"sharedDriveItem-id"+"}", _neturl.PathEscape(parameterToString(r.sharedDriveItemId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphSubscription == nil {
		return localVarReturnValue, nil, reportError("microsoftGraphSubscription is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphSubscription
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSharesListDeleteColumnsRequest struct {
	ctx _context.Context
	ApiService *SharesListApiService
	sharedDriveItemId string
	columnDefinitionId string
	ifMatch *string
}

// ETag
func (r ApiSharesListDeleteColumnsRequest) IfMatch(ifMatch string) ApiSharesListDeleteColumnsRequest {
	r.ifMatch = &ifMatch
	return r
}

func (r ApiSharesListDeleteColumnsRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.SharesListDeleteColumnsExecute(r)
}

/*
SharesListDeleteColumns Delete navigation property columns for shares

The collection of field definitions for this list.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param sharedDriveItemId key: id of sharedDriveItem
 @param columnDefinitionId key: id of columnDefinition
 @return ApiSharesListDeleteColumnsRequest
*/
func (a *SharesListApiService) SharesListDeleteColumns(ctx _context.Context, sharedDriveItemId string, columnDefinitionId string) ApiSharesListDeleteColumnsRequest {
	return ApiSharesListDeleteColumnsRequest{
		ApiService: a,
		ctx: ctx,
		sharedDriveItemId: sharedDriveItemId,
		columnDefinitionId: columnDefinitionId,
	}
}

// Execute executes the request
func (a *SharesListApiService) SharesListDeleteColumnsExecute(r ApiSharesListDeleteColumnsRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SharesListApiService.SharesListDeleteColumns")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/shares/{sharedDriveItem-id}/list/columns/{columnDefinition-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"sharedDriveItem-id"+"}", _neturl.PathEscape(parameterToString(r.sharedDriveItemId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"columnDefinition-id"+"}", _neturl.PathEscape(parameterToString(r.columnDefinitionId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ifMatch != nil {
		localVarHeaderParams["If-Match"] = parameterToString(*r.ifMatch, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiSharesListDeleteContentTypesRequest struct {
	ctx _context.Context
	ApiService *SharesListApiService
	sharedDriveItemId string
	contentTypeId string
	ifMatch *string
}

// ETag
func (r ApiSharesListDeleteContentTypesRequest) IfMatch(ifMatch string) ApiSharesListDeleteContentTypesRequest {
	r.ifMatch = &ifMatch
	return r
}

func (r ApiSharesListDeleteContentTypesRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.SharesListDeleteContentTypesExecute(r)
}

/*
SharesListDeleteContentTypes Delete navigation property contentTypes for shares

The collection of content types present in this list.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param sharedDriveItemId key: id of sharedDriveItem
 @param contentTypeId key: id of contentType
 @return ApiSharesListDeleteContentTypesRequest
*/
func (a *SharesListApiService) SharesListDeleteContentTypes(ctx _context.Context, sharedDriveItemId string, contentTypeId string) ApiSharesListDeleteContentTypesRequest {
	return ApiSharesListDeleteContentTypesRequest{
		ApiService: a,
		ctx: ctx,
		sharedDriveItemId: sharedDriveItemId,
		contentTypeId: contentTypeId,
	}
}

// Execute executes the request
func (a *SharesListApiService) SharesListDeleteContentTypesExecute(r ApiSharesListDeleteContentTypesRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SharesListApiService.SharesListDeleteContentTypes")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/shares/{sharedDriveItem-id}/list/contentTypes/{contentType-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"sharedDriveItem-id"+"}", _neturl.PathEscape(parameterToString(r.sharedDriveItemId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"contentType-id"+"}", _neturl.PathEscape(parameterToString(r.contentTypeId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ifMatch != nil {
		localVarHeaderParams["If-Match"] = parameterToString(*r.ifMatch, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiSharesListDeleteDriveRequest struct {
	ctx _context.Context
	ApiService *SharesListApiService
	sharedDriveItemId string
	ifMatch *string
}

// ETag
func (r ApiSharesListDeleteDriveRequest) IfMatch(ifMatch string) ApiSharesListDeleteDriveRequest {
	r.ifMatch = &ifMatch
	return r
}

func (r ApiSharesListDeleteDriveRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.SharesListDeleteDriveExecute(r)
}

/*
SharesListDeleteDrive Delete navigation property drive for shares

Only present on document libraries. Allows access to the list as a [drive][] resource with [driveItems][driveItem].

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param sharedDriveItemId key: id of sharedDriveItem
 @return ApiSharesListDeleteDriveRequest
*/
func (a *SharesListApiService) SharesListDeleteDrive(ctx _context.Context, sharedDriveItemId string) ApiSharesListDeleteDriveRequest {
	return ApiSharesListDeleteDriveRequest{
		ApiService: a,
		ctx: ctx,
		sharedDriveItemId: sharedDriveItemId,
	}
}

// Execute executes the request
func (a *SharesListApiService) SharesListDeleteDriveExecute(r ApiSharesListDeleteDriveRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SharesListApiService.SharesListDeleteDrive")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/shares/{sharedDriveItem-id}/list/drive"
	localVarPath = strings.Replace(localVarPath, "{"+"sharedDriveItem-id"+"}", _neturl.PathEscape(parameterToString(r.sharedDriveItemId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ifMatch != nil {
		localVarHeaderParams["If-Match"] = parameterToString(*r.ifMatch, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiSharesListDeleteItemsRequest struct {
	ctx _context.Context
	ApiService *SharesListApiService
	sharedDriveItemId string
	listItemId string
	ifMatch *string
}

// ETag
func (r ApiSharesListDeleteItemsRequest) IfMatch(ifMatch string) ApiSharesListDeleteItemsRequest {
	r.ifMatch = &ifMatch
	return r
}

func (r ApiSharesListDeleteItemsRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.SharesListDeleteItemsExecute(r)
}

/*
SharesListDeleteItems Delete navigation property items for shares

All items contained in the list.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param sharedDriveItemId key: id of sharedDriveItem
 @param listItemId key: id of listItem
 @return ApiSharesListDeleteItemsRequest
*/
func (a *SharesListApiService) SharesListDeleteItems(ctx _context.Context, sharedDriveItemId string, listItemId string) ApiSharesListDeleteItemsRequest {
	return ApiSharesListDeleteItemsRequest{
		ApiService: a,
		ctx: ctx,
		sharedDriveItemId: sharedDriveItemId,
		listItemId: listItemId,
	}
}

// Execute executes the request
func (a *SharesListApiService) SharesListDeleteItemsExecute(r ApiSharesListDeleteItemsRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SharesListApiService.SharesListDeleteItems")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/shares/{sharedDriveItem-id}/list/items/{listItem-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"sharedDriveItem-id"+"}", _neturl.PathEscape(parameterToString(r.sharedDriveItemId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"listItem-id"+"}", _neturl.PathEscape(parameterToString(r.listItemId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ifMatch != nil {
		localVarHeaderParams["If-Match"] = parameterToString(*r.ifMatch, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiSharesListDeleteSubscriptionsRequest struct {
	ctx _context.Context
	ApiService *SharesListApiService
	sharedDriveItemId string
	subscriptionId string
	ifMatch *string
}

// ETag
func (r ApiSharesListDeleteSubscriptionsRequest) IfMatch(ifMatch string) ApiSharesListDeleteSubscriptionsRequest {
	r.ifMatch = &ifMatch
	return r
}

func (r ApiSharesListDeleteSubscriptionsRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.SharesListDeleteSubscriptionsExecute(r)
}

/*
SharesListDeleteSubscriptions Delete navigation property subscriptions for shares

The set of subscriptions on the list.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param sharedDriveItemId key: id of sharedDriveItem
 @param subscriptionId key: id of subscription
 @return ApiSharesListDeleteSubscriptionsRequest
*/
func (a *SharesListApiService) SharesListDeleteSubscriptions(ctx _context.Context, sharedDriveItemId string, subscriptionId string) ApiSharesListDeleteSubscriptionsRequest {
	return ApiSharesListDeleteSubscriptionsRequest{
		ApiService: a,
		ctx: ctx,
		sharedDriveItemId: sharedDriveItemId,
		subscriptionId: subscriptionId,
	}
}

// Execute executes the request
func (a *SharesListApiService) SharesListDeleteSubscriptionsExecute(r ApiSharesListDeleteSubscriptionsRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SharesListApiService.SharesListDeleteSubscriptions")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/shares/{sharedDriveItem-id}/list/subscriptions/{subscription-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"sharedDriveItem-id"+"}", _neturl.PathEscape(parameterToString(r.sharedDriveItemId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"subscription-id"+"}", _neturl.PathEscape(parameterToString(r.subscriptionId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ifMatch != nil {
		localVarHeaderParams["If-Match"] = parameterToString(*r.ifMatch, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiSharesListGetColumnsRequest struct {
	ctx _context.Context
	ApiService *SharesListApiService
	sharedDriveItemId string
	columnDefinitionId string
	select_ *[]string
	expand *[]string
}

// Select properties to be returned
func (r ApiSharesListGetColumnsRequest) Select_(select_ []string) ApiSharesListGetColumnsRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiSharesListGetColumnsRequest) Expand(expand []string) ApiSharesListGetColumnsRequest {
	r.expand = &expand
	return r
}

func (r ApiSharesListGetColumnsRequest) Execute() (MicrosoftGraphColumnDefinition, *_nethttp.Response, error) {
	return r.ApiService.SharesListGetColumnsExecute(r)
}

/*
SharesListGetColumns Get columns from shares

The collection of field definitions for this list.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param sharedDriveItemId key: id of sharedDriveItem
 @param columnDefinitionId key: id of columnDefinition
 @return ApiSharesListGetColumnsRequest
*/
func (a *SharesListApiService) SharesListGetColumns(ctx _context.Context, sharedDriveItemId string, columnDefinitionId string) ApiSharesListGetColumnsRequest {
	return ApiSharesListGetColumnsRequest{
		ApiService: a,
		ctx: ctx,
		sharedDriveItemId: sharedDriveItemId,
		columnDefinitionId: columnDefinitionId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphColumnDefinition
func (a *SharesListApiService) SharesListGetColumnsExecute(r ApiSharesListGetColumnsRequest) (MicrosoftGraphColumnDefinition, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphColumnDefinition
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SharesListApiService.SharesListGetColumns")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/shares/{sharedDriveItem-id}/list/columns/{columnDefinition-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"sharedDriveItem-id"+"}", _neturl.PathEscape(parameterToString(r.sharedDriveItemId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"columnDefinition-id"+"}", _neturl.PathEscape(parameterToString(r.columnDefinitionId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSharesListGetContentTypesRequest struct {
	ctx _context.Context
	ApiService *SharesListApiService
	sharedDriveItemId string
	contentTypeId string
	select_ *[]string
	expand *[]string
}

// Select properties to be returned
func (r ApiSharesListGetContentTypesRequest) Select_(select_ []string) ApiSharesListGetContentTypesRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiSharesListGetContentTypesRequest) Expand(expand []string) ApiSharesListGetContentTypesRequest {
	r.expand = &expand
	return r
}

func (r ApiSharesListGetContentTypesRequest) Execute() (MicrosoftGraphContentType, *_nethttp.Response, error) {
	return r.ApiService.SharesListGetContentTypesExecute(r)
}

/*
SharesListGetContentTypes Get contentTypes from shares

The collection of content types present in this list.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param sharedDriveItemId key: id of sharedDriveItem
 @param contentTypeId key: id of contentType
 @return ApiSharesListGetContentTypesRequest
*/
func (a *SharesListApiService) SharesListGetContentTypes(ctx _context.Context, sharedDriveItemId string, contentTypeId string) ApiSharesListGetContentTypesRequest {
	return ApiSharesListGetContentTypesRequest{
		ApiService: a,
		ctx: ctx,
		sharedDriveItemId: sharedDriveItemId,
		contentTypeId: contentTypeId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphContentType
func (a *SharesListApiService) SharesListGetContentTypesExecute(r ApiSharesListGetContentTypesRequest) (MicrosoftGraphContentType, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphContentType
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SharesListApiService.SharesListGetContentTypes")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/shares/{sharedDriveItem-id}/list/contentTypes/{contentType-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"sharedDriveItem-id"+"}", _neturl.PathEscape(parameterToString(r.sharedDriveItemId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"contentType-id"+"}", _neturl.PathEscape(parameterToString(r.contentTypeId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSharesListGetDriveRequest struct {
	ctx _context.Context
	ApiService *SharesListApiService
	sharedDriveItemId string
	select_ *[]string
	expand *[]string
}

// Select properties to be returned
func (r ApiSharesListGetDriveRequest) Select_(select_ []string) ApiSharesListGetDriveRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiSharesListGetDriveRequest) Expand(expand []string) ApiSharesListGetDriveRequest {
	r.expand = &expand
	return r
}

func (r ApiSharesListGetDriveRequest) Execute() (MicrosoftGraphDrive, *_nethttp.Response, error) {
	return r.ApiService.SharesListGetDriveExecute(r)
}

/*
SharesListGetDrive Get drive from shares

Only present on document libraries. Allows access to the list as a [drive][] resource with [driveItems][driveItem].

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param sharedDriveItemId key: id of sharedDriveItem
 @return ApiSharesListGetDriveRequest
*/
func (a *SharesListApiService) SharesListGetDrive(ctx _context.Context, sharedDriveItemId string) ApiSharesListGetDriveRequest {
	return ApiSharesListGetDriveRequest{
		ApiService: a,
		ctx: ctx,
		sharedDriveItemId: sharedDriveItemId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphDrive
func (a *SharesListApiService) SharesListGetDriveExecute(r ApiSharesListGetDriveRequest) (MicrosoftGraphDrive, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphDrive
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SharesListApiService.SharesListGetDrive")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/shares/{sharedDriveItem-id}/list/drive"
	localVarPath = strings.Replace(localVarPath, "{"+"sharedDriveItem-id"+"}", _neturl.PathEscape(parameterToString(r.sharedDriveItemId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSharesListGetItemsRequest struct {
	ctx _context.Context
	ApiService *SharesListApiService
	sharedDriveItemId string
	listItemId string
	select_ *[]string
	expand *[]string
}

// Select properties to be returned
func (r ApiSharesListGetItemsRequest) Select_(select_ []string) ApiSharesListGetItemsRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiSharesListGetItemsRequest) Expand(expand []string) ApiSharesListGetItemsRequest {
	r.expand = &expand
	return r
}

func (r ApiSharesListGetItemsRequest) Execute() (MicrosoftGraphListItem, *_nethttp.Response, error) {
	return r.ApiService.SharesListGetItemsExecute(r)
}

/*
SharesListGetItems Get items from shares

All items contained in the list.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param sharedDriveItemId key: id of sharedDriveItem
 @param listItemId key: id of listItem
 @return ApiSharesListGetItemsRequest
*/
func (a *SharesListApiService) SharesListGetItems(ctx _context.Context, sharedDriveItemId string, listItemId string) ApiSharesListGetItemsRequest {
	return ApiSharesListGetItemsRequest{
		ApiService: a,
		ctx: ctx,
		sharedDriveItemId: sharedDriveItemId,
		listItemId: listItemId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphListItem
func (a *SharesListApiService) SharesListGetItemsExecute(r ApiSharesListGetItemsRequest) (MicrosoftGraphListItem, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphListItem
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SharesListApiService.SharesListGetItems")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/shares/{sharedDriveItem-id}/list/items/{listItem-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"sharedDriveItem-id"+"}", _neturl.PathEscape(parameterToString(r.sharedDriveItemId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"listItem-id"+"}", _neturl.PathEscape(parameterToString(r.listItemId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSharesListGetSubscriptionsRequest struct {
	ctx _context.Context
	ApiService *SharesListApiService
	sharedDriveItemId string
	subscriptionId string
	select_ *[]string
	expand *[]string
}

// Select properties to be returned
func (r ApiSharesListGetSubscriptionsRequest) Select_(select_ []string) ApiSharesListGetSubscriptionsRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiSharesListGetSubscriptionsRequest) Expand(expand []string) ApiSharesListGetSubscriptionsRequest {
	r.expand = &expand
	return r
}

func (r ApiSharesListGetSubscriptionsRequest) Execute() (MicrosoftGraphSubscription, *_nethttp.Response, error) {
	return r.ApiService.SharesListGetSubscriptionsExecute(r)
}

/*
SharesListGetSubscriptions Get subscriptions from shares

The set of subscriptions on the list.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param sharedDriveItemId key: id of sharedDriveItem
 @param subscriptionId key: id of subscription
 @return ApiSharesListGetSubscriptionsRequest
*/
func (a *SharesListApiService) SharesListGetSubscriptions(ctx _context.Context, sharedDriveItemId string, subscriptionId string) ApiSharesListGetSubscriptionsRequest {
	return ApiSharesListGetSubscriptionsRequest{
		ApiService: a,
		ctx: ctx,
		sharedDriveItemId: sharedDriveItemId,
		subscriptionId: subscriptionId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphSubscription
func (a *SharesListApiService) SharesListGetSubscriptionsExecute(r ApiSharesListGetSubscriptionsRequest) (MicrosoftGraphSubscription, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphSubscription
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SharesListApiService.SharesListGetSubscriptions")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/shares/{sharedDriveItem-id}/list/subscriptions/{subscription-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"sharedDriveItem-id"+"}", _neturl.PathEscape(parameterToString(r.sharedDriveItemId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"subscription-id"+"}", _neturl.PathEscape(parameterToString(r.subscriptionId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSharesListItemsCreateVersionsRequest struct {
	ctx _context.Context
	ApiService *SharesListApiService
	sharedDriveItemId string
	listItemId string
	microsoftGraphListItemVersion *MicrosoftGraphListItemVersion
}

// New navigation property
func (r ApiSharesListItemsCreateVersionsRequest) MicrosoftGraphListItemVersion(microsoftGraphListItemVersion MicrosoftGraphListItemVersion) ApiSharesListItemsCreateVersionsRequest {
	r.microsoftGraphListItemVersion = &microsoftGraphListItemVersion
	return r
}

func (r ApiSharesListItemsCreateVersionsRequest) Execute() (MicrosoftGraphListItemVersion, *_nethttp.Response, error) {
	return r.ApiService.SharesListItemsCreateVersionsExecute(r)
}

/*
SharesListItemsCreateVersions Create new navigation property to versions for shares

The list of previous versions of the list item.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param sharedDriveItemId key: id of sharedDriveItem
 @param listItemId key: id of listItem
 @return ApiSharesListItemsCreateVersionsRequest
*/
func (a *SharesListApiService) SharesListItemsCreateVersions(ctx _context.Context, sharedDriveItemId string, listItemId string) ApiSharesListItemsCreateVersionsRequest {
	return ApiSharesListItemsCreateVersionsRequest{
		ApiService: a,
		ctx: ctx,
		sharedDriveItemId: sharedDriveItemId,
		listItemId: listItemId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphListItemVersion
func (a *SharesListApiService) SharesListItemsCreateVersionsExecute(r ApiSharesListItemsCreateVersionsRequest) (MicrosoftGraphListItemVersion, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphListItemVersion
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SharesListApiService.SharesListItemsCreateVersions")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/shares/{sharedDriveItem-id}/list/items/{listItem-id}/versions"
	localVarPath = strings.Replace(localVarPath, "{"+"sharedDriveItem-id"+"}", _neturl.PathEscape(parameterToString(r.sharedDriveItemId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"listItem-id"+"}", _neturl.PathEscape(parameterToString(r.listItemId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphListItemVersion == nil {
		return localVarReturnValue, nil, reportError("microsoftGraphListItemVersion is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphListItemVersion
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSharesListItemsDeleteDriveItemRequest struct {
	ctx _context.Context
	ApiService *SharesListApiService
	sharedDriveItemId string
	listItemId string
	ifMatch *string
}

// ETag
func (r ApiSharesListItemsDeleteDriveItemRequest) IfMatch(ifMatch string) ApiSharesListItemsDeleteDriveItemRequest {
	r.ifMatch = &ifMatch
	return r
}

func (r ApiSharesListItemsDeleteDriveItemRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.SharesListItemsDeleteDriveItemExecute(r)
}

/*
SharesListItemsDeleteDriveItem Delete navigation property driveItem for shares

For document libraries, the driveItem relationship exposes the listItem as a [driveItem][]

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param sharedDriveItemId key: id of sharedDriveItem
 @param listItemId key: id of listItem
 @return ApiSharesListItemsDeleteDriveItemRequest
*/
func (a *SharesListApiService) SharesListItemsDeleteDriveItem(ctx _context.Context, sharedDriveItemId string, listItemId string) ApiSharesListItemsDeleteDriveItemRequest {
	return ApiSharesListItemsDeleteDriveItemRequest{
		ApiService: a,
		ctx: ctx,
		sharedDriveItemId: sharedDriveItemId,
		listItemId: listItemId,
	}
}

// Execute executes the request
func (a *SharesListApiService) SharesListItemsDeleteDriveItemExecute(r ApiSharesListItemsDeleteDriveItemRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SharesListApiService.SharesListItemsDeleteDriveItem")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/shares/{sharedDriveItem-id}/list/items/{listItem-id}/driveItem"
	localVarPath = strings.Replace(localVarPath, "{"+"sharedDriveItem-id"+"}", _neturl.PathEscape(parameterToString(r.sharedDriveItemId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"listItem-id"+"}", _neturl.PathEscape(parameterToString(r.listItemId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ifMatch != nil {
		localVarHeaderParams["If-Match"] = parameterToString(*r.ifMatch, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiSharesListItemsDeleteFieldsRequest struct {
	ctx _context.Context
	ApiService *SharesListApiService
	sharedDriveItemId string
	listItemId string
	ifMatch *string
}

// ETag
func (r ApiSharesListItemsDeleteFieldsRequest) IfMatch(ifMatch string) ApiSharesListItemsDeleteFieldsRequest {
	r.ifMatch = &ifMatch
	return r
}

func (r ApiSharesListItemsDeleteFieldsRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.SharesListItemsDeleteFieldsExecute(r)
}

/*
SharesListItemsDeleteFields Delete navigation property fields for shares

The values of the columns set on this list item.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param sharedDriveItemId key: id of sharedDriveItem
 @param listItemId key: id of listItem
 @return ApiSharesListItemsDeleteFieldsRequest
*/
func (a *SharesListApiService) SharesListItemsDeleteFields(ctx _context.Context, sharedDriveItemId string, listItemId string) ApiSharesListItemsDeleteFieldsRequest {
	return ApiSharesListItemsDeleteFieldsRequest{
		ApiService: a,
		ctx: ctx,
		sharedDriveItemId: sharedDriveItemId,
		listItemId: listItemId,
	}
}

// Execute executes the request
func (a *SharesListApiService) SharesListItemsDeleteFieldsExecute(r ApiSharesListItemsDeleteFieldsRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SharesListApiService.SharesListItemsDeleteFields")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/shares/{sharedDriveItem-id}/list/items/{listItem-id}/fields"
	localVarPath = strings.Replace(localVarPath, "{"+"sharedDriveItem-id"+"}", _neturl.PathEscape(parameterToString(r.sharedDriveItemId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"listItem-id"+"}", _neturl.PathEscape(parameterToString(r.listItemId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ifMatch != nil {
		localVarHeaderParams["If-Match"] = parameterToString(*r.ifMatch, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiSharesListItemsDeleteRefAnalyticsRequest struct {
	ctx _context.Context
	ApiService *SharesListApiService
	sharedDriveItemId string
	listItemId string
	ifMatch *string
}

// ETag
func (r ApiSharesListItemsDeleteRefAnalyticsRequest) IfMatch(ifMatch string) ApiSharesListItemsDeleteRefAnalyticsRequest {
	r.ifMatch = &ifMatch
	return r
}

func (r ApiSharesListItemsDeleteRefAnalyticsRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.SharesListItemsDeleteRefAnalyticsExecute(r)
}

/*
SharesListItemsDeleteRefAnalytics Delete ref of navigation property analytics for shares

Analytics about the view activities that took place on this item.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param sharedDriveItemId key: id of sharedDriveItem
 @param listItemId key: id of listItem
 @return ApiSharesListItemsDeleteRefAnalyticsRequest
*/
func (a *SharesListApiService) SharesListItemsDeleteRefAnalytics(ctx _context.Context, sharedDriveItemId string, listItemId string) ApiSharesListItemsDeleteRefAnalyticsRequest {
	return ApiSharesListItemsDeleteRefAnalyticsRequest{
		ApiService: a,
		ctx: ctx,
		sharedDriveItemId: sharedDriveItemId,
		listItemId: listItemId,
	}
}

// Execute executes the request
func (a *SharesListApiService) SharesListItemsDeleteRefAnalyticsExecute(r ApiSharesListItemsDeleteRefAnalyticsRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SharesListApiService.SharesListItemsDeleteRefAnalytics")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/shares/{sharedDriveItem-id}/list/items/{listItem-id}/analytics/$ref"
	localVarPath = strings.Replace(localVarPath, "{"+"sharedDriveItem-id"+"}", _neturl.PathEscape(parameterToString(r.sharedDriveItemId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"listItem-id"+"}", _neturl.PathEscape(parameterToString(r.listItemId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ifMatch != nil {
		localVarHeaderParams["If-Match"] = parameterToString(*r.ifMatch, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiSharesListItemsDeleteVersionsRequest struct {
	ctx _context.Context
	ApiService *SharesListApiService
	sharedDriveItemId string
	listItemId string
	listItemVersionId string
	ifMatch *string
}

// ETag
func (r ApiSharesListItemsDeleteVersionsRequest) IfMatch(ifMatch string) ApiSharesListItemsDeleteVersionsRequest {
	r.ifMatch = &ifMatch
	return r
}

func (r ApiSharesListItemsDeleteVersionsRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.SharesListItemsDeleteVersionsExecute(r)
}

/*
SharesListItemsDeleteVersions Delete navigation property versions for shares

The list of previous versions of the list item.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param sharedDriveItemId key: id of sharedDriveItem
 @param listItemId key: id of listItem
 @param listItemVersionId key: id of listItemVersion
 @return ApiSharesListItemsDeleteVersionsRequest
*/
func (a *SharesListApiService) SharesListItemsDeleteVersions(ctx _context.Context, sharedDriveItemId string, listItemId string, listItemVersionId string) ApiSharesListItemsDeleteVersionsRequest {
	return ApiSharesListItemsDeleteVersionsRequest{
		ApiService: a,
		ctx: ctx,
		sharedDriveItemId: sharedDriveItemId,
		listItemId: listItemId,
		listItemVersionId: listItemVersionId,
	}
}

// Execute executes the request
func (a *SharesListApiService) SharesListItemsDeleteVersionsExecute(r ApiSharesListItemsDeleteVersionsRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SharesListApiService.SharesListItemsDeleteVersions")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/shares/{sharedDriveItem-id}/list/items/{listItem-id}/versions/{listItemVersion-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"sharedDriveItem-id"+"}", _neturl.PathEscape(parameterToString(r.sharedDriveItemId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"listItem-id"+"}", _neturl.PathEscape(parameterToString(r.listItemId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"listItemVersion-id"+"}", _neturl.PathEscape(parameterToString(r.listItemVersionId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ifMatch != nil {
		localVarHeaderParams["If-Match"] = parameterToString(*r.ifMatch, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiSharesListItemsGetAnalyticsRequest struct {
	ctx _context.Context
	ApiService *SharesListApiService
	sharedDriveItemId string
	listItemId string
	select_ *[]string
	expand *[]string
}

// Select properties to be returned
func (r ApiSharesListItemsGetAnalyticsRequest) Select_(select_ []string) ApiSharesListItemsGetAnalyticsRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiSharesListItemsGetAnalyticsRequest) Expand(expand []string) ApiSharesListItemsGetAnalyticsRequest {
	r.expand = &expand
	return r
}

func (r ApiSharesListItemsGetAnalyticsRequest) Execute() (MicrosoftGraphItemAnalytics, *_nethttp.Response, error) {
	return r.ApiService.SharesListItemsGetAnalyticsExecute(r)
}

/*
SharesListItemsGetAnalytics Get analytics from shares

Analytics about the view activities that took place on this item.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param sharedDriveItemId key: id of sharedDriveItem
 @param listItemId key: id of listItem
 @return ApiSharesListItemsGetAnalyticsRequest
*/
func (a *SharesListApiService) SharesListItemsGetAnalytics(ctx _context.Context, sharedDriveItemId string, listItemId string) ApiSharesListItemsGetAnalyticsRequest {
	return ApiSharesListItemsGetAnalyticsRequest{
		ApiService: a,
		ctx: ctx,
		sharedDriveItemId: sharedDriveItemId,
		listItemId: listItemId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphItemAnalytics
func (a *SharesListApiService) SharesListItemsGetAnalyticsExecute(r ApiSharesListItemsGetAnalyticsRequest) (MicrosoftGraphItemAnalytics, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphItemAnalytics
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SharesListApiService.SharesListItemsGetAnalytics")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/shares/{sharedDriveItem-id}/list/items/{listItem-id}/analytics"
	localVarPath = strings.Replace(localVarPath, "{"+"sharedDriveItem-id"+"}", _neturl.PathEscape(parameterToString(r.sharedDriveItemId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"listItem-id"+"}", _neturl.PathEscape(parameterToString(r.listItemId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSharesListItemsGetDriveItemRequest struct {
	ctx _context.Context
	ApiService *SharesListApiService
	sharedDriveItemId string
	listItemId string
	select_ *[]string
	expand *[]string
}

// Select properties to be returned
func (r ApiSharesListItemsGetDriveItemRequest) Select_(select_ []string) ApiSharesListItemsGetDriveItemRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiSharesListItemsGetDriveItemRequest) Expand(expand []string) ApiSharesListItemsGetDriveItemRequest {
	r.expand = &expand
	return r
}

func (r ApiSharesListItemsGetDriveItemRequest) Execute() (MicrosoftGraphDriveItem, *_nethttp.Response, error) {
	return r.ApiService.SharesListItemsGetDriveItemExecute(r)
}

/*
SharesListItemsGetDriveItem Get driveItem from shares

For document libraries, the driveItem relationship exposes the listItem as a [driveItem][]

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param sharedDriveItemId key: id of sharedDriveItem
 @param listItemId key: id of listItem
 @return ApiSharesListItemsGetDriveItemRequest
*/
func (a *SharesListApiService) SharesListItemsGetDriveItem(ctx _context.Context, sharedDriveItemId string, listItemId string) ApiSharesListItemsGetDriveItemRequest {
	return ApiSharesListItemsGetDriveItemRequest{
		ApiService: a,
		ctx: ctx,
		sharedDriveItemId: sharedDriveItemId,
		listItemId: listItemId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphDriveItem
func (a *SharesListApiService) SharesListItemsGetDriveItemExecute(r ApiSharesListItemsGetDriveItemRequest) (MicrosoftGraphDriveItem, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphDriveItem
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SharesListApiService.SharesListItemsGetDriveItem")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/shares/{sharedDriveItem-id}/list/items/{listItem-id}/driveItem"
	localVarPath = strings.Replace(localVarPath, "{"+"sharedDriveItem-id"+"}", _neturl.PathEscape(parameterToString(r.sharedDriveItemId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"listItem-id"+"}", _neturl.PathEscape(parameterToString(r.listItemId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSharesListItemsGetDriveItemContentRequest struct {
	ctx _context.Context
	ApiService *SharesListApiService
	sharedDriveItemId string
	listItemId string
}


func (r ApiSharesListItemsGetDriveItemContentRequest) Execute() (*os.File, *_nethttp.Response, error) {
	return r.ApiService.SharesListItemsGetDriveItemContentExecute(r)
}

/*
SharesListItemsGetDriveItemContent Get media content for the navigation property driveItem from shares

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param sharedDriveItemId key: id of sharedDriveItem
 @param listItemId key: id of listItem
 @return ApiSharesListItemsGetDriveItemContentRequest
*/
func (a *SharesListApiService) SharesListItemsGetDriveItemContent(ctx _context.Context, sharedDriveItemId string, listItemId string) ApiSharesListItemsGetDriveItemContentRequest {
	return ApiSharesListItemsGetDriveItemContentRequest{
		ApiService: a,
		ctx: ctx,
		sharedDriveItemId: sharedDriveItemId,
		listItemId: listItemId,
	}
}

// Execute executes the request
//  @return *os.File
func (a *SharesListApiService) SharesListItemsGetDriveItemContentExecute(r ApiSharesListItemsGetDriveItemContentRequest) (*os.File, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  *os.File
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SharesListApiService.SharesListItemsGetDriveItemContent")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/shares/{sharedDriveItem-id}/list/items/{listItem-id}/driveItem/content"
	localVarPath = strings.Replace(localVarPath, "{"+"sharedDriveItem-id"+"}", _neturl.PathEscape(parameterToString(r.sharedDriveItemId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"listItem-id"+"}", _neturl.PathEscape(parameterToString(r.listItemId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/octet-stream", "application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSharesListItemsGetFieldsRequest struct {
	ctx _context.Context
	ApiService *SharesListApiService
	sharedDriveItemId string
	listItemId string
	select_ *[]string
	expand *[]string
}

// Select properties to be returned
func (r ApiSharesListItemsGetFieldsRequest) Select_(select_ []string) ApiSharesListItemsGetFieldsRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiSharesListItemsGetFieldsRequest) Expand(expand []string) ApiSharesListItemsGetFieldsRequest {
	r.expand = &expand
	return r
}

func (r ApiSharesListItemsGetFieldsRequest) Execute() (MicrosoftGraphFieldValueSet, *_nethttp.Response, error) {
	return r.ApiService.SharesListItemsGetFieldsExecute(r)
}

/*
SharesListItemsGetFields Get fields from shares

The values of the columns set on this list item.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param sharedDriveItemId key: id of sharedDriveItem
 @param listItemId key: id of listItem
 @return ApiSharesListItemsGetFieldsRequest
*/
func (a *SharesListApiService) SharesListItemsGetFields(ctx _context.Context, sharedDriveItemId string, listItemId string) ApiSharesListItemsGetFieldsRequest {
	return ApiSharesListItemsGetFieldsRequest{
		ApiService: a,
		ctx: ctx,
		sharedDriveItemId: sharedDriveItemId,
		listItemId: listItemId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphFieldValueSet
func (a *SharesListApiService) SharesListItemsGetFieldsExecute(r ApiSharesListItemsGetFieldsRequest) (MicrosoftGraphFieldValueSet, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphFieldValueSet
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SharesListApiService.SharesListItemsGetFields")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/shares/{sharedDriveItem-id}/list/items/{listItem-id}/fields"
	localVarPath = strings.Replace(localVarPath, "{"+"sharedDriveItem-id"+"}", _neturl.PathEscape(parameterToString(r.sharedDriveItemId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"listItem-id"+"}", _neturl.PathEscape(parameterToString(r.listItemId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSharesListItemsGetRefAnalyticsRequest struct {
	ctx _context.Context
	ApiService *SharesListApiService
	sharedDriveItemId string
	listItemId string
}


func (r ApiSharesListItemsGetRefAnalyticsRequest) Execute() (string, *_nethttp.Response, error) {
	return r.ApiService.SharesListItemsGetRefAnalyticsExecute(r)
}

/*
SharesListItemsGetRefAnalytics Get ref of analytics from shares

Analytics about the view activities that took place on this item.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param sharedDriveItemId key: id of sharedDriveItem
 @param listItemId key: id of listItem
 @return ApiSharesListItemsGetRefAnalyticsRequest
*/
func (a *SharesListApiService) SharesListItemsGetRefAnalytics(ctx _context.Context, sharedDriveItemId string, listItemId string) ApiSharesListItemsGetRefAnalyticsRequest {
	return ApiSharesListItemsGetRefAnalyticsRequest{
		ApiService: a,
		ctx: ctx,
		sharedDriveItemId: sharedDriveItemId,
		listItemId: listItemId,
	}
}

// Execute executes the request
//  @return string
func (a *SharesListApiService) SharesListItemsGetRefAnalyticsExecute(r ApiSharesListItemsGetRefAnalyticsRequest) (string, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  string
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SharesListApiService.SharesListItemsGetRefAnalytics")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/shares/{sharedDriveItem-id}/list/items/{listItem-id}/analytics/$ref"
	localVarPath = strings.Replace(localVarPath, "{"+"sharedDriveItem-id"+"}", _neturl.PathEscape(parameterToString(r.sharedDriveItemId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"listItem-id"+"}", _neturl.PathEscape(parameterToString(r.listItemId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSharesListItemsGetVersionsRequest struct {
	ctx _context.Context
	ApiService *SharesListApiService
	sharedDriveItemId string
	listItemId string
	listItemVersionId string
	select_ *[]string
	expand *[]string
}

// Select properties to be returned
func (r ApiSharesListItemsGetVersionsRequest) Select_(select_ []string) ApiSharesListItemsGetVersionsRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiSharesListItemsGetVersionsRequest) Expand(expand []string) ApiSharesListItemsGetVersionsRequest {
	r.expand = &expand
	return r
}

func (r ApiSharesListItemsGetVersionsRequest) Execute() (MicrosoftGraphListItemVersion, *_nethttp.Response, error) {
	return r.ApiService.SharesListItemsGetVersionsExecute(r)
}

/*
SharesListItemsGetVersions Get versions from shares

The list of previous versions of the list item.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param sharedDriveItemId key: id of sharedDriveItem
 @param listItemId key: id of listItem
 @param listItemVersionId key: id of listItemVersion
 @return ApiSharesListItemsGetVersionsRequest
*/
func (a *SharesListApiService) SharesListItemsGetVersions(ctx _context.Context, sharedDriveItemId string, listItemId string, listItemVersionId string) ApiSharesListItemsGetVersionsRequest {
	return ApiSharesListItemsGetVersionsRequest{
		ApiService: a,
		ctx: ctx,
		sharedDriveItemId: sharedDriveItemId,
		listItemId: listItemId,
		listItemVersionId: listItemVersionId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphListItemVersion
func (a *SharesListApiService) SharesListItemsGetVersionsExecute(r ApiSharesListItemsGetVersionsRequest) (MicrosoftGraphListItemVersion, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphListItemVersion
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SharesListApiService.SharesListItemsGetVersions")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/shares/{sharedDriveItem-id}/list/items/{listItem-id}/versions/{listItemVersion-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"sharedDriveItem-id"+"}", _neturl.PathEscape(parameterToString(r.sharedDriveItemId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"listItem-id"+"}", _neturl.PathEscape(parameterToString(r.listItemId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"listItemVersion-id"+"}", _neturl.PathEscape(parameterToString(r.listItemVersionId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSharesListItemsListVersionsRequest struct {
	ctx _context.Context
	ApiService *SharesListApiService
	sharedDriveItemId string
	listItemId string
	top *int32
	skip *int32
	search *string
	filter *string
	count *bool
	orderby *[]string
	select_ *[]string
	expand *[]string
}

// Show only the first n items
func (r ApiSharesListItemsListVersionsRequest) Top(top int32) ApiSharesListItemsListVersionsRequest {
	r.top = &top
	return r
}
// Skip the first n items
func (r ApiSharesListItemsListVersionsRequest) Skip(skip int32) ApiSharesListItemsListVersionsRequest {
	r.skip = &skip
	return r
}
// Search items by search phrases
func (r ApiSharesListItemsListVersionsRequest) Search(search string) ApiSharesListItemsListVersionsRequest {
	r.search = &search
	return r
}
// Filter items by property values
func (r ApiSharesListItemsListVersionsRequest) Filter(filter string) ApiSharesListItemsListVersionsRequest {
	r.filter = &filter
	return r
}
// Include count of items
func (r ApiSharesListItemsListVersionsRequest) Count(count bool) ApiSharesListItemsListVersionsRequest {
	r.count = &count
	return r
}
// Order items by property values
func (r ApiSharesListItemsListVersionsRequest) Orderby(orderby []string) ApiSharesListItemsListVersionsRequest {
	r.orderby = &orderby
	return r
}
// Select properties to be returned
func (r ApiSharesListItemsListVersionsRequest) Select_(select_ []string) ApiSharesListItemsListVersionsRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiSharesListItemsListVersionsRequest) Expand(expand []string) ApiSharesListItemsListVersionsRequest {
	r.expand = &expand
	return r
}

func (r ApiSharesListItemsListVersionsRequest) Execute() (CollectionOfListItemVersion, *_nethttp.Response, error) {
	return r.ApiService.SharesListItemsListVersionsExecute(r)
}

/*
SharesListItemsListVersions Get versions from shares

The list of previous versions of the list item.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param sharedDriveItemId key: id of sharedDriveItem
 @param listItemId key: id of listItem
 @return ApiSharesListItemsListVersionsRequest
*/
func (a *SharesListApiService) SharesListItemsListVersions(ctx _context.Context, sharedDriveItemId string, listItemId string) ApiSharesListItemsListVersionsRequest {
	return ApiSharesListItemsListVersionsRequest{
		ApiService: a,
		ctx: ctx,
		sharedDriveItemId: sharedDriveItemId,
		listItemId: listItemId,
	}
}

// Execute executes the request
//  @return CollectionOfListItemVersion
func (a *SharesListApiService) SharesListItemsListVersionsExecute(r ApiSharesListItemsListVersionsRequest) (CollectionOfListItemVersion, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  CollectionOfListItemVersion
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SharesListApiService.SharesListItemsListVersions")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/shares/{sharedDriveItem-id}/list/items/{listItem-id}/versions"
	localVarPath = strings.Replace(localVarPath, "{"+"sharedDriveItem-id"+"}", _neturl.PathEscape(parameterToString(r.sharedDriveItemId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"listItem-id"+"}", _neturl.PathEscape(parameterToString(r.listItemId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.top != nil {
		localVarQueryParams.Add("$top", parameterToString(*r.top, ""))
	}
	if r.skip != nil {
		localVarQueryParams.Add("$skip", parameterToString(*r.skip, ""))
	}
	if r.search != nil {
		localVarQueryParams.Add("$search", parameterToString(*r.search, ""))
	}
	if r.filter != nil {
		localVarQueryParams.Add("$filter", parameterToString(*r.filter, ""))
	}
	if r.count != nil {
		localVarQueryParams.Add("$count", parameterToString(*r.count, ""))
	}
	if r.orderby != nil {
		localVarQueryParams.Add("$orderby", parameterToString(*r.orderby, "csv"))
	}
	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSharesListItemsUpdateDriveItemRequest struct {
	ctx _context.Context
	ApiService *SharesListApiService
	sharedDriveItemId string
	listItemId string
	microsoftGraphDriveItem *MicrosoftGraphDriveItem
}

// New navigation property values
func (r ApiSharesListItemsUpdateDriveItemRequest) MicrosoftGraphDriveItem(microsoftGraphDriveItem MicrosoftGraphDriveItem) ApiSharesListItemsUpdateDriveItemRequest {
	r.microsoftGraphDriveItem = &microsoftGraphDriveItem
	return r
}

func (r ApiSharesListItemsUpdateDriveItemRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.SharesListItemsUpdateDriveItemExecute(r)
}

/*
SharesListItemsUpdateDriveItem Update the navigation property driveItem in shares

For document libraries, the driveItem relationship exposes the listItem as a [driveItem][]

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param sharedDriveItemId key: id of sharedDriveItem
 @param listItemId key: id of listItem
 @return ApiSharesListItemsUpdateDriveItemRequest
*/
func (a *SharesListApiService) SharesListItemsUpdateDriveItem(ctx _context.Context, sharedDriveItemId string, listItemId string) ApiSharesListItemsUpdateDriveItemRequest {
	return ApiSharesListItemsUpdateDriveItemRequest{
		ApiService: a,
		ctx: ctx,
		sharedDriveItemId: sharedDriveItemId,
		listItemId: listItemId,
	}
}

// Execute executes the request
func (a *SharesListApiService) SharesListItemsUpdateDriveItemExecute(r ApiSharesListItemsUpdateDriveItemRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPatch
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SharesListApiService.SharesListItemsUpdateDriveItem")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/shares/{sharedDriveItem-id}/list/items/{listItem-id}/driveItem"
	localVarPath = strings.Replace(localVarPath, "{"+"sharedDriveItem-id"+"}", _neturl.PathEscape(parameterToString(r.sharedDriveItemId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"listItem-id"+"}", _neturl.PathEscape(parameterToString(r.listItemId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphDriveItem == nil {
		return nil, reportError("microsoftGraphDriveItem is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphDriveItem
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiSharesListItemsUpdateDriveItemContentRequest struct {
	ctx _context.Context
	ApiService *SharesListApiService
	sharedDriveItemId string
	listItemId string
	body **os.File
}

// New media content.
func (r ApiSharesListItemsUpdateDriveItemContentRequest) Body(body *os.File) ApiSharesListItemsUpdateDriveItemContentRequest {
	r.body = &body
	return r
}

func (r ApiSharesListItemsUpdateDriveItemContentRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.SharesListItemsUpdateDriveItemContentExecute(r)
}

/*
SharesListItemsUpdateDriveItemContent Update media content for the navigation property driveItem in shares

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param sharedDriveItemId key: id of sharedDriveItem
 @param listItemId key: id of listItem
 @return ApiSharesListItemsUpdateDriveItemContentRequest
*/
func (a *SharesListApiService) SharesListItemsUpdateDriveItemContent(ctx _context.Context, sharedDriveItemId string, listItemId string) ApiSharesListItemsUpdateDriveItemContentRequest {
	return ApiSharesListItemsUpdateDriveItemContentRequest{
		ApiService: a,
		ctx: ctx,
		sharedDriveItemId: sharedDriveItemId,
		listItemId: listItemId,
	}
}

// Execute executes the request
func (a *SharesListApiService) SharesListItemsUpdateDriveItemContentExecute(r ApiSharesListItemsUpdateDriveItemContentRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPut
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SharesListApiService.SharesListItemsUpdateDriveItemContent")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/shares/{sharedDriveItem-id}/list/items/{listItem-id}/driveItem/content"
	localVarPath = strings.Replace(localVarPath, "{"+"sharedDriveItem-id"+"}", _neturl.PathEscape(parameterToString(r.sharedDriveItemId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"listItem-id"+"}", _neturl.PathEscape(parameterToString(r.listItemId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.body == nil {
		return nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/octet-stream"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiSharesListItemsUpdateFieldsRequest struct {
	ctx _context.Context
	ApiService *SharesListApiService
	sharedDriveItemId string
	listItemId string
	microsoftGraphFieldValueSet *MicrosoftGraphFieldValueSet
}

// New navigation property values
func (r ApiSharesListItemsUpdateFieldsRequest) MicrosoftGraphFieldValueSet(microsoftGraphFieldValueSet MicrosoftGraphFieldValueSet) ApiSharesListItemsUpdateFieldsRequest {
	r.microsoftGraphFieldValueSet = &microsoftGraphFieldValueSet
	return r
}

func (r ApiSharesListItemsUpdateFieldsRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.SharesListItemsUpdateFieldsExecute(r)
}

/*
SharesListItemsUpdateFields Update the navigation property fields in shares

The values of the columns set on this list item.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param sharedDriveItemId key: id of sharedDriveItem
 @param listItemId key: id of listItem
 @return ApiSharesListItemsUpdateFieldsRequest
*/
func (a *SharesListApiService) SharesListItemsUpdateFields(ctx _context.Context, sharedDriveItemId string, listItemId string) ApiSharesListItemsUpdateFieldsRequest {
	return ApiSharesListItemsUpdateFieldsRequest{
		ApiService: a,
		ctx: ctx,
		sharedDriveItemId: sharedDriveItemId,
		listItemId: listItemId,
	}
}

// Execute executes the request
func (a *SharesListApiService) SharesListItemsUpdateFieldsExecute(r ApiSharesListItemsUpdateFieldsRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPatch
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SharesListApiService.SharesListItemsUpdateFields")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/shares/{sharedDriveItem-id}/list/items/{listItem-id}/fields"
	localVarPath = strings.Replace(localVarPath, "{"+"sharedDriveItem-id"+"}", _neturl.PathEscape(parameterToString(r.sharedDriveItemId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"listItem-id"+"}", _neturl.PathEscape(parameterToString(r.listItemId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphFieldValueSet == nil {
		return nil, reportError("microsoftGraphFieldValueSet is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphFieldValueSet
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiSharesListItemsUpdateRefAnalyticsRequest struct {
	ctx _context.Context
	ApiService *SharesListApiService
	sharedDriveItemId string
	listItemId string
	requestBody *map[string]map[string]interface{}
}

// New navigation property ref values
func (r ApiSharesListItemsUpdateRefAnalyticsRequest) RequestBody(requestBody map[string]map[string]interface{}) ApiSharesListItemsUpdateRefAnalyticsRequest {
	r.requestBody = &requestBody
	return r
}

func (r ApiSharesListItemsUpdateRefAnalyticsRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.SharesListItemsUpdateRefAnalyticsExecute(r)
}

/*
SharesListItemsUpdateRefAnalytics Update the ref of navigation property analytics in shares

Analytics about the view activities that took place on this item.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param sharedDriveItemId key: id of sharedDriveItem
 @param listItemId key: id of listItem
 @return ApiSharesListItemsUpdateRefAnalyticsRequest
*/
func (a *SharesListApiService) SharesListItemsUpdateRefAnalytics(ctx _context.Context, sharedDriveItemId string, listItemId string) ApiSharesListItemsUpdateRefAnalyticsRequest {
	return ApiSharesListItemsUpdateRefAnalyticsRequest{
		ApiService: a,
		ctx: ctx,
		sharedDriveItemId: sharedDriveItemId,
		listItemId: listItemId,
	}
}

// Execute executes the request
func (a *SharesListApiService) SharesListItemsUpdateRefAnalyticsExecute(r ApiSharesListItemsUpdateRefAnalyticsRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPut
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SharesListApiService.SharesListItemsUpdateRefAnalytics")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/shares/{sharedDriveItem-id}/list/items/{listItem-id}/analytics/$ref"
	localVarPath = strings.Replace(localVarPath, "{"+"sharedDriveItem-id"+"}", _neturl.PathEscape(parameterToString(r.sharedDriveItemId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"listItem-id"+"}", _neturl.PathEscape(parameterToString(r.listItemId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.requestBody == nil {
		return nil, reportError("requestBody is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.requestBody
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiSharesListItemsUpdateVersionsRequest struct {
	ctx _context.Context
	ApiService *SharesListApiService
	sharedDriveItemId string
	listItemId string
	listItemVersionId string
	microsoftGraphListItemVersion *MicrosoftGraphListItemVersion
}

// New navigation property values
func (r ApiSharesListItemsUpdateVersionsRequest) MicrosoftGraphListItemVersion(microsoftGraphListItemVersion MicrosoftGraphListItemVersion) ApiSharesListItemsUpdateVersionsRequest {
	r.microsoftGraphListItemVersion = &microsoftGraphListItemVersion
	return r
}

func (r ApiSharesListItemsUpdateVersionsRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.SharesListItemsUpdateVersionsExecute(r)
}

/*
SharesListItemsUpdateVersions Update the navigation property versions in shares

The list of previous versions of the list item.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param sharedDriveItemId key: id of sharedDriveItem
 @param listItemId key: id of listItem
 @param listItemVersionId key: id of listItemVersion
 @return ApiSharesListItemsUpdateVersionsRequest
*/
func (a *SharesListApiService) SharesListItemsUpdateVersions(ctx _context.Context, sharedDriveItemId string, listItemId string, listItemVersionId string) ApiSharesListItemsUpdateVersionsRequest {
	return ApiSharesListItemsUpdateVersionsRequest{
		ApiService: a,
		ctx: ctx,
		sharedDriveItemId: sharedDriveItemId,
		listItemId: listItemId,
		listItemVersionId: listItemVersionId,
	}
}

// Execute executes the request
func (a *SharesListApiService) SharesListItemsUpdateVersionsExecute(r ApiSharesListItemsUpdateVersionsRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPatch
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SharesListApiService.SharesListItemsUpdateVersions")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/shares/{sharedDriveItem-id}/list/items/{listItem-id}/versions/{listItemVersion-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"sharedDriveItem-id"+"}", _neturl.PathEscape(parameterToString(r.sharedDriveItemId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"listItem-id"+"}", _neturl.PathEscape(parameterToString(r.listItemId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"listItemVersion-id"+"}", _neturl.PathEscape(parameterToString(r.listItemVersionId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphListItemVersion == nil {
		return nil, reportError("microsoftGraphListItemVersion is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphListItemVersion
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiSharesListItemsVersionsDeleteFieldsRequest struct {
	ctx _context.Context
	ApiService *SharesListApiService
	sharedDriveItemId string
	listItemId string
	listItemVersionId string
	ifMatch *string
}

// ETag
func (r ApiSharesListItemsVersionsDeleteFieldsRequest) IfMatch(ifMatch string) ApiSharesListItemsVersionsDeleteFieldsRequest {
	r.ifMatch = &ifMatch
	return r
}

func (r ApiSharesListItemsVersionsDeleteFieldsRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.SharesListItemsVersionsDeleteFieldsExecute(r)
}

/*
SharesListItemsVersionsDeleteFields Delete navigation property fields for shares

A collection of the fields and values for this version of the list item.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param sharedDriveItemId key: id of sharedDriveItem
 @param listItemId key: id of listItem
 @param listItemVersionId key: id of listItemVersion
 @return ApiSharesListItemsVersionsDeleteFieldsRequest
*/
func (a *SharesListApiService) SharesListItemsVersionsDeleteFields(ctx _context.Context, sharedDriveItemId string, listItemId string, listItemVersionId string) ApiSharesListItemsVersionsDeleteFieldsRequest {
	return ApiSharesListItemsVersionsDeleteFieldsRequest{
		ApiService: a,
		ctx: ctx,
		sharedDriveItemId: sharedDriveItemId,
		listItemId: listItemId,
		listItemVersionId: listItemVersionId,
	}
}

// Execute executes the request
func (a *SharesListApiService) SharesListItemsVersionsDeleteFieldsExecute(r ApiSharesListItemsVersionsDeleteFieldsRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SharesListApiService.SharesListItemsVersionsDeleteFields")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/shares/{sharedDriveItem-id}/list/items/{listItem-id}/versions/{listItemVersion-id}/fields"
	localVarPath = strings.Replace(localVarPath, "{"+"sharedDriveItem-id"+"}", _neturl.PathEscape(parameterToString(r.sharedDriveItemId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"listItem-id"+"}", _neturl.PathEscape(parameterToString(r.listItemId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"listItemVersion-id"+"}", _neturl.PathEscape(parameterToString(r.listItemVersionId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ifMatch != nil {
		localVarHeaderParams["If-Match"] = parameterToString(*r.ifMatch, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiSharesListItemsVersionsGetFieldsRequest struct {
	ctx _context.Context
	ApiService *SharesListApiService
	sharedDriveItemId string
	listItemId string
	listItemVersionId string
	select_ *[]string
	expand *[]string
}

// Select properties to be returned
func (r ApiSharesListItemsVersionsGetFieldsRequest) Select_(select_ []string) ApiSharesListItemsVersionsGetFieldsRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiSharesListItemsVersionsGetFieldsRequest) Expand(expand []string) ApiSharesListItemsVersionsGetFieldsRequest {
	r.expand = &expand
	return r
}

func (r ApiSharesListItemsVersionsGetFieldsRequest) Execute() (MicrosoftGraphFieldValueSet, *_nethttp.Response, error) {
	return r.ApiService.SharesListItemsVersionsGetFieldsExecute(r)
}

/*
SharesListItemsVersionsGetFields Get fields from shares

A collection of the fields and values for this version of the list item.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param sharedDriveItemId key: id of sharedDriveItem
 @param listItemId key: id of listItem
 @param listItemVersionId key: id of listItemVersion
 @return ApiSharesListItemsVersionsGetFieldsRequest
*/
func (a *SharesListApiService) SharesListItemsVersionsGetFields(ctx _context.Context, sharedDriveItemId string, listItemId string, listItemVersionId string) ApiSharesListItemsVersionsGetFieldsRequest {
	return ApiSharesListItemsVersionsGetFieldsRequest{
		ApiService: a,
		ctx: ctx,
		sharedDriveItemId: sharedDriveItemId,
		listItemId: listItemId,
		listItemVersionId: listItemVersionId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphFieldValueSet
func (a *SharesListApiService) SharesListItemsVersionsGetFieldsExecute(r ApiSharesListItemsVersionsGetFieldsRequest) (MicrosoftGraphFieldValueSet, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphFieldValueSet
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SharesListApiService.SharesListItemsVersionsGetFields")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/shares/{sharedDriveItem-id}/list/items/{listItem-id}/versions/{listItemVersion-id}/fields"
	localVarPath = strings.Replace(localVarPath, "{"+"sharedDriveItem-id"+"}", _neturl.PathEscape(parameterToString(r.sharedDriveItemId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"listItem-id"+"}", _neturl.PathEscape(parameterToString(r.listItemId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"listItemVersion-id"+"}", _neturl.PathEscape(parameterToString(r.listItemVersionId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSharesListItemsVersionsUpdateFieldsRequest struct {
	ctx _context.Context
	ApiService *SharesListApiService
	sharedDriveItemId string
	listItemId string
	listItemVersionId string
	microsoftGraphFieldValueSet *MicrosoftGraphFieldValueSet
}

// New navigation property values
func (r ApiSharesListItemsVersionsUpdateFieldsRequest) MicrosoftGraphFieldValueSet(microsoftGraphFieldValueSet MicrosoftGraphFieldValueSet) ApiSharesListItemsVersionsUpdateFieldsRequest {
	r.microsoftGraphFieldValueSet = &microsoftGraphFieldValueSet
	return r
}

func (r ApiSharesListItemsVersionsUpdateFieldsRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.SharesListItemsVersionsUpdateFieldsExecute(r)
}

/*
SharesListItemsVersionsUpdateFields Update the navigation property fields in shares

A collection of the fields and values for this version of the list item.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param sharedDriveItemId key: id of sharedDriveItem
 @param listItemId key: id of listItem
 @param listItemVersionId key: id of listItemVersion
 @return ApiSharesListItemsVersionsUpdateFieldsRequest
*/
func (a *SharesListApiService) SharesListItemsVersionsUpdateFields(ctx _context.Context, sharedDriveItemId string, listItemId string, listItemVersionId string) ApiSharesListItemsVersionsUpdateFieldsRequest {
	return ApiSharesListItemsVersionsUpdateFieldsRequest{
		ApiService: a,
		ctx: ctx,
		sharedDriveItemId: sharedDriveItemId,
		listItemId: listItemId,
		listItemVersionId: listItemVersionId,
	}
}

// Execute executes the request
func (a *SharesListApiService) SharesListItemsVersionsUpdateFieldsExecute(r ApiSharesListItemsVersionsUpdateFieldsRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPatch
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SharesListApiService.SharesListItemsVersionsUpdateFields")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/shares/{sharedDriveItem-id}/list/items/{listItem-id}/versions/{listItemVersion-id}/fields"
	localVarPath = strings.Replace(localVarPath, "{"+"sharedDriveItem-id"+"}", _neturl.PathEscape(parameterToString(r.sharedDriveItemId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"listItem-id"+"}", _neturl.PathEscape(parameterToString(r.listItemId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"listItemVersion-id"+"}", _neturl.PathEscape(parameterToString(r.listItemVersionId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphFieldValueSet == nil {
		return nil, reportError("microsoftGraphFieldValueSet is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphFieldValueSet
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiSharesListListColumnsRequest struct {
	ctx _context.Context
	ApiService *SharesListApiService
	sharedDriveItemId string
	top *int32
	skip *int32
	search *string
	filter *string
	count *bool
	orderby *[]string
	select_ *[]string
	expand *[]string
}

// Show only the first n items
func (r ApiSharesListListColumnsRequest) Top(top int32) ApiSharesListListColumnsRequest {
	r.top = &top
	return r
}
// Skip the first n items
func (r ApiSharesListListColumnsRequest) Skip(skip int32) ApiSharesListListColumnsRequest {
	r.skip = &skip
	return r
}
// Search items by search phrases
func (r ApiSharesListListColumnsRequest) Search(search string) ApiSharesListListColumnsRequest {
	r.search = &search
	return r
}
// Filter items by property values
func (r ApiSharesListListColumnsRequest) Filter(filter string) ApiSharesListListColumnsRequest {
	r.filter = &filter
	return r
}
// Include count of items
func (r ApiSharesListListColumnsRequest) Count(count bool) ApiSharesListListColumnsRequest {
	r.count = &count
	return r
}
// Order items by property values
func (r ApiSharesListListColumnsRequest) Orderby(orderby []string) ApiSharesListListColumnsRequest {
	r.orderby = &orderby
	return r
}
// Select properties to be returned
func (r ApiSharesListListColumnsRequest) Select_(select_ []string) ApiSharesListListColumnsRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiSharesListListColumnsRequest) Expand(expand []string) ApiSharesListListColumnsRequest {
	r.expand = &expand
	return r
}

func (r ApiSharesListListColumnsRequest) Execute() (CollectionOfColumnDefinition, *_nethttp.Response, error) {
	return r.ApiService.SharesListListColumnsExecute(r)
}

/*
SharesListListColumns Get columns from shares

The collection of field definitions for this list.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param sharedDriveItemId key: id of sharedDriveItem
 @return ApiSharesListListColumnsRequest
*/
func (a *SharesListApiService) SharesListListColumns(ctx _context.Context, sharedDriveItemId string) ApiSharesListListColumnsRequest {
	return ApiSharesListListColumnsRequest{
		ApiService: a,
		ctx: ctx,
		sharedDriveItemId: sharedDriveItemId,
	}
}

// Execute executes the request
//  @return CollectionOfColumnDefinition
func (a *SharesListApiService) SharesListListColumnsExecute(r ApiSharesListListColumnsRequest) (CollectionOfColumnDefinition, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  CollectionOfColumnDefinition
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SharesListApiService.SharesListListColumns")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/shares/{sharedDriveItem-id}/list/columns"
	localVarPath = strings.Replace(localVarPath, "{"+"sharedDriveItem-id"+"}", _neturl.PathEscape(parameterToString(r.sharedDriveItemId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.top != nil {
		localVarQueryParams.Add("$top", parameterToString(*r.top, ""))
	}
	if r.skip != nil {
		localVarQueryParams.Add("$skip", parameterToString(*r.skip, ""))
	}
	if r.search != nil {
		localVarQueryParams.Add("$search", parameterToString(*r.search, ""))
	}
	if r.filter != nil {
		localVarQueryParams.Add("$filter", parameterToString(*r.filter, ""))
	}
	if r.count != nil {
		localVarQueryParams.Add("$count", parameterToString(*r.count, ""))
	}
	if r.orderby != nil {
		localVarQueryParams.Add("$orderby", parameterToString(*r.orderby, "csv"))
	}
	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSharesListListContentTypesRequest struct {
	ctx _context.Context
	ApiService *SharesListApiService
	sharedDriveItemId string
	top *int32
	skip *int32
	search *string
	filter *string
	count *bool
	orderby *[]string
	select_ *[]string
	expand *[]string
}

// Show only the first n items
func (r ApiSharesListListContentTypesRequest) Top(top int32) ApiSharesListListContentTypesRequest {
	r.top = &top
	return r
}
// Skip the first n items
func (r ApiSharesListListContentTypesRequest) Skip(skip int32) ApiSharesListListContentTypesRequest {
	r.skip = &skip
	return r
}
// Search items by search phrases
func (r ApiSharesListListContentTypesRequest) Search(search string) ApiSharesListListContentTypesRequest {
	r.search = &search
	return r
}
// Filter items by property values
func (r ApiSharesListListContentTypesRequest) Filter(filter string) ApiSharesListListContentTypesRequest {
	r.filter = &filter
	return r
}
// Include count of items
func (r ApiSharesListListContentTypesRequest) Count(count bool) ApiSharesListListContentTypesRequest {
	r.count = &count
	return r
}
// Order items by property values
func (r ApiSharesListListContentTypesRequest) Orderby(orderby []string) ApiSharesListListContentTypesRequest {
	r.orderby = &orderby
	return r
}
// Select properties to be returned
func (r ApiSharesListListContentTypesRequest) Select_(select_ []string) ApiSharesListListContentTypesRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiSharesListListContentTypesRequest) Expand(expand []string) ApiSharesListListContentTypesRequest {
	r.expand = &expand
	return r
}

func (r ApiSharesListListContentTypesRequest) Execute() (CollectionOfContentType, *_nethttp.Response, error) {
	return r.ApiService.SharesListListContentTypesExecute(r)
}

/*
SharesListListContentTypes Get contentTypes from shares

The collection of content types present in this list.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param sharedDriveItemId key: id of sharedDriveItem
 @return ApiSharesListListContentTypesRequest
*/
func (a *SharesListApiService) SharesListListContentTypes(ctx _context.Context, sharedDriveItemId string) ApiSharesListListContentTypesRequest {
	return ApiSharesListListContentTypesRequest{
		ApiService: a,
		ctx: ctx,
		sharedDriveItemId: sharedDriveItemId,
	}
}

// Execute executes the request
//  @return CollectionOfContentType
func (a *SharesListApiService) SharesListListContentTypesExecute(r ApiSharesListListContentTypesRequest) (CollectionOfContentType, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  CollectionOfContentType
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SharesListApiService.SharesListListContentTypes")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/shares/{sharedDriveItem-id}/list/contentTypes"
	localVarPath = strings.Replace(localVarPath, "{"+"sharedDriveItem-id"+"}", _neturl.PathEscape(parameterToString(r.sharedDriveItemId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.top != nil {
		localVarQueryParams.Add("$top", parameterToString(*r.top, ""))
	}
	if r.skip != nil {
		localVarQueryParams.Add("$skip", parameterToString(*r.skip, ""))
	}
	if r.search != nil {
		localVarQueryParams.Add("$search", parameterToString(*r.search, ""))
	}
	if r.filter != nil {
		localVarQueryParams.Add("$filter", parameterToString(*r.filter, ""))
	}
	if r.count != nil {
		localVarQueryParams.Add("$count", parameterToString(*r.count, ""))
	}
	if r.orderby != nil {
		localVarQueryParams.Add("$orderby", parameterToString(*r.orderby, "csv"))
	}
	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSharesListListItemsRequest struct {
	ctx _context.Context
	ApiService *SharesListApiService
	sharedDriveItemId string
	top *int32
	skip *int32
	search *string
	filter *string
	count *bool
	orderby *[]string
	select_ *[]string
	expand *[]string
}

// Show only the first n items
func (r ApiSharesListListItemsRequest) Top(top int32) ApiSharesListListItemsRequest {
	r.top = &top
	return r
}
// Skip the first n items
func (r ApiSharesListListItemsRequest) Skip(skip int32) ApiSharesListListItemsRequest {
	r.skip = &skip
	return r
}
// Search items by search phrases
func (r ApiSharesListListItemsRequest) Search(search string) ApiSharesListListItemsRequest {
	r.search = &search
	return r
}
// Filter items by property values
func (r ApiSharesListListItemsRequest) Filter(filter string) ApiSharesListListItemsRequest {
	r.filter = &filter
	return r
}
// Include count of items
func (r ApiSharesListListItemsRequest) Count(count bool) ApiSharesListListItemsRequest {
	r.count = &count
	return r
}
// Order items by property values
func (r ApiSharesListListItemsRequest) Orderby(orderby []string) ApiSharesListListItemsRequest {
	r.orderby = &orderby
	return r
}
// Select properties to be returned
func (r ApiSharesListListItemsRequest) Select_(select_ []string) ApiSharesListListItemsRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiSharesListListItemsRequest) Expand(expand []string) ApiSharesListListItemsRequest {
	r.expand = &expand
	return r
}

func (r ApiSharesListListItemsRequest) Execute() (CollectionOfListItem, *_nethttp.Response, error) {
	return r.ApiService.SharesListListItemsExecute(r)
}

/*
SharesListListItems Get items from shares

All items contained in the list.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param sharedDriveItemId key: id of sharedDriveItem
 @return ApiSharesListListItemsRequest
*/
func (a *SharesListApiService) SharesListListItems(ctx _context.Context, sharedDriveItemId string) ApiSharesListListItemsRequest {
	return ApiSharesListListItemsRequest{
		ApiService: a,
		ctx: ctx,
		sharedDriveItemId: sharedDriveItemId,
	}
}

// Execute executes the request
//  @return CollectionOfListItem
func (a *SharesListApiService) SharesListListItemsExecute(r ApiSharesListListItemsRequest) (CollectionOfListItem, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  CollectionOfListItem
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SharesListApiService.SharesListListItems")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/shares/{sharedDriveItem-id}/list/items"
	localVarPath = strings.Replace(localVarPath, "{"+"sharedDriveItem-id"+"}", _neturl.PathEscape(parameterToString(r.sharedDriveItemId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.top != nil {
		localVarQueryParams.Add("$top", parameterToString(*r.top, ""))
	}
	if r.skip != nil {
		localVarQueryParams.Add("$skip", parameterToString(*r.skip, ""))
	}
	if r.search != nil {
		localVarQueryParams.Add("$search", parameterToString(*r.search, ""))
	}
	if r.filter != nil {
		localVarQueryParams.Add("$filter", parameterToString(*r.filter, ""))
	}
	if r.count != nil {
		localVarQueryParams.Add("$count", parameterToString(*r.count, ""))
	}
	if r.orderby != nil {
		localVarQueryParams.Add("$orderby", parameterToString(*r.orderby, "csv"))
	}
	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSharesListListSubscriptionsRequest struct {
	ctx _context.Context
	ApiService *SharesListApiService
	sharedDriveItemId string
	top *int32
	skip *int32
	search *string
	filter *string
	count *bool
	orderby *[]string
	select_ *[]string
	expand *[]string
}

// Show only the first n items
func (r ApiSharesListListSubscriptionsRequest) Top(top int32) ApiSharesListListSubscriptionsRequest {
	r.top = &top
	return r
}
// Skip the first n items
func (r ApiSharesListListSubscriptionsRequest) Skip(skip int32) ApiSharesListListSubscriptionsRequest {
	r.skip = &skip
	return r
}
// Search items by search phrases
func (r ApiSharesListListSubscriptionsRequest) Search(search string) ApiSharesListListSubscriptionsRequest {
	r.search = &search
	return r
}
// Filter items by property values
func (r ApiSharesListListSubscriptionsRequest) Filter(filter string) ApiSharesListListSubscriptionsRequest {
	r.filter = &filter
	return r
}
// Include count of items
func (r ApiSharesListListSubscriptionsRequest) Count(count bool) ApiSharesListListSubscriptionsRequest {
	r.count = &count
	return r
}
// Order items by property values
func (r ApiSharesListListSubscriptionsRequest) Orderby(orderby []string) ApiSharesListListSubscriptionsRequest {
	r.orderby = &orderby
	return r
}
// Select properties to be returned
func (r ApiSharesListListSubscriptionsRequest) Select_(select_ []string) ApiSharesListListSubscriptionsRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiSharesListListSubscriptionsRequest) Expand(expand []string) ApiSharesListListSubscriptionsRequest {
	r.expand = &expand
	return r
}

func (r ApiSharesListListSubscriptionsRequest) Execute() (CollectionOfSubscription, *_nethttp.Response, error) {
	return r.ApiService.SharesListListSubscriptionsExecute(r)
}

/*
SharesListListSubscriptions Get subscriptions from shares

The set of subscriptions on the list.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param sharedDriveItemId key: id of sharedDriveItem
 @return ApiSharesListListSubscriptionsRequest
*/
func (a *SharesListApiService) SharesListListSubscriptions(ctx _context.Context, sharedDriveItemId string) ApiSharesListListSubscriptionsRequest {
	return ApiSharesListListSubscriptionsRequest{
		ApiService: a,
		ctx: ctx,
		sharedDriveItemId: sharedDriveItemId,
	}
}

// Execute executes the request
//  @return CollectionOfSubscription
func (a *SharesListApiService) SharesListListSubscriptionsExecute(r ApiSharesListListSubscriptionsRequest) (CollectionOfSubscription, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  CollectionOfSubscription
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SharesListApiService.SharesListListSubscriptions")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/shares/{sharedDriveItem-id}/list/subscriptions"
	localVarPath = strings.Replace(localVarPath, "{"+"sharedDriveItem-id"+"}", _neturl.PathEscape(parameterToString(r.sharedDriveItemId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.top != nil {
		localVarQueryParams.Add("$top", parameterToString(*r.top, ""))
	}
	if r.skip != nil {
		localVarQueryParams.Add("$skip", parameterToString(*r.skip, ""))
	}
	if r.search != nil {
		localVarQueryParams.Add("$search", parameterToString(*r.search, ""))
	}
	if r.filter != nil {
		localVarQueryParams.Add("$filter", parameterToString(*r.filter, ""))
	}
	if r.count != nil {
		localVarQueryParams.Add("$count", parameterToString(*r.count, ""))
	}
	if r.orderby != nil {
		localVarQueryParams.Add("$orderby", parameterToString(*r.orderby, "csv"))
	}
	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSharesListUpdateColumnsRequest struct {
	ctx _context.Context
	ApiService *SharesListApiService
	sharedDriveItemId string
	columnDefinitionId string
	microsoftGraphColumnDefinition *MicrosoftGraphColumnDefinition
}

// New navigation property values
func (r ApiSharesListUpdateColumnsRequest) MicrosoftGraphColumnDefinition(microsoftGraphColumnDefinition MicrosoftGraphColumnDefinition) ApiSharesListUpdateColumnsRequest {
	r.microsoftGraphColumnDefinition = &microsoftGraphColumnDefinition
	return r
}

func (r ApiSharesListUpdateColumnsRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.SharesListUpdateColumnsExecute(r)
}

/*
SharesListUpdateColumns Update the navigation property columns in shares

The collection of field definitions for this list.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param sharedDriveItemId key: id of sharedDriveItem
 @param columnDefinitionId key: id of columnDefinition
 @return ApiSharesListUpdateColumnsRequest
*/
func (a *SharesListApiService) SharesListUpdateColumns(ctx _context.Context, sharedDriveItemId string, columnDefinitionId string) ApiSharesListUpdateColumnsRequest {
	return ApiSharesListUpdateColumnsRequest{
		ApiService: a,
		ctx: ctx,
		sharedDriveItemId: sharedDriveItemId,
		columnDefinitionId: columnDefinitionId,
	}
}

// Execute executes the request
func (a *SharesListApiService) SharesListUpdateColumnsExecute(r ApiSharesListUpdateColumnsRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPatch
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SharesListApiService.SharesListUpdateColumns")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/shares/{sharedDriveItem-id}/list/columns/{columnDefinition-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"sharedDriveItem-id"+"}", _neturl.PathEscape(parameterToString(r.sharedDriveItemId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"columnDefinition-id"+"}", _neturl.PathEscape(parameterToString(r.columnDefinitionId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphColumnDefinition == nil {
		return nil, reportError("microsoftGraphColumnDefinition is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphColumnDefinition
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiSharesListUpdateContentTypesRequest struct {
	ctx _context.Context
	ApiService *SharesListApiService
	sharedDriveItemId string
	contentTypeId string
	microsoftGraphContentType *MicrosoftGraphContentType
}

// New navigation property values
func (r ApiSharesListUpdateContentTypesRequest) MicrosoftGraphContentType(microsoftGraphContentType MicrosoftGraphContentType) ApiSharesListUpdateContentTypesRequest {
	r.microsoftGraphContentType = &microsoftGraphContentType
	return r
}

func (r ApiSharesListUpdateContentTypesRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.SharesListUpdateContentTypesExecute(r)
}

/*
SharesListUpdateContentTypes Update the navigation property contentTypes in shares

The collection of content types present in this list.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param sharedDriveItemId key: id of sharedDriveItem
 @param contentTypeId key: id of contentType
 @return ApiSharesListUpdateContentTypesRequest
*/
func (a *SharesListApiService) SharesListUpdateContentTypes(ctx _context.Context, sharedDriveItemId string, contentTypeId string) ApiSharesListUpdateContentTypesRequest {
	return ApiSharesListUpdateContentTypesRequest{
		ApiService: a,
		ctx: ctx,
		sharedDriveItemId: sharedDriveItemId,
		contentTypeId: contentTypeId,
	}
}

// Execute executes the request
func (a *SharesListApiService) SharesListUpdateContentTypesExecute(r ApiSharesListUpdateContentTypesRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPatch
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SharesListApiService.SharesListUpdateContentTypes")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/shares/{sharedDriveItem-id}/list/contentTypes/{contentType-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"sharedDriveItem-id"+"}", _neturl.PathEscape(parameterToString(r.sharedDriveItemId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"contentType-id"+"}", _neturl.PathEscape(parameterToString(r.contentTypeId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphContentType == nil {
		return nil, reportError("microsoftGraphContentType is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphContentType
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiSharesListUpdateDriveRequest struct {
	ctx _context.Context
	ApiService *SharesListApiService
	sharedDriveItemId string
	microsoftGraphDrive *MicrosoftGraphDrive
}

// New navigation property values
func (r ApiSharesListUpdateDriveRequest) MicrosoftGraphDrive(microsoftGraphDrive MicrosoftGraphDrive) ApiSharesListUpdateDriveRequest {
	r.microsoftGraphDrive = &microsoftGraphDrive
	return r
}

func (r ApiSharesListUpdateDriveRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.SharesListUpdateDriveExecute(r)
}

/*
SharesListUpdateDrive Update the navigation property drive in shares

Only present on document libraries. Allows access to the list as a [drive][] resource with [driveItems][driveItem].

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param sharedDriveItemId key: id of sharedDriveItem
 @return ApiSharesListUpdateDriveRequest
*/
func (a *SharesListApiService) SharesListUpdateDrive(ctx _context.Context, sharedDriveItemId string) ApiSharesListUpdateDriveRequest {
	return ApiSharesListUpdateDriveRequest{
		ApiService: a,
		ctx: ctx,
		sharedDriveItemId: sharedDriveItemId,
	}
}

// Execute executes the request
func (a *SharesListApiService) SharesListUpdateDriveExecute(r ApiSharesListUpdateDriveRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPatch
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SharesListApiService.SharesListUpdateDrive")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/shares/{sharedDriveItem-id}/list/drive"
	localVarPath = strings.Replace(localVarPath, "{"+"sharedDriveItem-id"+"}", _neturl.PathEscape(parameterToString(r.sharedDriveItemId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphDrive == nil {
		return nil, reportError("microsoftGraphDrive is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphDrive
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiSharesListUpdateItemsRequest struct {
	ctx _context.Context
	ApiService *SharesListApiService
	sharedDriveItemId string
	listItemId string
	microsoftGraphListItem *MicrosoftGraphListItem
}

// New navigation property values
func (r ApiSharesListUpdateItemsRequest) MicrosoftGraphListItem(microsoftGraphListItem MicrosoftGraphListItem) ApiSharesListUpdateItemsRequest {
	r.microsoftGraphListItem = &microsoftGraphListItem
	return r
}

func (r ApiSharesListUpdateItemsRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.SharesListUpdateItemsExecute(r)
}

/*
SharesListUpdateItems Update the navigation property items in shares

All items contained in the list.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param sharedDriveItemId key: id of sharedDriveItem
 @param listItemId key: id of listItem
 @return ApiSharesListUpdateItemsRequest
*/
func (a *SharesListApiService) SharesListUpdateItems(ctx _context.Context, sharedDriveItemId string, listItemId string) ApiSharesListUpdateItemsRequest {
	return ApiSharesListUpdateItemsRequest{
		ApiService: a,
		ctx: ctx,
		sharedDriveItemId: sharedDriveItemId,
		listItemId: listItemId,
	}
}

// Execute executes the request
func (a *SharesListApiService) SharesListUpdateItemsExecute(r ApiSharesListUpdateItemsRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPatch
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SharesListApiService.SharesListUpdateItems")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/shares/{sharedDriveItem-id}/list/items/{listItem-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"sharedDriveItem-id"+"}", _neturl.PathEscape(parameterToString(r.sharedDriveItemId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"listItem-id"+"}", _neturl.PathEscape(parameterToString(r.listItemId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphListItem == nil {
		return nil, reportError("microsoftGraphListItem is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphListItem
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiSharesListUpdateSubscriptionsRequest struct {
	ctx _context.Context
	ApiService *SharesListApiService
	sharedDriveItemId string
	subscriptionId string
	microsoftGraphSubscription *MicrosoftGraphSubscription
}

// New navigation property values
func (r ApiSharesListUpdateSubscriptionsRequest) MicrosoftGraphSubscription(microsoftGraphSubscription MicrosoftGraphSubscription) ApiSharesListUpdateSubscriptionsRequest {
	r.microsoftGraphSubscription = &microsoftGraphSubscription
	return r
}

func (r ApiSharesListUpdateSubscriptionsRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.SharesListUpdateSubscriptionsExecute(r)
}

/*
SharesListUpdateSubscriptions Update the navigation property subscriptions in shares

The set of subscriptions on the list.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param sharedDriveItemId key: id of sharedDriveItem
 @param subscriptionId key: id of subscription
 @return ApiSharesListUpdateSubscriptionsRequest
*/
func (a *SharesListApiService) SharesListUpdateSubscriptions(ctx _context.Context, sharedDriveItemId string, subscriptionId string) ApiSharesListUpdateSubscriptionsRequest {
	return ApiSharesListUpdateSubscriptionsRequest{
		ApiService: a,
		ctx: ctx,
		sharedDriveItemId: sharedDriveItemId,
		subscriptionId: subscriptionId,
	}
}

// Execute executes the request
func (a *SharesListApiService) SharesListUpdateSubscriptionsExecute(r ApiSharesListUpdateSubscriptionsRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPatch
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SharesListApiService.SharesListUpdateSubscriptions")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/shares/{sharedDriveItem-id}/list/subscriptions/{subscription-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"sharedDriveItem-id"+"}", _neturl.PathEscape(parameterToString(r.sharedDriveItemId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"subscription-id"+"}", _neturl.PathEscape(parameterToString(r.subscriptionId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphSubscription == nil {
		return nil, reportError("microsoftGraphSubscription is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphSubscription
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiSharesUpdateListRequest struct {
	ctx _context.Context
	ApiService *SharesListApiService
	sharedDriveItemId string
	microsoftGraphList *MicrosoftGraphList
}

// New navigation property values
func (r ApiSharesUpdateListRequest) MicrosoftGraphList(microsoftGraphList MicrosoftGraphList) ApiSharesUpdateListRequest {
	r.microsoftGraphList = &microsoftGraphList
	return r
}

func (r ApiSharesUpdateListRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.SharesUpdateListExecute(r)
}

/*
SharesUpdateList Update the navigation property list in shares

Used to access the underlying list

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param sharedDriveItemId key: id of sharedDriveItem
 @return ApiSharesUpdateListRequest
*/
func (a *SharesListApiService) SharesUpdateList(ctx _context.Context, sharedDriveItemId string) ApiSharesUpdateListRequest {
	return ApiSharesUpdateListRequest{
		ApiService: a,
		ctx: ctx,
		sharedDriveItemId: sharedDriveItemId,
	}
}

// Execute executes the request
func (a *SharesListApiService) SharesUpdateListExecute(r ApiSharesUpdateListRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPatch
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SharesListApiService.SharesUpdateList")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/shares/{sharedDriveItem-id}/list"
	localVarPath = strings.Replace(localVarPath, "{"+"sharedDriveItem-id"+"}", _neturl.PathEscape(parameterToString(r.sharedDriveItemId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphList == nil {
		return nil, reportError("microsoftGraphList is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphList
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}
