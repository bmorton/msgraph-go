/*
Partial Graph API

No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

API version: v1.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package msgraph

import (
	"bytes"
	_context "context"
	_ioutil "io/ioutil"
	_nethttp "net/http"
	_neturl "net/url"
	"strings"
)

// Linger please
var (
	_ _context.Context
)

// GroupsDirectoryObjectApiService GroupsDirectoryObjectApi service
type GroupsDirectoryObjectApiService service

type ApiGroupsCreateRefAcceptedSendersRequest struct {
	ctx _context.Context
	ApiService *GroupsDirectoryObjectApiService
	groupId string
	requestBody *map[string]map[string]interface{}
}

// New navigation property ref value
func (r ApiGroupsCreateRefAcceptedSendersRequest) RequestBody(requestBody map[string]map[string]interface{}) ApiGroupsCreateRefAcceptedSendersRequest {
	r.requestBody = &requestBody
	return r
}

func (r ApiGroupsCreateRefAcceptedSendersRequest) Execute() (map[string]interface{}, *_nethttp.Response, error) {
	return r.ApiService.GroupsCreateRefAcceptedSendersExecute(r)
}

/*
GroupsCreateRefAcceptedSenders Create new navigation property ref to acceptedSenders for groups

The list of users or groups that are allowed to create post's or calendar events in this group. If this list is non-empty then only users or groups listed here are allowed to post.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupId key: id of group
 @return ApiGroupsCreateRefAcceptedSendersRequest
*/
func (a *GroupsDirectoryObjectApiService) GroupsCreateRefAcceptedSenders(ctx _context.Context, groupId string) ApiGroupsCreateRefAcceptedSendersRequest {
	return ApiGroupsCreateRefAcceptedSendersRequest{
		ApiService: a,
		ctx: ctx,
		groupId: groupId,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *GroupsDirectoryObjectApiService) GroupsCreateRefAcceptedSendersExecute(r ApiGroupsCreateRefAcceptedSendersRequest) (map[string]interface{}, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GroupsDirectoryObjectApiService.GroupsCreateRefAcceptedSenders")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/groups/{group-id}/acceptedSenders/$ref"
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.requestBody == nil {
		return localVarReturnValue, nil, reportError("requestBody is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.requestBody
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGroupsCreateRefMemberOfRequest struct {
	ctx _context.Context
	ApiService *GroupsDirectoryObjectApiService
	groupId string
	requestBody *map[string]map[string]interface{}
}

// New navigation property ref value
func (r ApiGroupsCreateRefMemberOfRequest) RequestBody(requestBody map[string]map[string]interface{}) ApiGroupsCreateRefMemberOfRequest {
	r.requestBody = &requestBody
	return r
}

func (r ApiGroupsCreateRefMemberOfRequest) Execute() (map[string]interface{}, *_nethttp.Response, error) {
	return r.ApiService.GroupsCreateRefMemberOfExecute(r)
}

/*
GroupsCreateRefMemberOf Create new navigation property ref to memberOf for groups

Groups that this group is a member of. HTTP Methods: GET (supported for all groups). Read-only. Nullable. Supports $expand.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupId key: id of group
 @return ApiGroupsCreateRefMemberOfRequest
*/
func (a *GroupsDirectoryObjectApiService) GroupsCreateRefMemberOf(ctx _context.Context, groupId string) ApiGroupsCreateRefMemberOfRequest {
	return ApiGroupsCreateRefMemberOfRequest{
		ApiService: a,
		ctx: ctx,
		groupId: groupId,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *GroupsDirectoryObjectApiService) GroupsCreateRefMemberOfExecute(r ApiGroupsCreateRefMemberOfRequest) (map[string]interface{}, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GroupsDirectoryObjectApiService.GroupsCreateRefMemberOf")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/groups/{group-id}/memberOf/$ref"
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.requestBody == nil {
		return localVarReturnValue, nil, reportError("requestBody is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.requestBody
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGroupsCreateRefMembersRequest struct {
	ctx _context.Context
	ApiService *GroupsDirectoryObjectApiService
	groupId string
	requestBody *map[string]map[string]interface{}
}

// New navigation property ref value
func (r ApiGroupsCreateRefMembersRequest) RequestBody(requestBody map[string]map[string]interface{}) ApiGroupsCreateRefMembersRequest {
	r.requestBody = &requestBody
	return r
}

func (r ApiGroupsCreateRefMembersRequest) Execute() (map[string]interface{}, *_nethttp.Response, error) {
	return r.ApiService.GroupsCreateRefMembersExecute(r)
}

/*
GroupsCreateRefMembers Create new navigation property ref to members for groups

Users and groups that are members of this group. HTTP Methods: GET (supported for all groups), POST (supported for Microsoft 365 groups, security groups and mail-enabled security groups), DELETE (supported for Microsoft 365 groups and security groups). Nullable. Supports $expand.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupId key: id of group
 @return ApiGroupsCreateRefMembersRequest
*/
func (a *GroupsDirectoryObjectApiService) GroupsCreateRefMembers(ctx _context.Context, groupId string) ApiGroupsCreateRefMembersRequest {
	return ApiGroupsCreateRefMembersRequest{
		ApiService: a,
		ctx: ctx,
		groupId: groupId,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *GroupsDirectoryObjectApiService) GroupsCreateRefMembersExecute(r ApiGroupsCreateRefMembersRequest) (map[string]interface{}, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GroupsDirectoryObjectApiService.GroupsCreateRefMembers")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/groups/{group-id}/members/$ref"
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.requestBody == nil {
		return localVarReturnValue, nil, reportError("requestBody is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.requestBody
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGroupsCreateRefMembersWithLicenseErrorsRequest struct {
	ctx _context.Context
	ApiService *GroupsDirectoryObjectApiService
	groupId string
	requestBody *map[string]map[string]interface{}
}

// New navigation property ref value
func (r ApiGroupsCreateRefMembersWithLicenseErrorsRequest) RequestBody(requestBody map[string]map[string]interface{}) ApiGroupsCreateRefMembersWithLicenseErrorsRequest {
	r.requestBody = &requestBody
	return r
}

func (r ApiGroupsCreateRefMembersWithLicenseErrorsRequest) Execute() (map[string]interface{}, *_nethttp.Response, error) {
	return r.ApiService.GroupsCreateRefMembersWithLicenseErrorsExecute(r)
}

/*
GroupsCreateRefMembersWithLicenseErrors Create new navigation property ref to membersWithLicenseErrors for groups

A list of group members with license errors from this group-based license assignment. Read-only.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupId key: id of group
 @return ApiGroupsCreateRefMembersWithLicenseErrorsRequest
*/
func (a *GroupsDirectoryObjectApiService) GroupsCreateRefMembersWithLicenseErrors(ctx _context.Context, groupId string) ApiGroupsCreateRefMembersWithLicenseErrorsRequest {
	return ApiGroupsCreateRefMembersWithLicenseErrorsRequest{
		ApiService: a,
		ctx: ctx,
		groupId: groupId,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *GroupsDirectoryObjectApiService) GroupsCreateRefMembersWithLicenseErrorsExecute(r ApiGroupsCreateRefMembersWithLicenseErrorsRequest) (map[string]interface{}, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GroupsDirectoryObjectApiService.GroupsCreateRefMembersWithLicenseErrors")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/groups/{group-id}/membersWithLicenseErrors/$ref"
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.requestBody == nil {
		return localVarReturnValue, nil, reportError("requestBody is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.requestBody
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGroupsCreateRefOwnersRequest struct {
	ctx _context.Context
	ApiService *GroupsDirectoryObjectApiService
	groupId string
	requestBody *map[string]map[string]interface{}
}

// New navigation property ref value
func (r ApiGroupsCreateRefOwnersRequest) RequestBody(requestBody map[string]map[string]interface{}) ApiGroupsCreateRefOwnersRequest {
	r.requestBody = &requestBody
	return r
}

func (r ApiGroupsCreateRefOwnersRequest) Execute() (map[string]interface{}, *_nethttp.Response, error) {
	return r.ApiService.GroupsCreateRefOwnersExecute(r)
}

/*
GroupsCreateRefOwners Create new navigation property ref to owners for groups

The owners of the group. The owners are a set of non-admin users who are allowed to modify this object. Limited to 100 owners. Nullable. If this property is not specified when creating a Microsoft 365 group, the calling user is automatically assigned as the group owner. Supports $expand.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupId key: id of group
 @return ApiGroupsCreateRefOwnersRequest
*/
func (a *GroupsDirectoryObjectApiService) GroupsCreateRefOwners(ctx _context.Context, groupId string) ApiGroupsCreateRefOwnersRequest {
	return ApiGroupsCreateRefOwnersRequest{
		ApiService: a,
		ctx: ctx,
		groupId: groupId,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *GroupsDirectoryObjectApiService) GroupsCreateRefOwnersExecute(r ApiGroupsCreateRefOwnersRequest) (map[string]interface{}, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GroupsDirectoryObjectApiService.GroupsCreateRefOwners")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/groups/{group-id}/owners/$ref"
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.requestBody == nil {
		return localVarReturnValue, nil, reportError("requestBody is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.requestBody
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGroupsCreateRefRejectedSendersRequest struct {
	ctx _context.Context
	ApiService *GroupsDirectoryObjectApiService
	groupId string
	requestBody *map[string]map[string]interface{}
}

// New navigation property ref value
func (r ApiGroupsCreateRefRejectedSendersRequest) RequestBody(requestBody map[string]map[string]interface{}) ApiGroupsCreateRefRejectedSendersRequest {
	r.requestBody = &requestBody
	return r
}

func (r ApiGroupsCreateRefRejectedSendersRequest) Execute() (map[string]interface{}, *_nethttp.Response, error) {
	return r.ApiService.GroupsCreateRefRejectedSendersExecute(r)
}

/*
GroupsCreateRefRejectedSenders Create new navigation property ref to rejectedSenders for groups

The list of users or groups that are not allowed to create posts or calendar events in this group. Nullable

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupId key: id of group
 @return ApiGroupsCreateRefRejectedSendersRequest
*/
func (a *GroupsDirectoryObjectApiService) GroupsCreateRefRejectedSenders(ctx _context.Context, groupId string) ApiGroupsCreateRefRejectedSendersRequest {
	return ApiGroupsCreateRefRejectedSendersRequest{
		ApiService: a,
		ctx: ctx,
		groupId: groupId,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *GroupsDirectoryObjectApiService) GroupsCreateRefRejectedSendersExecute(r ApiGroupsCreateRefRejectedSendersRequest) (map[string]interface{}, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GroupsDirectoryObjectApiService.GroupsCreateRefRejectedSenders")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/groups/{group-id}/rejectedSenders/$ref"
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.requestBody == nil {
		return localVarReturnValue, nil, reportError("requestBody is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.requestBody
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGroupsCreateRefTransitiveMemberOfRequest struct {
	ctx _context.Context
	ApiService *GroupsDirectoryObjectApiService
	groupId string
	requestBody *map[string]map[string]interface{}
}

// New navigation property ref value
func (r ApiGroupsCreateRefTransitiveMemberOfRequest) RequestBody(requestBody map[string]map[string]interface{}) ApiGroupsCreateRefTransitiveMemberOfRequest {
	r.requestBody = &requestBody
	return r
}

func (r ApiGroupsCreateRefTransitiveMemberOfRequest) Execute() (map[string]interface{}, *_nethttp.Response, error) {
	return r.ApiService.GroupsCreateRefTransitiveMemberOfExecute(r)
}

/*
GroupsCreateRefTransitiveMemberOf Create new navigation property ref to transitiveMemberOf for groups

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupId key: id of group
 @return ApiGroupsCreateRefTransitiveMemberOfRequest
*/
func (a *GroupsDirectoryObjectApiService) GroupsCreateRefTransitiveMemberOf(ctx _context.Context, groupId string) ApiGroupsCreateRefTransitiveMemberOfRequest {
	return ApiGroupsCreateRefTransitiveMemberOfRequest{
		ApiService: a,
		ctx: ctx,
		groupId: groupId,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *GroupsDirectoryObjectApiService) GroupsCreateRefTransitiveMemberOfExecute(r ApiGroupsCreateRefTransitiveMemberOfRequest) (map[string]interface{}, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GroupsDirectoryObjectApiService.GroupsCreateRefTransitiveMemberOf")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/groups/{group-id}/transitiveMemberOf/$ref"
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.requestBody == nil {
		return localVarReturnValue, nil, reportError("requestBody is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.requestBody
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGroupsCreateRefTransitiveMembersRequest struct {
	ctx _context.Context
	ApiService *GroupsDirectoryObjectApiService
	groupId string
	requestBody *map[string]map[string]interface{}
}

// New navigation property ref value
func (r ApiGroupsCreateRefTransitiveMembersRequest) RequestBody(requestBody map[string]map[string]interface{}) ApiGroupsCreateRefTransitiveMembersRequest {
	r.requestBody = &requestBody
	return r
}

func (r ApiGroupsCreateRefTransitiveMembersRequest) Execute() (map[string]interface{}, *_nethttp.Response, error) {
	return r.ApiService.GroupsCreateRefTransitiveMembersExecute(r)
}

/*
GroupsCreateRefTransitiveMembers Create new navigation property ref to transitiveMembers for groups

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupId key: id of group
 @return ApiGroupsCreateRefTransitiveMembersRequest
*/
func (a *GroupsDirectoryObjectApiService) GroupsCreateRefTransitiveMembers(ctx _context.Context, groupId string) ApiGroupsCreateRefTransitiveMembersRequest {
	return ApiGroupsCreateRefTransitiveMembersRequest{
		ApiService: a,
		ctx: ctx,
		groupId: groupId,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *GroupsDirectoryObjectApiService) GroupsCreateRefTransitiveMembersExecute(r ApiGroupsCreateRefTransitiveMembersRequest) (map[string]interface{}, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GroupsDirectoryObjectApiService.GroupsCreateRefTransitiveMembers")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/groups/{group-id}/transitiveMembers/$ref"
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.requestBody == nil {
		return localVarReturnValue, nil, reportError("requestBody is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.requestBody
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGroupsDeleteRefCreatedOnBehalfOfRequest struct {
	ctx _context.Context
	ApiService *GroupsDirectoryObjectApiService
	groupId string
	ifMatch *string
}

// ETag
func (r ApiGroupsDeleteRefCreatedOnBehalfOfRequest) IfMatch(ifMatch string) ApiGroupsDeleteRefCreatedOnBehalfOfRequest {
	r.ifMatch = &ifMatch
	return r
}

func (r ApiGroupsDeleteRefCreatedOnBehalfOfRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.GroupsDeleteRefCreatedOnBehalfOfExecute(r)
}

/*
GroupsDeleteRefCreatedOnBehalfOf Delete ref of navigation property createdOnBehalfOf for groups

The user (or application) that created the group. NOTE: This is not set if the user is an administrator. Read-only.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupId key: id of group
 @return ApiGroupsDeleteRefCreatedOnBehalfOfRequest
*/
func (a *GroupsDirectoryObjectApiService) GroupsDeleteRefCreatedOnBehalfOf(ctx _context.Context, groupId string) ApiGroupsDeleteRefCreatedOnBehalfOfRequest {
	return ApiGroupsDeleteRefCreatedOnBehalfOfRequest{
		ApiService: a,
		ctx: ctx,
		groupId: groupId,
	}
}

// Execute executes the request
func (a *GroupsDirectoryObjectApiService) GroupsDeleteRefCreatedOnBehalfOfExecute(r ApiGroupsDeleteRefCreatedOnBehalfOfRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GroupsDirectoryObjectApiService.GroupsDeleteRefCreatedOnBehalfOf")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/groups/{group-id}/createdOnBehalfOf/$ref"
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ifMatch != nil {
		localVarHeaderParams["If-Match"] = parameterToString(*r.ifMatch, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGroupsGetCreatedOnBehalfOfRequest struct {
	ctx _context.Context
	ApiService *GroupsDirectoryObjectApiService
	groupId string
	select_ *[]string
	expand *[]string
}

// Select properties to be returned
func (r ApiGroupsGetCreatedOnBehalfOfRequest) Select_(select_ []string) ApiGroupsGetCreatedOnBehalfOfRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiGroupsGetCreatedOnBehalfOfRequest) Expand(expand []string) ApiGroupsGetCreatedOnBehalfOfRequest {
	r.expand = &expand
	return r
}

func (r ApiGroupsGetCreatedOnBehalfOfRequest) Execute() (MicrosoftGraphDirectoryObject, *_nethttp.Response, error) {
	return r.ApiService.GroupsGetCreatedOnBehalfOfExecute(r)
}

/*
GroupsGetCreatedOnBehalfOf Get createdOnBehalfOf from groups

The user (or application) that created the group. NOTE: This is not set if the user is an administrator. Read-only.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupId key: id of group
 @return ApiGroupsGetCreatedOnBehalfOfRequest
*/
func (a *GroupsDirectoryObjectApiService) GroupsGetCreatedOnBehalfOf(ctx _context.Context, groupId string) ApiGroupsGetCreatedOnBehalfOfRequest {
	return ApiGroupsGetCreatedOnBehalfOfRequest{
		ApiService: a,
		ctx: ctx,
		groupId: groupId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphDirectoryObject
func (a *GroupsDirectoryObjectApiService) GroupsGetCreatedOnBehalfOfExecute(r ApiGroupsGetCreatedOnBehalfOfRequest) (MicrosoftGraphDirectoryObject, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphDirectoryObject
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GroupsDirectoryObjectApiService.GroupsGetCreatedOnBehalfOf")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/groups/{group-id}/createdOnBehalfOf"
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGroupsGetRefCreatedOnBehalfOfRequest struct {
	ctx _context.Context
	ApiService *GroupsDirectoryObjectApiService
	groupId string
}


func (r ApiGroupsGetRefCreatedOnBehalfOfRequest) Execute() (string, *_nethttp.Response, error) {
	return r.ApiService.GroupsGetRefCreatedOnBehalfOfExecute(r)
}

/*
GroupsGetRefCreatedOnBehalfOf Get ref of createdOnBehalfOf from groups

The user (or application) that created the group. NOTE: This is not set if the user is an administrator. Read-only.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupId key: id of group
 @return ApiGroupsGetRefCreatedOnBehalfOfRequest
*/
func (a *GroupsDirectoryObjectApiService) GroupsGetRefCreatedOnBehalfOf(ctx _context.Context, groupId string) ApiGroupsGetRefCreatedOnBehalfOfRequest {
	return ApiGroupsGetRefCreatedOnBehalfOfRequest{
		ApiService: a,
		ctx: ctx,
		groupId: groupId,
	}
}

// Execute executes the request
//  @return string
func (a *GroupsDirectoryObjectApiService) GroupsGetRefCreatedOnBehalfOfExecute(r ApiGroupsGetRefCreatedOnBehalfOfRequest) (string, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  string
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GroupsDirectoryObjectApiService.GroupsGetRefCreatedOnBehalfOf")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/groups/{group-id}/createdOnBehalfOf/$ref"
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGroupsListAcceptedSendersRequest struct {
	ctx _context.Context
	ApiService *GroupsDirectoryObjectApiService
	groupId string
	top *int32
	skip *int32
	filter *string
	count *bool
	orderby *[]string
	select_ *[]string
}

// Show only the first n items
func (r ApiGroupsListAcceptedSendersRequest) Top(top int32) ApiGroupsListAcceptedSendersRequest {
	r.top = &top
	return r
}
// Skip the first n items
func (r ApiGroupsListAcceptedSendersRequest) Skip(skip int32) ApiGroupsListAcceptedSendersRequest {
	r.skip = &skip
	return r
}
// Filter items by property values
func (r ApiGroupsListAcceptedSendersRequest) Filter(filter string) ApiGroupsListAcceptedSendersRequest {
	r.filter = &filter
	return r
}
// Include count of items
func (r ApiGroupsListAcceptedSendersRequest) Count(count bool) ApiGroupsListAcceptedSendersRequest {
	r.count = &count
	return r
}
// Order items by property values
func (r ApiGroupsListAcceptedSendersRequest) Orderby(orderby []string) ApiGroupsListAcceptedSendersRequest {
	r.orderby = &orderby
	return r
}
// Select properties to be returned
func (r ApiGroupsListAcceptedSendersRequest) Select_(select_ []string) ApiGroupsListAcceptedSendersRequest {
	r.select_ = &select_
	return r
}

func (r ApiGroupsListAcceptedSendersRequest) Execute() (CollectionOfDirectoryObject, *_nethttp.Response, error) {
	return r.ApiService.GroupsListAcceptedSendersExecute(r)
}

/*
GroupsListAcceptedSenders Get acceptedSenders from groups

The list of users or groups that are allowed to create post's or calendar events in this group. If this list is non-empty then only users or groups listed here are allowed to post.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupId key: id of group
 @return ApiGroupsListAcceptedSendersRequest
*/
func (a *GroupsDirectoryObjectApiService) GroupsListAcceptedSenders(ctx _context.Context, groupId string) ApiGroupsListAcceptedSendersRequest {
	return ApiGroupsListAcceptedSendersRequest{
		ApiService: a,
		ctx: ctx,
		groupId: groupId,
	}
}

// Execute executes the request
//  @return CollectionOfDirectoryObject
func (a *GroupsDirectoryObjectApiService) GroupsListAcceptedSendersExecute(r ApiGroupsListAcceptedSendersRequest) (CollectionOfDirectoryObject, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  CollectionOfDirectoryObject
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GroupsDirectoryObjectApiService.GroupsListAcceptedSenders")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/groups/{group-id}/acceptedSenders"
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.top != nil {
		localVarQueryParams.Add("$top", parameterToString(*r.top, ""))
	}
	if r.skip != nil {
		localVarQueryParams.Add("$skip", parameterToString(*r.skip, ""))
	}
	if r.filter != nil {
		localVarQueryParams.Add("$filter", parameterToString(*r.filter, ""))
	}
	if r.count != nil {
		localVarQueryParams.Add("$count", parameterToString(*r.count, ""))
	}
	if r.orderby != nil {
		localVarQueryParams.Add("$orderby", parameterToString(*r.orderby, "csv"))
	}
	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGroupsListMemberOfRequest struct {
	ctx _context.Context
	ApiService *GroupsDirectoryObjectApiService
	groupId string
	top *int32
	skip *int32
	search *string
	filter *string
	count *bool
	orderby *[]string
	select_ *[]string
	expand *[]string
}

// Show only the first n items
func (r ApiGroupsListMemberOfRequest) Top(top int32) ApiGroupsListMemberOfRequest {
	r.top = &top
	return r
}
// Skip the first n items
func (r ApiGroupsListMemberOfRequest) Skip(skip int32) ApiGroupsListMemberOfRequest {
	r.skip = &skip
	return r
}
// Search items by search phrases
func (r ApiGroupsListMemberOfRequest) Search(search string) ApiGroupsListMemberOfRequest {
	r.search = &search
	return r
}
// Filter items by property values
func (r ApiGroupsListMemberOfRequest) Filter(filter string) ApiGroupsListMemberOfRequest {
	r.filter = &filter
	return r
}
// Include count of items
func (r ApiGroupsListMemberOfRequest) Count(count bool) ApiGroupsListMemberOfRequest {
	r.count = &count
	return r
}
// Order items by property values
func (r ApiGroupsListMemberOfRequest) Orderby(orderby []string) ApiGroupsListMemberOfRequest {
	r.orderby = &orderby
	return r
}
// Select properties to be returned
func (r ApiGroupsListMemberOfRequest) Select_(select_ []string) ApiGroupsListMemberOfRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiGroupsListMemberOfRequest) Expand(expand []string) ApiGroupsListMemberOfRequest {
	r.expand = &expand
	return r
}

func (r ApiGroupsListMemberOfRequest) Execute() (CollectionOfDirectoryObject, *_nethttp.Response, error) {
	return r.ApiService.GroupsListMemberOfExecute(r)
}

/*
GroupsListMemberOf Get memberOf from groups

Groups that this group is a member of. HTTP Methods: GET (supported for all groups). Read-only. Nullable. Supports $expand.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupId key: id of group
 @return ApiGroupsListMemberOfRequest
*/
func (a *GroupsDirectoryObjectApiService) GroupsListMemberOf(ctx _context.Context, groupId string) ApiGroupsListMemberOfRequest {
	return ApiGroupsListMemberOfRequest{
		ApiService: a,
		ctx: ctx,
		groupId: groupId,
	}
}

// Execute executes the request
//  @return CollectionOfDirectoryObject
func (a *GroupsDirectoryObjectApiService) GroupsListMemberOfExecute(r ApiGroupsListMemberOfRequest) (CollectionOfDirectoryObject, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  CollectionOfDirectoryObject
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GroupsDirectoryObjectApiService.GroupsListMemberOf")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/groups/{group-id}/memberOf"
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.top != nil {
		localVarQueryParams.Add("$top", parameterToString(*r.top, ""))
	}
	if r.skip != nil {
		localVarQueryParams.Add("$skip", parameterToString(*r.skip, ""))
	}
	if r.search != nil {
		localVarQueryParams.Add("$search", parameterToString(*r.search, ""))
	}
	if r.filter != nil {
		localVarQueryParams.Add("$filter", parameterToString(*r.filter, ""))
	}
	if r.count != nil {
		localVarQueryParams.Add("$count", parameterToString(*r.count, ""))
	}
	if r.orderby != nil {
		localVarQueryParams.Add("$orderby", parameterToString(*r.orderby, "csv"))
	}
	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGroupsListMembersRequest struct {
	ctx _context.Context
	ApiService *GroupsDirectoryObjectApiService
	groupId string
	top *int32
	skip *int32
	search *string
	filter *string
	count *bool
	orderby *[]string
	select_ *[]string
	expand *[]string
}

// Show only the first n items
func (r ApiGroupsListMembersRequest) Top(top int32) ApiGroupsListMembersRequest {
	r.top = &top
	return r
}
// Skip the first n items
func (r ApiGroupsListMembersRequest) Skip(skip int32) ApiGroupsListMembersRequest {
	r.skip = &skip
	return r
}
// Search items by search phrases
func (r ApiGroupsListMembersRequest) Search(search string) ApiGroupsListMembersRequest {
	r.search = &search
	return r
}
// Filter items by property values
func (r ApiGroupsListMembersRequest) Filter(filter string) ApiGroupsListMembersRequest {
	r.filter = &filter
	return r
}
// Include count of items
func (r ApiGroupsListMembersRequest) Count(count bool) ApiGroupsListMembersRequest {
	r.count = &count
	return r
}
// Order items by property values
func (r ApiGroupsListMembersRequest) Orderby(orderby []string) ApiGroupsListMembersRequest {
	r.orderby = &orderby
	return r
}
// Select properties to be returned
func (r ApiGroupsListMembersRequest) Select_(select_ []string) ApiGroupsListMembersRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiGroupsListMembersRequest) Expand(expand []string) ApiGroupsListMembersRequest {
	r.expand = &expand
	return r
}

func (r ApiGroupsListMembersRequest) Execute() (CollectionOfDirectoryObject, *_nethttp.Response, error) {
	return r.ApiService.GroupsListMembersExecute(r)
}

/*
GroupsListMembers Get members from groups

Users and groups that are members of this group. HTTP Methods: GET (supported for all groups), POST (supported for Microsoft 365 groups, security groups and mail-enabled security groups), DELETE (supported for Microsoft 365 groups and security groups). Nullable. Supports $expand.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupId key: id of group
 @return ApiGroupsListMembersRequest
*/
func (a *GroupsDirectoryObjectApiService) GroupsListMembers(ctx _context.Context, groupId string) ApiGroupsListMembersRequest {
	return ApiGroupsListMembersRequest{
		ApiService: a,
		ctx: ctx,
		groupId: groupId,
	}
}

// Execute executes the request
//  @return CollectionOfDirectoryObject
func (a *GroupsDirectoryObjectApiService) GroupsListMembersExecute(r ApiGroupsListMembersRequest) (CollectionOfDirectoryObject, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  CollectionOfDirectoryObject
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GroupsDirectoryObjectApiService.GroupsListMembers")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/groups/{group-id}/members"
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.top != nil {
		localVarQueryParams.Add("$top", parameterToString(*r.top, ""))
	}
	if r.skip != nil {
		localVarQueryParams.Add("$skip", parameterToString(*r.skip, ""))
	}
	if r.search != nil {
		localVarQueryParams.Add("$search", parameterToString(*r.search, ""))
	}
	if r.filter != nil {
		localVarQueryParams.Add("$filter", parameterToString(*r.filter, ""))
	}
	if r.count != nil {
		localVarQueryParams.Add("$count", parameterToString(*r.count, ""))
	}
	if r.orderby != nil {
		localVarQueryParams.Add("$orderby", parameterToString(*r.orderby, "csv"))
	}
	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGroupsListMembersWithLicenseErrorsRequest struct {
	ctx _context.Context
	ApiService *GroupsDirectoryObjectApiService
	groupId string
	top *int32
	skip *int32
	search *string
	filter *string
	count *bool
	orderby *[]string
	select_ *[]string
	expand *[]string
}

// Show only the first n items
func (r ApiGroupsListMembersWithLicenseErrorsRequest) Top(top int32) ApiGroupsListMembersWithLicenseErrorsRequest {
	r.top = &top
	return r
}
// Skip the first n items
func (r ApiGroupsListMembersWithLicenseErrorsRequest) Skip(skip int32) ApiGroupsListMembersWithLicenseErrorsRequest {
	r.skip = &skip
	return r
}
// Search items by search phrases
func (r ApiGroupsListMembersWithLicenseErrorsRequest) Search(search string) ApiGroupsListMembersWithLicenseErrorsRequest {
	r.search = &search
	return r
}
// Filter items by property values
func (r ApiGroupsListMembersWithLicenseErrorsRequest) Filter(filter string) ApiGroupsListMembersWithLicenseErrorsRequest {
	r.filter = &filter
	return r
}
// Include count of items
func (r ApiGroupsListMembersWithLicenseErrorsRequest) Count(count bool) ApiGroupsListMembersWithLicenseErrorsRequest {
	r.count = &count
	return r
}
// Order items by property values
func (r ApiGroupsListMembersWithLicenseErrorsRequest) Orderby(orderby []string) ApiGroupsListMembersWithLicenseErrorsRequest {
	r.orderby = &orderby
	return r
}
// Select properties to be returned
func (r ApiGroupsListMembersWithLicenseErrorsRequest) Select_(select_ []string) ApiGroupsListMembersWithLicenseErrorsRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiGroupsListMembersWithLicenseErrorsRequest) Expand(expand []string) ApiGroupsListMembersWithLicenseErrorsRequest {
	r.expand = &expand
	return r
}

func (r ApiGroupsListMembersWithLicenseErrorsRequest) Execute() (CollectionOfDirectoryObject, *_nethttp.Response, error) {
	return r.ApiService.GroupsListMembersWithLicenseErrorsExecute(r)
}

/*
GroupsListMembersWithLicenseErrors Get membersWithLicenseErrors from groups

A list of group members with license errors from this group-based license assignment. Read-only.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupId key: id of group
 @return ApiGroupsListMembersWithLicenseErrorsRequest
*/
func (a *GroupsDirectoryObjectApiService) GroupsListMembersWithLicenseErrors(ctx _context.Context, groupId string) ApiGroupsListMembersWithLicenseErrorsRequest {
	return ApiGroupsListMembersWithLicenseErrorsRequest{
		ApiService: a,
		ctx: ctx,
		groupId: groupId,
	}
}

// Execute executes the request
//  @return CollectionOfDirectoryObject
func (a *GroupsDirectoryObjectApiService) GroupsListMembersWithLicenseErrorsExecute(r ApiGroupsListMembersWithLicenseErrorsRequest) (CollectionOfDirectoryObject, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  CollectionOfDirectoryObject
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GroupsDirectoryObjectApiService.GroupsListMembersWithLicenseErrors")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/groups/{group-id}/membersWithLicenseErrors"
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.top != nil {
		localVarQueryParams.Add("$top", parameterToString(*r.top, ""))
	}
	if r.skip != nil {
		localVarQueryParams.Add("$skip", parameterToString(*r.skip, ""))
	}
	if r.search != nil {
		localVarQueryParams.Add("$search", parameterToString(*r.search, ""))
	}
	if r.filter != nil {
		localVarQueryParams.Add("$filter", parameterToString(*r.filter, ""))
	}
	if r.count != nil {
		localVarQueryParams.Add("$count", parameterToString(*r.count, ""))
	}
	if r.orderby != nil {
		localVarQueryParams.Add("$orderby", parameterToString(*r.orderby, "csv"))
	}
	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGroupsListOwnersRequest struct {
	ctx _context.Context
	ApiService *GroupsDirectoryObjectApiService
	groupId string
	top *int32
	skip *int32
	search *string
	filter *string
	count *bool
	orderby *[]string
	select_ *[]string
	expand *[]string
}

// Show only the first n items
func (r ApiGroupsListOwnersRequest) Top(top int32) ApiGroupsListOwnersRequest {
	r.top = &top
	return r
}
// Skip the first n items
func (r ApiGroupsListOwnersRequest) Skip(skip int32) ApiGroupsListOwnersRequest {
	r.skip = &skip
	return r
}
// Search items by search phrases
func (r ApiGroupsListOwnersRequest) Search(search string) ApiGroupsListOwnersRequest {
	r.search = &search
	return r
}
// Filter items by property values
func (r ApiGroupsListOwnersRequest) Filter(filter string) ApiGroupsListOwnersRequest {
	r.filter = &filter
	return r
}
// Include count of items
func (r ApiGroupsListOwnersRequest) Count(count bool) ApiGroupsListOwnersRequest {
	r.count = &count
	return r
}
// Order items by property values
func (r ApiGroupsListOwnersRequest) Orderby(orderby []string) ApiGroupsListOwnersRequest {
	r.orderby = &orderby
	return r
}
// Select properties to be returned
func (r ApiGroupsListOwnersRequest) Select_(select_ []string) ApiGroupsListOwnersRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiGroupsListOwnersRequest) Expand(expand []string) ApiGroupsListOwnersRequest {
	r.expand = &expand
	return r
}

func (r ApiGroupsListOwnersRequest) Execute() (CollectionOfDirectoryObject, *_nethttp.Response, error) {
	return r.ApiService.GroupsListOwnersExecute(r)
}

/*
GroupsListOwners Get owners from groups

The owners of the group. The owners are a set of non-admin users who are allowed to modify this object. Limited to 100 owners. Nullable. If this property is not specified when creating a Microsoft 365 group, the calling user is automatically assigned as the group owner. Supports $expand.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupId key: id of group
 @return ApiGroupsListOwnersRequest
*/
func (a *GroupsDirectoryObjectApiService) GroupsListOwners(ctx _context.Context, groupId string) ApiGroupsListOwnersRequest {
	return ApiGroupsListOwnersRequest{
		ApiService: a,
		ctx: ctx,
		groupId: groupId,
	}
}

// Execute executes the request
//  @return CollectionOfDirectoryObject
func (a *GroupsDirectoryObjectApiService) GroupsListOwnersExecute(r ApiGroupsListOwnersRequest) (CollectionOfDirectoryObject, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  CollectionOfDirectoryObject
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GroupsDirectoryObjectApiService.GroupsListOwners")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/groups/{group-id}/owners"
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.top != nil {
		localVarQueryParams.Add("$top", parameterToString(*r.top, ""))
	}
	if r.skip != nil {
		localVarQueryParams.Add("$skip", parameterToString(*r.skip, ""))
	}
	if r.search != nil {
		localVarQueryParams.Add("$search", parameterToString(*r.search, ""))
	}
	if r.filter != nil {
		localVarQueryParams.Add("$filter", parameterToString(*r.filter, ""))
	}
	if r.count != nil {
		localVarQueryParams.Add("$count", parameterToString(*r.count, ""))
	}
	if r.orderby != nil {
		localVarQueryParams.Add("$orderby", parameterToString(*r.orderby, "csv"))
	}
	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGroupsListRefAcceptedSendersRequest struct {
	ctx _context.Context
	ApiService *GroupsDirectoryObjectApiService
	groupId string
	top *int32
	skip *int32
	filter *string
	count *bool
	orderby *[]string
}

// Show only the first n items
func (r ApiGroupsListRefAcceptedSendersRequest) Top(top int32) ApiGroupsListRefAcceptedSendersRequest {
	r.top = &top
	return r
}
// Skip the first n items
func (r ApiGroupsListRefAcceptedSendersRequest) Skip(skip int32) ApiGroupsListRefAcceptedSendersRequest {
	r.skip = &skip
	return r
}
// Filter items by property values
func (r ApiGroupsListRefAcceptedSendersRequest) Filter(filter string) ApiGroupsListRefAcceptedSendersRequest {
	r.filter = &filter
	return r
}
// Include count of items
func (r ApiGroupsListRefAcceptedSendersRequest) Count(count bool) ApiGroupsListRefAcceptedSendersRequest {
	r.count = &count
	return r
}
// Order items by property values
func (r ApiGroupsListRefAcceptedSendersRequest) Orderby(orderby []string) ApiGroupsListRefAcceptedSendersRequest {
	r.orderby = &orderby
	return r
}

func (r ApiGroupsListRefAcceptedSendersRequest) Execute() (CollectionOfLinksOfDirectoryObject, *_nethttp.Response, error) {
	return r.ApiService.GroupsListRefAcceptedSendersExecute(r)
}

/*
GroupsListRefAcceptedSenders Get ref of acceptedSenders from groups

The list of users or groups that are allowed to create post's or calendar events in this group. If this list is non-empty then only users or groups listed here are allowed to post.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupId key: id of group
 @return ApiGroupsListRefAcceptedSendersRequest
*/
func (a *GroupsDirectoryObjectApiService) GroupsListRefAcceptedSenders(ctx _context.Context, groupId string) ApiGroupsListRefAcceptedSendersRequest {
	return ApiGroupsListRefAcceptedSendersRequest{
		ApiService: a,
		ctx: ctx,
		groupId: groupId,
	}
}

// Execute executes the request
//  @return CollectionOfLinksOfDirectoryObject
func (a *GroupsDirectoryObjectApiService) GroupsListRefAcceptedSendersExecute(r ApiGroupsListRefAcceptedSendersRequest) (CollectionOfLinksOfDirectoryObject, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  CollectionOfLinksOfDirectoryObject
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GroupsDirectoryObjectApiService.GroupsListRefAcceptedSenders")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/groups/{group-id}/acceptedSenders/$ref"
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.top != nil {
		localVarQueryParams.Add("$top", parameterToString(*r.top, ""))
	}
	if r.skip != nil {
		localVarQueryParams.Add("$skip", parameterToString(*r.skip, ""))
	}
	if r.filter != nil {
		localVarQueryParams.Add("$filter", parameterToString(*r.filter, ""))
	}
	if r.count != nil {
		localVarQueryParams.Add("$count", parameterToString(*r.count, ""))
	}
	if r.orderby != nil {
		localVarQueryParams.Add("$orderby", parameterToString(*r.orderby, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGroupsListRefMemberOfRequest struct {
	ctx _context.Context
	ApiService *GroupsDirectoryObjectApiService
	groupId string
	top *int32
	skip *int32
	search *string
	filter *string
	count *bool
	orderby *[]string
}

// Show only the first n items
func (r ApiGroupsListRefMemberOfRequest) Top(top int32) ApiGroupsListRefMemberOfRequest {
	r.top = &top
	return r
}
// Skip the first n items
func (r ApiGroupsListRefMemberOfRequest) Skip(skip int32) ApiGroupsListRefMemberOfRequest {
	r.skip = &skip
	return r
}
// Search items by search phrases
func (r ApiGroupsListRefMemberOfRequest) Search(search string) ApiGroupsListRefMemberOfRequest {
	r.search = &search
	return r
}
// Filter items by property values
func (r ApiGroupsListRefMemberOfRequest) Filter(filter string) ApiGroupsListRefMemberOfRequest {
	r.filter = &filter
	return r
}
// Include count of items
func (r ApiGroupsListRefMemberOfRequest) Count(count bool) ApiGroupsListRefMemberOfRequest {
	r.count = &count
	return r
}
// Order items by property values
func (r ApiGroupsListRefMemberOfRequest) Orderby(orderby []string) ApiGroupsListRefMemberOfRequest {
	r.orderby = &orderby
	return r
}

func (r ApiGroupsListRefMemberOfRequest) Execute() (CollectionOfLinksOfDirectoryObject, *_nethttp.Response, error) {
	return r.ApiService.GroupsListRefMemberOfExecute(r)
}

/*
GroupsListRefMemberOf Get ref of memberOf from groups

Groups that this group is a member of. HTTP Methods: GET (supported for all groups). Read-only. Nullable. Supports $expand.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupId key: id of group
 @return ApiGroupsListRefMemberOfRequest
*/
func (a *GroupsDirectoryObjectApiService) GroupsListRefMemberOf(ctx _context.Context, groupId string) ApiGroupsListRefMemberOfRequest {
	return ApiGroupsListRefMemberOfRequest{
		ApiService: a,
		ctx: ctx,
		groupId: groupId,
	}
}

// Execute executes the request
//  @return CollectionOfLinksOfDirectoryObject
func (a *GroupsDirectoryObjectApiService) GroupsListRefMemberOfExecute(r ApiGroupsListRefMemberOfRequest) (CollectionOfLinksOfDirectoryObject, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  CollectionOfLinksOfDirectoryObject
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GroupsDirectoryObjectApiService.GroupsListRefMemberOf")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/groups/{group-id}/memberOf/$ref"
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.top != nil {
		localVarQueryParams.Add("$top", parameterToString(*r.top, ""))
	}
	if r.skip != nil {
		localVarQueryParams.Add("$skip", parameterToString(*r.skip, ""))
	}
	if r.search != nil {
		localVarQueryParams.Add("$search", parameterToString(*r.search, ""))
	}
	if r.filter != nil {
		localVarQueryParams.Add("$filter", parameterToString(*r.filter, ""))
	}
	if r.count != nil {
		localVarQueryParams.Add("$count", parameterToString(*r.count, ""))
	}
	if r.orderby != nil {
		localVarQueryParams.Add("$orderby", parameterToString(*r.orderby, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGroupsListRefMembersRequest struct {
	ctx _context.Context
	ApiService *GroupsDirectoryObjectApiService
	groupId string
	top *int32
	skip *int32
	search *string
	filter *string
	count *bool
	orderby *[]string
}

// Show only the first n items
func (r ApiGroupsListRefMembersRequest) Top(top int32) ApiGroupsListRefMembersRequest {
	r.top = &top
	return r
}
// Skip the first n items
func (r ApiGroupsListRefMembersRequest) Skip(skip int32) ApiGroupsListRefMembersRequest {
	r.skip = &skip
	return r
}
// Search items by search phrases
func (r ApiGroupsListRefMembersRequest) Search(search string) ApiGroupsListRefMembersRequest {
	r.search = &search
	return r
}
// Filter items by property values
func (r ApiGroupsListRefMembersRequest) Filter(filter string) ApiGroupsListRefMembersRequest {
	r.filter = &filter
	return r
}
// Include count of items
func (r ApiGroupsListRefMembersRequest) Count(count bool) ApiGroupsListRefMembersRequest {
	r.count = &count
	return r
}
// Order items by property values
func (r ApiGroupsListRefMembersRequest) Orderby(orderby []string) ApiGroupsListRefMembersRequest {
	r.orderby = &orderby
	return r
}

func (r ApiGroupsListRefMembersRequest) Execute() (CollectionOfLinksOfDirectoryObject, *_nethttp.Response, error) {
	return r.ApiService.GroupsListRefMembersExecute(r)
}

/*
GroupsListRefMembers Get ref of members from groups

Users and groups that are members of this group. HTTP Methods: GET (supported for all groups), POST (supported for Microsoft 365 groups, security groups and mail-enabled security groups), DELETE (supported for Microsoft 365 groups and security groups). Nullable. Supports $expand.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupId key: id of group
 @return ApiGroupsListRefMembersRequest
*/
func (a *GroupsDirectoryObjectApiService) GroupsListRefMembers(ctx _context.Context, groupId string) ApiGroupsListRefMembersRequest {
	return ApiGroupsListRefMembersRequest{
		ApiService: a,
		ctx: ctx,
		groupId: groupId,
	}
}

// Execute executes the request
//  @return CollectionOfLinksOfDirectoryObject
func (a *GroupsDirectoryObjectApiService) GroupsListRefMembersExecute(r ApiGroupsListRefMembersRequest) (CollectionOfLinksOfDirectoryObject, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  CollectionOfLinksOfDirectoryObject
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GroupsDirectoryObjectApiService.GroupsListRefMembers")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/groups/{group-id}/members/$ref"
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.top != nil {
		localVarQueryParams.Add("$top", parameterToString(*r.top, ""))
	}
	if r.skip != nil {
		localVarQueryParams.Add("$skip", parameterToString(*r.skip, ""))
	}
	if r.search != nil {
		localVarQueryParams.Add("$search", parameterToString(*r.search, ""))
	}
	if r.filter != nil {
		localVarQueryParams.Add("$filter", parameterToString(*r.filter, ""))
	}
	if r.count != nil {
		localVarQueryParams.Add("$count", parameterToString(*r.count, ""))
	}
	if r.orderby != nil {
		localVarQueryParams.Add("$orderby", parameterToString(*r.orderby, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGroupsListRefMembersWithLicenseErrorsRequest struct {
	ctx _context.Context
	ApiService *GroupsDirectoryObjectApiService
	groupId string
	top *int32
	skip *int32
	search *string
	filter *string
	count *bool
	orderby *[]string
}

// Show only the first n items
func (r ApiGroupsListRefMembersWithLicenseErrorsRequest) Top(top int32) ApiGroupsListRefMembersWithLicenseErrorsRequest {
	r.top = &top
	return r
}
// Skip the first n items
func (r ApiGroupsListRefMembersWithLicenseErrorsRequest) Skip(skip int32) ApiGroupsListRefMembersWithLicenseErrorsRequest {
	r.skip = &skip
	return r
}
// Search items by search phrases
func (r ApiGroupsListRefMembersWithLicenseErrorsRequest) Search(search string) ApiGroupsListRefMembersWithLicenseErrorsRequest {
	r.search = &search
	return r
}
// Filter items by property values
func (r ApiGroupsListRefMembersWithLicenseErrorsRequest) Filter(filter string) ApiGroupsListRefMembersWithLicenseErrorsRequest {
	r.filter = &filter
	return r
}
// Include count of items
func (r ApiGroupsListRefMembersWithLicenseErrorsRequest) Count(count bool) ApiGroupsListRefMembersWithLicenseErrorsRequest {
	r.count = &count
	return r
}
// Order items by property values
func (r ApiGroupsListRefMembersWithLicenseErrorsRequest) Orderby(orderby []string) ApiGroupsListRefMembersWithLicenseErrorsRequest {
	r.orderby = &orderby
	return r
}

func (r ApiGroupsListRefMembersWithLicenseErrorsRequest) Execute() (CollectionOfLinksOfDirectoryObject, *_nethttp.Response, error) {
	return r.ApiService.GroupsListRefMembersWithLicenseErrorsExecute(r)
}

/*
GroupsListRefMembersWithLicenseErrors Get ref of membersWithLicenseErrors from groups

A list of group members with license errors from this group-based license assignment. Read-only.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupId key: id of group
 @return ApiGroupsListRefMembersWithLicenseErrorsRequest
*/
func (a *GroupsDirectoryObjectApiService) GroupsListRefMembersWithLicenseErrors(ctx _context.Context, groupId string) ApiGroupsListRefMembersWithLicenseErrorsRequest {
	return ApiGroupsListRefMembersWithLicenseErrorsRequest{
		ApiService: a,
		ctx: ctx,
		groupId: groupId,
	}
}

// Execute executes the request
//  @return CollectionOfLinksOfDirectoryObject
func (a *GroupsDirectoryObjectApiService) GroupsListRefMembersWithLicenseErrorsExecute(r ApiGroupsListRefMembersWithLicenseErrorsRequest) (CollectionOfLinksOfDirectoryObject, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  CollectionOfLinksOfDirectoryObject
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GroupsDirectoryObjectApiService.GroupsListRefMembersWithLicenseErrors")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/groups/{group-id}/membersWithLicenseErrors/$ref"
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.top != nil {
		localVarQueryParams.Add("$top", parameterToString(*r.top, ""))
	}
	if r.skip != nil {
		localVarQueryParams.Add("$skip", parameterToString(*r.skip, ""))
	}
	if r.search != nil {
		localVarQueryParams.Add("$search", parameterToString(*r.search, ""))
	}
	if r.filter != nil {
		localVarQueryParams.Add("$filter", parameterToString(*r.filter, ""))
	}
	if r.count != nil {
		localVarQueryParams.Add("$count", parameterToString(*r.count, ""))
	}
	if r.orderby != nil {
		localVarQueryParams.Add("$orderby", parameterToString(*r.orderby, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGroupsListRefOwnersRequest struct {
	ctx _context.Context
	ApiService *GroupsDirectoryObjectApiService
	groupId string
	top *int32
	skip *int32
	search *string
	filter *string
	count *bool
	orderby *[]string
}

// Show only the first n items
func (r ApiGroupsListRefOwnersRequest) Top(top int32) ApiGroupsListRefOwnersRequest {
	r.top = &top
	return r
}
// Skip the first n items
func (r ApiGroupsListRefOwnersRequest) Skip(skip int32) ApiGroupsListRefOwnersRequest {
	r.skip = &skip
	return r
}
// Search items by search phrases
func (r ApiGroupsListRefOwnersRequest) Search(search string) ApiGroupsListRefOwnersRequest {
	r.search = &search
	return r
}
// Filter items by property values
func (r ApiGroupsListRefOwnersRequest) Filter(filter string) ApiGroupsListRefOwnersRequest {
	r.filter = &filter
	return r
}
// Include count of items
func (r ApiGroupsListRefOwnersRequest) Count(count bool) ApiGroupsListRefOwnersRequest {
	r.count = &count
	return r
}
// Order items by property values
func (r ApiGroupsListRefOwnersRequest) Orderby(orderby []string) ApiGroupsListRefOwnersRequest {
	r.orderby = &orderby
	return r
}

func (r ApiGroupsListRefOwnersRequest) Execute() (CollectionOfLinksOfDirectoryObject, *_nethttp.Response, error) {
	return r.ApiService.GroupsListRefOwnersExecute(r)
}

/*
GroupsListRefOwners Get ref of owners from groups

The owners of the group. The owners are a set of non-admin users who are allowed to modify this object. Limited to 100 owners. Nullable. If this property is not specified when creating a Microsoft 365 group, the calling user is automatically assigned as the group owner. Supports $expand.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupId key: id of group
 @return ApiGroupsListRefOwnersRequest
*/
func (a *GroupsDirectoryObjectApiService) GroupsListRefOwners(ctx _context.Context, groupId string) ApiGroupsListRefOwnersRequest {
	return ApiGroupsListRefOwnersRequest{
		ApiService: a,
		ctx: ctx,
		groupId: groupId,
	}
}

// Execute executes the request
//  @return CollectionOfLinksOfDirectoryObject
func (a *GroupsDirectoryObjectApiService) GroupsListRefOwnersExecute(r ApiGroupsListRefOwnersRequest) (CollectionOfLinksOfDirectoryObject, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  CollectionOfLinksOfDirectoryObject
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GroupsDirectoryObjectApiService.GroupsListRefOwners")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/groups/{group-id}/owners/$ref"
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.top != nil {
		localVarQueryParams.Add("$top", parameterToString(*r.top, ""))
	}
	if r.skip != nil {
		localVarQueryParams.Add("$skip", parameterToString(*r.skip, ""))
	}
	if r.search != nil {
		localVarQueryParams.Add("$search", parameterToString(*r.search, ""))
	}
	if r.filter != nil {
		localVarQueryParams.Add("$filter", parameterToString(*r.filter, ""))
	}
	if r.count != nil {
		localVarQueryParams.Add("$count", parameterToString(*r.count, ""))
	}
	if r.orderby != nil {
		localVarQueryParams.Add("$orderby", parameterToString(*r.orderby, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGroupsListRefRejectedSendersRequest struct {
	ctx _context.Context
	ApiService *GroupsDirectoryObjectApiService
	groupId string
	top *int32
	skip *int32
	filter *string
	count *bool
	orderby *[]string
}

// Show only the first n items
func (r ApiGroupsListRefRejectedSendersRequest) Top(top int32) ApiGroupsListRefRejectedSendersRequest {
	r.top = &top
	return r
}
// Skip the first n items
func (r ApiGroupsListRefRejectedSendersRequest) Skip(skip int32) ApiGroupsListRefRejectedSendersRequest {
	r.skip = &skip
	return r
}
// Filter items by property values
func (r ApiGroupsListRefRejectedSendersRequest) Filter(filter string) ApiGroupsListRefRejectedSendersRequest {
	r.filter = &filter
	return r
}
// Include count of items
func (r ApiGroupsListRefRejectedSendersRequest) Count(count bool) ApiGroupsListRefRejectedSendersRequest {
	r.count = &count
	return r
}
// Order items by property values
func (r ApiGroupsListRefRejectedSendersRequest) Orderby(orderby []string) ApiGroupsListRefRejectedSendersRequest {
	r.orderby = &orderby
	return r
}

func (r ApiGroupsListRefRejectedSendersRequest) Execute() (CollectionOfLinksOfDirectoryObject, *_nethttp.Response, error) {
	return r.ApiService.GroupsListRefRejectedSendersExecute(r)
}

/*
GroupsListRefRejectedSenders Get ref of rejectedSenders from groups

The list of users or groups that are not allowed to create posts or calendar events in this group. Nullable

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupId key: id of group
 @return ApiGroupsListRefRejectedSendersRequest
*/
func (a *GroupsDirectoryObjectApiService) GroupsListRefRejectedSenders(ctx _context.Context, groupId string) ApiGroupsListRefRejectedSendersRequest {
	return ApiGroupsListRefRejectedSendersRequest{
		ApiService: a,
		ctx: ctx,
		groupId: groupId,
	}
}

// Execute executes the request
//  @return CollectionOfLinksOfDirectoryObject
func (a *GroupsDirectoryObjectApiService) GroupsListRefRejectedSendersExecute(r ApiGroupsListRefRejectedSendersRequest) (CollectionOfLinksOfDirectoryObject, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  CollectionOfLinksOfDirectoryObject
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GroupsDirectoryObjectApiService.GroupsListRefRejectedSenders")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/groups/{group-id}/rejectedSenders/$ref"
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.top != nil {
		localVarQueryParams.Add("$top", parameterToString(*r.top, ""))
	}
	if r.skip != nil {
		localVarQueryParams.Add("$skip", parameterToString(*r.skip, ""))
	}
	if r.filter != nil {
		localVarQueryParams.Add("$filter", parameterToString(*r.filter, ""))
	}
	if r.count != nil {
		localVarQueryParams.Add("$count", parameterToString(*r.count, ""))
	}
	if r.orderby != nil {
		localVarQueryParams.Add("$orderby", parameterToString(*r.orderby, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGroupsListRefTransitiveMemberOfRequest struct {
	ctx _context.Context
	ApiService *GroupsDirectoryObjectApiService
	groupId string
	top *int32
	skip *int32
	search *string
	filter *string
	count *bool
	orderby *[]string
}

// Show only the first n items
func (r ApiGroupsListRefTransitiveMemberOfRequest) Top(top int32) ApiGroupsListRefTransitiveMemberOfRequest {
	r.top = &top
	return r
}
// Skip the first n items
func (r ApiGroupsListRefTransitiveMemberOfRequest) Skip(skip int32) ApiGroupsListRefTransitiveMemberOfRequest {
	r.skip = &skip
	return r
}
// Search items by search phrases
func (r ApiGroupsListRefTransitiveMemberOfRequest) Search(search string) ApiGroupsListRefTransitiveMemberOfRequest {
	r.search = &search
	return r
}
// Filter items by property values
func (r ApiGroupsListRefTransitiveMemberOfRequest) Filter(filter string) ApiGroupsListRefTransitiveMemberOfRequest {
	r.filter = &filter
	return r
}
// Include count of items
func (r ApiGroupsListRefTransitiveMemberOfRequest) Count(count bool) ApiGroupsListRefTransitiveMemberOfRequest {
	r.count = &count
	return r
}
// Order items by property values
func (r ApiGroupsListRefTransitiveMemberOfRequest) Orderby(orderby []string) ApiGroupsListRefTransitiveMemberOfRequest {
	r.orderby = &orderby
	return r
}

func (r ApiGroupsListRefTransitiveMemberOfRequest) Execute() (CollectionOfLinksOfDirectoryObject, *_nethttp.Response, error) {
	return r.ApiService.GroupsListRefTransitiveMemberOfExecute(r)
}

/*
GroupsListRefTransitiveMemberOf Get ref of transitiveMemberOf from groups

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupId key: id of group
 @return ApiGroupsListRefTransitiveMemberOfRequest
*/
func (a *GroupsDirectoryObjectApiService) GroupsListRefTransitiveMemberOf(ctx _context.Context, groupId string) ApiGroupsListRefTransitiveMemberOfRequest {
	return ApiGroupsListRefTransitiveMemberOfRequest{
		ApiService: a,
		ctx: ctx,
		groupId: groupId,
	}
}

// Execute executes the request
//  @return CollectionOfLinksOfDirectoryObject
func (a *GroupsDirectoryObjectApiService) GroupsListRefTransitiveMemberOfExecute(r ApiGroupsListRefTransitiveMemberOfRequest) (CollectionOfLinksOfDirectoryObject, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  CollectionOfLinksOfDirectoryObject
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GroupsDirectoryObjectApiService.GroupsListRefTransitiveMemberOf")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/groups/{group-id}/transitiveMemberOf/$ref"
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.top != nil {
		localVarQueryParams.Add("$top", parameterToString(*r.top, ""))
	}
	if r.skip != nil {
		localVarQueryParams.Add("$skip", parameterToString(*r.skip, ""))
	}
	if r.search != nil {
		localVarQueryParams.Add("$search", parameterToString(*r.search, ""))
	}
	if r.filter != nil {
		localVarQueryParams.Add("$filter", parameterToString(*r.filter, ""))
	}
	if r.count != nil {
		localVarQueryParams.Add("$count", parameterToString(*r.count, ""))
	}
	if r.orderby != nil {
		localVarQueryParams.Add("$orderby", parameterToString(*r.orderby, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGroupsListRefTransitiveMembersRequest struct {
	ctx _context.Context
	ApiService *GroupsDirectoryObjectApiService
	groupId string
	top *int32
	skip *int32
	search *string
	filter *string
	count *bool
	orderby *[]string
}

// Show only the first n items
func (r ApiGroupsListRefTransitiveMembersRequest) Top(top int32) ApiGroupsListRefTransitiveMembersRequest {
	r.top = &top
	return r
}
// Skip the first n items
func (r ApiGroupsListRefTransitiveMembersRequest) Skip(skip int32) ApiGroupsListRefTransitiveMembersRequest {
	r.skip = &skip
	return r
}
// Search items by search phrases
func (r ApiGroupsListRefTransitiveMembersRequest) Search(search string) ApiGroupsListRefTransitiveMembersRequest {
	r.search = &search
	return r
}
// Filter items by property values
func (r ApiGroupsListRefTransitiveMembersRequest) Filter(filter string) ApiGroupsListRefTransitiveMembersRequest {
	r.filter = &filter
	return r
}
// Include count of items
func (r ApiGroupsListRefTransitiveMembersRequest) Count(count bool) ApiGroupsListRefTransitiveMembersRequest {
	r.count = &count
	return r
}
// Order items by property values
func (r ApiGroupsListRefTransitiveMembersRequest) Orderby(orderby []string) ApiGroupsListRefTransitiveMembersRequest {
	r.orderby = &orderby
	return r
}

func (r ApiGroupsListRefTransitiveMembersRequest) Execute() (CollectionOfLinksOfDirectoryObject, *_nethttp.Response, error) {
	return r.ApiService.GroupsListRefTransitiveMembersExecute(r)
}

/*
GroupsListRefTransitiveMembers Get ref of transitiveMembers from groups

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupId key: id of group
 @return ApiGroupsListRefTransitiveMembersRequest
*/
func (a *GroupsDirectoryObjectApiService) GroupsListRefTransitiveMembers(ctx _context.Context, groupId string) ApiGroupsListRefTransitiveMembersRequest {
	return ApiGroupsListRefTransitiveMembersRequest{
		ApiService: a,
		ctx: ctx,
		groupId: groupId,
	}
}

// Execute executes the request
//  @return CollectionOfLinksOfDirectoryObject
func (a *GroupsDirectoryObjectApiService) GroupsListRefTransitiveMembersExecute(r ApiGroupsListRefTransitiveMembersRequest) (CollectionOfLinksOfDirectoryObject, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  CollectionOfLinksOfDirectoryObject
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GroupsDirectoryObjectApiService.GroupsListRefTransitiveMembers")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/groups/{group-id}/transitiveMembers/$ref"
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.top != nil {
		localVarQueryParams.Add("$top", parameterToString(*r.top, ""))
	}
	if r.skip != nil {
		localVarQueryParams.Add("$skip", parameterToString(*r.skip, ""))
	}
	if r.search != nil {
		localVarQueryParams.Add("$search", parameterToString(*r.search, ""))
	}
	if r.filter != nil {
		localVarQueryParams.Add("$filter", parameterToString(*r.filter, ""))
	}
	if r.count != nil {
		localVarQueryParams.Add("$count", parameterToString(*r.count, ""))
	}
	if r.orderby != nil {
		localVarQueryParams.Add("$orderby", parameterToString(*r.orderby, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGroupsListRejectedSendersRequest struct {
	ctx _context.Context
	ApiService *GroupsDirectoryObjectApiService
	groupId string
	top *int32
	skip *int32
	filter *string
	count *bool
	orderby *[]string
	select_ *[]string
}

// Show only the first n items
func (r ApiGroupsListRejectedSendersRequest) Top(top int32) ApiGroupsListRejectedSendersRequest {
	r.top = &top
	return r
}
// Skip the first n items
func (r ApiGroupsListRejectedSendersRequest) Skip(skip int32) ApiGroupsListRejectedSendersRequest {
	r.skip = &skip
	return r
}
// Filter items by property values
func (r ApiGroupsListRejectedSendersRequest) Filter(filter string) ApiGroupsListRejectedSendersRequest {
	r.filter = &filter
	return r
}
// Include count of items
func (r ApiGroupsListRejectedSendersRequest) Count(count bool) ApiGroupsListRejectedSendersRequest {
	r.count = &count
	return r
}
// Order items by property values
func (r ApiGroupsListRejectedSendersRequest) Orderby(orderby []string) ApiGroupsListRejectedSendersRequest {
	r.orderby = &orderby
	return r
}
// Select properties to be returned
func (r ApiGroupsListRejectedSendersRequest) Select_(select_ []string) ApiGroupsListRejectedSendersRequest {
	r.select_ = &select_
	return r
}

func (r ApiGroupsListRejectedSendersRequest) Execute() (CollectionOfDirectoryObject, *_nethttp.Response, error) {
	return r.ApiService.GroupsListRejectedSendersExecute(r)
}

/*
GroupsListRejectedSenders Get rejectedSenders from groups

The list of users or groups that are not allowed to create posts or calendar events in this group. Nullable

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupId key: id of group
 @return ApiGroupsListRejectedSendersRequest
*/
func (a *GroupsDirectoryObjectApiService) GroupsListRejectedSenders(ctx _context.Context, groupId string) ApiGroupsListRejectedSendersRequest {
	return ApiGroupsListRejectedSendersRequest{
		ApiService: a,
		ctx: ctx,
		groupId: groupId,
	}
}

// Execute executes the request
//  @return CollectionOfDirectoryObject
func (a *GroupsDirectoryObjectApiService) GroupsListRejectedSendersExecute(r ApiGroupsListRejectedSendersRequest) (CollectionOfDirectoryObject, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  CollectionOfDirectoryObject
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GroupsDirectoryObjectApiService.GroupsListRejectedSenders")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/groups/{group-id}/rejectedSenders"
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.top != nil {
		localVarQueryParams.Add("$top", parameterToString(*r.top, ""))
	}
	if r.skip != nil {
		localVarQueryParams.Add("$skip", parameterToString(*r.skip, ""))
	}
	if r.filter != nil {
		localVarQueryParams.Add("$filter", parameterToString(*r.filter, ""))
	}
	if r.count != nil {
		localVarQueryParams.Add("$count", parameterToString(*r.count, ""))
	}
	if r.orderby != nil {
		localVarQueryParams.Add("$orderby", parameterToString(*r.orderby, "csv"))
	}
	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGroupsListTransitiveMemberOfRequest struct {
	ctx _context.Context
	ApiService *GroupsDirectoryObjectApiService
	groupId string
	top *int32
	skip *int32
	search *string
	filter *string
	count *bool
	orderby *[]string
	select_ *[]string
	expand *[]string
}

// Show only the first n items
func (r ApiGroupsListTransitiveMemberOfRequest) Top(top int32) ApiGroupsListTransitiveMemberOfRequest {
	r.top = &top
	return r
}
// Skip the first n items
func (r ApiGroupsListTransitiveMemberOfRequest) Skip(skip int32) ApiGroupsListTransitiveMemberOfRequest {
	r.skip = &skip
	return r
}
// Search items by search phrases
func (r ApiGroupsListTransitiveMemberOfRequest) Search(search string) ApiGroupsListTransitiveMemberOfRequest {
	r.search = &search
	return r
}
// Filter items by property values
func (r ApiGroupsListTransitiveMemberOfRequest) Filter(filter string) ApiGroupsListTransitiveMemberOfRequest {
	r.filter = &filter
	return r
}
// Include count of items
func (r ApiGroupsListTransitiveMemberOfRequest) Count(count bool) ApiGroupsListTransitiveMemberOfRequest {
	r.count = &count
	return r
}
// Order items by property values
func (r ApiGroupsListTransitiveMemberOfRequest) Orderby(orderby []string) ApiGroupsListTransitiveMemberOfRequest {
	r.orderby = &orderby
	return r
}
// Select properties to be returned
func (r ApiGroupsListTransitiveMemberOfRequest) Select_(select_ []string) ApiGroupsListTransitiveMemberOfRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiGroupsListTransitiveMemberOfRequest) Expand(expand []string) ApiGroupsListTransitiveMemberOfRequest {
	r.expand = &expand
	return r
}

func (r ApiGroupsListTransitiveMemberOfRequest) Execute() (CollectionOfDirectoryObject, *_nethttp.Response, error) {
	return r.ApiService.GroupsListTransitiveMemberOfExecute(r)
}

/*
GroupsListTransitiveMemberOf Get transitiveMemberOf from groups

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupId key: id of group
 @return ApiGroupsListTransitiveMemberOfRequest
*/
func (a *GroupsDirectoryObjectApiService) GroupsListTransitiveMemberOf(ctx _context.Context, groupId string) ApiGroupsListTransitiveMemberOfRequest {
	return ApiGroupsListTransitiveMemberOfRequest{
		ApiService: a,
		ctx: ctx,
		groupId: groupId,
	}
}

// Execute executes the request
//  @return CollectionOfDirectoryObject
func (a *GroupsDirectoryObjectApiService) GroupsListTransitiveMemberOfExecute(r ApiGroupsListTransitiveMemberOfRequest) (CollectionOfDirectoryObject, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  CollectionOfDirectoryObject
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GroupsDirectoryObjectApiService.GroupsListTransitiveMemberOf")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/groups/{group-id}/transitiveMemberOf"
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.top != nil {
		localVarQueryParams.Add("$top", parameterToString(*r.top, ""))
	}
	if r.skip != nil {
		localVarQueryParams.Add("$skip", parameterToString(*r.skip, ""))
	}
	if r.search != nil {
		localVarQueryParams.Add("$search", parameterToString(*r.search, ""))
	}
	if r.filter != nil {
		localVarQueryParams.Add("$filter", parameterToString(*r.filter, ""))
	}
	if r.count != nil {
		localVarQueryParams.Add("$count", parameterToString(*r.count, ""))
	}
	if r.orderby != nil {
		localVarQueryParams.Add("$orderby", parameterToString(*r.orderby, "csv"))
	}
	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGroupsListTransitiveMembersRequest struct {
	ctx _context.Context
	ApiService *GroupsDirectoryObjectApiService
	groupId string
	top *int32
	skip *int32
	search *string
	filter *string
	count *bool
	orderby *[]string
	select_ *[]string
	expand *[]string
}

// Show only the first n items
func (r ApiGroupsListTransitiveMembersRequest) Top(top int32) ApiGroupsListTransitiveMembersRequest {
	r.top = &top
	return r
}
// Skip the first n items
func (r ApiGroupsListTransitiveMembersRequest) Skip(skip int32) ApiGroupsListTransitiveMembersRequest {
	r.skip = &skip
	return r
}
// Search items by search phrases
func (r ApiGroupsListTransitiveMembersRequest) Search(search string) ApiGroupsListTransitiveMembersRequest {
	r.search = &search
	return r
}
// Filter items by property values
func (r ApiGroupsListTransitiveMembersRequest) Filter(filter string) ApiGroupsListTransitiveMembersRequest {
	r.filter = &filter
	return r
}
// Include count of items
func (r ApiGroupsListTransitiveMembersRequest) Count(count bool) ApiGroupsListTransitiveMembersRequest {
	r.count = &count
	return r
}
// Order items by property values
func (r ApiGroupsListTransitiveMembersRequest) Orderby(orderby []string) ApiGroupsListTransitiveMembersRequest {
	r.orderby = &orderby
	return r
}
// Select properties to be returned
func (r ApiGroupsListTransitiveMembersRequest) Select_(select_ []string) ApiGroupsListTransitiveMembersRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiGroupsListTransitiveMembersRequest) Expand(expand []string) ApiGroupsListTransitiveMembersRequest {
	r.expand = &expand
	return r
}

func (r ApiGroupsListTransitiveMembersRequest) Execute() (CollectionOfDirectoryObject, *_nethttp.Response, error) {
	return r.ApiService.GroupsListTransitiveMembersExecute(r)
}

/*
GroupsListTransitiveMembers Get transitiveMembers from groups

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupId key: id of group
 @return ApiGroupsListTransitiveMembersRequest
*/
func (a *GroupsDirectoryObjectApiService) GroupsListTransitiveMembers(ctx _context.Context, groupId string) ApiGroupsListTransitiveMembersRequest {
	return ApiGroupsListTransitiveMembersRequest{
		ApiService: a,
		ctx: ctx,
		groupId: groupId,
	}
}

// Execute executes the request
//  @return CollectionOfDirectoryObject
func (a *GroupsDirectoryObjectApiService) GroupsListTransitiveMembersExecute(r ApiGroupsListTransitiveMembersRequest) (CollectionOfDirectoryObject, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  CollectionOfDirectoryObject
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GroupsDirectoryObjectApiService.GroupsListTransitiveMembers")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/groups/{group-id}/transitiveMembers"
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.top != nil {
		localVarQueryParams.Add("$top", parameterToString(*r.top, ""))
	}
	if r.skip != nil {
		localVarQueryParams.Add("$skip", parameterToString(*r.skip, ""))
	}
	if r.search != nil {
		localVarQueryParams.Add("$search", parameterToString(*r.search, ""))
	}
	if r.filter != nil {
		localVarQueryParams.Add("$filter", parameterToString(*r.filter, ""))
	}
	if r.count != nil {
		localVarQueryParams.Add("$count", parameterToString(*r.count, ""))
	}
	if r.orderby != nil {
		localVarQueryParams.Add("$orderby", parameterToString(*r.orderby, "csv"))
	}
	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGroupsUpdateRefCreatedOnBehalfOfRequest struct {
	ctx _context.Context
	ApiService *GroupsDirectoryObjectApiService
	groupId string
	requestBody *map[string]map[string]interface{}
}

// New navigation property ref values
func (r ApiGroupsUpdateRefCreatedOnBehalfOfRequest) RequestBody(requestBody map[string]map[string]interface{}) ApiGroupsUpdateRefCreatedOnBehalfOfRequest {
	r.requestBody = &requestBody
	return r
}

func (r ApiGroupsUpdateRefCreatedOnBehalfOfRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.GroupsUpdateRefCreatedOnBehalfOfExecute(r)
}

/*
GroupsUpdateRefCreatedOnBehalfOf Update the ref of navigation property createdOnBehalfOf in groups

The user (or application) that created the group. NOTE: This is not set if the user is an administrator. Read-only.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupId key: id of group
 @return ApiGroupsUpdateRefCreatedOnBehalfOfRequest
*/
func (a *GroupsDirectoryObjectApiService) GroupsUpdateRefCreatedOnBehalfOf(ctx _context.Context, groupId string) ApiGroupsUpdateRefCreatedOnBehalfOfRequest {
	return ApiGroupsUpdateRefCreatedOnBehalfOfRequest{
		ApiService: a,
		ctx: ctx,
		groupId: groupId,
	}
}

// Execute executes the request
func (a *GroupsDirectoryObjectApiService) GroupsUpdateRefCreatedOnBehalfOfExecute(r ApiGroupsUpdateRefCreatedOnBehalfOfRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPut
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GroupsDirectoryObjectApiService.GroupsUpdateRefCreatedOnBehalfOf")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/groups/{group-id}/createdOnBehalfOf/$ref"
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.requestBody == nil {
		return nil, reportError("requestBody is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.requestBody
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}
