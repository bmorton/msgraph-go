/*
Partial Graph API

No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

API version: v1.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package msgraph

import (
	"bytes"
	_context "context"
	_ioutil "io/ioutil"
	_nethttp "net/http"
	_neturl "net/url"
	"strings"
)

// Linger please
var (
	_ _context.Context
)

// MeUserTeamworkApiService MeUserTeamworkApi service
type MeUserTeamworkApiService service

type ApiMeDeleteTeamworkRequest struct {
	ctx _context.Context
	ApiService *MeUserTeamworkApiService
	ifMatch *string
}

// ETag
func (r ApiMeDeleteTeamworkRequest) IfMatch(ifMatch string) ApiMeDeleteTeamworkRequest {
	r.ifMatch = &ifMatch
	return r
}

func (r ApiMeDeleteTeamworkRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.MeDeleteTeamworkExecute(r)
}

/*
MeDeleteTeamwork Delete navigation property teamwork for me

A container for Microsoft Teams features available for the user. Read-only. Nullable.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiMeDeleteTeamworkRequest
*/
func (a *MeUserTeamworkApiService) MeDeleteTeamwork(ctx _context.Context) ApiMeDeleteTeamworkRequest {
	return ApiMeDeleteTeamworkRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *MeUserTeamworkApiService) MeDeleteTeamworkExecute(r ApiMeDeleteTeamworkRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MeUserTeamworkApiService.MeDeleteTeamwork")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/teamwork"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ifMatch != nil {
		localVarHeaderParams["If-Match"] = parameterToString(*r.ifMatch, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiMeGetTeamworkRequest struct {
	ctx _context.Context
	ApiService *MeUserTeamworkApiService
	select_ *[]string
	expand *[]string
}

// Select properties to be returned
func (r ApiMeGetTeamworkRequest) Select_(select_ []string) ApiMeGetTeamworkRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiMeGetTeamworkRequest) Expand(expand []string) ApiMeGetTeamworkRequest {
	r.expand = &expand
	return r
}

func (r ApiMeGetTeamworkRequest) Execute() (MicrosoftGraphUserTeamwork, *_nethttp.Response, error) {
	return r.ApiService.MeGetTeamworkExecute(r)
}

/*
MeGetTeamwork Get teamwork from me

A container for Microsoft Teams features available for the user. Read-only. Nullable.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiMeGetTeamworkRequest
*/
func (a *MeUserTeamworkApiService) MeGetTeamwork(ctx _context.Context) ApiMeGetTeamworkRequest {
	return ApiMeGetTeamworkRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return MicrosoftGraphUserTeamwork
func (a *MeUserTeamworkApiService) MeGetTeamworkExecute(r ApiMeGetTeamworkRequest) (MicrosoftGraphUserTeamwork, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphUserTeamwork
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MeUserTeamworkApiService.MeGetTeamwork")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/teamwork"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMeTeamworkCreateInstalledAppsRequest struct {
	ctx _context.Context
	ApiService *MeUserTeamworkApiService
	microsoftGraphUserScopeTeamsAppInstallation *MicrosoftGraphUserScopeTeamsAppInstallation
}

// New navigation property
func (r ApiMeTeamworkCreateInstalledAppsRequest) MicrosoftGraphUserScopeTeamsAppInstallation(microsoftGraphUserScopeTeamsAppInstallation MicrosoftGraphUserScopeTeamsAppInstallation) ApiMeTeamworkCreateInstalledAppsRequest {
	r.microsoftGraphUserScopeTeamsAppInstallation = &microsoftGraphUserScopeTeamsAppInstallation
	return r
}

func (r ApiMeTeamworkCreateInstalledAppsRequest) Execute() (MicrosoftGraphUserScopeTeamsAppInstallation, *_nethttp.Response, error) {
	return r.ApiService.MeTeamworkCreateInstalledAppsExecute(r)
}

/*
MeTeamworkCreateInstalledApps Create new navigation property to installedApps for me

The apps installed in the personal scope of this user.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiMeTeamworkCreateInstalledAppsRequest
*/
func (a *MeUserTeamworkApiService) MeTeamworkCreateInstalledApps(ctx _context.Context) ApiMeTeamworkCreateInstalledAppsRequest {
	return ApiMeTeamworkCreateInstalledAppsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return MicrosoftGraphUserScopeTeamsAppInstallation
func (a *MeUserTeamworkApiService) MeTeamworkCreateInstalledAppsExecute(r ApiMeTeamworkCreateInstalledAppsRequest) (MicrosoftGraphUserScopeTeamsAppInstallation, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphUserScopeTeamsAppInstallation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MeUserTeamworkApiService.MeTeamworkCreateInstalledApps")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/teamwork/installedApps"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphUserScopeTeamsAppInstallation == nil {
		return localVarReturnValue, nil, reportError("microsoftGraphUserScopeTeamsAppInstallation is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphUserScopeTeamsAppInstallation
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMeTeamworkDeleteInstalledAppsRequest struct {
	ctx _context.Context
	ApiService *MeUserTeamworkApiService
	userScopeTeamsAppInstallationId string
	ifMatch *string
}

// ETag
func (r ApiMeTeamworkDeleteInstalledAppsRequest) IfMatch(ifMatch string) ApiMeTeamworkDeleteInstalledAppsRequest {
	r.ifMatch = &ifMatch
	return r
}

func (r ApiMeTeamworkDeleteInstalledAppsRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.MeTeamworkDeleteInstalledAppsExecute(r)
}

/*
MeTeamworkDeleteInstalledApps Delete navigation property installedApps for me

The apps installed in the personal scope of this user.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userScopeTeamsAppInstallationId key: id of userScopeTeamsAppInstallation
 @return ApiMeTeamworkDeleteInstalledAppsRequest
*/
func (a *MeUserTeamworkApiService) MeTeamworkDeleteInstalledApps(ctx _context.Context, userScopeTeamsAppInstallationId string) ApiMeTeamworkDeleteInstalledAppsRequest {
	return ApiMeTeamworkDeleteInstalledAppsRequest{
		ApiService: a,
		ctx: ctx,
		userScopeTeamsAppInstallationId: userScopeTeamsAppInstallationId,
	}
}

// Execute executes the request
func (a *MeUserTeamworkApiService) MeTeamworkDeleteInstalledAppsExecute(r ApiMeTeamworkDeleteInstalledAppsRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MeUserTeamworkApiService.MeTeamworkDeleteInstalledApps")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/teamwork/installedApps/{userScopeTeamsAppInstallation-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"userScopeTeamsAppInstallation-id"+"}", _neturl.PathEscape(parameterToString(r.userScopeTeamsAppInstallationId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ifMatch != nil {
		localVarHeaderParams["If-Match"] = parameterToString(*r.ifMatch, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiMeTeamworkGetInstalledAppsRequest struct {
	ctx _context.Context
	ApiService *MeUserTeamworkApiService
	userScopeTeamsAppInstallationId string
	select_ *[]string
	expand *[]string
}

// Select properties to be returned
func (r ApiMeTeamworkGetInstalledAppsRequest) Select_(select_ []string) ApiMeTeamworkGetInstalledAppsRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiMeTeamworkGetInstalledAppsRequest) Expand(expand []string) ApiMeTeamworkGetInstalledAppsRequest {
	r.expand = &expand
	return r
}

func (r ApiMeTeamworkGetInstalledAppsRequest) Execute() (MicrosoftGraphUserScopeTeamsAppInstallation, *_nethttp.Response, error) {
	return r.ApiService.MeTeamworkGetInstalledAppsExecute(r)
}

/*
MeTeamworkGetInstalledApps Get installedApps from me

The apps installed in the personal scope of this user.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userScopeTeamsAppInstallationId key: id of userScopeTeamsAppInstallation
 @return ApiMeTeamworkGetInstalledAppsRequest
*/
func (a *MeUserTeamworkApiService) MeTeamworkGetInstalledApps(ctx _context.Context, userScopeTeamsAppInstallationId string) ApiMeTeamworkGetInstalledAppsRequest {
	return ApiMeTeamworkGetInstalledAppsRequest{
		ApiService: a,
		ctx: ctx,
		userScopeTeamsAppInstallationId: userScopeTeamsAppInstallationId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphUserScopeTeamsAppInstallation
func (a *MeUserTeamworkApiService) MeTeamworkGetInstalledAppsExecute(r ApiMeTeamworkGetInstalledAppsRequest) (MicrosoftGraphUserScopeTeamsAppInstallation, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphUserScopeTeamsAppInstallation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MeUserTeamworkApiService.MeTeamworkGetInstalledApps")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/teamwork/installedApps/{userScopeTeamsAppInstallation-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"userScopeTeamsAppInstallation-id"+"}", _neturl.PathEscape(parameterToString(r.userScopeTeamsAppInstallationId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMeTeamworkInstalledAppsDeleteRefChatRequest struct {
	ctx _context.Context
	ApiService *MeUserTeamworkApiService
	userScopeTeamsAppInstallationId string
	ifMatch *string
}

// ETag
func (r ApiMeTeamworkInstalledAppsDeleteRefChatRequest) IfMatch(ifMatch string) ApiMeTeamworkInstalledAppsDeleteRefChatRequest {
	r.ifMatch = &ifMatch
	return r
}

func (r ApiMeTeamworkInstalledAppsDeleteRefChatRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.MeTeamworkInstalledAppsDeleteRefChatExecute(r)
}

/*
MeTeamworkInstalledAppsDeleteRefChat Delete ref of navigation property chat for me

The chat between the user and Teams app.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userScopeTeamsAppInstallationId key: id of userScopeTeamsAppInstallation
 @return ApiMeTeamworkInstalledAppsDeleteRefChatRequest
*/
func (a *MeUserTeamworkApiService) MeTeamworkInstalledAppsDeleteRefChat(ctx _context.Context, userScopeTeamsAppInstallationId string) ApiMeTeamworkInstalledAppsDeleteRefChatRequest {
	return ApiMeTeamworkInstalledAppsDeleteRefChatRequest{
		ApiService: a,
		ctx: ctx,
		userScopeTeamsAppInstallationId: userScopeTeamsAppInstallationId,
	}
}

// Execute executes the request
func (a *MeUserTeamworkApiService) MeTeamworkInstalledAppsDeleteRefChatExecute(r ApiMeTeamworkInstalledAppsDeleteRefChatRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MeUserTeamworkApiService.MeTeamworkInstalledAppsDeleteRefChat")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/teamwork/installedApps/{userScopeTeamsAppInstallation-id}/chat/$ref"
	localVarPath = strings.Replace(localVarPath, "{"+"userScopeTeamsAppInstallation-id"+"}", _neturl.PathEscape(parameterToString(r.userScopeTeamsAppInstallationId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ifMatch != nil {
		localVarHeaderParams["If-Match"] = parameterToString(*r.ifMatch, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiMeTeamworkInstalledAppsGetChatRequest struct {
	ctx _context.Context
	ApiService *MeUserTeamworkApiService
	userScopeTeamsAppInstallationId string
	select_ *[]string
	expand *[]string
}

// Select properties to be returned
func (r ApiMeTeamworkInstalledAppsGetChatRequest) Select_(select_ []string) ApiMeTeamworkInstalledAppsGetChatRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiMeTeamworkInstalledAppsGetChatRequest) Expand(expand []string) ApiMeTeamworkInstalledAppsGetChatRequest {
	r.expand = &expand
	return r
}

func (r ApiMeTeamworkInstalledAppsGetChatRequest) Execute() (MicrosoftGraphChat, *_nethttp.Response, error) {
	return r.ApiService.MeTeamworkInstalledAppsGetChatExecute(r)
}

/*
MeTeamworkInstalledAppsGetChat Get chat from me

The chat between the user and Teams app.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userScopeTeamsAppInstallationId key: id of userScopeTeamsAppInstallation
 @return ApiMeTeamworkInstalledAppsGetChatRequest
*/
func (a *MeUserTeamworkApiService) MeTeamworkInstalledAppsGetChat(ctx _context.Context, userScopeTeamsAppInstallationId string) ApiMeTeamworkInstalledAppsGetChatRequest {
	return ApiMeTeamworkInstalledAppsGetChatRequest{
		ApiService: a,
		ctx: ctx,
		userScopeTeamsAppInstallationId: userScopeTeamsAppInstallationId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphChat
func (a *MeUserTeamworkApiService) MeTeamworkInstalledAppsGetChatExecute(r ApiMeTeamworkInstalledAppsGetChatRequest) (MicrosoftGraphChat, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphChat
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MeUserTeamworkApiService.MeTeamworkInstalledAppsGetChat")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/teamwork/installedApps/{userScopeTeamsAppInstallation-id}/chat"
	localVarPath = strings.Replace(localVarPath, "{"+"userScopeTeamsAppInstallation-id"+"}", _neturl.PathEscape(parameterToString(r.userScopeTeamsAppInstallationId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMeTeamworkInstalledAppsGetRefChatRequest struct {
	ctx _context.Context
	ApiService *MeUserTeamworkApiService
	userScopeTeamsAppInstallationId string
}


func (r ApiMeTeamworkInstalledAppsGetRefChatRequest) Execute() (string, *_nethttp.Response, error) {
	return r.ApiService.MeTeamworkInstalledAppsGetRefChatExecute(r)
}

/*
MeTeamworkInstalledAppsGetRefChat Get ref of chat from me

The chat between the user and Teams app.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userScopeTeamsAppInstallationId key: id of userScopeTeamsAppInstallation
 @return ApiMeTeamworkInstalledAppsGetRefChatRequest
*/
func (a *MeUserTeamworkApiService) MeTeamworkInstalledAppsGetRefChat(ctx _context.Context, userScopeTeamsAppInstallationId string) ApiMeTeamworkInstalledAppsGetRefChatRequest {
	return ApiMeTeamworkInstalledAppsGetRefChatRequest{
		ApiService: a,
		ctx: ctx,
		userScopeTeamsAppInstallationId: userScopeTeamsAppInstallationId,
	}
}

// Execute executes the request
//  @return string
func (a *MeUserTeamworkApiService) MeTeamworkInstalledAppsGetRefChatExecute(r ApiMeTeamworkInstalledAppsGetRefChatRequest) (string, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  string
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MeUserTeamworkApiService.MeTeamworkInstalledAppsGetRefChat")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/teamwork/installedApps/{userScopeTeamsAppInstallation-id}/chat/$ref"
	localVarPath = strings.Replace(localVarPath, "{"+"userScopeTeamsAppInstallation-id"+"}", _neturl.PathEscape(parameterToString(r.userScopeTeamsAppInstallationId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMeTeamworkInstalledAppsUpdateRefChatRequest struct {
	ctx _context.Context
	ApiService *MeUserTeamworkApiService
	userScopeTeamsAppInstallationId string
	requestBody *map[string]map[string]interface{}
}

// New navigation property ref values
func (r ApiMeTeamworkInstalledAppsUpdateRefChatRequest) RequestBody(requestBody map[string]map[string]interface{}) ApiMeTeamworkInstalledAppsUpdateRefChatRequest {
	r.requestBody = &requestBody
	return r
}

func (r ApiMeTeamworkInstalledAppsUpdateRefChatRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.MeTeamworkInstalledAppsUpdateRefChatExecute(r)
}

/*
MeTeamworkInstalledAppsUpdateRefChat Update the ref of navigation property chat in me

The chat between the user and Teams app.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userScopeTeamsAppInstallationId key: id of userScopeTeamsAppInstallation
 @return ApiMeTeamworkInstalledAppsUpdateRefChatRequest
*/
func (a *MeUserTeamworkApiService) MeTeamworkInstalledAppsUpdateRefChat(ctx _context.Context, userScopeTeamsAppInstallationId string) ApiMeTeamworkInstalledAppsUpdateRefChatRequest {
	return ApiMeTeamworkInstalledAppsUpdateRefChatRequest{
		ApiService: a,
		ctx: ctx,
		userScopeTeamsAppInstallationId: userScopeTeamsAppInstallationId,
	}
}

// Execute executes the request
func (a *MeUserTeamworkApiService) MeTeamworkInstalledAppsUpdateRefChatExecute(r ApiMeTeamworkInstalledAppsUpdateRefChatRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPut
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MeUserTeamworkApiService.MeTeamworkInstalledAppsUpdateRefChat")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/teamwork/installedApps/{userScopeTeamsAppInstallation-id}/chat/$ref"
	localVarPath = strings.Replace(localVarPath, "{"+"userScopeTeamsAppInstallation-id"+"}", _neturl.PathEscape(parameterToString(r.userScopeTeamsAppInstallationId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.requestBody == nil {
		return nil, reportError("requestBody is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.requestBody
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiMeTeamworkListInstalledAppsRequest struct {
	ctx _context.Context
	ApiService *MeUserTeamworkApiService
	top *int32
	skip *int32
	search *string
	filter *string
	count *bool
	orderby *[]string
	select_ *[]string
	expand *[]string
}

// Show only the first n items
func (r ApiMeTeamworkListInstalledAppsRequest) Top(top int32) ApiMeTeamworkListInstalledAppsRequest {
	r.top = &top
	return r
}
// Skip the first n items
func (r ApiMeTeamworkListInstalledAppsRequest) Skip(skip int32) ApiMeTeamworkListInstalledAppsRequest {
	r.skip = &skip
	return r
}
// Search items by search phrases
func (r ApiMeTeamworkListInstalledAppsRequest) Search(search string) ApiMeTeamworkListInstalledAppsRequest {
	r.search = &search
	return r
}
// Filter items by property values
func (r ApiMeTeamworkListInstalledAppsRequest) Filter(filter string) ApiMeTeamworkListInstalledAppsRequest {
	r.filter = &filter
	return r
}
// Include count of items
func (r ApiMeTeamworkListInstalledAppsRequest) Count(count bool) ApiMeTeamworkListInstalledAppsRequest {
	r.count = &count
	return r
}
// Order items by property values
func (r ApiMeTeamworkListInstalledAppsRequest) Orderby(orderby []string) ApiMeTeamworkListInstalledAppsRequest {
	r.orderby = &orderby
	return r
}
// Select properties to be returned
func (r ApiMeTeamworkListInstalledAppsRequest) Select_(select_ []string) ApiMeTeamworkListInstalledAppsRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiMeTeamworkListInstalledAppsRequest) Expand(expand []string) ApiMeTeamworkListInstalledAppsRequest {
	r.expand = &expand
	return r
}

func (r ApiMeTeamworkListInstalledAppsRequest) Execute() (CollectionOfUserScopeTeamsAppInstallation, *_nethttp.Response, error) {
	return r.ApiService.MeTeamworkListInstalledAppsExecute(r)
}

/*
MeTeamworkListInstalledApps Get installedApps from me

The apps installed in the personal scope of this user.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiMeTeamworkListInstalledAppsRequest
*/
func (a *MeUserTeamworkApiService) MeTeamworkListInstalledApps(ctx _context.Context) ApiMeTeamworkListInstalledAppsRequest {
	return ApiMeTeamworkListInstalledAppsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CollectionOfUserScopeTeamsAppInstallation
func (a *MeUserTeamworkApiService) MeTeamworkListInstalledAppsExecute(r ApiMeTeamworkListInstalledAppsRequest) (CollectionOfUserScopeTeamsAppInstallation, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  CollectionOfUserScopeTeamsAppInstallation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MeUserTeamworkApiService.MeTeamworkListInstalledApps")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/teamwork/installedApps"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.top != nil {
		localVarQueryParams.Add("$top", parameterToString(*r.top, ""))
	}
	if r.skip != nil {
		localVarQueryParams.Add("$skip", parameterToString(*r.skip, ""))
	}
	if r.search != nil {
		localVarQueryParams.Add("$search", parameterToString(*r.search, ""))
	}
	if r.filter != nil {
		localVarQueryParams.Add("$filter", parameterToString(*r.filter, ""))
	}
	if r.count != nil {
		localVarQueryParams.Add("$count", parameterToString(*r.count, ""))
	}
	if r.orderby != nil {
		localVarQueryParams.Add("$orderby", parameterToString(*r.orderby, "csv"))
	}
	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMeTeamworkUpdateInstalledAppsRequest struct {
	ctx _context.Context
	ApiService *MeUserTeamworkApiService
	userScopeTeamsAppInstallationId string
	microsoftGraphUserScopeTeamsAppInstallation *MicrosoftGraphUserScopeTeamsAppInstallation
}

// New navigation property values
func (r ApiMeTeamworkUpdateInstalledAppsRequest) MicrosoftGraphUserScopeTeamsAppInstallation(microsoftGraphUserScopeTeamsAppInstallation MicrosoftGraphUserScopeTeamsAppInstallation) ApiMeTeamworkUpdateInstalledAppsRequest {
	r.microsoftGraphUserScopeTeamsAppInstallation = &microsoftGraphUserScopeTeamsAppInstallation
	return r
}

func (r ApiMeTeamworkUpdateInstalledAppsRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.MeTeamworkUpdateInstalledAppsExecute(r)
}

/*
MeTeamworkUpdateInstalledApps Update the navigation property installedApps in me

The apps installed in the personal scope of this user.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userScopeTeamsAppInstallationId key: id of userScopeTeamsAppInstallation
 @return ApiMeTeamworkUpdateInstalledAppsRequest
*/
func (a *MeUserTeamworkApiService) MeTeamworkUpdateInstalledApps(ctx _context.Context, userScopeTeamsAppInstallationId string) ApiMeTeamworkUpdateInstalledAppsRequest {
	return ApiMeTeamworkUpdateInstalledAppsRequest{
		ApiService: a,
		ctx: ctx,
		userScopeTeamsAppInstallationId: userScopeTeamsAppInstallationId,
	}
}

// Execute executes the request
func (a *MeUserTeamworkApiService) MeTeamworkUpdateInstalledAppsExecute(r ApiMeTeamworkUpdateInstalledAppsRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPatch
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MeUserTeamworkApiService.MeTeamworkUpdateInstalledApps")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/teamwork/installedApps/{userScopeTeamsAppInstallation-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"userScopeTeamsAppInstallation-id"+"}", _neturl.PathEscape(parameterToString(r.userScopeTeamsAppInstallationId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphUserScopeTeamsAppInstallation == nil {
		return nil, reportError("microsoftGraphUserScopeTeamsAppInstallation is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphUserScopeTeamsAppInstallation
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiMeUpdateTeamworkRequest struct {
	ctx _context.Context
	ApiService *MeUserTeamworkApiService
	microsoftGraphUserTeamwork *MicrosoftGraphUserTeamwork
}

// New navigation property values
func (r ApiMeUpdateTeamworkRequest) MicrosoftGraphUserTeamwork(microsoftGraphUserTeamwork MicrosoftGraphUserTeamwork) ApiMeUpdateTeamworkRequest {
	r.microsoftGraphUserTeamwork = &microsoftGraphUserTeamwork
	return r
}

func (r ApiMeUpdateTeamworkRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.MeUpdateTeamworkExecute(r)
}

/*
MeUpdateTeamwork Update the navigation property teamwork in me

A container for Microsoft Teams features available for the user. Read-only. Nullable.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiMeUpdateTeamworkRequest
*/
func (a *MeUserTeamworkApiService) MeUpdateTeamwork(ctx _context.Context) ApiMeUpdateTeamworkRequest {
	return ApiMeUpdateTeamworkRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *MeUserTeamworkApiService) MeUpdateTeamworkExecute(r ApiMeUpdateTeamworkRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPatch
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MeUserTeamworkApiService.MeUpdateTeamwork")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/teamwork"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphUserTeamwork == nil {
		return nil, reportError("microsoftGraphUserTeamwork is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphUserTeamwork
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}
