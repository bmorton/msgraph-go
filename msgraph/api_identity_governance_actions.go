/*
Partial Graph API

No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

API version: v1.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package openapi

import (
	"bytes"
	_context "context"
	_ioutil "io/ioutil"
	_nethttp "net/http"
	_neturl "net/url"
	"strings"
)

// Linger please
var (
	_ _context.Context
)

// IdentityGovernanceActionsApiService IdentityGovernanceActionsApi service
type IdentityGovernanceActionsApiService service

type ApiIdentityGovernanceAccessReviewsDefinitionsAccessReviewScheduleDefinitionInstancesAccessReviewInstanceAcceptRecommendationsRequest struct {
	ctx _context.Context
	ApiService *IdentityGovernanceActionsApiService
	accessReviewScheduleDefinitionId string
	accessReviewInstanceId string
}


func (r ApiIdentityGovernanceAccessReviewsDefinitionsAccessReviewScheduleDefinitionInstancesAccessReviewInstanceAcceptRecommendationsRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.IdentityGovernanceAccessReviewsDefinitionsAccessReviewScheduleDefinitionInstancesAccessReviewInstanceAcceptRecommendationsExecute(r)
}

/*
IdentityGovernanceAccessReviewsDefinitionsAccessReviewScheduleDefinitionInstancesAccessReviewInstanceAcceptRecommendations Invoke action acceptRecommendations

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accessReviewScheduleDefinitionId key: id of accessReviewScheduleDefinition
 @param accessReviewInstanceId key: id of accessReviewInstance
 @return ApiIdentityGovernanceAccessReviewsDefinitionsAccessReviewScheduleDefinitionInstancesAccessReviewInstanceAcceptRecommendationsRequest
*/
func (a *IdentityGovernanceActionsApiService) IdentityGovernanceAccessReviewsDefinitionsAccessReviewScheduleDefinitionInstancesAccessReviewInstanceAcceptRecommendations(ctx _context.Context, accessReviewScheduleDefinitionId string, accessReviewInstanceId string) ApiIdentityGovernanceAccessReviewsDefinitionsAccessReviewScheduleDefinitionInstancesAccessReviewInstanceAcceptRecommendationsRequest {
	return ApiIdentityGovernanceAccessReviewsDefinitionsAccessReviewScheduleDefinitionInstancesAccessReviewInstanceAcceptRecommendationsRequest{
		ApiService: a,
		ctx: ctx,
		accessReviewScheduleDefinitionId: accessReviewScheduleDefinitionId,
		accessReviewInstanceId: accessReviewInstanceId,
	}
}

// Execute executes the request
func (a *IdentityGovernanceActionsApiService) IdentityGovernanceAccessReviewsDefinitionsAccessReviewScheduleDefinitionInstancesAccessReviewInstanceAcceptRecommendationsExecute(r ApiIdentityGovernanceAccessReviewsDefinitionsAccessReviewScheduleDefinitionInstancesAccessReviewInstanceAcceptRecommendationsRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IdentityGovernanceActionsApiService.IdentityGovernanceAccessReviewsDefinitionsAccessReviewScheduleDefinitionInstancesAccessReviewInstanceAcceptRecommendations")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/identityGovernance/accessReviews/definitions/{accessReviewScheduleDefinition-id}/instances/{accessReviewInstance-id}/microsoft.graph.acceptRecommendations"
	localVarPath = strings.Replace(localVarPath, "{"+"accessReviewScheduleDefinition-id"+"}", _neturl.PathEscape(parameterToString(r.accessReviewScheduleDefinitionId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"accessReviewInstance-id"+"}", _neturl.PathEscape(parameterToString(r.accessReviewInstanceId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiIdentityGovernanceAccessReviewsDefinitionsAccessReviewScheduleDefinitionInstancesAccessReviewInstanceApplyDecisionsRequest struct {
	ctx _context.Context
	ApiService *IdentityGovernanceActionsApiService
	accessReviewScheduleDefinitionId string
	accessReviewInstanceId string
}


func (r ApiIdentityGovernanceAccessReviewsDefinitionsAccessReviewScheduleDefinitionInstancesAccessReviewInstanceApplyDecisionsRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.IdentityGovernanceAccessReviewsDefinitionsAccessReviewScheduleDefinitionInstancesAccessReviewInstanceApplyDecisionsExecute(r)
}

/*
IdentityGovernanceAccessReviewsDefinitionsAccessReviewScheduleDefinitionInstancesAccessReviewInstanceApplyDecisions Invoke action applyDecisions

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accessReviewScheduleDefinitionId key: id of accessReviewScheduleDefinition
 @param accessReviewInstanceId key: id of accessReviewInstance
 @return ApiIdentityGovernanceAccessReviewsDefinitionsAccessReviewScheduleDefinitionInstancesAccessReviewInstanceApplyDecisionsRequest
*/
func (a *IdentityGovernanceActionsApiService) IdentityGovernanceAccessReviewsDefinitionsAccessReviewScheduleDefinitionInstancesAccessReviewInstanceApplyDecisions(ctx _context.Context, accessReviewScheduleDefinitionId string, accessReviewInstanceId string) ApiIdentityGovernanceAccessReviewsDefinitionsAccessReviewScheduleDefinitionInstancesAccessReviewInstanceApplyDecisionsRequest {
	return ApiIdentityGovernanceAccessReviewsDefinitionsAccessReviewScheduleDefinitionInstancesAccessReviewInstanceApplyDecisionsRequest{
		ApiService: a,
		ctx: ctx,
		accessReviewScheduleDefinitionId: accessReviewScheduleDefinitionId,
		accessReviewInstanceId: accessReviewInstanceId,
	}
}

// Execute executes the request
func (a *IdentityGovernanceActionsApiService) IdentityGovernanceAccessReviewsDefinitionsAccessReviewScheduleDefinitionInstancesAccessReviewInstanceApplyDecisionsExecute(r ApiIdentityGovernanceAccessReviewsDefinitionsAccessReviewScheduleDefinitionInstancesAccessReviewInstanceApplyDecisionsRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IdentityGovernanceActionsApiService.IdentityGovernanceAccessReviewsDefinitionsAccessReviewScheduleDefinitionInstancesAccessReviewInstanceApplyDecisions")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/identityGovernance/accessReviews/definitions/{accessReviewScheduleDefinition-id}/instances/{accessReviewInstance-id}/microsoft.graph.applyDecisions"
	localVarPath = strings.Replace(localVarPath, "{"+"accessReviewScheduleDefinition-id"+"}", _neturl.PathEscape(parameterToString(r.accessReviewScheduleDefinitionId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"accessReviewInstance-id"+"}", _neturl.PathEscape(parameterToString(r.accessReviewInstanceId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiIdentityGovernanceAccessReviewsDefinitionsAccessReviewScheduleDefinitionInstancesAccessReviewInstanceBatchRecordDecisionsRequest struct {
	ctx _context.Context
	ApiService *IdentityGovernanceActionsApiService
	accessReviewScheduleDefinitionId string
	accessReviewInstanceId string
	inlineObject358 *InlineObject358
}

func (r ApiIdentityGovernanceAccessReviewsDefinitionsAccessReviewScheduleDefinitionInstancesAccessReviewInstanceBatchRecordDecisionsRequest) InlineObject358(inlineObject358 InlineObject358) ApiIdentityGovernanceAccessReviewsDefinitionsAccessReviewScheduleDefinitionInstancesAccessReviewInstanceBatchRecordDecisionsRequest {
	r.inlineObject358 = &inlineObject358
	return r
}

func (r ApiIdentityGovernanceAccessReviewsDefinitionsAccessReviewScheduleDefinitionInstancesAccessReviewInstanceBatchRecordDecisionsRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.IdentityGovernanceAccessReviewsDefinitionsAccessReviewScheduleDefinitionInstancesAccessReviewInstanceBatchRecordDecisionsExecute(r)
}

/*
IdentityGovernanceAccessReviewsDefinitionsAccessReviewScheduleDefinitionInstancesAccessReviewInstanceBatchRecordDecisions Invoke action batchRecordDecisions

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accessReviewScheduleDefinitionId key: id of accessReviewScheduleDefinition
 @param accessReviewInstanceId key: id of accessReviewInstance
 @return ApiIdentityGovernanceAccessReviewsDefinitionsAccessReviewScheduleDefinitionInstancesAccessReviewInstanceBatchRecordDecisionsRequest
*/
func (a *IdentityGovernanceActionsApiService) IdentityGovernanceAccessReviewsDefinitionsAccessReviewScheduleDefinitionInstancesAccessReviewInstanceBatchRecordDecisions(ctx _context.Context, accessReviewScheduleDefinitionId string, accessReviewInstanceId string) ApiIdentityGovernanceAccessReviewsDefinitionsAccessReviewScheduleDefinitionInstancesAccessReviewInstanceBatchRecordDecisionsRequest {
	return ApiIdentityGovernanceAccessReviewsDefinitionsAccessReviewScheduleDefinitionInstancesAccessReviewInstanceBatchRecordDecisionsRequest{
		ApiService: a,
		ctx: ctx,
		accessReviewScheduleDefinitionId: accessReviewScheduleDefinitionId,
		accessReviewInstanceId: accessReviewInstanceId,
	}
}

// Execute executes the request
func (a *IdentityGovernanceActionsApiService) IdentityGovernanceAccessReviewsDefinitionsAccessReviewScheduleDefinitionInstancesAccessReviewInstanceBatchRecordDecisionsExecute(r ApiIdentityGovernanceAccessReviewsDefinitionsAccessReviewScheduleDefinitionInstancesAccessReviewInstanceBatchRecordDecisionsRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IdentityGovernanceActionsApiService.IdentityGovernanceAccessReviewsDefinitionsAccessReviewScheduleDefinitionInstancesAccessReviewInstanceBatchRecordDecisions")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/identityGovernance/accessReviews/definitions/{accessReviewScheduleDefinition-id}/instances/{accessReviewInstance-id}/microsoft.graph.batchRecordDecisions"
	localVarPath = strings.Replace(localVarPath, "{"+"accessReviewScheduleDefinition-id"+"}", _neturl.PathEscape(parameterToString(r.accessReviewScheduleDefinitionId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"accessReviewInstance-id"+"}", _neturl.PathEscape(parameterToString(r.accessReviewInstanceId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject358 == nil {
		return nil, reportError("inlineObject358 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject358
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiIdentityGovernanceAccessReviewsDefinitionsAccessReviewScheduleDefinitionInstancesAccessReviewInstanceResetDecisionsRequest struct {
	ctx _context.Context
	ApiService *IdentityGovernanceActionsApiService
	accessReviewScheduleDefinitionId string
	accessReviewInstanceId string
}


func (r ApiIdentityGovernanceAccessReviewsDefinitionsAccessReviewScheduleDefinitionInstancesAccessReviewInstanceResetDecisionsRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.IdentityGovernanceAccessReviewsDefinitionsAccessReviewScheduleDefinitionInstancesAccessReviewInstanceResetDecisionsExecute(r)
}

/*
IdentityGovernanceAccessReviewsDefinitionsAccessReviewScheduleDefinitionInstancesAccessReviewInstanceResetDecisions Invoke action resetDecisions

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accessReviewScheduleDefinitionId key: id of accessReviewScheduleDefinition
 @param accessReviewInstanceId key: id of accessReviewInstance
 @return ApiIdentityGovernanceAccessReviewsDefinitionsAccessReviewScheduleDefinitionInstancesAccessReviewInstanceResetDecisionsRequest
*/
func (a *IdentityGovernanceActionsApiService) IdentityGovernanceAccessReviewsDefinitionsAccessReviewScheduleDefinitionInstancesAccessReviewInstanceResetDecisions(ctx _context.Context, accessReviewScheduleDefinitionId string, accessReviewInstanceId string) ApiIdentityGovernanceAccessReviewsDefinitionsAccessReviewScheduleDefinitionInstancesAccessReviewInstanceResetDecisionsRequest {
	return ApiIdentityGovernanceAccessReviewsDefinitionsAccessReviewScheduleDefinitionInstancesAccessReviewInstanceResetDecisionsRequest{
		ApiService: a,
		ctx: ctx,
		accessReviewScheduleDefinitionId: accessReviewScheduleDefinitionId,
		accessReviewInstanceId: accessReviewInstanceId,
	}
}

// Execute executes the request
func (a *IdentityGovernanceActionsApiService) IdentityGovernanceAccessReviewsDefinitionsAccessReviewScheduleDefinitionInstancesAccessReviewInstanceResetDecisionsExecute(r ApiIdentityGovernanceAccessReviewsDefinitionsAccessReviewScheduleDefinitionInstancesAccessReviewInstanceResetDecisionsRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IdentityGovernanceActionsApiService.IdentityGovernanceAccessReviewsDefinitionsAccessReviewScheduleDefinitionInstancesAccessReviewInstanceResetDecisions")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/identityGovernance/accessReviews/definitions/{accessReviewScheduleDefinition-id}/instances/{accessReviewInstance-id}/microsoft.graph.resetDecisions"
	localVarPath = strings.Replace(localVarPath, "{"+"accessReviewScheduleDefinition-id"+"}", _neturl.PathEscape(parameterToString(r.accessReviewScheduleDefinitionId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"accessReviewInstance-id"+"}", _neturl.PathEscape(parameterToString(r.accessReviewInstanceId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiIdentityGovernanceAccessReviewsDefinitionsAccessReviewScheduleDefinitionInstancesAccessReviewInstanceSendReminderRequest struct {
	ctx _context.Context
	ApiService *IdentityGovernanceActionsApiService
	accessReviewScheduleDefinitionId string
	accessReviewInstanceId string
}


func (r ApiIdentityGovernanceAccessReviewsDefinitionsAccessReviewScheduleDefinitionInstancesAccessReviewInstanceSendReminderRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.IdentityGovernanceAccessReviewsDefinitionsAccessReviewScheduleDefinitionInstancesAccessReviewInstanceSendReminderExecute(r)
}

/*
IdentityGovernanceAccessReviewsDefinitionsAccessReviewScheduleDefinitionInstancesAccessReviewInstanceSendReminder Invoke action sendReminder

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accessReviewScheduleDefinitionId key: id of accessReviewScheduleDefinition
 @param accessReviewInstanceId key: id of accessReviewInstance
 @return ApiIdentityGovernanceAccessReviewsDefinitionsAccessReviewScheduleDefinitionInstancesAccessReviewInstanceSendReminderRequest
*/
func (a *IdentityGovernanceActionsApiService) IdentityGovernanceAccessReviewsDefinitionsAccessReviewScheduleDefinitionInstancesAccessReviewInstanceSendReminder(ctx _context.Context, accessReviewScheduleDefinitionId string, accessReviewInstanceId string) ApiIdentityGovernanceAccessReviewsDefinitionsAccessReviewScheduleDefinitionInstancesAccessReviewInstanceSendReminderRequest {
	return ApiIdentityGovernanceAccessReviewsDefinitionsAccessReviewScheduleDefinitionInstancesAccessReviewInstanceSendReminderRequest{
		ApiService: a,
		ctx: ctx,
		accessReviewScheduleDefinitionId: accessReviewScheduleDefinitionId,
		accessReviewInstanceId: accessReviewInstanceId,
	}
}

// Execute executes the request
func (a *IdentityGovernanceActionsApiService) IdentityGovernanceAccessReviewsDefinitionsAccessReviewScheduleDefinitionInstancesAccessReviewInstanceSendReminderExecute(r ApiIdentityGovernanceAccessReviewsDefinitionsAccessReviewScheduleDefinitionInstancesAccessReviewInstanceSendReminderRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IdentityGovernanceActionsApiService.IdentityGovernanceAccessReviewsDefinitionsAccessReviewScheduleDefinitionInstancesAccessReviewInstanceSendReminder")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/identityGovernance/accessReviews/definitions/{accessReviewScheduleDefinition-id}/instances/{accessReviewInstance-id}/microsoft.graph.sendReminder"
	localVarPath = strings.Replace(localVarPath, "{"+"accessReviewScheduleDefinition-id"+"}", _neturl.PathEscape(parameterToString(r.accessReviewScheduleDefinitionId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"accessReviewInstance-id"+"}", _neturl.PathEscape(parameterToString(r.accessReviewInstanceId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiIdentityGovernanceAccessReviewsDefinitionsAccessReviewScheduleDefinitionInstancesAccessReviewInstanceStopRequest struct {
	ctx _context.Context
	ApiService *IdentityGovernanceActionsApiService
	accessReviewScheduleDefinitionId string
	accessReviewInstanceId string
}


func (r ApiIdentityGovernanceAccessReviewsDefinitionsAccessReviewScheduleDefinitionInstancesAccessReviewInstanceStopRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.IdentityGovernanceAccessReviewsDefinitionsAccessReviewScheduleDefinitionInstancesAccessReviewInstanceStopExecute(r)
}

/*
IdentityGovernanceAccessReviewsDefinitionsAccessReviewScheduleDefinitionInstancesAccessReviewInstanceStop Invoke action stop

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accessReviewScheduleDefinitionId key: id of accessReviewScheduleDefinition
 @param accessReviewInstanceId key: id of accessReviewInstance
 @return ApiIdentityGovernanceAccessReviewsDefinitionsAccessReviewScheduleDefinitionInstancesAccessReviewInstanceStopRequest
*/
func (a *IdentityGovernanceActionsApiService) IdentityGovernanceAccessReviewsDefinitionsAccessReviewScheduleDefinitionInstancesAccessReviewInstanceStop(ctx _context.Context, accessReviewScheduleDefinitionId string, accessReviewInstanceId string) ApiIdentityGovernanceAccessReviewsDefinitionsAccessReviewScheduleDefinitionInstancesAccessReviewInstanceStopRequest {
	return ApiIdentityGovernanceAccessReviewsDefinitionsAccessReviewScheduleDefinitionInstancesAccessReviewInstanceStopRequest{
		ApiService: a,
		ctx: ctx,
		accessReviewScheduleDefinitionId: accessReviewScheduleDefinitionId,
		accessReviewInstanceId: accessReviewInstanceId,
	}
}

// Execute executes the request
func (a *IdentityGovernanceActionsApiService) IdentityGovernanceAccessReviewsDefinitionsAccessReviewScheduleDefinitionInstancesAccessReviewInstanceStopExecute(r ApiIdentityGovernanceAccessReviewsDefinitionsAccessReviewScheduleDefinitionInstancesAccessReviewInstanceStopRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IdentityGovernanceActionsApiService.IdentityGovernanceAccessReviewsDefinitionsAccessReviewScheduleDefinitionInstancesAccessReviewInstanceStop")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/identityGovernance/accessReviews/definitions/{accessReviewScheduleDefinition-id}/instances/{accessReviewInstance-id}/microsoft.graph.stop"
	localVarPath = strings.Replace(localVarPath, "{"+"accessReviewScheduleDefinition-id"+"}", _neturl.PathEscape(parameterToString(r.accessReviewScheduleDefinitionId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"accessReviewInstance-id"+"}", _neturl.PathEscape(parameterToString(r.accessReviewInstanceId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiIdentityGovernanceAccessReviewsDefinitionsAccessReviewScheduleDefinitionStopRequest struct {
	ctx _context.Context
	ApiService *IdentityGovernanceActionsApiService
	accessReviewScheduleDefinitionId string
}


func (r ApiIdentityGovernanceAccessReviewsDefinitionsAccessReviewScheduleDefinitionStopRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.IdentityGovernanceAccessReviewsDefinitionsAccessReviewScheduleDefinitionStopExecute(r)
}

/*
IdentityGovernanceAccessReviewsDefinitionsAccessReviewScheduleDefinitionStop Invoke action stop

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accessReviewScheduleDefinitionId key: id of accessReviewScheduleDefinition
 @return ApiIdentityGovernanceAccessReviewsDefinitionsAccessReviewScheduleDefinitionStopRequest
*/
func (a *IdentityGovernanceActionsApiService) IdentityGovernanceAccessReviewsDefinitionsAccessReviewScheduleDefinitionStop(ctx _context.Context, accessReviewScheduleDefinitionId string) ApiIdentityGovernanceAccessReviewsDefinitionsAccessReviewScheduleDefinitionStopRequest {
	return ApiIdentityGovernanceAccessReviewsDefinitionsAccessReviewScheduleDefinitionStopRequest{
		ApiService: a,
		ctx: ctx,
		accessReviewScheduleDefinitionId: accessReviewScheduleDefinitionId,
	}
}

// Execute executes the request
func (a *IdentityGovernanceActionsApiService) IdentityGovernanceAccessReviewsDefinitionsAccessReviewScheduleDefinitionStopExecute(r ApiIdentityGovernanceAccessReviewsDefinitionsAccessReviewScheduleDefinitionStopRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IdentityGovernanceActionsApiService.IdentityGovernanceAccessReviewsDefinitionsAccessReviewScheduleDefinitionStop")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/identityGovernance/accessReviews/definitions/{accessReviewScheduleDefinition-id}/microsoft.graph.stop"
	localVarPath = strings.Replace(localVarPath, "{"+"accessReviewScheduleDefinition-id"+"}", _neturl.PathEscape(parameterToString(r.accessReviewScheduleDefinitionId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiIdentityGovernanceEntitlementManagementAccessPackagesAccessPackageGetApplicablePolicyRequirementsRequest struct {
	ctx _context.Context
	ApiService *IdentityGovernanceActionsApiService
	accessPackageId string
}


func (r ApiIdentityGovernanceEntitlementManagementAccessPackagesAccessPackageGetApplicablePolicyRequirementsRequest) Execute() ([]*AnyOfmicrosoftGraphAccessPackageAssignmentRequestRequirements, *_nethttp.Response, error) {
	return r.ApiService.IdentityGovernanceEntitlementManagementAccessPackagesAccessPackageGetApplicablePolicyRequirementsExecute(r)
}

/*
IdentityGovernanceEntitlementManagementAccessPackagesAccessPackageGetApplicablePolicyRequirements Invoke action getApplicablePolicyRequirements

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accessPackageId key: id of accessPackage
 @return ApiIdentityGovernanceEntitlementManagementAccessPackagesAccessPackageGetApplicablePolicyRequirementsRequest
*/
func (a *IdentityGovernanceActionsApiService) IdentityGovernanceEntitlementManagementAccessPackagesAccessPackageGetApplicablePolicyRequirements(ctx _context.Context, accessPackageId string) ApiIdentityGovernanceEntitlementManagementAccessPackagesAccessPackageGetApplicablePolicyRequirementsRequest {
	return ApiIdentityGovernanceEntitlementManagementAccessPackagesAccessPackageGetApplicablePolicyRequirementsRequest{
		ApiService: a,
		ctx: ctx,
		accessPackageId: accessPackageId,
	}
}

// Execute executes the request
//  @return []*AnyOfmicrosoftGraphAccessPackageAssignmentRequestRequirements
func (a *IdentityGovernanceActionsApiService) IdentityGovernanceEntitlementManagementAccessPackagesAccessPackageGetApplicablePolicyRequirementsExecute(r ApiIdentityGovernanceEntitlementManagementAccessPackagesAccessPackageGetApplicablePolicyRequirementsRequest) ([]*AnyOfmicrosoftGraphAccessPackageAssignmentRequestRequirements, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  []*AnyOfmicrosoftGraphAccessPackageAssignmentRequestRequirements
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IdentityGovernanceActionsApiService.IdentityGovernanceEntitlementManagementAccessPackagesAccessPackageGetApplicablePolicyRequirements")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/identityGovernance/entitlementManagement/accessPackages/{accessPackage-id}/microsoft.graph.getApplicablePolicyRequirements"
	localVarPath = strings.Replace(localVarPath, "{"+"accessPackage-id"+"}", _neturl.PathEscape(parameterToString(r.accessPackageId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIdentityGovernanceEntitlementManagementAssignmentRequestsAccessPackageAssignmentRequestAccessPackageGetApplicablePolicyRequirementsRequest struct {
	ctx _context.Context
	ApiService *IdentityGovernanceActionsApiService
	accessPackageAssignmentRequestId string
}


func (r ApiIdentityGovernanceEntitlementManagementAssignmentRequestsAccessPackageAssignmentRequestAccessPackageGetApplicablePolicyRequirementsRequest) Execute() ([]*AnyOfmicrosoftGraphAccessPackageAssignmentRequestRequirements, *_nethttp.Response, error) {
	return r.ApiService.IdentityGovernanceEntitlementManagementAssignmentRequestsAccessPackageAssignmentRequestAccessPackageGetApplicablePolicyRequirementsExecute(r)
}

/*
IdentityGovernanceEntitlementManagementAssignmentRequestsAccessPackageAssignmentRequestAccessPackageGetApplicablePolicyRequirements Invoke action getApplicablePolicyRequirements

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accessPackageAssignmentRequestId key: id of accessPackageAssignmentRequest
 @return ApiIdentityGovernanceEntitlementManagementAssignmentRequestsAccessPackageAssignmentRequestAccessPackageGetApplicablePolicyRequirementsRequest
*/
func (a *IdentityGovernanceActionsApiService) IdentityGovernanceEntitlementManagementAssignmentRequestsAccessPackageAssignmentRequestAccessPackageGetApplicablePolicyRequirements(ctx _context.Context, accessPackageAssignmentRequestId string) ApiIdentityGovernanceEntitlementManagementAssignmentRequestsAccessPackageAssignmentRequestAccessPackageGetApplicablePolicyRequirementsRequest {
	return ApiIdentityGovernanceEntitlementManagementAssignmentRequestsAccessPackageAssignmentRequestAccessPackageGetApplicablePolicyRequirementsRequest{
		ApiService: a,
		ctx: ctx,
		accessPackageAssignmentRequestId: accessPackageAssignmentRequestId,
	}
}

// Execute executes the request
//  @return []*AnyOfmicrosoftGraphAccessPackageAssignmentRequestRequirements
func (a *IdentityGovernanceActionsApiService) IdentityGovernanceEntitlementManagementAssignmentRequestsAccessPackageAssignmentRequestAccessPackageGetApplicablePolicyRequirementsExecute(r ApiIdentityGovernanceEntitlementManagementAssignmentRequestsAccessPackageAssignmentRequestAccessPackageGetApplicablePolicyRequirementsRequest) ([]*AnyOfmicrosoftGraphAccessPackageAssignmentRequestRequirements, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  []*AnyOfmicrosoftGraphAccessPackageAssignmentRequestRequirements
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IdentityGovernanceActionsApiService.IdentityGovernanceEntitlementManagementAssignmentRequestsAccessPackageAssignmentRequestAccessPackageGetApplicablePolicyRequirements")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/identityGovernance/entitlementManagement/assignmentRequests/{accessPackageAssignmentRequest-id}/accessPackage/microsoft.graph.getApplicablePolicyRequirements"
	localVarPath = strings.Replace(localVarPath, "{"+"accessPackageAssignmentRequest-id"+"}", _neturl.PathEscape(parameterToString(r.accessPackageAssignmentRequestId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIdentityGovernanceEntitlementManagementAssignmentRequestsAccessPackageAssignmentRequestCancelRequest struct {
	ctx _context.Context
	ApiService *IdentityGovernanceActionsApiService
	accessPackageAssignmentRequestId string
}


func (r ApiIdentityGovernanceEntitlementManagementAssignmentRequestsAccessPackageAssignmentRequestCancelRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.IdentityGovernanceEntitlementManagementAssignmentRequestsAccessPackageAssignmentRequestCancelExecute(r)
}

/*
IdentityGovernanceEntitlementManagementAssignmentRequestsAccessPackageAssignmentRequestCancel Invoke action cancel

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accessPackageAssignmentRequestId key: id of accessPackageAssignmentRequest
 @return ApiIdentityGovernanceEntitlementManagementAssignmentRequestsAccessPackageAssignmentRequestCancelRequest
*/
func (a *IdentityGovernanceActionsApiService) IdentityGovernanceEntitlementManagementAssignmentRequestsAccessPackageAssignmentRequestCancel(ctx _context.Context, accessPackageAssignmentRequestId string) ApiIdentityGovernanceEntitlementManagementAssignmentRequestsAccessPackageAssignmentRequestCancelRequest {
	return ApiIdentityGovernanceEntitlementManagementAssignmentRequestsAccessPackageAssignmentRequestCancelRequest{
		ApiService: a,
		ctx: ctx,
		accessPackageAssignmentRequestId: accessPackageAssignmentRequestId,
	}
}

// Execute executes the request
func (a *IdentityGovernanceActionsApiService) IdentityGovernanceEntitlementManagementAssignmentRequestsAccessPackageAssignmentRequestCancelExecute(r ApiIdentityGovernanceEntitlementManagementAssignmentRequestsAccessPackageAssignmentRequestCancelRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IdentityGovernanceActionsApiService.IdentityGovernanceEntitlementManagementAssignmentRequestsAccessPackageAssignmentRequestCancel")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/identityGovernance/entitlementManagement/assignmentRequests/{accessPackageAssignmentRequest-id}/microsoft.graph.cancel"
	localVarPath = strings.Replace(localVarPath, "{"+"accessPackageAssignmentRequest-id"+"}", _neturl.PathEscape(parameterToString(r.accessPackageAssignmentRequestId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiIdentityGovernanceEntitlementManagementAssignmentsAccessPackageAssignmentAccessPackageGetApplicablePolicyRequirementsRequest struct {
	ctx _context.Context
	ApiService *IdentityGovernanceActionsApiService
	accessPackageAssignmentId string
}


func (r ApiIdentityGovernanceEntitlementManagementAssignmentsAccessPackageAssignmentAccessPackageGetApplicablePolicyRequirementsRequest) Execute() ([]*AnyOfmicrosoftGraphAccessPackageAssignmentRequestRequirements, *_nethttp.Response, error) {
	return r.ApiService.IdentityGovernanceEntitlementManagementAssignmentsAccessPackageAssignmentAccessPackageGetApplicablePolicyRequirementsExecute(r)
}

/*
IdentityGovernanceEntitlementManagementAssignmentsAccessPackageAssignmentAccessPackageGetApplicablePolicyRequirements Invoke action getApplicablePolicyRequirements

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accessPackageAssignmentId key: id of accessPackageAssignment
 @return ApiIdentityGovernanceEntitlementManagementAssignmentsAccessPackageAssignmentAccessPackageGetApplicablePolicyRequirementsRequest
*/
func (a *IdentityGovernanceActionsApiService) IdentityGovernanceEntitlementManagementAssignmentsAccessPackageAssignmentAccessPackageGetApplicablePolicyRequirements(ctx _context.Context, accessPackageAssignmentId string) ApiIdentityGovernanceEntitlementManagementAssignmentsAccessPackageAssignmentAccessPackageGetApplicablePolicyRequirementsRequest {
	return ApiIdentityGovernanceEntitlementManagementAssignmentsAccessPackageAssignmentAccessPackageGetApplicablePolicyRequirementsRequest{
		ApiService: a,
		ctx: ctx,
		accessPackageAssignmentId: accessPackageAssignmentId,
	}
}

// Execute executes the request
//  @return []*AnyOfmicrosoftGraphAccessPackageAssignmentRequestRequirements
func (a *IdentityGovernanceActionsApiService) IdentityGovernanceEntitlementManagementAssignmentsAccessPackageAssignmentAccessPackageGetApplicablePolicyRequirementsExecute(r ApiIdentityGovernanceEntitlementManagementAssignmentsAccessPackageAssignmentAccessPackageGetApplicablePolicyRequirementsRequest) ([]*AnyOfmicrosoftGraphAccessPackageAssignmentRequestRequirements, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  []*AnyOfmicrosoftGraphAccessPackageAssignmentRequestRequirements
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IdentityGovernanceActionsApiService.IdentityGovernanceEntitlementManagementAssignmentsAccessPackageAssignmentAccessPackageGetApplicablePolicyRequirements")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/identityGovernance/entitlementManagement/assignments/{accessPackageAssignment-id}/accessPackage/microsoft.graph.getApplicablePolicyRequirements"
	localVarPath = strings.Replace(localVarPath, "{"+"accessPackageAssignment-id"+"}", _neturl.PathEscape(parameterToString(r.accessPackageAssignmentId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIdentityGovernanceEntitlementManagementCatalogsAccessPackageCatalogAccessPackagesAccessPackageGetApplicablePolicyRequirementsRequest struct {
	ctx _context.Context
	ApiService *IdentityGovernanceActionsApiService
	accessPackageCatalogId string
	accessPackageId string
}


func (r ApiIdentityGovernanceEntitlementManagementCatalogsAccessPackageCatalogAccessPackagesAccessPackageGetApplicablePolicyRequirementsRequest) Execute() ([]*AnyOfmicrosoftGraphAccessPackageAssignmentRequestRequirements, *_nethttp.Response, error) {
	return r.ApiService.IdentityGovernanceEntitlementManagementCatalogsAccessPackageCatalogAccessPackagesAccessPackageGetApplicablePolicyRequirementsExecute(r)
}

/*
IdentityGovernanceEntitlementManagementCatalogsAccessPackageCatalogAccessPackagesAccessPackageGetApplicablePolicyRequirements Invoke action getApplicablePolicyRequirements

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accessPackageCatalogId key: id of accessPackageCatalog
 @param accessPackageId key: id of accessPackage
 @return ApiIdentityGovernanceEntitlementManagementCatalogsAccessPackageCatalogAccessPackagesAccessPackageGetApplicablePolicyRequirementsRequest
*/
func (a *IdentityGovernanceActionsApiService) IdentityGovernanceEntitlementManagementCatalogsAccessPackageCatalogAccessPackagesAccessPackageGetApplicablePolicyRequirements(ctx _context.Context, accessPackageCatalogId string, accessPackageId string) ApiIdentityGovernanceEntitlementManagementCatalogsAccessPackageCatalogAccessPackagesAccessPackageGetApplicablePolicyRequirementsRequest {
	return ApiIdentityGovernanceEntitlementManagementCatalogsAccessPackageCatalogAccessPackagesAccessPackageGetApplicablePolicyRequirementsRequest{
		ApiService: a,
		ctx: ctx,
		accessPackageCatalogId: accessPackageCatalogId,
		accessPackageId: accessPackageId,
	}
}

// Execute executes the request
//  @return []*AnyOfmicrosoftGraphAccessPackageAssignmentRequestRequirements
func (a *IdentityGovernanceActionsApiService) IdentityGovernanceEntitlementManagementCatalogsAccessPackageCatalogAccessPackagesAccessPackageGetApplicablePolicyRequirementsExecute(r ApiIdentityGovernanceEntitlementManagementCatalogsAccessPackageCatalogAccessPackagesAccessPackageGetApplicablePolicyRequirementsRequest) ([]*AnyOfmicrosoftGraphAccessPackageAssignmentRequestRequirements, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  []*AnyOfmicrosoftGraphAccessPackageAssignmentRequestRequirements
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IdentityGovernanceActionsApiService.IdentityGovernanceEntitlementManagementCatalogsAccessPackageCatalogAccessPackagesAccessPackageGetApplicablePolicyRequirements")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/identityGovernance/entitlementManagement/catalogs/{accessPackageCatalog-id}/accessPackages/{accessPackage-id}/microsoft.graph.getApplicablePolicyRequirements"
	localVarPath = strings.Replace(localVarPath, "{"+"accessPackageCatalog-id"+"}", _neturl.PathEscape(parameterToString(r.accessPackageCatalogId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"accessPackage-id"+"}", _neturl.PathEscape(parameterToString(r.accessPackageId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
