/*
Partial Graph API

No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

API version: v1.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package msgraph

import (
	"bytes"
	_context "context"
	_ioutil "io/ioutil"
	_nethttp "net/http"
	_neturl "net/url"
	"strings"
)

// Linger please
var (
	_ _context.Context
)

// IdentityGovernanceAccessReviewSetApiService IdentityGovernanceAccessReviewSetApi service
type IdentityGovernanceAccessReviewSetApiService service

type ApiIdentityGovernanceAccessReviewsCreateDefinitionsRequest struct {
	ctx _context.Context
	ApiService *IdentityGovernanceAccessReviewSetApiService
	microsoftGraphAccessReviewScheduleDefinition *MicrosoftGraphAccessReviewScheduleDefinition
}

// New navigation property
func (r ApiIdentityGovernanceAccessReviewsCreateDefinitionsRequest) MicrosoftGraphAccessReviewScheduleDefinition(microsoftGraphAccessReviewScheduleDefinition MicrosoftGraphAccessReviewScheduleDefinition) ApiIdentityGovernanceAccessReviewsCreateDefinitionsRequest {
	r.microsoftGraphAccessReviewScheduleDefinition = &microsoftGraphAccessReviewScheduleDefinition
	return r
}

func (r ApiIdentityGovernanceAccessReviewsCreateDefinitionsRequest) Execute() (MicrosoftGraphAccessReviewScheduleDefinition, *_nethttp.Response, error) {
	return r.ApiService.IdentityGovernanceAccessReviewsCreateDefinitionsExecute(r)
}

/*
IdentityGovernanceAccessReviewsCreateDefinitions Create new navigation property to definitions for identityGovernance

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiIdentityGovernanceAccessReviewsCreateDefinitionsRequest
*/
func (a *IdentityGovernanceAccessReviewSetApiService) IdentityGovernanceAccessReviewsCreateDefinitions(ctx _context.Context) ApiIdentityGovernanceAccessReviewsCreateDefinitionsRequest {
	return ApiIdentityGovernanceAccessReviewsCreateDefinitionsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return MicrosoftGraphAccessReviewScheduleDefinition
func (a *IdentityGovernanceAccessReviewSetApiService) IdentityGovernanceAccessReviewsCreateDefinitionsExecute(r ApiIdentityGovernanceAccessReviewsCreateDefinitionsRequest) (MicrosoftGraphAccessReviewScheduleDefinition, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphAccessReviewScheduleDefinition
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IdentityGovernanceAccessReviewSetApiService.IdentityGovernanceAccessReviewsCreateDefinitions")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/identityGovernance/accessReviews/definitions"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphAccessReviewScheduleDefinition == nil {
		return localVarReturnValue, nil, reportError("microsoftGraphAccessReviewScheduleDefinition is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphAccessReviewScheduleDefinition
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIdentityGovernanceAccessReviewsDefinitionsCreateInstancesRequest struct {
	ctx _context.Context
	ApiService *IdentityGovernanceAccessReviewSetApiService
	accessReviewScheduleDefinitionId string
	microsoftGraphAccessReviewInstance *MicrosoftGraphAccessReviewInstance
}

// New navigation property
func (r ApiIdentityGovernanceAccessReviewsDefinitionsCreateInstancesRequest) MicrosoftGraphAccessReviewInstance(microsoftGraphAccessReviewInstance MicrosoftGraphAccessReviewInstance) ApiIdentityGovernanceAccessReviewsDefinitionsCreateInstancesRequest {
	r.microsoftGraphAccessReviewInstance = &microsoftGraphAccessReviewInstance
	return r
}

func (r ApiIdentityGovernanceAccessReviewsDefinitionsCreateInstancesRequest) Execute() (MicrosoftGraphAccessReviewInstance, *_nethttp.Response, error) {
	return r.ApiService.IdentityGovernanceAccessReviewsDefinitionsCreateInstancesExecute(r)
}

/*
IdentityGovernanceAccessReviewsDefinitionsCreateInstances Create new navigation property to instances for identityGovernance

If the accessReviewScheduleDefinition is a recurring access review, instances represent each recurrence. A review that does not recur will have exactly one instance. Instances also represent each unique resource under review in the accessReviewScheduleDefinition. If a review has multiple resources and multiple instances, each resource will have a unique instance for each recurrence.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accessReviewScheduleDefinitionId key: id of accessReviewScheduleDefinition
 @return ApiIdentityGovernanceAccessReviewsDefinitionsCreateInstancesRequest
*/
func (a *IdentityGovernanceAccessReviewSetApiService) IdentityGovernanceAccessReviewsDefinitionsCreateInstances(ctx _context.Context, accessReviewScheduleDefinitionId string) ApiIdentityGovernanceAccessReviewsDefinitionsCreateInstancesRequest {
	return ApiIdentityGovernanceAccessReviewsDefinitionsCreateInstancesRequest{
		ApiService: a,
		ctx: ctx,
		accessReviewScheduleDefinitionId: accessReviewScheduleDefinitionId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphAccessReviewInstance
func (a *IdentityGovernanceAccessReviewSetApiService) IdentityGovernanceAccessReviewsDefinitionsCreateInstancesExecute(r ApiIdentityGovernanceAccessReviewsDefinitionsCreateInstancesRequest) (MicrosoftGraphAccessReviewInstance, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphAccessReviewInstance
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IdentityGovernanceAccessReviewSetApiService.IdentityGovernanceAccessReviewsDefinitionsCreateInstances")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/identityGovernance/accessReviews/definitions/{accessReviewScheduleDefinition-id}/instances"
	localVarPath = strings.Replace(localVarPath, "{"+"accessReviewScheduleDefinition-id"+"}", _neturl.PathEscape(parameterToString(r.accessReviewScheduleDefinitionId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphAccessReviewInstance == nil {
		return localVarReturnValue, nil, reportError("microsoftGraphAccessReviewInstance is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphAccessReviewInstance
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIdentityGovernanceAccessReviewsDefinitionsDeleteInstancesRequest struct {
	ctx _context.Context
	ApiService *IdentityGovernanceAccessReviewSetApiService
	accessReviewScheduleDefinitionId string
	accessReviewInstanceId string
	ifMatch *string
}

// ETag
func (r ApiIdentityGovernanceAccessReviewsDefinitionsDeleteInstancesRequest) IfMatch(ifMatch string) ApiIdentityGovernanceAccessReviewsDefinitionsDeleteInstancesRequest {
	r.ifMatch = &ifMatch
	return r
}

func (r ApiIdentityGovernanceAccessReviewsDefinitionsDeleteInstancesRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.IdentityGovernanceAccessReviewsDefinitionsDeleteInstancesExecute(r)
}

/*
IdentityGovernanceAccessReviewsDefinitionsDeleteInstances Delete navigation property instances for identityGovernance

If the accessReviewScheduleDefinition is a recurring access review, instances represent each recurrence. A review that does not recur will have exactly one instance. Instances also represent each unique resource under review in the accessReviewScheduleDefinition. If a review has multiple resources and multiple instances, each resource will have a unique instance for each recurrence.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accessReviewScheduleDefinitionId key: id of accessReviewScheduleDefinition
 @param accessReviewInstanceId key: id of accessReviewInstance
 @return ApiIdentityGovernanceAccessReviewsDefinitionsDeleteInstancesRequest
*/
func (a *IdentityGovernanceAccessReviewSetApiService) IdentityGovernanceAccessReviewsDefinitionsDeleteInstances(ctx _context.Context, accessReviewScheduleDefinitionId string, accessReviewInstanceId string) ApiIdentityGovernanceAccessReviewsDefinitionsDeleteInstancesRequest {
	return ApiIdentityGovernanceAccessReviewsDefinitionsDeleteInstancesRequest{
		ApiService: a,
		ctx: ctx,
		accessReviewScheduleDefinitionId: accessReviewScheduleDefinitionId,
		accessReviewInstanceId: accessReviewInstanceId,
	}
}

// Execute executes the request
func (a *IdentityGovernanceAccessReviewSetApiService) IdentityGovernanceAccessReviewsDefinitionsDeleteInstancesExecute(r ApiIdentityGovernanceAccessReviewsDefinitionsDeleteInstancesRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IdentityGovernanceAccessReviewSetApiService.IdentityGovernanceAccessReviewsDefinitionsDeleteInstances")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/identityGovernance/accessReviews/definitions/{accessReviewScheduleDefinition-id}/instances/{accessReviewInstance-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"accessReviewScheduleDefinition-id"+"}", _neturl.PathEscape(parameterToString(r.accessReviewScheduleDefinitionId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"accessReviewInstance-id"+"}", _neturl.PathEscape(parameterToString(r.accessReviewInstanceId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ifMatch != nil {
		localVarHeaderParams["If-Match"] = parameterToString(*r.ifMatch, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiIdentityGovernanceAccessReviewsDefinitionsGetInstancesRequest struct {
	ctx _context.Context
	ApiService *IdentityGovernanceAccessReviewSetApiService
	accessReviewScheduleDefinitionId string
	accessReviewInstanceId string
	select_ *[]string
	expand *[]string
}

// Select properties to be returned
func (r ApiIdentityGovernanceAccessReviewsDefinitionsGetInstancesRequest) Select_(select_ []string) ApiIdentityGovernanceAccessReviewsDefinitionsGetInstancesRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiIdentityGovernanceAccessReviewsDefinitionsGetInstancesRequest) Expand(expand []string) ApiIdentityGovernanceAccessReviewsDefinitionsGetInstancesRequest {
	r.expand = &expand
	return r
}

func (r ApiIdentityGovernanceAccessReviewsDefinitionsGetInstancesRequest) Execute() (MicrosoftGraphAccessReviewInstance, *_nethttp.Response, error) {
	return r.ApiService.IdentityGovernanceAccessReviewsDefinitionsGetInstancesExecute(r)
}

/*
IdentityGovernanceAccessReviewsDefinitionsGetInstances Get instances from identityGovernance

If the accessReviewScheduleDefinition is a recurring access review, instances represent each recurrence. A review that does not recur will have exactly one instance. Instances also represent each unique resource under review in the accessReviewScheduleDefinition. If a review has multiple resources and multiple instances, each resource will have a unique instance for each recurrence.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accessReviewScheduleDefinitionId key: id of accessReviewScheduleDefinition
 @param accessReviewInstanceId key: id of accessReviewInstance
 @return ApiIdentityGovernanceAccessReviewsDefinitionsGetInstancesRequest
*/
func (a *IdentityGovernanceAccessReviewSetApiService) IdentityGovernanceAccessReviewsDefinitionsGetInstances(ctx _context.Context, accessReviewScheduleDefinitionId string, accessReviewInstanceId string) ApiIdentityGovernanceAccessReviewsDefinitionsGetInstancesRequest {
	return ApiIdentityGovernanceAccessReviewsDefinitionsGetInstancesRequest{
		ApiService: a,
		ctx: ctx,
		accessReviewScheduleDefinitionId: accessReviewScheduleDefinitionId,
		accessReviewInstanceId: accessReviewInstanceId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphAccessReviewInstance
func (a *IdentityGovernanceAccessReviewSetApiService) IdentityGovernanceAccessReviewsDefinitionsGetInstancesExecute(r ApiIdentityGovernanceAccessReviewsDefinitionsGetInstancesRequest) (MicrosoftGraphAccessReviewInstance, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphAccessReviewInstance
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IdentityGovernanceAccessReviewSetApiService.IdentityGovernanceAccessReviewsDefinitionsGetInstances")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/identityGovernance/accessReviews/definitions/{accessReviewScheduleDefinition-id}/instances/{accessReviewInstance-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"accessReviewScheduleDefinition-id"+"}", _neturl.PathEscape(parameterToString(r.accessReviewScheduleDefinitionId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"accessReviewInstance-id"+"}", _neturl.PathEscape(parameterToString(r.accessReviewInstanceId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIdentityGovernanceAccessReviewsDefinitionsInstancesCreateDecisionsRequest struct {
	ctx _context.Context
	ApiService *IdentityGovernanceAccessReviewSetApiService
	accessReviewScheduleDefinitionId string
	accessReviewInstanceId string
	microsoftGraphAccessReviewInstanceDecisionItem *MicrosoftGraphAccessReviewInstanceDecisionItem
}

// New navigation property
func (r ApiIdentityGovernanceAccessReviewsDefinitionsInstancesCreateDecisionsRequest) MicrosoftGraphAccessReviewInstanceDecisionItem(microsoftGraphAccessReviewInstanceDecisionItem MicrosoftGraphAccessReviewInstanceDecisionItem) ApiIdentityGovernanceAccessReviewsDefinitionsInstancesCreateDecisionsRequest {
	r.microsoftGraphAccessReviewInstanceDecisionItem = &microsoftGraphAccessReviewInstanceDecisionItem
	return r
}

func (r ApiIdentityGovernanceAccessReviewsDefinitionsInstancesCreateDecisionsRequest) Execute() (MicrosoftGraphAccessReviewInstanceDecisionItem, *_nethttp.Response, error) {
	return r.ApiService.IdentityGovernanceAccessReviewsDefinitionsInstancesCreateDecisionsExecute(r)
}

/*
IdentityGovernanceAccessReviewsDefinitionsInstancesCreateDecisions Create new navigation property to decisions for identityGovernance

Each principal reviewed in an accessReviewInstance has a decision item representing if they were approved, denied, or not yet reviewed.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accessReviewScheduleDefinitionId key: id of accessReviewScheduleDefinition
 @param accessReviewInstanceId key: id of accessReviewInstance
 @return ApiIdentityGovernanceAccessReviewsDefinitionsInstancesCreateDecisionsRequest
*/
func (a *IdentityGovernanceAccessReviewSetApiService) IdentityGovernanceAccessReviewsDefinitionsInstancesCreateDecisions(ctx _context.Context, accessReviewScheduleDefinitionId string, accessReviewInstanceId string) ApiIdentityGovernanceAccessReviewsDefinitionsInstancesCreateDecisionsRequest {
	return ApiIdentityGovernanceAccessReviewsDefinitionsInstancesCreateDecisionsRequest{
		ApiService: a,
		ctx: ctx,
		accessReviewScheduleDefinitionId: accessReviewScheduleDefinitionId,
		accessReviewInstanceId: accessReviewInstanceId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphAccessReviewInstanceDecisionItem
func (a *IdentityGovernanceAccessReviewSetApiService) IdentityGovernanceAccessReviewsDefinitionsInstancesCreateDecisionsExecute(r ApiIdentityGovernanceAccessReviewsDefinitionsInstancesCreateDecisionsRequest) (MicrosoftGraphAccessReviewInstanceDecisionItem, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphAccessReviewInstanceDecisionItem
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IdentityGovernanceAccessReviewSetApiService.IdentityGovernanceAccessReviewsDefinitionsInstancesCreateDecisions")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/identityGovernance/accessReviews/definitions/{accessReviewScheduleDefinition-id}/instances/{accessReviewInstance-id}/decisions"
	localVarPath = strings.Replace(localVarPath, "{"+"accessReviewScheduleDefinition-id"+"}", _neturl.PathEscape(parameterToString(r.accessReviewScheduleDefinitionId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"accessReviewInstance-id"+"}", _neturl.PathEscape(parameterToString(r.accessReviewInstanceId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphAccessReviewInstanceDecisionItem == nil {
		return localVarReturnValue, nil, reportError("microsoftGraphAccessReviewInstanceDecisionItem is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphAccessReviewInstanceDecisionItem
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIdentityGovernanceAccessReviewsDefinitionsInstancesDeleteDecisionsRequest struct {
	ctx _context.Context
	ApiService *IdentityGovernanceAccessReviewSetApiService
	accessReviewScheduleDefinitionId string
	accessReviewInstanceId string
	accessReviewInstanceDecisionItemId string
	ifMatch *string
}

// ETag
func (r ApiIdentityGovernanceAccessReviewsDefinitionsInstancesDeleteDecisionsRequest) IfMatch(ifMatch string) ApiIdentityGovernanceAccessReviewsDefinitionsInstancesDeleteDecisionsRequest {
	r.ifMatch = &ifMatch
	return r
}

func (r ApiIdentityGovernanceAccessReviewsDefinitionsInstancesDeleteDecisionsRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.IdentityGovernanceAccessReviewsDefinitionsInstancesDeleteDecisionsExecute(r)
}

/*
IdentityGovernanceAccessReviewsDefinitionsInstancesDeleteDecisions Delete navigation property decisions for identityGovernance

Each principal reviewed in an accessReviewInstance has a decision item representing if they were approved, denied, or not yet reviewed.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accessReviewScheduleDefinitionId key: id of accessReviewScheduleDefinition
 @param accessReviewInstanceId key: id of accessReviewInstance
 @param accessReviewInstanceDecisionItemId key: id of accessReviewInstanceDecisionItem
 @return ApiIdentityGovernanceAccessReviewsDefinitionsInstancesDeleteDecisionsRequest
*/
func (a *IdentityGovernanceAccessReviewSetApiService) IdentityGovernanceAccessReviewsDefinitionsInstancesDeleteDecisions(ctx _context.Context, accessReviewScheduleDefinitionId string, accessReviewInstanceId string, accessReviewInstanceDecisionItemId string) ApiIdentityGovernanceAccessReviewsDefinitionsInstancesDeleteDecisionsRequest {
	return ApiIdentityGovernanceAccessReviewsDefinitionsInstancesDeleteDecisionsRequest{
		ApiService: a,
		ctx: ctx,
		accessReviewScheduleDefinitionId: accessReviewScheduleDefinitionId,
		accessReviewInstanceId: accessReviewInstanceId,
		accessReviewInstanceDecisionItemId: accessReviewInstanceDecisionItemId,
	}
}

// Execute executes the request
func (a *IdentityGovernanceAccessReviewSetApiService) IdentityGovernanceAccessReviewsDefinitionsInstancesDeleteDecisionsExecute(r ApiIdentityGovernanceAccessReviewsDefinitionsInstancesDeleteDecisionsRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IdentityGovernanceAccessReviewSetApiService.IdentityGovernanceAccessReviewsDefinitionsInstancesDeleteDecisions")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/identityGovernance/accessReviews/definitions/{accessReviewScheduleDefinition-id}/instances/{accessReviewInstance-id}/decisions/{accessReviewInstanceDecisionItem-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"accessReviewScheduleDefinition-id"+"}", _neturl.PathEscape(parameterToString(r.accessReviewScheduleDefinitionId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"accessReviewInstance-id"+"}", _neturl.PathEscape(parameterToString(r.accessReviewInstanceId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"accessReviewInstanceDecisionItem-id"+"}", _neturl.PathEscape(parameterToString(r.accessReviewInstanceDecisionItemId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ifMatch != nil {
		localVarHeaderParams["If-Match"] = parameterToString(*r.ifMatch, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiIdentityGovernanceAccessReviewsDefinitionsInstancesGetDecisionsRequest struct {
	ctx _context.Context
	ApiService *IdentityGovernanceAccessReviewSetApiService
	accessReviewScheduleDefinitionId string
	accessReviewInstanceId string
	accessReviewInstanceDecisionItemId string
	select_ *[]string
	expand *[]string
}

// Select properties to be returned
func (r ApiIdentityGovernanceAccessReviewsDefinitionsInstancesGetDecisionsRequest) Select_(select_ []string) ApiIdentityGovernanceAccessReviewsDefinitionsInstancesGetDecisionsRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiIdentityGovernanceAccessReviewsDefinitionsInstancesGetDecisionsRequest) Expand(expand []string) ApiIdentityGovernanceAccessReviewsDefinitionsInstancesGetDecisionsRequest {
	r.expand = &expand
	return r
}

func (r ApiIdentityGovernanceAccessReviewsDefinitionsInstancesGetDecisionsRequest) Execute() (MicrosoftGraphAccessReviewInstanceDecisionItem, *_nethttp.Response, error) {
	return r.ApiService.IdentityGovernanceAccessReviewsDefinitionsInstancesGetDecisionsExecute(r)
}

/*
IdentityGovernanceAccessReviewsDefinitionsInstancesGetDecisions Get decisions from identityGovernance

Each principal reviewed in an accessReviewInstance has a decision item representing if they were approved, denied, or not yet reviewed.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accessReviewScheduleDefinitionId key: id of accessReviewScheduleDefinition
 @param accessReviewInstanceId key: id of accessReviewInstance
 @param accessReviewInstanceDecisionItemId key: id of accessReviewInstanceDecisionItem
 @return ApiIdentityGovernanceAccessReviewsDefinitionsInstancesGetDecisionsRequest
*/
func (a *IdentityGovernanceAccessReviewSetApiService) IdentityGovernanceAccessReviewsDefinitionsInstancesGetDecisions(ctx _context.Context, accessReviewScheduleDefinitionId string, accessReviewInstanceId string, accessReviewInstanceDecisionItemId string) ApiIdentityGovernanceAccessReviewsDefinitionsInstancesGetDecisionsRequest {
	return ApiIdentityGovernanceAccessReviewsDefinitionsInstancesGetDecisionsRequest{
		ApiService: a,
		ctx: ctx,
		accessReviewScheduleDefinitionId: accessReviewScheduleDefinitionId,
		accessReviewInstanceId: accessReviewInstanceId,
		accessReviewInstanceDecisionItemId: accessReviewInstanceDecisionItemId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphAccessReviewInstanceDecisionItem
func (a *IdentityGovernanceAccessReviewSetApiService) IdentityGovernanceAccessReviewsDefinitionsInstancesGetDecisionsExecute(r ApiIdentityGovernanceAccessReviewsDefinitionsInstancesGetDecisionsRequest) (MicrosoftGraphAccessReviewInstanceDecisionItem, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphAccessReviewInstanceDecisionItem
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IdentityGovernanceAccessReviewSetApiService.IdentityGovernanceAccessReviewsDefinitionsInstancesGetDecisions")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/identityGovernance/accessReviews/definitions/{accessReviewScheduleDefinition-id}/instances/{accessReviewInstance-id}/decisions/{accessReviewInstanceDecisionItem-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"accessReviewScheduleDefinition-id"+"}", _neturl.PathEscape(parameterToString(r.accessReviewScheduleDefinitionId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"accessReviewInstance-id"+"}", _neturl.PathEscape(parameterToString(r.accessReviewInstanceId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"accessReviewInstanceDecisionItem-id"+"}", _neturl.PathEscape(parameterToString(r.accessReviewInstanceDecisionItemId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIdentityGovernanceAccessReviewsDefinitionsInstancesListDecisionsRequest struct {
	ctx _context.Context
	ApiService *IdentityGovernanceAccessReviewSetApiService
	accessReviewScheduleDefinitionId string
	accessReviewInstanceId string
	top *int32
	skip *int32
	search *string
	filter *string
	count *bool
	orderby *[]string
	select_ *[]string
	expand *[]string
}

// Show only the first n items
func (r ApiIdentityGovernanceAccessReviewsDefinitionsInstancesListDecisionsRequest) Top(top int32) ApiIdentityGovernanceAccessReviewsDefinitionsInstancesListDecisionsRequest {
	r.top = &top
	return r
}
// Skip the first n items
func (r ApiIdentityGovernanceAccessReviewsDefinitionsInstancesListDecisionsRequest) Skip(skip int32) ApiIdentityGovernanceAccessReviewsDefinitionsInstancesListDecisionsRequest {
	r.skip = &skip
	return r
}
// Search items by search phrases
func (r ApiIdentityGovernanceAccessReviewsDefinitionsInstancesListDecisionsRequest) Search(search string) ApiIdentityGovernanceAccessReviewsDefinitionsInstancesListDecisionsRequest {
	r.search = &search
	return r
}
// Filter items by property values
func (r ApiIdentityGovernanceAccessReviewsDefinitionsInstancesListDecisionsRequest) Filter(filter string) ApiIdentityGovernanceAccessReviewsDefinitionsInstancesListDecisionsRequest {
	r.filter = &filter
	return r
}
// Include count of items
func (r ApiIdentityGovernanceAccessReviewsDefinitionsInstancesListDecisionsRequest) Count(count bool) ApiIdentityGovernanceAccessReviewsDefinitionsInstancesListDecisionsRequest {
	r.count = &count
	return r
}
// Order items by property values
func (r ApiIdentityGovernanceAccessReviewsDefinitionsInstancesListDecisionsRequest) Orderby(orderby []string) ApiIdentityGovernanceAccessReviewsDefinitionsInstancesListDecisionsRequest {
	r.orderby = &orderby
	return r
}
// Select properties to be returned
func (r ApiIdentityGovernanceAccessReviewsDefinitionsInstancesListDecisionsRequest) Select_(select_ []string) ApiIdentityGovernanceAccessReviewsDefinitionsInstancesListDecisionsRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiIdentityGovernanceAccessReviewsDefinitionsInstancesListDecisionsRequest) Expand(expand []string) ApiIdentityGovernanceAccessReviewsDefinitionsInstancesListDecisionsRequest {
	r.expand = &expand
	return r
}

func (r ApiIdentityGovernanceAccessReviewsDefinitionsInstancesListDecisionsRequest) Execute() (CollectionOfAccessReviewInstanceDecisionItem, *_nethttp.Response, error) {
	return r.ApiService.IdentityGovernanceAccessReviewsDefinitionsInstancesListDecisionsExecute(r)
}

/*
IdentityGovernanceAccessReviewsDefinitionsInstancesListDecisions Get decisions from identityGovernance

Each principal reviewed in an accessReviewInstance has a decision item representing if they were approved, denied, or not yet reviewed.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accessReviewScheduleDefinitionId key: id of accessReviewScheduleDefinition
 @param accessReviewInstanceId key: id of accessReviewInstance
 @return ApiIdentityGovernanceAccessReviewsDefinitionsInstancesListDecisionsRequest
*/
func (a *IdentityGovernanceAccessReviewSetApiService) IdentityGovernanceAccessReviewsDefinitionsInstancesListDecisions(ctx _context.Context, accessReviewScheduleDefinitionId string, accessReviewInstanceId string) ApiIdentityGovernanceAccessReviewsDefinitionsInstancesListDecisionsRequest {
	return ApiIdentityGovernanceAccessReviewsDefinitionsInstancesListDecisionsRequest{
		ApiService: a,
		ctx: ctx,
		accessReviewScheduleDefinitionId: accessReviewScheduleDefinitionId,
		accessReviewInstanceId: accessReviewInstanceId,
	}
}

// Execute executes the request
//  @return CollectionOfAccessReviewInstanceDecisionItem
func (a *IdentityGovernanceAccessReviewSetApiService) IdentityGovernanceAccessReviewsDefinitionsInstancesListDecisionsExecute(r ApiIdentityGovernanceAccessReviewsDefinitionsInstancesListDecisionsRequest) (CollectionOfAccessReviewInstanceDecisionItem, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  CollectionOfAccessReviewInstanceDecisionItem
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IdentityGovernanceAccessReviewSetApiService.IdentityGovernanceAccessReviewsDefinitionsInstancesListDecisions")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/identityGovernance/accessReviews/definitions/{accessReviewScheduleDefinition-id}/instances/{accessReviewInstance-id}/decisions"
	localVarPath = strings.Replace(localVarPath, "{"+"accessReviewScheduleDefinition-id"+"}", _neturl.PathEscape(parameterToString(r.accessReviewScheduleDefinitionId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"accessReviewInstance-id"+"}", _neturl.PathEscape(parameterToString(r.accessReviewInstanceId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.top != nil {
		localVarQueryParams.Add("$top", parameterToString(*r.top, ""))
	}
	if r.skip != nil {
		localVarQueryParams.Add("$skip", parameterToString(*r.skip, ""))
	}
	if r.search != nil {
		localVarQueryParams.Add("$search", parameterToString(*r.search, ""))
	}
	if r.filter != nil {
		localVarQueryParams.Add("$filter", parameterToString(*r.filter, ""))
	}
	if r.count != nil {
		localVarQueryParams.Add("$count", parameterToString(*r.count, ""))
	}
	if r.orderby != nil {
		localVarQueryParams.Add("$orderby", parameterToString(*r.orderby, "csv"))
	}
	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIdentityGovernanceAccessReviewsDefinitionsInstancesUpdateDecisionsRequest struct {
	ctx _context.Context
	ApiService *IdentityGovernanceAccessReviewSetApiService
	accessReviewScheduleDefinitionId string
	accessReviewInstanceId string
	accessReviewInstanceDecisionItemId string
	microsoftGraphAccessReviewInstanceDecisionItem *MicrosoftGraphAccessReviewInstanceDecisionItem
}

// New navigation property values
func (r ApiIdentityGovernanceAccessReviewsDefinitionsInstancesUpdateDecisionsRequest) MicrosoftGraphAccessReviewInstanceDecisionItem(microsoftGraphAccessReviewInstanceDecisionItem MicrosoftGraphAccessReviewInstanceDecisionItem) ApiIdentityGovernanceAccessReviewsDefinitionsInstancesUpdateDecisionsRequest {
	r.microsoftGraphAccessReviewInstanceDecisionItem = &microsoftGraphAccessReviewInstanceDecisionItem
	return r
}

func (r ApiIdentityGovernanceAccessReviewsDefinitionsInstancesUpdateDecisionsRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.IdentityGovernanceAccessReviewsDefinitionsInstancesUpdateDecisionsExecute(r)
}

/*
IdentityGovernanceAccessReviewsDefinitionsInstancesUpdateDecisions Update the navigation property decisions in identityGovernance

Each principal reviewed in an accessReviewInstance has a decision item representing if they were approved, denied, or not yet reviewed.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accessReviewScheduleDefinitionId key: id of accessReviewScheduleDefinition
 @param accessReviewInstanceId key: id of accessReviewInstance
 @param accessReviewInstanceDecisionItemId key: id of accessReviewInstanceDecisionItem
 @return ApiIdentityGovernanceAccessReviewsDefinitionsInstancesUpdateDecisionsRequest
*/
func (a *IdentityGovernanceAccessReviewSetApiService) IdentityGovernanceAccessReviewsDefinitionsInstancesUpdateDecisions(ctx _context.Context, accessReviewScheduleDefinitionId string, accessReviewInstanceId string, accessReviewInstanceDecisionItemId string) ApiIdentityGovernanceAccessReviewsDefinitionsInstancesUpdateDecisionsRequest {
	return ApiIdentityGovernanceAccessReviewsDefinitionsInstancesUpdateDecisionsRequest{
		ApiService: a,
		ctx: ctx,
		accessReviewScheduleDefinitionId: accessReviewScheduleDefinitionId,
		accessReviewInstanceId: accessReviewInstanceId,
		accessReviewInstanceDecisionItemId: accessReviewInstanceDecisionItemId,
	}
}

// Execute executes the request
func (a *IdentityGovernanceAccessReviewSetApiService) IdentityGovernanceAccessReviewsDefinitionsInstancesUpdateDecisionsExecute(r ApiIdentityGovernanceAccessReviewsDefinitionsInstancesUpdateDecisionsRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPatch
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IdentityGovernanceAccessReviewSetApiService.IdentityGovernanceAccessReviewsDefinitionsInstancesUpdateDecisions")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/identityGovernance/accessReviews/definitions/{accessReviewScheduleDefinition-id}/instances/{accessReviewInstance-id}/decisions/{accessReviewInstanceDecisionItem-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"accessReviewScheduleDefinition-id"+"}", _neturl.PathEscape(parameterToString(r.accessReviewScheduleDefinitionId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"accessReviewInstance-id"+"}", _neturl.PathEscape(parameterToString(r.accessReviewInstanceId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"accessReviewInstanceDecisionItem-id"+"}", _neturl.PathEscape(parameterToString(r.accessReviewInstanceDecisionItemId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphAccessReviewInstanceDecisionItem == nil {
		return nil, reportError("microsoftGraphAccessReviewInstanceDecisionItem is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphAccessReviewInstanceDecisionItem
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiIdentityGovernanceAccessReviewsDefinitionsListInstancesRequest struct {
	ctx _context.Context
	ApiService *IdentityGovernanceAccessReviewSetApiService
	accessReviewScheduleDefinitionId string
	top *int32
	skip *int32
	search *string
	filter *string
	count *bool
	orderby *[]string
	select_ *[]string
	expand *[]string
}

// Show only the first n items
func (r ApiIdentityGovernanceAccessReviewsDefinitionsListInstancesRequest) Top(top int32) ApiIdentityGovernanceAccessReviewsDefinitionsListInstancesRequest {
	r.top = &top
	return r
}
// Skip the first n items
func (r ApiIdentityGovernanceAccessReviewsDefinitionsListInstancesRequest) Skip(skip int32) ApiIdentityGovernanceAccessReviewsDefinitionsListInstancesRequest {
	r.skip = &skip
	return r
}
// Search items by search phrases
func (r ApiIdentityGovernanceAccessReviewsDefinitionsListInstancesRequest) Search(search string) ApiIdentityGovernanceAccessReviewsDefinitionsListInstancesRequest {
	r.search = &search
	return r
}
// Filter items by property values
func (r ApiIdentityGovernanceAccessReviewsDefinitionsListInstancesRequest) Filter(filter string) ApiIdentityGovernanceAccessReviewsDefinitionsListInstancesRequest {
	r.filter = &filter
	return r
}
// Include count of items
func (r ApiIdentityGovernanceAccessReviewsDefinitionsListInstancesRequest) Count(count bool) ApiIdentityGovernanceAccessReviewsDefinitionsListInstancesRequest {
	r.count = &count
	return r
}
// Order items by property values
func (r ApiIdentityGovernanceAccessReviewsDefinitionsListInstancesRequest) Orderby(orderby []string) ApiIdentityGovernanceAccessReviewsDefinitionsListInstancesRequest {
	r.orderby = &orderby
	return r
}
// Select properties to be returned
func (r ApiIdentityGovernanceAccessReviewsDefinitionsListInstancesRequest) Select_(select_ []string) ApiIdentityGovernanceAccessReviewsDefinitionsListInstancesRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiIdentityGovernanceAccessReviewsDefinitionsListInstancesRequest) Expand(expand []string) ApiIdentityGovernanceAccessReviewsDefinitionsListInstancesRequest {
	r.expand = &expand
	return r
}

func (r ApiIdentityGovernanceAccessReviewsDefinitionsListInstancesRequest) Execute() (CollectionOfAccessReviewInstance, *_nethttp.Response, error) {
	return r.ApiService.IdentityGovernanceAccessReviewsDefinitionsListInstancesExecute(r)
}

/*
IdentityGovernanceAccessReviewsDefinitionsListInstances Get instances from identityGovernance

If the accessReviewScheduleDefinition is a recurring access review, instances represent each recurrence. A review that does not recur will have exactly one instance. Instances also represent each unique resource under review in the accessReviewScheduleDefinition. If a review has multiple resources and multiple instances, each resource will have a unique instance for each recurrence.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accessReviewScheduleDefinitionId key: id of accessReviewScheduleDefinition
 @return ApiIdentityGovernanceAccessReviewsDefinitionsListInstancesRequest
*/
func (a *IdentityGovernanceAccessReviewSetApiService) IdentityGovernanceAccessReviewsDefinitionsListInstances(ctx _context.Context, accessReviewScheduleDefinitionId string) ApiIdentityGovernanceAccessReviewsDefinitionsListInstancesRequest {
	return ApiIdentityGovernanceAccessReviewsDefinitionsListInstancesRequest{
		ApiService: a,
		ctx: ctx,
		accessReviewScheduleDefinitionId: accessReviewScheduleDefinitionId,
	}
}

// Execute executes the request
//  @return CollectionOfAccessReviewInstance
func (a *IdentityGovernanceAccessReviewSetApiService) IdentityGovernanceAccessReviewsDefinitionsListInstancesExecute(r ApiIdentityGovernanceAccessReviewsDefinitionsListInstancesRequest) (CollectionOfAccessReviewInstance, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  CollectionOfAccessReviewInstance
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IdentityGovernanceAccessReviewSetApiService.IdentityGovernanceAccessReviewsDefinitionsListInstances")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/identityGovernance/accessReviews/definitions/{accessReviewScheduleDefinition-id}/instances"
	localVarPath = strings.Replace(localVarPath, "{"+"accessReviewScheduleDefinition-id"+"}", _neturl.PathEscape(parameterToString(r.accessReviewScheduleDefinitionId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.top != nil {
		localVarQueryParams.Add("$top", parameterToString(*r.top, ""))
	}
	if r.skip != nil {
		localVarQueryParams.Add("$skip", parameterToString(*r.skip, ""))
	}
	if r.search != nil {
		localVarQueryParams.Add("$search", parameterToString(*r.search, ""))
	}
	if r.filter != nil {
		localVarQueryParams.Add("$filter", parameterToString(*r.filter, ""))
	}
	if r.count != nil {
		localVarQueryParams.Add("$count", parameterToString(*r.count, ""))
	}
	if r.orderby != nil {
		localVarQueryParams.Add("$orderby", parameterToString(*r.orderby, "csv"))
	}
	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIdentityGovernanceAccessReviewsDefinitionsUpdateInstancesRequest struct {
	ctx _context.Context
	ApiService *IdentityGovernanceAccessReviewSetApiService
	accessReviewScheduleDefinitionId string
	accessReviewInstanceId string
	microsoftGraphAccessReviewInstance *MicrosoftGraphAccessReviewInstance
}

// New navigation property values
func (r ApiIdentityGovernanceAccessReviewsDefinitionsUpdateInstancesRequest) MicrosoftGraphAccessReviewInstance(microsoftGraphAccessReviewInstance MicrosoftGraphAccessReviewInstance) ApiIdentityGovernanceAccessReviewsDefinitionsUpdateInstancesRequest {
	r.microsoftGraphAccessReviewInstance = &microsoftGraphAccessReviewInstance
	return r
}

func (r ApiIdentityGovernanceAccessReviewsDefinitionsUpdateInstancesRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.IdentityGovernanceAccessReviewsDefinitionsUpdateInstancesExecute(r)
}

/*
IdentityGovernanceAccessReviewsDefinitionsUpdateInstances Update the navigation property instances in identityGovernance

If the accessReviewScheduleDefinition is a recurring access review, instances represent each recurrence. A review that does not recur will have exactly one instance. Instances also represent each unique resource under review in the accessReviewScheduleDefinition. If a review has multiple resources and multiple instances, each resource will have a unique instance for each recurrence.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accessReviewScheduleDefinitionId key: id of accessReviewScheduleDefinition
 @param accessReviewInstanceId key: id of accessReviewInstance
 @return ApiIdentityGovernanceAccessReviewsDefinitionsUpdateInstancesRequest
*/
func (a *IdentityGovernanceAccessReviewSetApiService) IdentityGovernanceAccessReviewsDefinitionsUpdateInstances(ctx _context.Context, accessReviewScheduleDefinitionId string, accessReviewInstanceId string) ApiIdentityGovernanceAccessReviewsDefinitionsUpdateInstancesRequest {
	return ApiIdentityGovernanceAccessReviewsDefinitionsUpdateInstancesRequest{
		ApiService: a,
		ctx: ctx,
		accessReviewScheduleDefinitionId: accessReviewScheduleDefinitionId,
		accessReviewInstanceId: accessReviewInstanceId,
	}
}

// Execute executes the request
func (a *IdentityGovernanceAccessReviewSetApiService) IdentityGovernanceAccessReviewsDefinitionsUpdateInstancesExecute(r ApiIdentityGovernanceAccessReviewsDefinitionsUpdateInstancesRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPatch
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IdentityGovernanceAccessReviewSetApiService.IdentityGovernanceAccessReviewsDefinitionsUpdateInstances")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/identityGovernance/accessReviews/definitions/{accessReviewScheduleDefinition-id}/instances/{accessReviewInstance-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"accessReviewScheduleDefinition-id"+"}", _neturl.PathEscape(parameterToString(r.accessReviewScheduleDefinitionId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"accessReviewInstance-id"+"}", _neturl.PathEscape(parameterToString(r.accessReviewInstanceId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphAccessReviewInstance == nil {
		return nil, reportError("microsoftGraphAccessReviewInstance is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphAccessReviewInstance
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiIdentityGovernanceAccessReviewsDeleteDefinitionsRequest struct {
	ctx _context.Context
	ApiService *IdentityGovernanceAccessReviewSetApiService
	accessReviewScheduleDefinitionId string
	ifMatch *string
}

// ETag
func (r ApiIdentityGovernanceAccessReviewsDeleteDefinitionsRequest) IfMatch(ifMatch string) ApiIdentityGovernanceAccessReviewsDeleteDefinitionsRequest {
	r.ifMatch = &ifMatch
	return r
}

func (r ApiIdentityGovernanceAccessReviewsDeleteDefinitionsRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.IdentityGovernanceAccessReviewsDeleteDefinitionsExecute(r)
}

/*
IdentityGovernanceAccessReviewsDeleteDefinitions Delete navigation property definitions for identityGovernance

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accessReviewScheduleDefinitionId key: id of accessReviewScheduleDefinition
 @return ApiIdentityGovernanceAccessReviewsDeleteDefinitionsRequest
*/
func (a *IdentityGovernanceAccessReviewSetApiService) IdentityGovernanceAccessReviewsDeleteDefinitions(ctx _context.Context, accessReviewScheduleDefinitionId string) ApiIdentityGovernanceAccessReviewsDeleteDefinitionsRequest {
	return ApiIdentityGovernanceAccessReviewsDeleteDefinitionsRequest{
		ApiService: a,
		ctx: ctx,
		accessReviewScheduleDefinitionId: accessReviewScheduleDefinitionId,
	}
}

// Execute executes the request
func (a *IdentityGovernanceAccessReviewSetApiService) IdentityGovernanceAccessReviewsDeleteDefinitionsExecute(r ApiIdentityGovernanceAccessReviewsDeleteDefinitionsRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IdentityGovernanceAccessReviewSetApiService.IdentityGovernanceAccessReviewsDeleteDefinitions")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/identityGovernance/accessReviews/definitions/{accessReviewScheduleDefinition-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"accessReviewScheduleDefinition-id"+"}", _neturl.PathEscape(parameterToString(r.accessReviewScheduleDefinitionId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ifMatch != nil {
		localVarHeaderParams["If-Match"] = parameterToString(*r.ifMatch, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiIdentityGovernanceAccessReviewsGetDefinitionsRequest struct {
	ctx _context.Context
	ApiService *IdentityGovernanceAccessReviewSetApiService
	accessReviewScheduleDefinitionId string
	select_ *[]string
	expand *[]string
}

// Select properties to be returned
func (r ApiIdentityGovernanceAccessReviewsGetDefinitionsRequest) Select_(select_ []string) ApiIdentityGovernanceAccessReviewsGetDefinitionsRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiIdentityGovernanceAccessReviewsGetDefinitionsRequest) Expand(expand []string) ApiIdentityGovernanceAccessReviewsGetDefinitionsRequest {
	r.expand = &expand
	return r
}

func (r ApiIdentityGovernanceAccessReviewsGetDefinitionsRequest) Execute() (MicrosoftGraphAccessReviewScheduleDefinition, *_nethttp.Response, error) {
	return r.ApiService.IdentityGovernanceAccessReviewsGetDefinitionsExecute(r)
}

/*
IdentityGovernanceAccessReviewsGetDefinitions Get definitions from identityGovernance

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accessReviewScheduleDefinitionId key: id of accessReviewScheduleDefinition
 @return ApiIdentityGovernanceAccessReviewsGetDefinitionsRequest
*/
func (a *IdentityGovernanceAccessReviewSetApiService) IdentityGovernanceAccessReviewsGetDefinitions(ctx _context.Context, accessReviewScheduleDefinitionId string) ApiIdentityGovernanceAccessReviewsGetDefinitionsRequest {
	return ApiIdentityGovernanceAccessReviewsGetDefinitionsRequest{
		ApiService: a,
		ctx: ctx,
		accessReviewScheduleDefinitionId: accessReviewScheduleDefinitionId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphAccessReviewScheduleDefinition
func (a *IdentityGovernanceAccessReviewSetApiService) IdentityGovernanceAccessReviewsGetDefinitionsExecute(r ApiIdentityGovernanceAccessReviewsGetDefinitionsRequest) (MicrosoftGraphAccessReviewScheduleDefinition, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphAccessReviewScheduleDefinition
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IdentityGovernanceAccessReviewSetApiService.IdentityGovernanceAccessReviewsGetDefinitions")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/identityGovernance/accessReviews/definitions/{accessReviewScheduleDefinition-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"accessReviewScheduleDefinition-id"+"}", _neturl.PathEscape(parameterToString(r.accessReviewScheduleDefinitionId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIdentityGovernanceAccessReviewsListDefinitionsRequest struct {
	ctx _context.Context
	ApiService *IdentityGovernanceAccessReviewSetApiService
	top *int32
	skip *int32
	search *string
	filter *string
	count *bool
	orderby *[]string
	select_ *[]string
	expand *[]string
}

// Show only the first n items
func (r ApiIdentityGovernanceAccessReviewsListDefinitionsRequest) Top(top int32) ApiIdentityGovernanceAccessReviewsListDefinitionsRequest {
	r.top = &top
	return r
}
// Skip the first n items
func (r ApiIdentityGovernanceAccessReviewsListDefinitionsRequest) Skip(skip int32) ApiIdentityGovernanceAccessReviewsListDefinitionsRequest {
	r.skip = &skip
	return r
}
// Search items by search phrases
func (r ApiIdentityGovernanceAccessReviewsListDefinitionsRequest) Search(search string) ApiIdentityGovernanceAccessReviewsListDefinitionsRequest {
	r.search = &search
	return r
}
// Filter items by property values
func (r ApiIdentityGovernanceAccessReviewsListDefinitionsRequest) Filter(filter string) ApiIdentityGovernanceAccessReviewsListDefinitionsRequest {
	r.filter = &filter
	return r
}
// Include count of items
func (r ApiIdentityGovernanceAccessReviewsListDefinitionsRequest) Count(count bool) ApiIdentityGovernanceAccessReviewsListDefinitionsRequest {
	r.count = &count
	return r
}
// Order items by property values
func (r ApiIdentityGovernanceAccessReviewsListDefinitionsRequest) Orderby(orderby []string) ApiIdentityGovernanceAccessReviewsListDefinitionsRequest {
	r.orderby = &orderby
	return r
}
// Select properties to be returned
func (r ApiIdentityGovernanceAccessReviewsListDefinitionsRequest) Select_(select_ []string) ApiIdentityGovernanceAccessReviewsListDefinitionsRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiIdentityGovernanceAccessReviewsListDefinitionsRequest) Expand(expand []string) ApiIdentityGovernanceAccessReviewsListDefinitionsRequest {
	r.expand = &expand
	return r
}

func (r ApiIdentityGovernanceAccessReviewsListDefinitionsRequest) Execute() (CollectionOfAccessReviewScheduleDefinition, *_nethttp.Response, error) {
	return r.ApiService.IdentityGovernanceAccessReviewsListDefinitionsExecute(r)
}

/*
IdentityGovernanceAccessReviewsListDefinitions Get definitions from identityGovernance

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiIdentityGovernanceAccessReviewsListDefinitionsRequest
*/
func (a *IdentityGovernanceAccessReviewSetApiService) IdentityGovernanceAccessReviewsListDefinitions(ctx _context.Context) ApiIdentityGovernanceAccessReviewsListDefinitionsRequest {
	return ApiIdentityGovernanceAccessReviewsListDefinitionsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CollectionOfAccessReviewScheduleDefinition
func (a *IdentityGovernanceAccessReviewSetApiService) IdentityGovernanceAccessReviewsListDefinitionsExecute(r ApiIdentityGovernanceAccessReviewsListDefinitionsRequest) (CollectionOfAccessReviewScheduleDefinition, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  CollectionOfAccessReviewScheduleDefinition
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IdentityGovernanceAccessReviewSetApiService.IdentityGovernanceAccessReviewsListDefinitions")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/identityGovernance/accessReviews/definitions"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.top != nil {
		localVarQueryParams.Add("$top", parameterToString(*r.top, ""))
	}
	if r.skip != nil {
		localVarQueryParams.Add("$skip", parameterToString(*r.skip, ""))
	}
	if r.search != nil {
		localVarQueryParams.Add("$search", parameterToString(*r.search, ""))
	}
	if r.filter != nil {
		localVarQueryParams.Add("$filter", parameterToString(*r.filter, ""))
	}
	if r.count != nil {
		localVarQueryParams.Add("$count", parameterToString(*r.count, ""))
	}
	if r.orderby != nil {
		localVarQueryParams.Add("$orderby", parameterToString(*r.orderby, "csv"))
	}
	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIdentityGovernanceAccessReviewsUpdateDefinitionsRequest struct {
	ctx _context.Context
	ApiService *IdentityGovernanceAccessReviewSetApiService
	accessReviewScheduleDefinitionId string
	microsoftGraphAccessReviewScheduleDefinition *MicrosoftGraphAccessReviewScheduleDefinition
}

// New navigation property values
func (r ApiIdentityGovernanceAccessReviewsUpdateDefinitionsRequest) MicrosoftGraphAccessReviewScheduleDefinition(microsoftGraphAccessReviewScheduleDefinition MicrosoftGraphAccessReviewScheduleDefinition) ApiIdentityGovernanceAccessReviewsUpdateDefinitionsRequest {
	r.microsoftGraphAccessReviewScheduleDefinition = &microsoftGraphAccessReviewScheduleDefinition
	return r
}

func (r ApiIdentityGovernanceAccessReviewsUpdateDefinitionsRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.IdentityGovernanceAccessReviewsUpdateDefinitionsExecute(r)
}

/*
IdentityGovernanceAccessReviewsUpdateDefinitions Update the navigation property definitions in identityGovernance

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accessReviewScheduleDefinitionId key: id of accessReviewScheduleDefinition
 @return ApiIdentityGovernanceAccessReviewsUpdateDefinitionsRequest
*/
func (a *IdentityGovernanceAccessReviewSetApiService) IdentityGovernanceAccessReviewsUpdateDefinitions(ctx _context.Context, accessReviewScheduleDefinitionId string) ApiIdentityGovernanceAccessReviewsUpdateDefinitionsRequest {
	return ApiIdentityGovernanceAccessReviewsUpdateDefinitionsRequest{
		ApiService: a,
		ctx: ctx,
		accessReviewScheduleDefinitionId: accessReviewScheduleDefinitionId,
	}
}

// Execute executes the request
func (a *IdentityGovernanceAccessReviewSetApiService) IdentityGovernanceAccessReviewsUpdateDefinitionsExecute(r ApiIdentityGovernanceAccessReviewsUpdateDefinitionsRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPatch
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IdentityGovernanceAccessReviewSetApiService.IdentityGovernanceAccessReviewsUpdateDefinitions")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/identityGovernance/accessReviews/definitions/{accessReviewScheduleDefinition-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"accessReviewScheduleDefinition-id"+"}", _neturl.PathEscape(parameterToString(r.accessReviewScheduleDefinitionId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphAccessReviewScheduleDefinition == nil {
		return nil, reportError("microsoftGraphAccessReviewScheduleDefinition is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphAccessReviewScheduleDefinition
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiIdentityGovernanceDeleteAccessReviewsRequest struct {
	ctx _context.Context
	ApiService *IdentityGovernanceAccessReviewSetApiService
	ifMatch *string
}

// ETag
func (r ApiIdentityGovernanceDeleteAccessReviewsRequest) IfMatch(ifMatch string) ApiIdentityGovernanceDeleteAccessReviewsRequest {
	r.ifMatch = &ifMatch
	return r
}

func (r ApiIdentityGovernanceDeleteAccessReviewsRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.IdentityGovernanceDeleteAccessReviewsExecute(r)
}

/*
IdentityGovernanceDeleteAccessReviews Delete navigation property accessReviews for identityGovernance

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiIdentityGovernanceDeleteAccessReviewsRequest
*/
func (a *IdentityGovernanceAccessReviewSetApiService) IdentityGovernanceDeleteAccessReviews(ctx _context.Context) ApiIdentityGovernanceDeleteAccessReviewsRequest {
	return ApiIdentityGovernanceDeleteAccessReviewsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *IdentityGovernanceAccessReviewSetApiService) IdentityGovernanceDeleteAccessReviewsExecute(r ApiIdentityGovernanceDeleteAccessReviewsRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IdentityGovernanceAccessReviewSetApiService.IdentityGovernanceDeleteAccessReviews")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/identityGovernance/accessReviews"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ifMatch != nil {
		localVarHeaderParams["If-Match"] = parameterToString(*r.ifMatch, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiIdentityGovernanceGetAccessReviewsRequest struct {
	ctx _context.Context
	ApiService *IdentityGovernanceAccessReviewSetApiService
	select_ *[]string
	expand *[]string
}

// Select properties to be returned
func (r ApiIdentityGovernanceGetAccessReviewsRequest) Select_(select_ []string) ApiIdentityGovernanceGetAccessReviewsRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiIdentityGovernanceGetAccessReviewsRequest) Expand(expand []string) ApiIdentityGovernanceGetAccessReviewsRequest {
	r.expand = &expand
	return r
}

func (r ApiIdentityGovernanceGetAccessReviewsRequest) Execute() (MicrosoftGraphAccessReviewSet, *_nethttp.Response, error) {
	return r.ApiService.IdentityGovernanceGetAccessReviewsExecute(r)
}

/*
IdentityGovernanceGetAccessReviews Get accessReviews from identityGovernance

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiIdentityGovernanceGetAccessReviewsRequest
*/
func (a *IdentityGovernanceAccessReviewSetApiService) IdentityGovernanceGetAccessReviews(ctx _context.Context) ApiIdentityGovernanceGetAccessReviewsRequest {
	return ApiIdentityGovernanceGetAccessReviewsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return MicrosoftGraphAccessReviewSet
func (a *IdentityGovernanceAccessReviewSetApiService) IdentityGovernanceGetAccessReviewsExecute(r ApiIdentityGovernanceGetAccessReviewsRequest) (MicrosoftGraphAccessReviewSet, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphAccessReviewSet
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IdentityGovernanceAccessReviewSetApiService.IdentityGovernanceGetAccessReviews")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/identityGovernance/accessReviews"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIdentityGovernanceUpdateAccessReviewsRequest struct {
	ctx _context.Context
	ApiService *IdentityGovernanceAccessReviewSetApiService
	microsoftGraphAccessReviewSet *MicrosoftGraphAccessReviewSet
}

// New navigation property values
func (r ApiIdentityGovernanceUpdateAccessReviewsRequest) MicrosoftGraphAccessReviewSet(microsoftGraphAccessReviewSet MicrosoftGraphAccessReviewSet) ApiIdentityGovernanceUpdateAccessReviewsRequest {
	r.microsoftGraphAccessReviewSet = &microsoftGraphAccessReviewSet
	return r
}

func (r ApiIdentityGovernanceUpdateAccessReviewsRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.IdentityGovernanceUpdateAccessReviewsExecute(r)
}

/*
IdentityGovernanceUpdateAccessReviews Update the navigation property accessReviews in identityGovernance

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiIdentityGovernanceUpdateAccessReviewsRequest
*/
func (a *IdentityGovernanceAccessReviewSetApiService) IdentityGovernanceUpdateAccessReviews(ctx _context.Context) ApiIdentityGovernanceUpdateAccessReviewsRequest {
	return ApiIdentityGovernanceUpdateAccessReviewsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *IdentityGovernanceAccessReviewSetApiService) IdentityGovernanceUpdateAccessReviewsExecute(r ApiIdentityGovernanceUpdateAccessReviewsRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPatch
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IdentityGovernanceAccessReviewSetApiService.IdentityGovernanceUpdateAccessReviews")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/identityGovernance/accessReviews"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphAccessReviewSet == nil {
		return nil, reportError("microsoftGraphAccessReviewSet is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphAccessReviewSet
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}
