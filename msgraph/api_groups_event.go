/*
Partial Graph API

No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

API version: v1.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package msgraph

import (
	"bytes"
	_context "context"
	_ioutil "io/ioutil"
	_nethttp "net/http"
	_neturl "net/url"
	"strings"
)

// Linger please
var (
	_ _context.Context
)

// GroupsEventApiService GroupsEventApi service
type GroupsEventApiService service

type ApiGroupsCalendarViewCalendarCreateCalendarPermissionsRequest struct {
	ctx _context.Context
	ApiService *GroupsEventApiService
	groupId string
	eventId string
	microsoftGraphCalendarPermission *MicrosoftGraphCalendarPermission
}

// New navigation property
func (r ApiGroupsCalendarViewCalendarCreateCalendarPermissionsRequest) MicrosoftGraphCalendarPermission(microsoftGraphCalendarPermission MicrosoftGraphCalendarPermission) ApiGroupsCalendarViewCalendarCreateCalendarPermissionsRequest {
	r.microsoftGraphCalendarPermission = &microsoftGraphCalendarPermission
	return r
}

func (r ApiGroupsCalendarViewCalendarCreateCalendarPermissionsRequest) Execute() (MicrosoftGraphCalendarPermission, *_nethttp.Response, error) {
	return r.ApiService.GroupsCalendarViewCalendarCreateCalendarPermissionsExecute(r)
}

/*
GroupsCalendarViewCalendarCreateCalendarPermissions Create new navigation property to calendarPermissions for groups

The permissions of the users with whom the calendar is shared.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupId key: id of group
 @param eventId key: id of event
 @return ApiGroupsCalendarViewCalendarCreateCalendarPermissionsRequest
*/
func (a *GroupsEventApiService) GroupsCalendarViewCalendarCreateCalendarPermissions(ctx _context.Context, groupId string, eventId string) ApiGroupsCalendarViewCalendarCreateCalendarPermissionsRequest {
	return ApiGroupsCalendarViewCalendarCreateCalendarPermissionsRequest{
		ApiService: a,
		ctx: ctx,
		groupId: groupId,
		eventId: eventId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphCalendarPermission
func (a *GroupsEventApiService) GroupsCalendarViewCalendarCreateCalendarPermissionsExecute(r ApiGroupsCalendarViewCalendarCreateCalendarPermissionsRequest) (MicrosoftGraphCalendarPermission, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphCalendarPermission
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GroupsEventApiService.GroupsCalendarViewCalendarCreateCalendarPermissions")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/groups/{group-id}/calendarView/{event-id}/calendar/calendarPermissions"
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphCalendarPermission == nil {
		return localVarReturnValue, nil, reportError("microsoftGraphCalendarPermission is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphCalendarPermission
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGroupsCalendarViewCalendarCreateCalendarViewRequest struct {
	ctx _context.Context
	ApiService *GroupsEventApiService
	groupId string
	eventId string
	microsoftGraphEvent *MicrosoftGraphEvent
}

// New navigation property
func (r ApiGroupsCalendarViewCalendarCreateCalendarViewRequest) MicrosoftGraphEvent(microsoftGraphEvent MicrosoftGraphEvent) ApiGroupsCalendarViewCalendarCreateCalendarViewRequest {
	r.microsoftGraphEvent = &microsoftGraphEvent
	return r
}

func (r ApiGroupsCalendarViewCalendarCreateCalendarViewRequest) Execute() (MicrosoftGraphEvent, *_nethttp.Response, error) {
	return r.ApiService.GroupsCalendarViewCalendarCreateCalendarViewExecute(r)
}

/*
GroupsCalendarViewCalendarCreateCalendarView Create new navigation property to calendarView for groups

The calendar view for the calendar. Navigation property. Read-only.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupId key: id of group
 @param eventId key: id of event
 @return ApiGroupsCalendarViewCalendarCreateCalendarViewRequest
*/
func (a *GroupsEventApiService) GroupsCalendarViewCalendarCreateCalendarView(ctx _context.Context, groupId string, eventId string) ApiGroupsCalendarViewCalendarCreateCalendarViewRequest {
	return ApiGroupsCalendarViewCalendarCreateCalendarViewRequest{
		ApiService: a,
		ctx: ctx,
		groupId: groupId,
		eventId: eventId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphEvent
func (a *GroupsEventApiService) GroupsCalendarViewCalendarCreateCalendarViewExecute(r ApiGroupsCalendarViewCalendarCreateCalendarViewRequest) (MicrosoftGraphEvent, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphEvent
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GroupsEventApiService.GroupsCalendarViewCalendarCreateCalendarView")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/groups/{group-id}/calendarView/{event-id}/calendar/calendarView"
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphEvent == nil {
		return localVarReturnValue, nil, reportError("microsoftGraphEvent is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphEvent
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGroupsCalendarViewCalendarCreateEventsRequest struct {
	ctx _context.Context
	ApiService *GroupsEventApiService
	groupId string
	eventId string
	microsoftGraphEvent *MicrosoftGraphEvent
}

// New navigation property
func (r ApiGroupsCalendarViewCalendarCreateEventsRequest) MicrosoftGraphEvent(microsoftGraphEvent MicrosoftGraphEvent) ApiGroupsCalendarViewCalendarCreateEventsRequest {
	r.microsoftGraphEvent = &microsoftGraphEvent
	return r
}

func (r ApiGroupsCalendarViewCalendarCreateEventsRequest) Execute() (MicrosoftGraphEvent, *_nethttp.Response, error) {
	return r.ApiService.GroupsCalendarViewCalendarCreateEventsExecute(r)
}

/*
GroupsCalendarViewCalendarCreateEvents Create new navigation property to events for groups

The events in the calendar. Navigation property. Read-only.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupId key: id of group
 @param eventId key: id of event
 @return ApiGroupsCalendarViewCalendarCreateEventsRequest
*/
func (a *GroupsEventApiService) GroupsCalendarViewCalendarCreateEvents(ctx _context.Context, groupId string, eventId string) ApiGroupsCalendarViewCalendarCreateEventsRequest {
	return ApiGroupsCalendarViewCalendarCreateEventsRequest{
		ApiService: a,
		ctx: ctx,
		groupId: groupId,
		eventId: eventId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphEvent
func (a *GroupsEventApiService) GroupsCalendarViewCalendarCreateEventsExecute(r ApiGroupsCalendarViewCalendarCreateEventsRequest) (MicrosoftGraphEvent, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphEvent
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GroupsEventApiService.GroupsCalendarViewCalendarCreateEvents")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/groups/{group-id}/calendarView/{event-id}/calendar/events"
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphEvent == nil {
		return localVarReturnValue, nil, reportError("microsoftGraphEvent is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphEvent
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGroupsCalendarViewCalendarCreateMultiValueExtendedPropertiesRequest struct {
	ctx _context.Context
	ApiService *GroupsEventApiService
	groupId string
	eventId string
	microsoftGraphMultiValueLegacyExtendedProperty *MicrosoftGraphMultiValueLegacyExtendedProperty
}

// New navigation property
func (r ApiGroupsCalendarViewCalendarCreateMultiValueExtendedPropertiesRequest) MicrosoftGraphMultiValueLegacyExtendedProperty(microsoftGraphMultiValueLegacyExtendedProperty MicrosoftGraphMultiValueLegacyExtendedProperty) ApiGroupsCalendarViewCalendarCreateMultiValueExtendedPropertiesRequest {
	r.microsoftGraphMultiValueLegacyExtendedProperty = &microsoftGraphMultiValueLegacyExtendedProperty
	return r
}

func (r ApiGroupsCalendarViewCalendarCreateMultiValueExtendedPropertiesRequest) Execute() (MicrosoftGraphMultiValueLegacyExtendedProperty, *_nethttp.Response, error) {
	return r.ApiService.GroupsCalendarViewCalendarCreateMultiValueExtendedPropertiesExecute(r)
}

/*
GroupsCalendarViewCalendarCreateMultiValueExtendedProperties Create new navigation property to multiValueExtendedProperties for groups

The collection of multi-value extended properties defined for the calendar. Read-only. Nullable.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupId key: id of group
 @param eventId key: id of event
 @return ApiGroupsCalendarViewCalendarCreateMultiValueExtendedPropertiesRequest
*/
func (a *GroupsEventApiService) GroupsCalendarViewCalendarCreateMultiValueExtendedProperties(ctx _context.Context, groupId string, eventId string) ApiGroupsCalendarViewCalendarCreateMultiValueExtendedPropertiesRequest {
	return ApiGroupsCalendarViewCalendarCreateMultiValueExtendedPropertiesRequest{
		ApiService: a,
		ctx: ctx,
		groupId: groupId,
		eventId: eventId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphMultiValueLegacyExtendedProperty
func (a *GroupsEventApiService) GroupsCalendarViewCalendarCreateMultiValueExtendedPropertiesExecute(r ApiGroupsCalendarViewCalendarCreateMultiValueExtendedPropertiesRequest) (MicrosoftGraphMultiValueLegacyExtendedProperty, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphMultiValueLegacyExtendedProperty
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GroupsEventApiService.GroupsCalendarViewCalendarCreateMultiValueExtendedProperties")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/groups/{group-id}/calendarView/{event-id}/calendar/multiValueExtendedProperties"
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphMultiValueLegacyExtendedProperty == nil {
		return localVarReturnValue, nil, reportError("microsoftGraphMultiValueLegacyExtendedProperty is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphMultiValueLegacyExtendedProperty
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGroupsCalendarViewCalendarCreateSingleValueExtendedPropertiesRequest struct {
	ctx _context.Context
	ApiService *GroupsEventApiService
	groupId string
	eventId string
	microsoftGraphSingleValueLegacyExtendedProperty *MicrosoftGraphSingleValueLegacyExtendedProperty
}

// New navigation property
func (r ApiGroupsCalendarViewCalendarCreateSingleValueExtendedPropertiesRequest) MicrosoftGraphSingleValueLegacyExtendedProperty(microsoftGraphSingleValueLegacyExtendedProperty MicrosoftGraphSingleValueLegacyExtendedProperty) ApiGroupsCalendarViewCalendarCreateSingleValueExtendedPropertiesRequest {
	r.microsoftGraphSingleValueLegacyExtendedProperty = &microsoftGraphSingleValueLegacyExtendedProperty
	return r
}

func (r ApiGroupsCalendarViewCalendarCreateSingleValueExtendedPropertiesRequest) Execute() (MicrosoftGraphSingleValueLegacyExtendedProperty, *_nethttp.Response, error) {
	return r.ApiService.GroupsCalendarViewCalendarCreateSingleValueExtendedPropertiesExecute(r)
}

/*
GroupsCalendarViewCalendarCreateSingleValueExtendedProperties Create new navigation property to singleValueExtendedProperties for groups

The collection of single-value extended properties defined for the calendar. Read-only. Nullable.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupId key: id of group
 @param eventId key: id of event
 @return ApiGroupsCalendarViewCalendarCreateSingleValueExtendedPropertiesRequest
*/
func (a *GroupsEventApiService) GroupsCalendarViewCalendarCreateSingleValueExtendedProperties(ctx _context.Context, groupId string, eventId string) ApiGroupsCalendarViewCalendarCreateSingleValueExtendedPropertiesRequest {
	return ApiGroupsCalendarViewCalendarCreateSingleValueExtendedPropertiesRequest{
		ApiService: a,
		ctx: ctx,
		groupId: groupId,
		eventId: eventId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphSingleValueLegacyExtendedProperty
func (a *GroupsEventApiService) GroupsCalendarViewCalendarCreateSingleValueExtendedPropertiesExecute(r ApiGroupsCalendarViewCalendarCreateSingleValueExtendedPropertiesRequest) (MicrosoftGraphSingleValueLegacyExtendedProperty, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphSingleValueLegacyExtendedProperty
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GroupsEventApiService.GroupsCalendarViewCalendarCreateSingleValueExtendedProperties")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/groups/{group-id}/calendarView/{event-id}/calendar/singleValueExtendedProperties"
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphSingleValueLegacyExtendedProperty == nil {
		return localVarReturnValue, nil, reportError("microsoftGraphSingleValueLegacyExtendedProperty is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphSingleValueLegacyExtendedProperty
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGroupsCalendarViewCalendarDeleteCalendarPermissionsRequest struct {
	ctx _context.Context
	ApiService *GroupsEventApiService
	groupId string
	eventId string
	calendarPermissionId string
	ifMatch *string
}

// ETag
func (r ApiGroupsCalendarViewCalendarDeleteCalendarPermissionsRequest) IfMatch(ifMatch string) ApiGroupsCalendarViewCalendarDeleteCalendarPermissionsRequest {
	r.ifMatch = &ifMatch
	return r
}

func (r ApiGroupsCalendarViewCalendarDeleteCalendarPermissionsRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.GroupsCalendarViewCalendarDeleteCalendarPermissionsExecute(r)
}

/*
GroupsCalendarViewCalendarDeleteCalendarPermissions Delete navigation property calendarPermissions for groups

The permissions of the users with whom the calendar is shared.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupId key: id of group
 @param eventId key: id of event
 @param calendarPermissionId key: id of calendarPermission
 @return ApiGroupsCalendarViewCalendarDeleteCalendarPermissionsRequest
*/
func (a *GroupsEventApiService) GroupsCalendarViewCalendarDeleteCalendarPermissions(ctx _context.Context, groupId string, eventId string, calendarPermissionId string) ApiGroupsCalendarViewCalendarDeleteCalendarPermissionsRequest {
	return ApiGroupsCalendarViewCalendarDeleteCalendarPermissionsRequest{
		ApiService: a,
		ctx: ctx,
		groupId: groupId,
		eventId: eventId,
		calendarPermissionId: calendarPermissionId,
	}
}

// Execute executes the request
func (a *GroupsEventApiService) GroupsCalendarViewCalendarDeleteCalendarPermissionsExecute(r ApiGroupsCalendarViewCalendarDeleteCalendarPermissionsRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GroupsEventApiService.GroupsCalendarViewCalendarDeleteCalendarPermissions")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/groups/{group-id}/calendarView/{event-id}/calendar/calendarPermissions/{calendarPermission-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"calendarPermission-id"+"}", _neturl.PathEscape(parameterToString(r.calendarPermissionId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ifMatch != nil {
		localVarHeaderParams["If-Match"] = parameterToString(*r.ifMatch, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGroupsCalendarViewCalendarDeleteCalendarViewRequest struct {
	ctx _context.Context
	ApiService *GroupsEventApiService
	groupId string
	eventId string
	eventId1 string
	ifMatch *string
}

// ETag
func (r ApiGroupsCalendarViewCalendarDeleteCalendarViewRequest) IfMatch(ifMatch string) ApiGroupsCalendarViewCalendarDeleteCalendarViewRequest {
	r.ifMatch = &ifMatch
	return r
}

func (r ApiGroupsCalendarViewCalendarDeleteCalendarViewRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.GroupsCalendarViewCalendarDeleteCalendarViewExecute(r)
}

/*
GroupsCalendarViewCalendarDeleteCalendarView Delete navigation property calendarView for groups

The calendar view for the calendar. Navigation property. Read-only.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupId key: id of group
 @param eventId key: id of event
 @param eventId1 key: id of event
 @return ApiGroupsCalendarViewCalendarDeleteCalendarViewRequest
*/
func (a *GroupsEventApiService) GroupsCalendarViewCalendarDeleteCalendarView(ctx _context.Context, groupId string, eventId string, eventId1 string) ApiGroupsCalendarViewCalendarDeleteCalendarViewRequest {
	return ApiGroupsCalendarViewCalendarDeleteCalendarViewRequest{
		ApiService: a,
		ctx: ctx,
		groupId: groupId,
		eventId: eventId,
		eventId1: eventId1,
	}
}

// Execute executes the request
func (a *GroupsEventApiService) GroupsCalendarViewCalendarDeleteCalendarViewExecute(r ApiGroupsCalendarViewCalendarDeleteCalendarViewRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GroupsEventApiService.GroupsCalendarViewCalendarDeleteCalendarView")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/groups/{group-id}/calendarView/{event-id}/calendar/calendarView/{event-id1}"
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id1"+"}", _neturl.PathEscape(parameterToString(r.eventId1, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ifMatch != nil {
		localVarHeaderParams["If-Match"] = parameterToString(*r.ifMatch, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGroupsCalendarViewCalendarDeleteEventsRequest struct {
	ctx _context.Context
	ApiService *GroupsEventApiService
	groupId string
	eventId string
	eventId1 string
	ifMatch *string
}

// ETag
func (r ApiGroupsCalendarViewCalendarDeleteEventsRequest) IfMatch(ifMatch string) ApiGroupsCalendarViewCalendarDeleteEventsRequest {
	r.ifMatch = &ifMatch
	return r
}

func (r ApiGroupsCalendarViewCalendarDeleteEventsRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.GroupsCalendarViewCalendarDeleteEventsExecute(r)
}

/*
GroupsCalendarViewCalendarDeleteEvents Delete navigation property events for groups

The events in the calendar. Navigation property. Read-only.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupId key: id of group
 @param eventId key: id of event
 @param eventId1 key: id of event
 @return ApiGroupsCalendarViewCalendarDeleteEventsRequest
*/
func (a *GroupsEventApiService) GroupsCalendarViewCalendarDeleteEvents(ctx _context.Context, groupId string, eventId string, eventId1 string) ApiGroupsCalendarViewCalendarDeleteEventsRequest {
	return ApiGroupsCalendarViewCalendarDeleteEventsRequest{
		ApiService: a,
		ctx: ctx,
		groupId: groupId,
		eventId: eventId,
		eventId1: eventId1,
	}
}

// Execute executes the request
func (a *GroupsEventApiService) GroupsCalendarViewCalendarDeleteEventsExecute(r ApiGroupsCalendarViewCalendarDeleteEventsRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GroupsEventApiService.GroupsCalendarViewCalendarDeleteEvents")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/groups/{group-id}/calendarView/{event-id}/calendar/events/{event-id1}"
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id1"+"}", _neturl.PathEscape(parameterToString(r.eventId1, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ifMatch != nil {
		localVarHeaderParams["If-Match"] = parameterToString(*r.ifMatch, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGroupsCalendarViewCalendarDeleteMultiValueExtendedPropertiesRequest struct {
	ctx _context.Context
	ApiService *GroupsEventApiService
	groupId string
	eventId string
	multiValueLegacyExtendedPropertyId string
	ifMatch *string
}

// ETag
func (r ApiGroupsCalendarViewCalendarDeleteMultiValueExtendedPropertiesRequest) IfMatch(ifMatch string) ApiGroupsCalendarViewCalendarDeleteMultiValueExtendedPropertiesRequest {
	r.ifMatch = &ifMatch
	return r
}

func (r ApiGroupsCalendarViewCalendarDeleteMultiValueExtendedPropertiesRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.GroupsCalendarViewCalendarDeleteMultiValueExtendedPropertiesExecute(r)
}

/*
GroupsCalendarViewCalendarDeleteMultiValueExtendedProperties Delete navigation property multiValueExtendedProperties for groups

The collection of multi-value extended properties defined for the calendar. Read-only. Nullable.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupId key: id of group
 @param eventId key: id of event
 @param multiValueLegacyExtendedPropertyId key: id of multiValueLegacyExtendedProperty
 @return ApiGroupsCalendarViewCalendarDeleteMultiValueExtendedPropertiesRequest
*/
func (a *GroupsEventApiService) GroupsCalendarViewCalendarDeleteMultiValueExtendedProperties(ctx _context.Context, groupId string, eventId string, multiValueLegacyExtendedPropertyId string) ApiGroupsCalendarViewCalendarDeleteMultiValueExtendedPropertiesRequest {
	return ApiGroupsCalendarViewCalendarDeleteMultiValueExtendedPropertiesRequest{
		ApiService: a,
		ctx: ctx,
		groupId: groupId,
		eventId: eventId,
		multiValueLegacyExtendedPropertyId: multiValueLegacyExtendedPropertyId,
	}
}

// Execute executes the request
func (a *GroupsEventApiService) GroupsCalendarViewCalendarDeleteMultiValueExtendedPropertiesExecute(r ApiGroupsCalendarViewCalendarDeleteMultiValueExtendedPropertiesRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GroupsEventApiService.GroupsCalendarViewCalendarDeleteMultiValueExtendedProperties")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/groups/{group-id}/calendarView/{event-id}/calendar/multiValueExtendedProperties/{multiValueLegacyExtendedProperty-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"multiValueLegacyExtendedProperty-id"+"}", _neturl.PathEscape(parameterToString(r.multiValueLegacyExtendedPropertyId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ifMatch != nil {
		localVarHeaderParams["If-Match"] = parameterToString(*r.ifMatch, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGroupsCalendarViewCalendarDeleteSingleValueExtendedPropertiesRequest struct {
	ctx _context.Context
	ApiService *GroupsEventApiService
	groupId string
	eventId string
	singleValueLegacyExtendedPropertyId string
	ifMatch *string
}

// ETag
func (r ApiGroupsCalendarViewCalendarDeleteSingleValueExtendedPropertiesRequest) IfMatch(ifMatch string) ApiGroupsCalendarViewCalendarDeleteSingleValueExtendedPropertiesRequest {
	r.ifMatch = &ifMatch
	return r
}

func (r ApiGroupsCalendarViewCalendarDeleteSingleValueExtendedPropertiesRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.GroupsCalendarViewCalendarDeleteSingleValueExtendedPropertiesExecute(r)
}

/*
GroupsCalendarViewCalendarDeleteSingleValueExtendedProperties Delete navigation property singleValueExtendedProperties for groups

The collection of single-value extended properties defined for the calendar. Read-only. Nullable.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupId key: id of group
 @param eventId key: id of event
 @param singleValueLegacyExtendedPropertyId key: id of singleValueLegacyExtendedProperty
 @return ApiGroupsCalendarViewCalendarDeleteSingleValueExtendedPropertiesRequest
*/
func (a *GroupsEventApiService) GroupsCalendarViewCalendarDeleteSingleValueExtendedProperties(ctx _context.Context, groupId string, eventId string, singleValueLegacyExtendedPropertyId string) ApiGroupsCalendarViewCalendarDeleteSingleValueExtendedPropertiesRequest {
	return ApiGroupsCalendarViewCalendarDeleteSingleValueExtendedPropertiesRequest{
		ApiService: a,
		ctx: ctx,
		groupId: groupId,
		eventId: eventId,
		singleValueLegacyExtendedPropertyId: singleValueLegacyExtendedPropertyId,
	}
}

// Execute executes the request
func (a *GroupsEventApiService) GroupsCalendarViewCalendarDeleteSingleValueExtendedPropertiesExecute(r ApiGroupsCalendarViewCalendarDeleteSingleValueExtendedPropertiesRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GroupsEventApiService.GroupsCalendarViewCalendarDeleteSingleValueExtendedProperties")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/groups/{group-id}/calendarView/{event-id}/calendar/singleValueExtendedProperties/{singleValueLegacyExtendedProperty-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"singleValueLegacyExtendedProperty-id"+"}", _neturl.PathEscape(parameterToString(r.singleValueLegacyExtendedPropertyId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ifMatch != nil {
		localVarHeaderParams["If-Match"] = parameterToString(*r.ifMatch, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGroupsCalendarViewCalendarGetCalendarPermissionsRequest struct {
	ctx _context.Context
	ApiService *GroupsEventApiService
	groupId string
	eventId string
	calendarPermissionId string
	select_ *[]string
}

// Select properties to be returned
func (r ApiGroupsCalendarViewCalendarGetCalendarPermissionsRequest) Select_(select_ []string) ApiGroupsCalendarViewCalendarGetCalendarPermissionsRequest {
	r.select_ = &select_
	return r
}

func (r ApiGroupsCalendarViewCalendarGetCalendarPermissionsRequest) Execute() (MicrosoftGraphCalendarPermission, *_nethttp.Response, error) {
	return r.ApiService.GroupsCalendarViewCalendarGetCalendarPermissionsExecute(r)
}

/*
GroupsCalendarViewCalendarGetCalendarPermissions Get calendarPermissions from groups

The permissions of the users with whom the calendar is shared.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupId key: id of group
 @param eventId key: id of event
 @param calendarPermissionId key: id of calendarPermission
 @return ApiGroupsCalendarViewCalendarGetCalendarPermissionsRequest
*/
func (a *GroupsEventApiService) GroupsCalendarViewCalendarGetCalendarPermissions(ctx _context.Context, groupId string, eventId string, calendarPermissionId string) ApiGroupsCalendarViewCalendarGetCalendarPermissionsRequest {
	return ApiGroupsCalendarViewCalendarGetCalendarPermissionsRequest{
		ApiService: a,
		ctx: ctx,
		groupId: groupId,
		eventId: eventId,
		calendarPermissionId: calendarPermissionId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphCalendarPermission
func (a *GroupsEventApiService) GroupsCalendarViewCalendarGetCalendarPermissionsExecute(r ApiGroupsCalendarViewCalendarGetCalendarPermissionsRequest) (MicrosoftGraphCalendarPermission, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphCalendarPermission
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GroupsEventApiService.GroupsCalendarViewCalendarGetCalendarPermissions")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/groups/{group-id}/calendarView/{event-id}/calendar/calendarPermissions/{calendarPermission-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"calendarPermission-id"+"}", _neturl.PathEscape(parameterToString(r.calendarPermissionId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGroupsCalendarViewCalendarGetCalendarViewRequest struct {
	ctx _context.Context
	ApiService *GroupsEventApiService
	groupId string
	eventId string
	eventId1 string
	select_ *[]string
}

// Select properties to be returned
func (r ApiGroupsCalendarViewCalendarGetCalendarViewRequest) Select_(select_ []string) ApiGroupsCalendarViewCalendarGetCalendarViewRequest {
	r.select_ = &select_
	return r
}

func (r ApiGroupsCalendarViewCalendarGetCalendarViewRequest) Execute() (MicrosoftGraphEvent, *_nethttp.Response, error) {
	return r.ApiService.GroupsCalendarViewCalendarGetCalendarViewExecute(r)
}

/*
GroupsCalendarViewCalendarGetCalendarView Get calendarView from groups

The calendar view for the calendar. Navigation property. Read-only.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupId key: id of group
 @param eventId key: id of event
 @param eventId1 key: id of event
 @return ApiGroupsCalendarViewCalendarGetCalendarViewRequest
*/
func (a *GroupsEventApiService) GroupsCalendarViewCalendarGetCalendarView(ctx _context.Context, groupId string, eventId string, eventId1 string) ApiGroupsCalendarViewCalendarGetCalendarViewRequest {
	return ApiGroupsCalendarViewCalendarGetCalendarViewRequest{
		ApiService: a,
		ctx: ctx,
		groupId: groupId,
		eventId: eventId,
		eventId1: eventId1,
	}
}

// Execute executes the request
//  @return MicrosoftGraphEvent
func (a *GroupsEventApiService) GroupsCalendarViewCalendarGetCalendarViewExecute(r ApiGroupsCalendarViewCalendarGetCalendarViewRequest) (MicrosoftGraphEvent, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphEvent
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GroupsEventApiService.GroupsCalendarViewCalendarGetCalendarView")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/groups/{group-id}/calendarView/{event-id}/calendar/calendarView/{event-id1}"
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id1"+"}", _neturl.PathEscape(parameterToString(r.eventId1, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGroupsCalendarViewCalendarGetEventsRequest struct {
	ctx _context.Context
	ApiService *GroupsEventApiService
	groupId string
	eventId string
	eventId1 string
	select_ *[]string
}

// Select properties to be returned
func (r ApiGroupsCalendarViewCalendarGetEventsRequest) Select_(select_ []string) ApiGroupsCalendarViewCalendarGetEventsRequest {
	r.select_ = &select_
	return r
}

func (r ApiGroupsCalendarViewCalendarGetEventsRequest) Execute() (MicrosoftGraphEvent, *_nethttp.Response, error) {
	return r.ApiService.GroupsCalendarViewCalendarGetEventsExecute(r)
}

/*
GroupsCalendarViewCalendarGetEvents Get events from groups

The events in the calendar. Navigation property. Read-only.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupId key: id of group
 @param eventId key: id of event
 @param eventId1 key: id of event
 @return ApiGroupsCalendarViewCalendarGetEventsRequest
*/
func (a *GroupsEventApiService) GroupsCalendarViewCalendarGetEvents(ctx _context.Context, groupId string, eventId string, eventId1 string) ApiGroupsCalendarViewCalendarGetEventsRequest {
	return ApiGroupsCalendarViewCalendarGetEventsRequest{
		ApiService: a,
		ctx: ctx,
		groupId: groupId,
		eventId: eventId,
		eventId1: eventId1,
	}
}

// Execute executes the request
//  @return MicrosoftGraphEvent
func (a *GroupsEventApiService) GroupsCalendarViewCalendarGetEventsExecute(r ApiGroupsCalendarViewCalendarGetEventsRequest) (MicrosoftGraphEvent, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphEvent
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GroupsEventApiService.GroupsCalendarViewCalendarGetEvents")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/groups/{group-id}/calendarView/{event-id}/calendar/events/{event-id1}"
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id1"+"}", _neturl.PathEscape(parameterToString(r.eventId1, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGroupsCalendarViewCalendarGetMultiValueExtendedPropertiesRequest struct {
	ctx _context.Context
	ApiService *GroupsEventApiService
	groupId string
	eventId string
	multiValueLegacyExtendedPropertyId string
	select_ *[]string
	expand *[]string
}

// Select properties to be returned
func (r ApiGroupsCalendarViewCalendarGetMultiValueExtendedPropertiesRequest) Select_(select_ []string) ApiGroupsCalendarViewCalendarGetMultiValueExtendedPropertiesRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiGroupsCalendarViewCalendarGetMultiValueExtendedPropertiesRequest) Expand(expand []string) ApiGroupsCalendarViewCalendarGetMultiValueExtendedPropertiesRequest {
	r.expand = &expand
	return r
}

func (r ApiGroupsCalendarViewCalendarGetMultiValueExtendedPropertiesRequest) Execute() (MicrosoftGraphMultiValueLegacyExtendedProperty, *_nethttp.Response, error) {
	return r.ApiService.GroupsCalendarViewCalendarGetMultiValueExtendedPropertiesExecute(r)
}

/*
GroupsCalendarViewCalendarGetMultiValueExtendedProperties Get multiValueExtendedProperties from groups

The collection of multi-value extended properties defined for the calendar. Read-only. Nullable.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupId key: id of group
 @param eventId key: id of event
 @param multiValueLegacyExtendedPropertyId key: id of multiValueLegacyExtendedProperty
 @return ApiGroupsCalendarViewCalendarGetMultiValueExtendedPropertiesRequest
*/
func (a *GroupsEventApiService) GroupsCalendarViewCalendarGetMultiValueExtendedProperties(ctx _context.Context, groupId string, eventId string, multiValueLegacyExtendedPropertyId string) ApiGroupsCalendarViewCalendarGetMultiValueExtendedPropertiesRequest {
	return ApiGroupsCalendarViewCalendarGetMultiValueExtendedPropertiesRequest{
		ApiService: a,
		ctx: ctx,
		groupId: groupId,
		eventId: eventId,
		multiValueLegacyExtendedPropertyId: multiValueLegacyExtendedPropertyId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphMultiValueLegacyExtendedProperty
func (a *GroupsEventApiService) GroupsCalendarViewCalendarGetMultiValueExtendedPropertiesExecute(r ApiGroupsCalendarViewCalendarGetMultiValueExtendedPropertiesRequest) (MicrosoftGraphMultiValueLegacyExtendedProperty, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphMultiValueLegacyExtendedProperty
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GroupsEventApiService.GroupsCalendarViewCalendarGetMultiValueExtendedProperties")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/groups/{group-id}/calendarView/{event-id}/calendar/multiValueExtendedProperties/{multiValueLegacyExtendedProperty-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"multiValueLegacyExtendedProperty-id"+"}", _neturl.PathEscape(parameterToString(r.multiValueLegacyExtendedPropertyId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGroupsCalendarViewCalendarGetSingleValueExtendedPropertiesRequest struct {
	ctx _context.Context
	ApiService *GroupsEventApiService
	groupId string
	eventId string
	singleValueLegacyExtendedPropertyId string
	select_ *[]string
	expand *[]string
}

// Select properties to be returned
func (r ApiGroupsCalendarViewCalendarGetSingleValueExtendedPropertiesRequest) Select_(select_ []string) ApiGroupsCalendarViewCalendarGetSingleValueExtendedPropertiesRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiGroupsCalendarViewCalendarGetSingleValueExtendedPropertiesRequest) Expand(expand []string) ApiGroupsCalendarViewCalendarGetSingleValueExtendedPropertiesRequest {
	r.expand = &expand
	return r
}

func (r ApiGroupsCalendarViewCalendarGetSingleValueExtendedPropertiesRequest) Execute() (MicrosoftGraphSingleValueLegacyExtendedProperty, *_nethttp.Response, error) {
	return r.ApiService.GroupsCalendarViewCalendarGetSingleValueExtendedPropertiesExecute(r)
}

/*
GroupsCalendarViewCalendarGetSingleValueExtendedProperties Get singleValueExtendedProperties from groups

The collection of single-value extended properties defined for the calendar. Read-only. Nullable.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupId key: id of group
 @param eventId key: id of event
 @param singleValueLegacyExtendedPropertyId key: id of singleValueLegacyExtendedProperty
 @return ApiGroupsCalendarViewCalendarGetSingleValueExtendedPropertiesRequest
*/
func (a *GroupsEventApiService) GroupsCalendarViewCalendarGetSingleValueExtendedProperties(ctx _context.Context, groupId string, eventId string, singleValueLegacyExtendedPropertyId string) ApiGroupsCalendarViewCalendarGetSingleValueExtendedPropertiesRequest {
	return ApiGroupsCalendarViewCalendarGetSingleValueExtendedPropertiesRequest{
		ApiService: a,
		ctx: ctx,
		groupId: groupId,
		eventId: eventId,
		singleValueLegacyExtendedPropertyId: singleValueLegacyExtendedPropertyId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphSingleValueLegacyExtendedProperty
func (a *GroupsEventApiService) GroupsCalendarViewCalendarGetSingleValueExtendedPropertiesExecute(r ApiGroupsCalendarViewCalendarGetSingleValueExtendedPropertiesRequest) (MicrosoftGraphSingleValueLegacyExtendedProperty, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphSingleValueLegacyExtendedProperty
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GroupsEventApiService.GroupsCalendarViewCalendarGetSingleValueExtendedProperties")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/groups/{group-id}/calendarView/{event-id}/calendar/singleValueExtendedProperties/{singleValueLegacyExtendedProperty-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"singleValueLegacyExtendedProperty-id"+"}", _neturl.PathEscape(parameterToString(r.singleValueLegacyExtendedPropertyId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGroupsCalendarViewCalendarListCalendarPermissionsRequest struct {
	ctx _context.Context
	ApiService *GroupsEventApiService
	groupId string
	eventId string
	top *int32
	skip *int32
	filter *string
	count *bool
	orderby *[]string
	select_ *[]string
}

// Show only the first n items
func (r ApiGroupsCalendarViewCalendarListCalendarPermissionsRequest) Top(top int32) ApiGroupsCalendarViewCalendarListCalendarPermissionsRequest {
	r.top = &top
	return r
}
// Skip the first n items
func (r ApiGroupsCalendarViewCalendarListCalendarPermissionsRequest) Skip(skip int32) ApiGroupsCalendarViewCalendarListCalendarPermissionsRequest {
	r.skip = &skip
	return r
}
// Filter items by property values
func (r ApiGroupsCalendarViewCalendarListCalendarPermissionsRequest) Filter(filter string) ApiGroupsCalendarViewCalendarListCalendarPermissionsRequest {
	r.filter = &filter
	return r
}
// Include count of items
func (r ApiGroupsCalendarViewCalendarListCalendarPermissionsRequest) Count(count bool) ApiGroupsCalendarViewCalendarListCalendarPermissionsRequest {
	r.count = &count
	return r
}
// Order items by property values
func (r ApiGroupsCalendarViewCalendarListCalendarPermissionsRequest) Orderby(orderby []string) ApiGroupsCalendarViewCalendarListCalendarPermissionsRequest {
	r.orderby = &orderby
	return r
}
// Select properties to be returned
func (r ApiGroupsCalendarViewCalendarListCalendarPermissionsRequest) Select_(select_ []string) ApiGroupsCalendarViewCalendarListCalendarPermissionsRequest {
	r.select_ = &select_
	return r
}

func (r ApiGroupsCalendarViewCalendarListCalendarPermissionsRequest) Execute() (CollectionOfCalendarPermission, *_nethttp.Response, error) {
	return r.ApiService.GroupsCalendarViewCalendarListCalendarPermissionsExecute(r)
}

/*
GroupsCalendarViewCalendarListCalendarPermissions Get calendarPermissions from groups

The permissions of the users with whom the calendar is shared.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupId key: id of group
 @param eventId key: id of event
 @return ApiGroupsCalendarViewCalendarListCalendarPermissionsRequest
*/
func (a *GroupsEventApiService) GroupsCalendarViewCalendarListCalendarPermissions(ctx _context.Context, groupId string, eventId string) ApiGroupsCalendarViewCalendarListCalendarPermissionsRequest {
	return ApiGroupsCalendarViewCalendarListCalendarPermissionsRequest{
		ApiService: a,
		ctx: ctx,
		groupId: groupId,
		eventId: eventId,
	}
}

// Execute executes the request
//  @return CollectionOfCalendarPermission
func (a *GroupsEventApiService) GroupsCalendarViewCalendarListCalendarPermissionsExecute(r ApiGroupsCalendarViewCalendarListCalendarPermissionsRequest) (CollectionOfCalendarPermission, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  CollectionOfCalendarPermission
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GroupsEventApiService.GroupsCalendarViewCalendarListCalendarPermissions")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/groups/{group-id}/calendarView/{event-id}/calendar/calendarPermissions"
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.top != nil {
		localVarQueryParams.Add("$top", parameterToString(*r.top, ""))
	}
	if r.skip != nil {
		localVarQueryParams.Add("$skip", parameterToString(*r.skip, ""))
	}
	if r.filter != nil {
		localVarQueryParams.Add("$filter", parameterToString(*r.filter, ""))
	}
	if r.count != nil {
		localVarQueryParams.Add("$count", parameterToString(*r.count, ""))
	}
	if r.orderby != nil {
		localVarQueryParams.Add("$orderby", parameterToString(*r.orderby, "csv"))
	}
	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGroupsCalendarViewCalendarListCalendarViewRequest struct {
	ctx _context.Context
	ApiService *GroupsEventApiService
	groupId string
	eventId string
	top *int32
	skip *int32
	filter *string
	count *bool
	orderby *[]string
	select_ *[]string
}

// Show only the first n items
func (r ApiGroupsCalendarViewCalendarListCalendarViewRequest) Top(top int32) ApiGroupsCalendarViewCalendarListCalendarViewRequest {
	r.top = &top
	return r
}
// Skip the first n items
func (r ApiGroupsCalendarViewCalendarListCalendarViewRequest) Skip(skip int32) ApiGroupsCalendarViewCalendarListCalendarViewRequest {
	r.skip = &skip
	return r
}
// Filter items by property values
func (r ApiGroupsCalendarViewCalendarListCalendarViewRequest) Filter(filter string) ApiGroupsCalendarViewCalendarListCalendarViewRequest {
	r.filter = &filter
	return r
}
// Include count of items
func (r ApiGroupsCalendarViewCalendarListCalendarViewRequest) Count(count bool) ApiGroupsCalendarViewCalendarListCalendarViewRequest {
	r.count = &count
	return r
}
// Order items by property values
func (r ApiGroupsCalendarViewCalendarListCalendarViewRequest) Orderby(orderby []string) ApiGroupsCalendarViewCalendarListCalendarViewRequest {
	r.orderby = &orderby
	return r
}
// Select properties to be returned
func (r ApiGroupsCalendarViewCalendarListCalendarViewRequest) Select_(select_ []string) ApiGroupsCalendarViewCalendarListCalendarViewRequest {
	r.select_ = &select_
	return r
}

func (r ApiGroupsCalendarViewCalendarListCalendarViewRequest) Execute() (CollectionOfEvent, *_nethttp.Response, error) {
	return r.ApiService.GroupsCalendarViewCalendarListCalendarViewExecute(r)
}

/*
GroupsCalendarViewCalendarListCalendarView Get calendarView from groups

The calendar view for the calendar. Navigation property. Read-only.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupId key: id of group
 @param eventId key: id of event
 @return ApiGroupsCalendarViewCalendarListCalendarViewRequest
*/
func (a *GroupsEventApiService) GroupsCalendarViewCalendarListCalendarView(ctx _context.Context, groupId string, eventId string) ApiGroupsCalendarViewCalendarListCalendarViewRequest {
	return ApiGroupsCalendarViewCalendarListCalendarViewRequest{
		ApiService: a,
		ctx: ctx,
		groupId: groupId,
		eventId: eventId,
	}
}

// Execute executes the request
//  @return CollectionOfEvent
func (a *GroupsEventApiService) GroupsCalendarViewCalendarListCalendarViewExecute(r ApiGroupsCalendarViewCalendarListCalendarViewRequest) (CollectionOfEvent, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  CollectionOfEvent
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GroupsEventApiService.GroupsCalendarViewCalendarListCalendarView")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/groups/{group-id}/calendarView/{event-id}/calendar/calendarView"
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.top != nil {
		localVarQueryParams.Add("$top", parameterToString(*r.top, ""))
	}
	if r.skip != nil {
		localVarQueryParams.Add("$skip", parameterToString(*r.skip, ""))
	}
	if r.filter != nil {
		localVarQueryParams.Add("$filter", parameterToString(*r.filter, ""))
	}
	if r.count != nil {
		localVarQueryParams.Add("$count", parameterToString(*r.count, ""))
	}
	if r.orderby != nil {
		localVarQueryParams.Add("$orderby", parameterToString(*r.orderby, "csv"))
	}
	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGroupsCalendarViewCalendarListEventsRequest struct {
	ctx _context.Context
	ApiService *GroupsEventApiService
	groupId string
	eventId string
	top *int32
	skip *int32
	filter *string
	count *bool
	orderby *[]string
	select_ *[]string
}

// Show only the first n items
func (r ApiGroupsCalendarViewCalendarListEventsRequest) Top(top int32) ApiGroupsCalendarViewCalendarListEventsRequest {
	r.top = &top
	return r
}
// Skip the first n items
func (r ApiGroupsCalendarViewCalendarListEventsRequest) Skip(skip int32) ApiGroupsCalendarViewCalendarListEventsRequest {
	r.skip = &skip
	return r
}
// Filter items by property values
func (r ApiGroupsCalendarViewCalendarListEventsRequest) Filter(filter string) ApiGroupsCalendarViewCalendarListEventsRequest {
	r.filter = &filter
	return r
}
// Include count of items
func (r ApiGroupsCalendarViewCalendarListEventsRequest) Count(count bool) ApiGroupsCalendarViewCalendarListEventsRequest {
	r.count = &count
	return r
}
// Order items by property values
func (r ApiGroupsCalendarViewCalendarListEventsRequest) Orderby(orderby []string) ApiGroupsCalendarViewCalendarListEventsRequest {
	r.orderby = &orderby
	return r
}
// Select properties to be returned
func (r ApiGroupsCalendarViewCalendarListEventsRequest) Select_(select_ []string) ApiGroupsCalendarViewCalendarListEventsRequest {
	r.select_ = &select_
	return r
}

func (r ApiGroupsCalendarViewCalendarListEventsRequest) Execute() (CollectionOfEvent, *_nethttp.Response, error) {
	return r.ApiService.GroupsCalendarViewCalendarListEventsExecute(r)
}

/*
GroupsCalendarViewCalendarListEvents Get events from groups

The events in the calendar. Navigation property. Read-only.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupId key: id of group
 @param eventId key: id of event
 @return ApiGroupsCalendarViewCalendarListEventsRequest
*/
func (a *GroupsEventApiService) GroupsCalendarViewCalendarListEvents(ctx _context.Context, groupId string, eventId string) ApiGroupsCalendarViewCalendarListEventsRequest {
	return ApiGroupsCalendarViewCalendarListEventsRequest{
		ApiService: a,
		ctx: ctx,
		groupId: groupId,
		eventId: eventId,
	}
}

// Execute executes the request
//  @return CollectionOfEvent
func (a *GroupsEventApiService) GroupsCalendarViewCalendarListEventsExecute(r ApiGroupsCalendarViewCalendarListEventsRequest) (CollectionOfEvent, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  CollectionOfEvent
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GroupsEventApiService.GroupsCalendarViewCalendarListEvents")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/groups/{group-id}/calendarView/{event-id}/calendar/events"
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.top != nil {
		localVarQueryParams.Add("$top", parameterToString(*r.top, ""))
	}
	if r.skip != nil {
		localVarQueryParams.Add("$skip", parameterToString(*r.skip, ""))
	}
	if r.filter != nil {
		localVarQueryParams.Add("$filter", parameterToString(*r.filter, ""))
	}
	if r.count != nil {
		localVarQueryParams.Add("$count", parameterToString(*r.count, ""))
	}
	if r.orderby != nil {
		localVarQueryParams.Add("$orderby", parameterToString(*r.orderby, "csv"))
	}
	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGroupsCalendarViewCalendarListMultiValueExtendedPropertiesRequest struct {
	ctx _context.Context
	ApiService *GroupsEventApiService
	groupId string
	eventId string
	top *int32
	skip *int32
	search *string
	filter *string
	count *bool
	orderby *[]string
	select_ *[]string
	expand *[]string
}

// Show only the first n items
func (r ApiGroupsCalendarViewCalendarListMultiValueExtendedPropertiesRequest) Top(top int32) ApiGroupsCalendarViewCalendarListMultiValueExtendedPropertiesRequest {
	r.top = &top
	return r
}
// Skip the first n items
func (r ApiGroupsCalendarViewCalendarListMultiValueExtendedPropertiesRequest) Skip(skip int32) ApiGroupsCalendarViewCalendarListMultiValueExtendedPropertiesRequest {
	r.skip = &skip
	return r
}
// Search items by search phrases
func (r ApiGroupsCalendarViewCalendarListMultiValueExtendedPropertiesRequest) Search(search string) ApiGroupsCalendarViewCalendarListMultiValueExtendedPropertiesRequest {
	r.search = &search
	return r
}
// Filter items by property values
func (r ApiGroupsCalendarViewCalendarListMultiValueExtendedPropertiesRequest) Filter(filter string) ApiGroupsCalendarViewCalendarListMultiValueExtendedPropertiesRequest {
	r.filter = &filter
	return r
}
// Include count of items
func (r ApiGroupsCalendarViewCalendarListMultiValueExtendedPropertiesRequest) Count(count bool) ApiGroupsCalendarViewCalendarListMultiValueExtendedPropertiesRequest {
	r.count = &count
	return r
}
// Order items by property values
func (r ApiGroupsCalendarViewCalendarListMultiValueExtendedPropertiesRequest) Orderby(orderby []string) ApiGroupsCalendarViewCalendarListMultiValueExtendedPropertiesRequest {
	r.orderby = &orderby
	return r
}
// Select properties to be returned
func (r ApiGroupsCalendarViewCalendarListMultiValueExtendedPropertiesRequest) Select_(select_ []string) ApiGroupsCalendarViewCalendarListMultiValueExtendedPropertiesRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiGroupsCalendarViewCalendarListMultiValueExtendedPropertiesRequest) Expand(expand []string) ApiGroupsCalendarViewCalendarListMultiValueExtendedPropertiesRequest {
	r.expand = &expand
	return r
}

func (r ApiGroupsCalendarViewCalendarListMultiValueExtendedPropertiesRequest) Execute() (CollectionOfMultiValueLegacyExtendedProperty, *_nethttp.Response, error) {
	return r.ApiService.GroupsCalendarViewCalendarListMultiValueExtendedPropertiesExecute(r)
}

/*
GroupsCalendarViewCalendarListMultiValueExtendedProperties Get multiValueExtendedProperties from groups

The collection of multi-value extended properties defined for the calendar. Read-only. Nullable.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupId key: id of group
 @param eventId key: id of event
 @return ApiGroupsCalendarViewCalendarListMultiValueExtendedPropertiesRequest
*/
func (a *GroupsEventApiService) GroupsCalendarViewCalendarListMultiValueExtendedProperties(ctx _context.Context, groupId string, eventId string) ApiGroupsCalendarViewCalendarListMultiValueExtendedPropertiesRequest {
	return ApiGroupsCalendarViewCalendarListMultiValueExtendedPropertiesRequest{
		ApiService: a,
		ctx: ctx,
		groupId: groupId,
		eventId: eventId,
	}
}

// Execute executes the request
//  @return CollectionOfMultiValueLegacyExtendedProperty
func (a *GroupsEventApiService) GroupsCalendarViewCalendarListMultiValueExtendedPropertiesExecute(r ApiGroupsCalendarViewCalendarListMultiValueExtendedPropertiesRequest) (CollectionOfMultiValueLegacyExtendedProperty, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  CollectionOfMultiValueLegacyExtendedProperty
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GroupsEventApiService.GroupsCalendarViewCalendarListMultiValueExtendedProperties")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/groups/{group-id}/calendarView/{event-id}/calendar/multiValueExtendedProperties"
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.top != nil {
		localVarQueryParams.Add("$top", parameterToString(*r.top, ""))
	}
	if r.skip != nil {
		localVarQueryParams.Add("$skip", parameterToString(*r.skip, ""))
	}
	if r.search != nil {
		localVarQueryParams.Add("$search", parameterToString(*r.search, ""))
	}
	if r.filter != nil {
		localVarQueryParams.Add("$filter", parameterToString(*r.filter, ""))
	}
	if r.count != nil {
		localVarQueryParams.Add("$count", parameterToString(*r.count, ""))
	}
	if r.orderby != nil {
		localVarQueryParams.Add("$orderby", parameterToString(*r.orderby, "csv"))
	}
	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGroupsCalendarViewCalendarListSingleValueExtendedPropertiesRequest struct {
	ctx _context.Context
	ApiService *GroupsEventApiService
	groupId string
	eventId string
	top *int32
	skip *int32
	search *string
	filter *string
	count *bool
	orderby *[]string
	select_ *[]string
	expand *[]string
}

// Show only the first n items
func (r ApiGroupsCalendarViewCalendarListSingleValueExtendedPropertiesRequest) Top(top int32) ApiGroupsCalendarViewCalendarListSingleValueExtendedPropertiesRequest {
	r.top = &top
	return r
}
// Skip the first n items
func (r ApiGroupsCalendarViewCalendarListSingleValueExtendedPropertiesRequest) Skip(skip int32) ApiGroupsCalendarViewCalendarListSingleValueExtendedPropertiesRequest {
	r.skip = &skip
	return r
}
// Search items by search phrases
func (r ApiGroupsCalendarViewCalendarListSingleValueExtendedPropertiesRequest) Search(search string) ApiGroupsCalendarViewCalendarListSingleValueExtendedPropertiesRequest {
	r.search = &search
	return r
}
// Filter items by property values
func (r ApiGroupsCalendarViewCalendarListSingleValueExtendedPropertiesRequest) Filter(filter string) ApiGroupsCalendarViewCalendarListSingleValueExtendedPropertiesRequest {
	r.filter = &filter
	return r
}
// Include count of items
func (r ApiGroupsCalendarViewCalendarListSingleValueExtendedPropertiesRequest) Count(count bool) ApiGroupsCalendarViewCalendarListSingleValueExtendedPropertiesRequest {
	r.count = &count
	return r
}
// Order items by property values
func (r ApiGroupsCalendarViewCalendarListSingleValueExtendedPropertiesRequest) Orderby(orderby []string) ApiGroupsCalendarViewCalendarListSingleValueExtendedPropertiesRequest {
	r.orderby = &orderby
	return r
}
// Select properties to be returned
func (r ApiGroupsCalendarViewCalendarListSingleValueExtendedPropertiesRequest) Select_(select_ []string) ApiGroupsCalendarViewCalendarListSingleValueExtendedPropertiesRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiGroupsCalendarViewCalendarListSingleValueExtendedPropertiesRequest) Expand(expand []string) ApiGroupsCalendarViewCalendarListSingleValueExtendedPropertiesRequest {
	r.expand = &expand
	return r
}

func (r ApiGroupsCalendarViewCalendarListSingleValueExtendedPropertiesRequest) Execute() (CollectionOfSingleValueLegacyExtendedProperty, *_nethttp.Response, error) {
	return r.ApiService.GroupsCalendarViewCalendarListSingleValueExtendedPropertiesExecute(r)
}

/*
GroupsCalendarViewCalendarListSingleValueExtendedProperties Get singleValueExtendedProperties from groups

The collection of single-value extended properties defined for the calendar. Read-only. Nullable.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupId key: id of group
 @param eventId key: id of event
 @return ApiGroupsCalendarViewCalendarListSingleValueExtendedPropertiesRequest
*/
func (a *GroupsEventApiService) GroupsCalendarViewCalendarListSingleValueExtendedProperties(ctx _context.Context, groupId string, eventId string) ApiGroupsCalendarViewCalendarListSingleValueExtendedPropertiesRequest {
	return ApiGroupsCalendarViewCalendarListSingleValueExtendedPropertiesRequest{
		ApiService: a,
		ctx: ctx,
		groupId: groupId,
		eventId: eventId,
	}
}

// Execute executes the request
//  @return CollectionOfSingleValueLegacyExtendedProperty
func (a *GroupsEventApiService) GroupsCalendarViewCalendarListSingleValueExtendedPropertiesExecute(r ApiGroupsCalendarViewCalendarListSingleValueExtendedPropertiesRequest) (CollectionOfSingleValueLegacyExtendedProperty, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  CollectionOfSingleValueLegacyExtendedProperty
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GroupsEventApiService.GroupsCalendarViewCalendarListSingleValueExtendedProperties")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/groups/{group-id}/calendarView/{event-id}/calendar/singleValueExtendedProperties"
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.top != nil {
		localVarQueryParams.Add("$top", parameterToString(*r.top, ""))
	}
	if r.skip != nil {
		localVarQueryParams.Add("$skip", parameterToString(*r.skip, ""))
	}
	if r.search != nil {
		localVarQueryParams.Add("$search", parameterToString(*r.search, ""))
	}
	if r.filter != nil {
		localVarQueryParams.Add("$filter", parameterToString(*r.filter, ""))
	}
	if r.count != nil {
		localVarQueryParams.Add("$count", parameterToString(*r.count, ""))
	}
	if r.orderby != nil {
		localVarQueryParams.Add("$orderby", parameterToString(*r.orderby, "csv"))
	}
	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGroupsCalendarViewCalendarUpdateCalendarPermissionsRequest struct {
	ctx _context.Context
	ApiService *GroupsEventApiService
	groupId string
	eventId string
	calendarPermissionId string
	microsoftGraphCalendarPermission *MicrosoftGraphCalendarPermission
}

// New navigation property values
func (r ApiGroupsCalendarViewCalendarUpdateCalendarPermissionsRequest) MicrosoftGraphCalendarPermission(microsoftGraphCalendarPermission MicrosoftGraphCalendarPermission) ApiGroupsCalendarViewCalendarUpdateCalendarPermissionsRequest {
	r.microsoftGraphCalendarPermission = &microsoftGraphCalendarPermission
	return r
}

func (r ApiGroupsCalendarViewCalendarUpdateCalendarPermissionsRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.GroupsCalendarViewCalendarUpdateCalendarPermissionsExecute(r)
}

/*
GroupsCalendarViewCalendarUpdateCalendarPermissions Update the navigation property calendarPermissions in groups

The permissions of the users with whom the calendar is shared.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupId key: id of group
 @param eventId key: id of event
 @param calendarPermissionId key: id of calendarPermission
 @return ApiGroupsCalendarViewCalendarUpdateCalendarPermissionsRequest
*/
func (a *GroupsEventApiService) GroupsCalendarViewCalendarUpdateCalendarPermissions(ctx _context.Context, groupId string, eventId string, calendarPermissionId string) ApiGroupsCalendarViewCalendarUpdateCalendarPermissionsRequest {
	return ApiGroupsCalendarViewCalendarUpdateCalendarPermissionsRequest{
		ApiService: a,
		ctx: ctx,
		groupId: groupId,
		eventId: eventId,
		calendarPermissionId: calendarPermissionId,
	}
}

// Execute executes the request
func (a *GroupsEventApiService) GroupsCalendarViewCalendarUpdateCalendarPermissionsExecute(r ApiGroupsCalendarViewCalendarUpdateCalendarPermissionsRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPatch
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GroupsEventApiService.GroupsCalendarViewCalendarUpdateCalendarPermissions")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/groups/{group-id}/calendarView/{event-id}/calendar/calendarPermissions/{calendarPermission-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"calendarPermission-id"+"}", _neturl.PathEscape(parameterToString(r.calendarPermissionId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphCalendarPermission == nil {
		return nil, reportError("microsoftGraphCalendarPermission is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphCalendarPermission
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGroupsCalendarViewCalendarUpdateCalendarViewRequest struct {
	ctx _context.Context
	ApiService *GroupsEventApiService
	groupId string
	eventId string
	eventId1 string
	microsoftGraphEvent *MicrosoftGraphEvent
}

// New navigation property values
func (r ApiGroupsCalendarViewCalendarUpdateCalendarViewRequest) MicrosoftGraphEvent(microsoftGraphEvent MicrosoftGraphEvent) ApiGroupsCalendarViewCalendarUpdateCalendarViewRequest {
	r.microsoftGraphEvent = &microsoftGraphEvent
	return r
}

func (r ApiGroupsCalendarViewCalendarUpdateCalendarViewRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.GroupsCalendarViewCalendarUpdateCalendarViewExecute(r)
}

/*
GroupsCalendarViewCalendarUpdateCalendarView Update the navigation property calendarView in groups

The calendar view for the calendar. Navigation property. Read-only.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupId key: id of group
 @param eventId key: id of event
 @param eventId1 key: id of event
 @return ApiGroupsCalendarViewCalendarUpdateCalendarViewRequest
*/
func (a *GroupsEventApiService) GroupsCalendarViewCalendarUpdateCalendarView(ctx _context.Context, groupId string, eventId string, eventId1 string) ApiGroupsCalendarViewCalendarUpdateCalendarViewRequest {
	return ApiGroupsCalendarViewCalendarUpdateCalendarViewRequest{
		ApiService: a,
		ctx: ctx,
		groupId: groupId,
		eventId: eventId,
		eventId1: eventId1,
	}
}

// Execute executes the request
func (a *GroupsEventApiService) GroupsCalendarViewCalendarUpdateCalendarViewExecute(r ApiGroupsCalendarViewCalendarUpdateCalendarViewRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPatch
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GroupsEventApiService.GroupsCalendarViewCalendarUpdateCalendarView")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/groups/{group-id}/calendarView/{event-id}/calendar/calendarView/{event-id1}"
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id1"+"}", _neturl.PathEscape(parameterToString(r.eventId1, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphEvent == nil {
		return nil, reportError("microsoftGraphEvent is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphEvent
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGroupsCalendarViewCalendarUpdateEventsRequest struct {
	ctx _context.Context
	ApiService *GroupsEventApiService
	groupId string
	eventId string
	eventId1 string
	microsoftGraphEvent *MicrosoftGraphEvent
}

// New navigation property values
func (r ApiGroupsCalendarViewCalendarUpdateEventsRequest) MicrosoftGraphEvent(microsoftGraphEvent MicrosoftGraphEvent) ApiGroupsCalendarViewCalendarUpdateEventsRequest {
	r.microsoftGraphEvent = &microsoftGraphEvent
	return r
}

func (r ApiGroupsCalendarViewCalendarUpdateEventsRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.GroupsCalendarViewCalendarUpdateEventsExecute(r)
}

/*
GroupsCalendarViewCalendarUpdateEvents Update the navigation property events in groups

The events in the calendar. Navigation property. Read-only.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupId key: id of group
 @param eventId key: id of event
 @param eventId1 key: id of event
 @return ApiGroupsCalendarViewCalendarUpdateEventsRequest
*/
func (a *GroupsEventApiService) GroupsCalendarViewCalendarUpdateEvents(ctx _context.Context, groupId string, eventId string, eventId1 string) ApiGroupsCalendarViewCalendarUpdateEventsRequest {
	return ApiGroupsCalendarViewCalendarUpdateEventsRequest{
		ApiService: a,
		ctx: ctx,
		groupId: groupId,
		eventId: eventId,
		eventId1: eventId1,
	}
}

// Execute executes the request
func (a *GroupsEventApiService) GroupsCalendarViewCalendarUpdateEventsExecute(r ApiGroupsCalendarViewCalendarUpdateEventsRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPatch
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GroupsEventApiService.GroupsCalendarViewCalendarUpdateEvents")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/groups/{group-id}/calendarView/{event-id}/calendar/events/{event-id1}"
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id1"+"}", _neturl.PathEscape(parameterToString(r.eventId1, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphEvent == nil {
		return nil, reportError("microsoftGraphEvent is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphEvent
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGroupsCalendarViewCalendarUpdateMultiValueExtendedPropertiesRequest struct {
	ctx _context.Context
	ApiService *GroupsEventApiService
	groupId string
	eventId string
	multiValueLegacyExtendedPropertyId string
	microsoftGraphMultiValueLegacyExtendedProperty *MicrosoftGraphMultiValueLegacyExtendedProperty
}

// New navigation property values
func (r ApiGroupsCalendarViewCalendarUpdateMultiValueExtendedPropertiesRequest) MicrosoftGraphMultiValueLegacyExtendedProperty(microsoftGraphMultiValueLegacyExtendedProperty MicrosoftGraphMultiValueLegacyExtendedProperty) ApiGroupsCalendarViewCalendarUpdateMultiValueExtendedPropertiesRequest {
	r.microsoftGraphMultiValueLegacyExtendedProperty = &microsoftGraphMultiValueLegacyExtendedProperty
	return r
}

func (r ApiGroupsCalendarViewCalendarUpdateMultiValueExtendedPropertiesRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.GroupsCalendarViewCalendarUpdateMultiValueExtendedPropertiesExecute(r)
}

/*
GroupsCalendarViewCalendarUpdateMultiValueExtendedProperties Update the navigation property multiValueExtendedProperties in groups

The collection of multi-value extended properties defined for the calendar. Read-only. Nullable.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupId key: id of group
 @param eventId key: id of event
 @param multiValueLegacyExtendedPropertyId key: id of multiValueLegacyExtendedProperty
 @return ApiGroupsCalendarViewCalendarUpdateMultiValueExtendedPropertiesRequest
*/
func (a *GroupsEventApiService) GroupsCalendarViewCalendarUpdateMultiValueExtendedProperties(ctx _context.Context, groupId string, eventId string, multiValueLegacyExtendedPropertyId string) ApiGroupsCalendarViewCalendarUpdateMultiValueExtendedPropertiesRequest {
	return ApiGroupsCalendarViewCalendarUpdateMultiValueExtendedPropertiesRequest{
		ApiService: a,
		ctx: ctx,
		groupId: groupId,
		eventId: eventId,
		multiValueLegacyExtendedPropertyId: multiValueLegacyExtendedPropertyId,
	}
}

// Execute executes the request
func (a *GroupsEventApiService) GroupsCalendarViewCalendarUpdateMultiValueExtendedPropertiesExecute(r ApiGroupsCalendarViewCalendarUpdateMultiValueExtendedPropertiesRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPatch
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GroupsEventApiService.GroupsCalendarViewCalendarUpdateMultiValueExtendedProperties")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/groups/{group-id}/calendarView/{event-id}/calendar/multiValueExtendedProperties/{multiValueLegacyExtendedProperty-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"multiValueLegacyExtendedProperty-id"+"}", _neturl.PathEscape(parameterToString(r.multiValueLegacyExtendedPropertyId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphMultiValueLegacyExtendedProperty == nil {
		return nil, reportError("microsoftGraphMultiValueLegacyExtendedProperty is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphMultiValueLegacyExtendedProperty
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGroupsCalendarViewCalendarUpdateSingleValueExtendedPropertiesRequest struct {
	ctx _context.Context
	ApiService *GroupsEventApiService
	groupId string
	eventId string
	singleValueLegacyExtendedPropertyId string
	microsoftGraphSingleValueLegacyExtendedProperty *MicrosoftGraphSingleValueLegacyExtendedProperty
}

// New navigation property values
func (r ApiGroupsCalendarViewCalendarUpdateSingleValueExtendedPropertiesRequest) MicrosoftGraphSingleValueLegacyExtendedProperty(microsoftGraphSingleValueLegacyExtendedProperty MicrosoftGraphSingleValueLegacyExtendedProperty) ApiGroupsCalendarViewCalendarUpdateSingleValueExtendedPropertiesRequest {
	r.microsoftGraphSingleValueLegacyExtendedProperty = &microsoftGraphSingleValueLegacyExtendedProperty
	return r
}

func (r ApiGroupsCalendarViewCalendarUpdateSingleValueExtendedPropertiesRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.GroupsCalendarViewCalendarUpdateSingleValueExtendedPropertiesExecute(r)
}

/*
GroupsCalendarViewCalendarUpdateSingleValueExtendedProperties Update the navigation property singleValueExtendedProperties in groups

The collection of single-value extended properties defined for the calendar. Read-only. Nullable.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupId key: id of group
 @param eventId key: id of event
 @param singleValueLegacyExtendedPropertyId key: id of singleValueLegacyExtendedProperty
 @return ApiGroupsCalendarViewCalendarUpdateSingleValueExtendedPropertiesRequest
*/
func (a *GroupsEventApiService) GroupsCalendarViewCalendarUpdateSingleValueExtendedProperties(ctx _context.Context, groupId string, eventId string, singleValueLegacyExtendedPropertyId string) ApiGroupsCalendarViewCalendarUpdateSingleValueExtendedPropertiesRequest {
	return ApiGroupsCalendarViewCalendarUpdateSingleValueExtendedPropertiesRequest{
		ApiService: a,
		ctx: ctx,
		groupId: groupId,
		eventId: eventId,
		singleValueLegacyExtendedPropertyId: singleValueLegacyExtendedPropertyId,
	}
}

// Execute executes the request
func (a *GroupsEventApiService) GroupsCalendarViewCalendarUpdateSingleValueExtendedPropertiesExecute(r ApiGroupsCalendarViewCalendarUpdateSingleValueExtendedPropertiesRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPatch
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GroupsEventApiService.GroupsCalendarViewCalendarUpdateSingleValueExtendedProperties")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/groups/{group-id}/calendarView/{event-id}/calendar/singleValueExtendedProperties/{singleValueLegacyExtendedProperty-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"singleValueLegacyExtendedProperty-id"+"}", _neturl.PathEscape(parameterToString(r.singleValueLegacyExtendedPropertyId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphSingleValueLegacyExtendedProperty == nil {
		return nil, reportError("microsoftGraphSingleValueLegacyExtendedProperty is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphSingleValueLegacyExtendedProperty
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGroupsCalendarViewCreateAttachmentsRequest struct {
	ctx _context.Context
	ApiService *GroupsEventApiService
	groupId string
	eventId string
	microsoftGraphAttachment *MicrosoftGraphAttachment
}

// New navigation property
func (r ApiGroupsCalendarViewCreateAttachmentsRequest) MicrosoftGraphAttachment(microsoftGraphAttachment MicrosoftGraphAttachment) ApiGroupsCalendarViewCreateAttachmentsRequest {
	r.microsoftGraphAttachment = &microsoftGraphAttachment
	return r
}

func (r ApiGroupsCalendarViewCreateAttachmentsRequest) Execute() (MicrosoftGraphAttachment, *_nethttp.Response, error) {
	return r.ApiService.GroupsCalendarViewCreateAttachmentsExecute(r)
}

/*
GroupsCalendarViewCreateAttachments Create new navigation property to attachments for groups

The collection of FileAttachment, ItemAttachment, and referenceAttachment attachments for the event. Navigation property. Read-only. Nullable.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupId key: id of group
 @param eventId key: id of event
 @return ApiGroupsCalendarViewCreateAttachmentsRequest
*/
func (a *GroupsEventApiService) GroupsCalendarViewCreateAttachments(ctx _context.Context, groupId string, eventId string) ApiGroupsCalendarViewCreateAttachmentsRequest {
	return ApiGroupsCalendarViewCreateAttachmentsRequest{
		ApiService: a,
		ctx: ctx,
		groupId: groupId,
		eventId: eventId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphAttachment
func (a *GroupsEventApiService) GroupsCalendarViewCreateAttachmentsExecute(r ApiGroupsCalendarViewCreateAttachmentsRequest) (MicrosoftGraphAttachment, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphAttachment
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GroupsEventApiService.GroupsCalendarViewCreateAttachments")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/groups/{group-id}/calendarView/{event-id}/attachments"
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphAttachment == nil {
		return localVarReturnValue, nil, reportError("microsoftGraphAttachment is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphAttachment
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGroupsCalendarViewCreateExtensionsRequest struct {
	ctx _context.Context
	ApiService *GroupsEventApiService
	groupId string
	eventId string
	microsoftGraphExtension *MicrosoftGraphExtension
}

// New navigation property
func (r ApiGroupsCalendarViewCreateExtensionsRequest) MicrosoftGraphExtension(microsoftGraphExtension MicrosoftGraphExtension) ApiGroupsCalendarViewCreateExtensionsRequest {
	r.microsoftGraphExtension = &microsoftGraphExtension
	return r
}

func (r ApiGroupsCalendarViewCreateExtensionsRequest) Execute() (MicrosoftGraphExtension, *_nethttp.Response, error) {
	return r.ApiService.GroupsCalendarViewCreateExtensionsExecute(r)
}

/*
GroupsCalendarViewCreateExtensions Create new navigation property to extensions for groups

The collection of open extensions defined for the event. Nullable.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupId key: id of group
 @param eventId key: id of event
 @return ApiGroupsCalendarViewCreateExtensionsRequest
*/
func (a *GroupsEventApiService) GroupsCalendarViewCreateExtensions(ctx _context.Context, groupId string, eventId string) ApiGroupsCalendarViewCreateExtensionsRequest {
	return ApiGroupsCalendarViewCreateExtensionsRequest{
		ApiService: a,
		ctx: ctx,
		groupId: groupId,
		eventId: eventId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphExtension
func (a *GroupsEventApiService) GroupsCalendarViewCreateExtensionsExecute(r ApiGroupsCalendarViewCreateExtensionsRequest) (MicrosoftGraphExtension, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphExtension
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GroupsEventApiService.GroupsCalendarViewCreateExtensions")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/groups/{group-id}/calendarView/{event-id}/extensions"
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphExtension == nil {
		return localVarReturnValue, nil, reportError("microsoftGraphExtension is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphExtension
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGroupsCalendarViewCreateInstancesRequest struct {
	ctx _context.Context
	ApiService *GroupsEventApiService
	groupId string
	eventId string
	microsoftGraphEvent *MicrosoftGraphEvent
}

// New navigation property
func (r ApiGroupsCalendarViewCreateInstancesRequest) MicrosoftGraphEvent(microsoftGraphEvent MicrosoftGraphEvent) ApiGroupsCalendarViewCreateInstancesRequest {
	r.microsoftGraphEvent = &microsoftGraphEvent
	return r
}

func (r ApiGroupsCalendarViewCreateInstancesRequest) Execute() (MicrosoftGraphEvent, *_nethttp.Response, error) {
	return r.ApiService.GroupsCalendarViewCreateInstancesExecute(r)
}

/*
GroupsCalendarViewCreateInstances Create new navigation property to instances for groups

The occurrences of a recurring series, if the event is a series master. This property includes occurrences that are part of the recurrence pattern, and exceptions that have been modified, but does not include occurrences that have been cancelled from the series. Navigation property. Read-only. Nullable.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupId key: id of group
 @param eventId key: id of event
 @return ApiGroupsCalendarViewCreateInstancesRequest
*/
func (a *GroupsEventApiService) GroupsCalendarViewCreateInstances(ctx _context.Context, groupId string, eventId string) ApiGroupsCalendarViewCreateInstancesRequest {
	return ApiGroupsCalendarViewCreateInstancesRequest{
		ApiService: a,
		ctx: ctx,
		groupId: groupId,
		eventId: eventId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphEvent
func (a *GroupsEventApiService) GroupsCalendarViewCreateInstancesExecute(r ApiGroupsCalendarViewCreateInstancesRequest) (MicrosoftGraphEvent, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphEvent
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GroupsEventApiService.GroupsCalendarViewCreateInstances")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/groups/{group-id}/calendarView/{event-id}/instances"
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphEvent == nil {
		return localVarReturnValue, nil, reportError("microsoftGraphEvent is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphEvent
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGroupsCalendarViewCreateMultiValueExtendedPropertiesRequest struct {
	ctx _context.Context
	ApiService *GroupsEventApiService
	groupId string
	eventId string
	microsoftGraphMultiValueLegacyExtendedProperty *MicrosoftGraphMultiValueLegacyExtendedProperty
}

// New navigation property
func (r ApiGroupsCalendarViewCreateMultiValueExtendedPropertiesRequest) MicrosoftGraphMultiValueLegacyExtendedProperty(microsoftGraphMultiValueLegacyExtendedProperty MicrosoftGraphMultiValueLegacyExtendedProperty) ApiGroupsCalendarViewCreateMultiValueExtendedPropertiesRequest {
	r.microsoftGraphMultiValueLegacyExtendedProperty = &microsoftGraphMultiValueLegacyExtendedProperty
	return r
}

func (r ApiGroupsCalendarViewCreateMultiValueExtendedPropertiesRequest) Execute() (MicrosoftGraphMultiValueLegacyExtendedProperty, *_nethttp.Response, error) {
	return r.ApiService.GroupsCalendarViewCreateMultiValueExtendedPropertiesExecute(r)
}

/*
GroupsCalendarViewCreateMultiValueExtendedProperties Create new navigation property to multiValueExtendedProperties for groups

The collection of multi-value extended properties defined for the event. Read-only. Nullable.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupId key: id of group
 @param eventId key: id of event
 @return ApiGroupsCalendarViewCreateMultiValueExtendedPropertiesRequest
*/
func (a *GroupsEventApiService) GroupsCalendarViewCreateMultiValueExtendedProperties(ctx _context.Context, groupId string, eventId string) ApiGroupsCalendarViewCreateMultiValueExtendedPropertiesRequest {
	return ApiGroupsCalendarViewCreateMultiValueExtendedPropertiesRequest{
		ApiService: a,
		ctx: ctx,
		groupId: groupId,
		eventId: eventId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphMultiValueLegacyExtendedProperty
func (a *GroupsEventApiService) GroupsCalendarViewCreateMultiValueExtendedPropertiesExecute(r ApiGroupsCalendarViewCreateMultiValueExtendedPropertiesRequest) (MicrosoftGraphMultiValueLegacyExtendedProperty, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphMultiValueLegacyExtendedProperty
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GroupsEventApiService.GroupsCalendarViewCreateMultiValueExtendedProperties")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/groups/{group-id}/calendarView/{event-id}/multiValueExtendedProperties"
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphMultiValueLegacyExtendedProperty == nil {
		return localVarReturnValue, nil, reportError("microsoftGraphMultiValueLegacyExtendedProperty is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphMultiValueLegacyExtendedProperty
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGroupsCalendarViewCreateSingleValueExtendedPropertiesRequest struct {
	ctx _context.Context
	ApiService *GroupsEventApiService
	groupId string
	eventId string
	microsoftGraphSingleValueLegacyExtendedProperty *MicrosoftGraphSingleValueLegacyExtendedProperty
}

// New navigation property
func (r ApiGroupsCalendarViewCreateSingleValueExtendedPropertiesRequest) MicrosoftGraphSingleValueLegacyExtendedProperty(microsoftGraphSingleValueLegacyExtendedProperty MicrosoftGraphSingleValueLegacyExtendedProperty) ApiGroupsCalendarViewCreateSingleValueExtendedPropertiesRequest {
	r.microsoftGraphSingleValueLegacyExtendedProperty = &microsoftGraphSingleValueLegacyExtendedProperty
	return r
}

func (r ApiGroupsCalendarViewCreateSingleValueExtendedPropertiesRequest) Execute() (MicrosoftGraphSingleValueLegacyExtendedProperty, *_nethttp.Response, error) {
	return r.ApiService.GroupsCalendarViewCreateSingleValueExtendedPropertiesExecute(r)
}

/*
GroupsCalendarViewCreateSingleValueExtendedProperties Create new navigation property to singleValueExtendedProperties for groups

The collection of single-value extended properties defined for the event. Read-only. Nullable.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupId key: id of group
 @param eventId key: id of event
 @return ApiGroupsCalendarViewCreateSingleValueExtendedPropertiesRequest
*/
func (a *GroupsEventApiService) GroupsCalendarViewCreateSingleValueExtendedProperties(ctx _context.Context, groupId string, eventId string) ApiGroupsCalendarViewCreateSingleValueExtendedPropertiesRequest {
	return ApiGroupsCalendarViewCreateSingleValueExtendedPropertiesRequest{
		ApiService: a,
		ctx: ctx,
		groupId: groupId,
		eventId: eventId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphSingleValueLegacyExtendedProperty
func (a *GroupsEventApiService) GroupsCalendarViewCreateSingleValueExtendedPropertiesExecute(r ApiGroupsCalendarViewCreateSingleValueExtendedPropertiesRequest) (MicrosoftGraphSingleValueLegacyExtendedProperty, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphSingleValueLegacyExtendedProperty
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GroupsEventApiService.GroupsCalendarViewCreateSingleValueExtendedProperties")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/groups/{group-id}/calendarView/{event-id}/singleValueExtendedProperties"
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphSingleValueLegacyExtendedProperty == nil {
		return localVarReturnValue, nil, reportError("microsoftGraphSingleValueLegacyExtendedProperty is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphSingleValueLegacyExtendedProperty
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGroupsCalendarViewDeleteAttachmentsRequest struct {
	ctx _context.Context
	ApiService *GroupsEventApiService
	groupId string
	eventId string
	attachmentId string
	ifMatch *string
}

// ETag
func (r ApiGroupsCalendarViewDeleteAttachmentsRequest) IfMatch(ifMatch string) ApiGroupsCalendarViewDeleteAttachmentsRequest {
	r.ifMatch = &ifMatch
	return r
}

func (r ApiGroupsCalendarViewDeleteAttachmentsRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.GroupsCalendarViewDeleteAttachmentsExecute(r)
}

/*
GroupsCalendarViewDeleteAttachments Delete navigation property attachments for groups

The collection of FileAttachment, ItemAttachment, and referenceAttachment attachments for the event. Navigation property. Read-only. Nullable.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupId key: id of group
 @param eventId key: id of event
 @param attachmentId key: id of attachment
 @return ApiGroupsCalendarViewDeleteAttachmentsRequest
*/
func (a *GroupsEventApiService) GroupsCalendarViewDeleteAttachments(ctx _context.Context, groupId string, eventId string, attachmentId string) ApiGroupsCalendarViewDeleteAttachmentsRequest {
	return ApiGroupsCalendarViewDeleteAttachmentsRequest{
		ApiService: a,
		ctx: ctx,
		groupId: groupId,
		eventId: eventId,
		attachmentId: attachmentId,
	}
}

// Execute executes the request
func (a *GroupsEventApiService) GroupsCalendarViewDeleteAttachmentsExecute(r ApiGroupsCalendarViewDeleteAttachmentsRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GroupsEventApiService.GroupsCalendarViewDeleteAttachments")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/groups/{group-id}/calendarView/{event-id}/attachments/{attachment-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"attachment-id"+"}", _neturl.PathEscape(parameterToString(r.attachmentId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ifMatch != nil {
		localVarHeaderParams["If-Match"] = parameterToString(*r.ifMatch, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGroupsCalendarViewDeleteCalendarRequest struct {
	ctx _context.Context
	ApiService *GroupsEventApiService
	groupId string
	eventId string
	ifMatch *string
}

// ETag
func (r ApiGroupsCalendarViewDeleteCalendarRequest) IfMatch(ifMatch string) ApiGroupsCalendarViewDeleteCalendarRequest {
	r.ifMatch = &ifMatch
	return r
}

func (r ApiGroupsCalendarViewDeleteCalendarRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.GroupsCalendarViewDeleteCalendarExecute(r)
}

/*
GroupsCalendarViewDeleteCalendar Delete navigation property calendar for groups

The calendar that contains the event. Navigation property. Read-only.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupId key: id of group
 @param eventId key: id of event
 @return ApiGroupsCalendarViewDeleteCalendarRequest
*/
func (a *GroupsEventApiService) GroupsCalendarViewDeleteCalendar(ctx _context.Context, groupId string, eventId string) ApiGroupsCalendarViewDeleteCalendarRequest {
	return ApiGroupsCalendarViewDeleteCalendarRequest{
		ApiService: a,
		ctx: ctx,
		groupId: groupId,
		eventId: eventId,
	}
}

// Execute executes the request
func (a *GroupsEventApiService) GroupsCalendarViewDeleteCalendarExecute(r ApiGroupsCalendarViewDeleteCalendarRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GroupsEventApiService.GroupsCalendarViewDeleteCalendar")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/groups/{group-id}/calendarView/{event-id}/calendar"
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ifMatch != nil {
		localVarHeaderParams["If-Match"] = parameterToString(*r.ifMatch, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGroupsCalendarViewDeleteExtensionsRequest struct {
	ctx _context.Context
	ApiService *GroupsEventApiService
	groupId string
	eventId string
	extensionId string
	ifMatch *string
}

// ETag
func (r ApiGroupsCalendarViewDeleteExtensionsRequest) IfMatch(ifMatch string) ApiGroupsCalendarViewDeleteExtensionsRequest {
	r.ifMatch = &ifMatch
	return r
}

func (r ApiGroupsCalendarViewDeleteExtensionsRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.GroupsCalendarViewDeleteExtensionsExecute(r)
}

/*
GroupsCalendarViewDeleteExtensions Delete navigation property extensions for groups

The collection of open extensions defined for the event. Nullable.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupId key: id of group
 @param eventId key: id of event
 @param extensionId key: id of extension
 @return ApiGroupsCalendarViewDeleteExtensionsRequest
*/
func (a *GroupsEventApiService) GroupsCalendarViewDeleteExtensions(ctx _context.Context, groupId string, eventId string, extensionId string) ApiGroupsCalendarViewDeleteExtensionsRequest {
	return ApiGroupsCalendarViewDeleteExtensionsRequest{
		ApiService: a,
		ctx: ctx,
		groupId: groupId,
		eventId: eventId,
		extensionId: extensionId,
	}
}

// Execute executes the request
func (a *GroupsEventApiService) GroupsCalendarViewDeleteExtensionsExecute(r ApiGroupsCalendarViewDeleteExtensionsRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GroupsEventApiService.GroupsCalendarViewDeleteExtensions")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/groups/{group-id}/calendarView/{event-id}/extensions/{extension-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"extension-id"+"}", _neturl.PathEscape(parameterToString(r.extensionId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ifMatch != nil {
		localVarHeaderParams["If-Match"] = parameterToString(*r.ifMatch, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGroupsCalendarViewDeleteInstancesRequest struct {
	ctx _context.Context
	ApiService *GroupsEventApiService
	groupId string
	eventId string
	eventId1 string
	ifMatch *string
}

// ETag
func (r ApiGroupsCalendarViewDeleteInstancesRequest) IfMatch(ifMatch string) ApiGroupsCalendarViewDeleteInstancesRequest {
	r.ifMatch = &ifMatch
	return r
}

func (r ApiGroupsCalendarViewDeleteInstancesRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.GroupsCalendarViewDeleteInstancesExecute(r)
}

/*
GroupsCalendarViewDeleteInstances Delete navigation property instances for groups

The occurrences of a recurring series, if the event is a series master. This property includes occurrences that are part of the recurrence pattern, and exceptions that have been modified, but does not include occurrences that have been cancelled from the series. Navigation property. Read-only. Nullable.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupId key: id of group
 @param eventId key: id of event
 @param eventId1 key: id of event
 @return ApiGroupsCalendarViewDeleteInstancesRequest
*/
func (a *GroupsEventApiService) GroupsCalendarViewDeleteInstances(ctx _context.Context, groupId string, eventId string, eventId1 string) ApiGroupsCalendarViewDeleteInstancesRequest {
	return ApiGroupsCalendarViewDeleteInstancesRequest{
		ApiService: a,
		ctx: ctx,
		groupId: groupId,
		eventId: eventId,
		eventId1: eventId1,
	}
}

// Execute executes the request
func (a *GroupsEventApiService) GroupsCalendarViewDeleteInstancesExecute(r ApiGroupsCalendarViewDeleteInstancesRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GroupsEventApiService.GroupsCalendarViewDeleteInstances")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/groups/{group-id}/calendarView/{event-id}/instances/{event-id1}"
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id1"+"}", _neturl.PathEscape(parameterToString(r.eventId1, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ifMatch != nil {
		localVarHeaderParams["If-Match"] = parameterToString(*r.ifMatch, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGroupsCalendarViewDeleteMultiValueExtendedPropertiesRequest struct {
	ctx _context.Context
	ApiService *GroupsEventApiService
	groupId string
	eventId string
	multiValueLegacyExtendedPropertyId string
	ifMatch *string
}

// ETag
func (r ApiGroupsCalendarViewDeleteMultiValueExtendedPropertiesRequest) IfMatch(ifMatch string) ApiGroupsCalendarViewDeleteMultiValueExtendedPropertiesRequest {
	r.ifMatch = &ifMatch
	return r
}

func (r ApiGroupsCalendarViewDeleteMultiValueExtendedPropertiesRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.GroupsCalendarViewDeleteMultiValueExtendedPropertiesExecute(r)
}

/*
GroupsCalendarViewDeleteMultiValueExtendedProperties Delete navigation property multiValueExtendedProperties for groups

The collection of multi-value extended properties defined for the event. Read-only. Nullable.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupId key: id of group
 @param eventId key: id of event
 @param multiValueLegacyExtendedPropertyId key: id of multiValueLegacyExtendedProperty
 @return ApiGroupsCalendarViewDeleteMultiValueExtendedPropertiesRequest
*/
func (a *GroupsEventApiService) GroupsCalendarViewDeleteMultiValueExtendedProperties(ctx _context.Context, groupId string, eventId string, multiValueLegacyExtendedPropertyId string) ApiGroupsCalendarViewDeleteMultiValueExtendedPropertiesRequest {
	return ApiGroupsCalendarViewDeleteMultiValueExtendedPropertiesRequest{
		ApiService: a,
		ctx: ctx,
		groupId: groupId,
		eventId: eventId,
		multiValueLegacyExtendedPropertyId: multiValueLegacyExtendedPropertyId,
	}
}

// Execute executes the request
func (a *GroupsEventApiService) GroupsCalendarViewDeleteMultiValueExtendedPropertiesExecute(r ApiGroupsCalendarViewDeleteMultiValueExtendedPropertiesRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GroupsEventApiService.GroupsCalendarViewDeleteMultiValueExtendedProperties")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/groups/{group-id}/calendarView/{event-id}/multiValueExtendedProperties/{multiValueLegacyExtendedProperty-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"multiValueLegacyExtendedProperty-id"+"}", _neturl.PathEscape(parameterToString(r.multiValueLegacyExtendedPropertyId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ifMatch != nil {
		localVarHeaderParams["If-Match"] = parameterToString(*r.ifMatch, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGroupsCalendarViewDeleteSingleValueExtendedPropertiesRequest struct {
	ctx _context.Context
	ApiService *GroupsEventApiService
	groupId string
	eventId string
	singleValueLegacyExtendedPropertyId string
	ifMatch *string
}

// ETag
func (r ApiGroupsCalendarViewDeleteSingleValueExtendedPropertiesRequest) IfMatch(ifMatch string) ApiGroupsCalendarViewDeleteSingleValueExtendedPropertiesRequest {
	r.ifMatch = &ifMatch
	return r
}

func (r ApiGroupsCalendarViewDeleteSingleValueExtendedPropertiesRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.GroupsCalendarViewDeleteSingleValueExtendedPropertiesExecute(r)
}

/*
GroupsCalendarViewDeleteSingleValueExtendedProperties Delete navigation property singleValueExtendedProperties for groups

The collection of single-value extended properties defined for the event. Read-only. Nullable.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupId key: id of group
 @param eventId key: id of event
 @param singleValueLegacyExtendedPropertyId key: id of singleValueLegacyExtendedProperty
 @return ApiGroupsCalendarViewDeleteSingleValueExtendedPropertiesRequest
*/
func (a *GroupsEventApiService) GroupsCalendarViewDeleteSingleValueExtendedProperties(ctx _context.Context, groupId string, eventId string, singleValueLegacyExtendedPropertyId string) ApiGroupsCalendarViewDeleteSingleValueExtendedPropertiesRequest {
	return ApiGroupsCalendarViewDeleteSingleValueExtendedPropertiesRequest{
		ApiService: a,
		ctx: ctx,
		groupId: groupId,
		eventId: eventId,
		singleValueLegacyExtendedPropertyId: singleValueLegacyExtendedPropertyId,
	}
}

// Execute executes the request
func (a *GroupsEventApiService) GroupsCalendarViewDeleteSingleValueExtendedPropertiesExecute(r ApiGroupsCalendarViewDeleteSingleValueExtendedPropertiesRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GroupsEventApiService.GroupsCalendarViewDeleteSingleValueExtendedProperties")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/groups/{group-id}/calendarView/{event-id}/singleValueExtendedProperties/{singleValueLegacyExtendedProperty-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"singleValueLegacyExtendedProperty-id"+"}", _neturl.PathEscape(parameterToString(r.singleValueLegacyExtendedPropertyId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ifMatch != nil {
		localVarHeaderParams["If-Match"] = parameterToString(*r.ifMatch, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGroupsCalendarViewGetAttachmentsRequest struct {
	ctx _context.Context
	ApiService *GroupsEventApiService
	groupId string
	eventId string
	attachmentId string
	select_ *[]string
	expand *[]string
}

// Select properties to be returned
func (r ApiGroupsCalendarViewGetAttachmentsRequest) Select_(select_ []string) ApiGroupsCalendarViewGetAttachmentsRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiGroupsCalendarViewGetAttachmentsRequest) Expand(expand []string) ApiGroupsCalendarViewGetAttachmentsRequest {
	r.expand = &expand
	return r
}

func (r ApiGroupsCalendarViewGetAttachmentsRequest) Execute() (MicrosoftGraphAttachment, *_nethttp.Response, error) {
	return r.ApiService.GroupsCalendarViewGetAttachmentsExecute(r)
}

/*
GroupsCalendarViewGetAttachments Get attachments from groups

The collection of FileAttachment, ItemAttachment, and referenceAttachment attachments for the event. Navigation property. Read-only. Nullable.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupId key: id of group
 @param eventId key: id of event
 @param attachmentId key: id of attachment
 @return ApiGroupsCalendarViewGetAttachmentsRequest
*/
func (a *GroupsEventApiService) GroupsCalendarViewGetAttachments(ctx _context.Context, groupId string, eventId string, attachmentId string) ApiGroupsCalendarViewGetAttachmentsRequest {
	return ApiGroupsCalendarViewGetAttachmentsRequest{
		ApiService: a,
		ctx: ctx,
		groupId: groupId,
		eventId: eventId,
		attachmentId: attachmentId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphAttachment
func (a *GroupsEventApiService) GroupsCalendarViewGetAttachmentsExecute(r ApiGroupsCalendarViewGetAttachmentsRequest) (MicrosoftGraphAttachment, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphAttachment
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GroupsEventApiService.GroupsCalendarViewGetAttachments")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/groups/{group-id}/calendarView/{event-id}/attachments/{attachment-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"attachment-id"+"}", _neturl.PathEscape(parameterToString(r.attachmentId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGroupsCalendarViewGetCalendarRequest struct {
	ctx _context.Context
	ApiService *GroupsEventApiService
	groupId string
	eventId string
	select_ *[]string
}

// Select properties to be returned
func (r ApiGroupsCalendarViewGetCalendarRequest) Select_(select_ []string) ApiGroupsCalendarViewGetCalendarRequest {
	r.select_ = &select_
	return r
}

func (r ApiGroupsCalendarViewGetCalendarRequest) Execute() (MicrosoftGraphCalendar, *_nethttp.Response, error) {
	return r.ApiService.GroupsCalendarViewGetCalendarExecute(r)
}

/*
GroupsCalendarViewGetCalendar Get calendar from groups

The calendar that contains the event. Navigation property. Read-only.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupId key: id of group
 @param eventId key: id of event
 @return ApiGroupsCalendarViewGetCalendarRequest
*/
func (a *GroupsEventApiService) GroupsCalendarViewGetCalendar(ctx _context.Context, groupId string, eventId string) ApiGroupsCalendarViewGetCalendarRequest {
	return ApiGroupsCalendarViewGetCalendarRequest{
		ApiService: a,
		ctx: ctx,
		groupId: groupId,
		eventId: eventId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphCalendar
func (a *GroupsEventApiService) GroupsCalendarViewGetCalendarExecute(r ApiGroupsCalendarViewGetCalendarRequest) (MicrosoftGraphCalendar, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphCalendar
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GroupsEventApiService.GroupsCalendarViewGetCalendar")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/groups/{group-id}/calendarView/{event-id}/calendar"
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGroupsCalendarViewGetExtensionsRequest struct {
	ctx _context.Context
	ApiService *GroupsEventApiService
	groupId string
	eventId string
	extensionId string
	select_ *[]string
	expand *[]string
}

// Select properties to be returned
func (r ApiGroupsCalendarViewGetExtensionsRequest) Select_(select_ []string) ApiGroupsCalendarViewGetExtensionsRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiGroupsCalendarViewGetExtensionsRequest) Expand(expand []string) ApiGroupsCalendarViewGetExtensionsRequest {
	r.expand = &expand
	return r
}

func (r ApiGroupsCalendarViewGetExtensionsRequest) Execute() (MicrosoftGraphExtension, *_nethttp.Response, error) {
	return r.ApiService.GroupsCalendarViewGetExtensionsExecute(r)
}

/*
GroupsCalendarViewGetExtensions Get extensions from groups

The collection of open extensions defined for the event. Nullable.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupId key: id of group
 @param eventId key: id of event
 @param extensionId key: id of extension
 @return ApiGroupsCalendarViewGetExtensionsRequest
*/
func (a *GroupsEventApiService) GroupsCalendarViewGetExtensions(ctx _context.Context, groupId string, eventId string, extensionId string) ApiGroupsCalendarViewGetExtensionsRequest {
	return ApiGroupsCalendarViewGetExtensionsRequest{
		ApiService: a,
		ctx: ctx,
		groupId: groupId,
		eventId: eventId,
		extensionId: extensionId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphExtension
func (a *GroupsEventApiService) GroupsCalendarViewGetExtensionsExecute(r ApiGroupsCalendarViewGetExtensionsRequest) (MicrosoftGraphExtension, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphExtension
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GroupsEventApiService.GroupsCalendarViewGetExtensions")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/groups/{group-id}/calendarView/{event-id}/extensions/{extension-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"extension-id"+"}", _neturl.PathEscape(parameterToString(r.extensionId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGroupsCalendarViewGetInstancesRequest struct {
	ctx _context.Context
	ApiService *GroupsEventApiService
	groupId string
	eventId string
	eventId1 string
	select_ *[]string
}

// Select properties to be returned
func (r ApiGroupsCalendarViewGetInstancesRequest) Select_(select_ []string) ApiGroupsCalendarViewGetInstancesRequest {
	r.select_ = &select_
	return r
}

func (r ApiGroupsCalendarViewGetInstancesRequest) Execute() (MicrosoftGraphEvent, *_nethttp.Response, error) {
	return r.ApiService.GroupsCalendarViewGetInstancesExecute(r)
}

/*
GroupsCalendarViewGetInstances Get instances from groups

The occurrences of a recurring series, if the event is a series master. This property includes occurrences that are part of the recurrence pattern, and exceptions that have been modified, but does not include occurrences that have been cancelled from the series. Navigation property. Read-only. Nullable.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupId key: id of group
 @param eventId key: id of event
 @param eventId1 key: id of event
 @return ApiGroupsCalendarViewGetInstancesRequest
*/
func (a *GroupsEventApiService) GroupsCalendarViewGetInstances(ctx _context.Context, groupId string, eventId string, eventId1 string) ApiGroupsCalendarViewGetInstancesRequest {
	return ApiGroupsCalendarViewGetInstancesRequest{
		ApiService: a,
		ctx: ctx,
		groupId: groupId,
		eventId: eventId,
		eventId1: eventId1,
	}
}

// Execute executes the request
//  @return MicrosoftGraphEvent
func (a *GroupsEventApiService) GroupsCalendarViewGetInstancesExecute(r ApiGroupsCalendarViewGetInstancesRequest) (MicrosoftGraphEvent, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphEvent
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GroupsEventApiService.GroupsCalendarViewGetInstances")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/groups/{group-id}/calendarView/{event-id}/instances/{event-id1}"
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id1"+"}", _neturl.PathEscape(parameterToString(r.eventId1, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGroupsCalendarViewGetMultiValueExtendedPropertiesRequest struct {
	ctx _context.Context
	ApiService *GroupsEventApiService
	groupId string
	eventId string
	multiValueLegacyExtendedPropertyId string
	select_ *[]string
	expand *[]string
}

// Select properties to be returned
func (r ApiGroupsCalendarViewGetMultiValueExtendedPropertiesRequest) Select_(select_ []string) ApiGroupsCalendarViewGetMultiValueExtendedPropertiesRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiGroupsCalendarViewGetMultiValueExtendedPropertiesRequest) Expand(expand []string) ApiGroupsCalendarViewGetMultiValueExtendedPropertiesRequest {
	r.expand = &expand
	return r
}

func (r ApiGroupsCalendarViewGetMultiValueExtendedPropertiesRequest) Execute() (MicrosoftGraphMultiValueLegacyExtendedProperty, *_nethttp.Response, error) {
	return r.ApiService.GroupsCalendarViewGetMultiValueExtendedPropertiesExecute(r)
}

/*
GroupsCalendarViewGetMultiValueExtendedProperties Get multiValueExtendedProperties from groups

The collection of multi-value extended properties defined for the event. Read-only. Nullable.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupId key: id of group
 @param eventId key: id of event
 @param multiValueLegacyExtendedPropertyId key: id of multiValueLegacyExtendedProperty
 @return ApiGroupsCalendarViewGetMultiValueExtendedPropertiesRequest
*/
func (a *GroupsEventApiService) GroupsCalendarViewGetMultiValueExtendedProperties(ctx _context.Context, groupId string, eventId string, multiValueLegacyExtendedPropertyId string) ApiGroupsCalendarViewGetMultiValueExtendedPropertiesRequest {
	return ApiGroupsCalendarViewGetMultiValueExtendedPropertiesRequest{
		ApiService: a,
		ctx: ctx,
		groupId: groupId,
		eventId: eventId,
		multiValueLegacyExtendedPropertyId: multiValueLegacyExtendedPropertyId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphMultiValueLegacyExtendedProperty
func (a *GroupsEventApiService) GroupsCalendarViewGetMultiValueExtendedPropertiesExecute(r ApiGroupsCalendarViewGetMultiValueExtendedPropertiesRequest) (MicrosoftGraphMultiValueLegacyExtendedProperty, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphMultiValueLegacyExtendedProperty
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GroupsEventApiService.GroupsCalendarViewGetMultiValueExtendedProperties")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/groups/{group-id}/calendarView/{event-id}/multiValueExtendedProperties/{multiValueLegacyExtendedProperty-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"multiValueLegacyExtendedProperty-id"+"}", _neturl.PathEscape(parameterToString(r.multiValueLegacyExtendedPropertyId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGroupsCalendarViewGetSingleValueExtendedPropertiesRequest struct {
	ctx _context.Context
	ApiService *GroupsEventApiService
	groupId string
	eventId string
	singleValueLegacyExtendedPropertyId string
	select_ *[]string
	expand *[]string
}

// Select properties to be returned
func (r ApiGroupsCalendarViewGetSingleValueExtendedPropertiesRequest) Select_(select_ []string) ApiGroupsCalendarViewGetSingleValueExtendedPropertiesRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiGroupsCalendarViewGetSingleValueExtendedPropertiesRequest) Expand(expand []string) ApiGroupsCalendarViewGetSingleValueExtendedPropertiesRequest {
	r.expand = &expand
	return r
}

func (r ApiGroupsCalendarViewGetSingleValueExtendedPropertiesRequest) Execute() (MicrosoftGraphSingleValueLegacyExtendedProperty, *_nethttp.Response, error) {
	return r.ApiService.GroupsCalendarViewGetSingleValueExtendedPropertiesExecute(r)
}

/*
GroupsCalendarViewGetSingleValueExtendedProperties Get singleValueExtendedProperties from groups

The collection of single-value extended properties defined for the event. Read-only. Nullable.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupId key: id of group
 @param eventId key: id of event
 @param singleValueLegacyExtendedPropertyId key: id of singleValueLegacyExtendedProperty
 @return ApiGroupsCalendarViewGetSingleValueExtendedPropertiesRequest
*/
func (a *GroupsEventApiService) GroupsCalendarViewGetSingleValueExtendedProperties(ctx _context.Context, groupId string, eventId string, singleValueLegacyExtendedPropertyId string) ApiGroupsCalendarViewGetSingleValueExtendedPropertiesRequest {
	return ApiGroupsCalendarViewGetSingleValueExtendedPropertiesRequest{
		ApiService: a,
		ctx: ctx,
		groupId: groupId,
		eventId: eventId,
		singleValueLegacyExtendedPropertyId: singleValueLegacyExtendedPropertyId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphSingleValueLegacyExtendedProperty
func (a *GroupsEventApiService) GroupsCalendarViewGetSingleValueExtendedPropertiesExecute(r ApiGroupsCalendarViewGetSingleValueExtendedPropertiesRequest) (MicrosoftGraphSingleValueLegacyExtendedProperty, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphSingleValueLegacyExtendedProperty
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GroupsEventApiService.GroupsCalendarViewGetSingleValueExtendedProperties")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/groups/{group-id}/calendarView/{event-id}/singleValueExtendedProperties/{singleValueLegacyExtendedProperty-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"singleValueLegacyExtendedProperty-id"+"}", _neturl.PathEscape(parameterToString(r.singleValueLegacyExtendedPropertyId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGroupsCalendarViewListAttachmentsRequest struct {
	ctx _context.Context
	ApiService *GroupsEventApiService
	groupId string
	eventId string
	top *int32
	skip *int32
	filter *string
	count *bool
	orderby *[]string
	select_ *[]string
	expand *[]string
}

// Show only the first n items
func (r ApiGroupsCalendarViewListAttachmentsRequest) Top(top int32) ApiGroupsCalendarViewListAttachmentsRequest {
	r.top = &top
	return r
}
// Skip the first n items
func (r ApiGroupsCalendarViewListAttachmentsRequest) Skip(skip int32) ApiGroupsCalendarViewListAttachmentsRequest {
	r.skip = &skip
	return r
}
// Filter items by property values
func (r ApiGroupsCalendarViewListAttachmentsRequest) Filter(filter string) ApiGroupsCalendarViewListAttachmentsRequest {
	r.filter = &filter
	return r
}
// Include count of items
func (r ApiGroupsCalendarViewListAttachmentsRequest) Count(count bool) ApiGroupsCalendarViewListAttachmentsRequest {
	r.count = &count
	return r
}
// Order items by property values
func (r ApiGroupsCalendarViewListAttachmentsRequest) Orderby(orderby []string) ApiGroupsCalendarViewListAttachmentsRequest {
	r.orderby = &orderby
	return r
}
// Select properties to be returned
func (r ApiGroupsCalendarViewListAttachmentsRequest) Select_(select_ []string) ApiGroupsCalendarViewListAttachmentsRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiGroupsCalendarViewListAttachmentsRequest) Expand(expand []string) ApiGroupsCalendarViewListAttachmentsRequest {
	r.expand = &expand
	return r
}

func (r ApiGroupsCalendarViewListAttachmentsRequest) Execute() (CollectionOfAttachment, *_nethttp.Response, error) {
	return r.ApiService.GroupsCalendarViewListAttachmentsExecute(r)
}

/*
GroupsCalendarViewListAttachments Get attachments from groups

The collection of FileAttachment, ItemAttachment, and referenceAttachment attachments for the event. Navigation property. Read-only. Nullable.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupId key: id of group
 @param eventId key: id of event
 @return ApiGroupsCalendarViewListAttachmentsRequest
*/
func (a *GroupsEventApiService) GroupsCalendarViewListAttachments(ctx _context.Context, groupId string, eventId string) ApiGroupsCalendarViewListAttachmentsRequest {
	return ApiGroupsCalendarViewListAttachmentsRequest{
		ApiService: a,
		ctx: ctx,
		groupId: groupId,
		eventId: eventId,
	}
}

// Execute executes the request
//  @return CollectionOfAttachment
func (a *GroupsEventApiService) GroupsCalendarViewListAttachmentsExecute(r ApiGroupsCalendarViewListAttachmentsRequest) (CollectionOfAttachment, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  CollectionOfAttachment
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GroupsEventApiService.GroupsCalendarViewListAttachments")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/groups/{group-id}/calendarView/{event-id}/attachments"
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.top != nil {
		localVarQueryParams.Add("$top", parameterToString(*r.top, ""))
	}
	if r.skip != nil {
		localVarQueryParams.Add("$skip", parameterToString(*r.skip, ""))
	}
	if r.filter != nil {
		localVarQueryParams.Add("$filter", parameterToString(*r.filter, ""))
	}
	if r.count != nil {
		localVarQueryParams.Add("$count", parameterToString(*r.count, ""))
	}
	if r.orderby != nil {
		localVarQueryParams.Add("$orderby", parameterToString(*r.orderby, "csv"))
	}
	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGroupsCalendarViewListExtensionsRequest struct {
	ctx _context.Context
	ApiService *GroupsEventApiService
	groupId string
	eventId string
	top *int32
	skip *int32
	filter *string
	count *bool
	orderby *[]string
	select_ *[]string
	expand *[]string
}

// Show only the first n items
func (r ApiGroupsCalendarViewListExtensionsRequest) Top(top int32) ApiGroupsCalendarViewListExtensionsRequest {
	r.top = &top
	return r
}
// Skip the first n items
func (r ApiGroupsCalendarViewListExtensionsRequest) Skip(skip int32) ApiGroupsCalendarViewListExtensionsRequest {
	r.skip = &skip
	return r
}
// Filter items by property values
func (r ApiGroupsCalendarViewListExtensionsRequest) Filter(filter string) ApiGroupsCalendarViewListExtensionsRequest {
	r.filter = &filter
	return r
}
// Include count of items
func (r ApiGroupsCalendarViewListExtensionsRequest) Count(count bool) ApiGroupsCalendarViewListExtensionsRequest {
	r.count = &count
	return r
}
// Order items by property values
func (r ApiGroupsCalendarViewListExtensionsRequest) Orderby(orderby []string) ApiGroupsCalendarViewListExtensionsRequest {
	r.orderby = &orderby
	return r
}
// Select properties to be returned
func (r ApiGroupsCalendarViewListExtensionsRequest) Select_(select_ []string) ApiGroupsCalendarViewListExtensionsRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiGroupsCalendarViewListExtensionsRequest) Expand(expand []string) ApiGroupsCalendarViewListExtensionsRequest {
	r.expand = &expand
	return r
}

func (r ApiGroupsCalendarViewListExtensionsRequest) Execute() (CollectionOfExtension, *_nethttp.Response, error) {
	return r.ApiService.GroupsCalendarViewListExtensionsExecute(r)
}

/*
GroupsCalendarViewListExtensions Get extensions from groups

The collection of open extensions defined for the event. Nullable.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupId key: id of group
 @param eventId key: id of event
 @return ApiGroupsCalendarViewListExtensionsRequest
*/
func (a *GroupsEventApiService) GroupsCalendarViewListExtensions(ctx _context.Context, groupId string, eventId string) ApiGroupsCalendarViewListExtensionsRequest {
	return ApiGroupsCalendarViewListExtensionsRequest{
		ApiService: a,
		ctx: ctx,
		groupId: groupId,
		eventId: eventId,
	}
}

// Execute executes the request
//  @return CollectionOfExtension
func (a *GroupsEventApiService) GroupsCalendarViewListExtensionsExecute(r ApiGroupsCalendarViewListExtensionsRequest) (CollectionOfExtension, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  CollectionOfExtension
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GroupsEventApiService.GroupsCalendarViewListExtensions")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/groups/{group-id}/calendarView/{event-id}/extensions"
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.top != nil {
		localVarQueryParams.Add("$top", parameterToString(*r.top, ""))
	}
	if r.skip != nil {
		localVarQueryParams.Add("$skip", parameterToString(*r.skip, ""))
	}
	if r.filter != nil {
		localVarQueryParams.Add("$filter", parameterToString(*r.filter, ""))
	}
	if r.count != nil {
		localVarQueryParams.Add("$count", parameterToString(*r.count, ""))
	}
	if r.orderby != nil {
		localVarQueryParams.Add("$orderby", parameterToString(*r.orderby, "csv"))
	}
	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGroupsCalendarViewListInstancesRequest struct {
	ctx _context.Context
	ApiService *GroupsEventApiService
	groupId string
	eventId string
	top *int32
	skip *int32
	filter *string
	count *bool
	orderby *[]string
	select_ *[]string
}

// Show only the first n items
func (r ApiGroupsCalendarViewListInstancesRequest) Top(top int32) ApiGroupsCalendarViewListInstancesRequest {
	r.top = &top
	return r
}
// Skip the first n items
func (r ApiGroupsCalendarViewListInstancesRequest) Skip(skip int32) ApiGroupsCalendarViewListInstancesRequest {
	r.skip = &skip
	return r
}
// Filter items by property values
func (r ApiGroupsCalendarViewListInstancesRequest) Filter(filter string) ApiGroupsCalendarViewListInstancesRequest {
	r.filter = &filter
	return r
}
// Include count of items
func (r ApiGroupsCalendarViewListInstancesRequest) Count(count bool) ApiGroupsCalendarViewListInstancesRequest {
	r.count = &count
	return r
}
// Order items by property values
func (r ApiGroupsCalendarViewListInstancesRequest) Orderby(orderby []string) ApiGroupsCalendarViewListInstancesRequest {
	r.orderby = &orderby
	return r
}
// Select properties to be returned
func (r ApiGroupsCalendarViewListInstancesRequest) Select_(select_ []string) ApiGroupsCalendarViewListInstancesRequest {
	r.select_ = &select_
	return r
}

func (r ApiGroupsCalendarViewListInstancesRequest) Execute() (CollectionOfEvent, *_nethttp.Response, error) {
	return r.ApiService.GroupsCalendarViewListInstancesExecute(r)
}

/*
GroupsCalendarViewListInstances Get instances from groups

The occurrences of a recurring series, if the event is a series master. This property includes occurrences that are part of the recurrence pattern, and exceptions that have been modified, but does not include occurrences that have been cancelled from the series. Navigation property. Read-only. Nullable.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupId key: id of group
 @param eventId key: id of event
 @return ApiGroupsCalendarViewListInstancesRequest
*/
func (a *GroupsEventApiService) GroupsCalendarViewListInstances(ctx _context.Context, groupId string, eventId string) ApiGroupsCalendarViewListInstancesRequest {
	return ApiGroupsCalendarViewListInstancesRequest{
		ApiService: a,
		ctx: ctx,
		groupId: groupId,
		eventId: eventId,
	}
}

// Execute executes the request
//  @return CollectionOfEvent
func (a *GroupsEventApiService) GroupsCalendarViewListInstancesExecute(r ApiGroupsCalendarViewListInstancesRequest) (CollectionOfEvent, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  CollectionOfEvent
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GroupsEventApiService.GroupsCalendarViewListInstances")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/groups/{group-id}/calendarView/{event-id}/instances"
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.top != nil {
		localVarQueryParams.Add("$top", parameterToString(*r.top, ""))
	}
	if r.skip != nil {
		localVarQueryParams.Add("$skip", parameterToString(*r.skip, ""))
	}
	if r.filter != nil {
		localVarQueryParams.Add("$filter", parameterToString(*r.filter, ""))
	}
	if r.count != nil {
		localVarQueryParams.Add("$count", parameterToString(*r.count, ""))
	}
	if r.orderby != nil {
		localVarQueryParams.Add("$orderby", parameterToString(*r.orderby, "csv"))
	}
	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGroupsCalendarViewListMultiValueExtendedPropertiesRequest struct {
	ctx _context.Context
	ApiService *GroupsEventApiService
	groupId string
	eventId string
	top *int32
	skip *int32
	search *string
	filter *string
	count *bool
	orderby *[]string
	select_ *[]string
	expand *[]string
}

// Show only the first n items
func (r ApiGroupsCalendarViewListMultiValueExtendedPropertiesRequest) Top(top int32) ApiGroupsCalendarViewListMultiValueExtendedPropertiesRequest {
	r.top = &top
	return r
}
// Skip the first n items
func (r ApiGroupsCalendarViewListMultiValueExtendedPropertiesRequest) Skip(skip int32) ApiGroupsCalendarViewListMultiValueExtendedPropertiesRequest {
	r.skip = &skip
	return r
}
// Search items by search phrases
func (r ApiGroupsCalendarViewListMultiValueExtendedPropertiesRequest) Search(search string) ApiGroupsCalendarViewListMultiValueExtendedPropertiesRequest {
	r.search = &search
	return r
}
// Filter items by property values
func (r ApiGroupsCalendarViewListMultiValueExtendedPropertiesRequest) Filter(filter string) ApiGroupsCalendarViewListMultiValueExtendedPropertiesRequest {
	r.filter = &filter
	return r
}
// Include count of items
func (r ApiGroupsCalendarViewListMultiValueExtendedPropertiesRequest) Count(count bool) ApiGroupsCalendarViewListMultiValueExtendedPropertiesRequest {
	r.count = &count
	return r
}
// Order items by property values
func (r ApiGroupsCalendarViewListMultiValueExtendedPropertiesRequest) Orderby(orderby []string) ApiGroupsCalendarViewListMultiValueExtendedPropertiesRequest {
	r.orderby = &orderby
	return r
}
// Select properties to be returned
func (r ApiGroupsCalendarViewListMultiValueExtendedPropertiesRequest) Select_(select_ []string) ApiGroupsCalendarViewListMultiValueExtendedPropertiesRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiGroupsCalendarViewListMultiValueExtendedPropertiesRequest) Expand(expand []string) ApiGroupsCalendarViewListMultiValueExtendedPropertiesRequest {
	r.expand = &expand
	return r
}

func (r ApiGroupsCalendarViewListMultiValueExtendedPropertiesRequest) Execute() (CollectionOfMultiValueLegacyExtendedProperty, *_nethttp.Response, error) {
	return r.ApiService.GroupsCalendarViewListMultiValueExtendedPropertiesExecute(r)
}

/*
GroupsCalendarViewListMultiValueExtendedProperties Get multiValueExtendedProperties from groups

The collection of multi-value extended properties defined for the event. Read-only. Nullable.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupId key: id of group
 @param eventId key: id of event
 @return ApiGroupsCalendarViewListMultiValueExtendedPropertiesRequest
*/
func (a *GroupsEventApiService) GroupsCalendarViewListMultiValueExtendedProperties(ctx _context.Context, groupId string, eventId string) ApiGroupsCalendarViewListMultiValueExtendedPropertiesRequest {
	return ApiGroupsCalendarViewListMultiValueExtendedPropertiesRequest{
		ApiService: a,
		ctx: ctx,
		groupId: groupId,
		eventId: eventId,
	}
}

// Execute executes the request
//  @return CollectionOfMultiValueLegacyExtendedProperty
func (a *GroupsEventApiService) GroupsCalendarViewListMultiValueExtendedPropertiesExecute(r ApiGroupsCalendarViewListMultiValueExtendedPropertiesRequest) (CollectionOfMultiValueLegacyExtendedProperty, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  CollectionOfMultiValueLegacyExtendedProperty
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GroupsEventApiService.GroupsCalendarViewListMultiValueExtendedProperties")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/groups/{group-id}/calendarView/{event-id}/multiValueExtendedProperties"
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.top != nil {
		localVarQueryParams.Add("$top", parameterToString(*r.top, ""))
	}
	if r.skip != nil {
		localVarQueryParams.Add("$skip", parameterToString(*r.skip, ""))
	}
	if r.search != nil {
		localVarQueryParams.Add("$search", parameterToString(*r.search, ""))
	}
	if r.filter != nil {
		localVarQueryParams.Add("$filter", parameterToString(*r.filter, ""))
	}
	if r.count != nil {
		localVarQueryParams.Add("$count", parameterToString(*r.count, ""))
	}
	if r.orderby != nil {
		localVarQueryParams.Add("$orderby", parameterToString(*r.orderby, "csv"))
	}
	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGroupsCalendarViewListSingleValueExtendedPropertiesRequest struct {
	ctx _context.Context
	ApiService *GroupsEventApiService
	groupId string
	eventId string
	top *int32
	skip *int32
	search *string
	filter *string
	count *bool
	orderby *[]string
	select_ *[]string
	expand *[]string
}

// Show only the first n items
func (r ApiGroupsCalendarViewListSingleValueExtendedPropertiesRequest) Top(top int32) ApiGroupsCalendarViewListSingleValueExtendedPropertiesRequest {
	r.top = &top
	return r
}
// Skip the first n items
func (r ApiGroupsCalendarViewListSingleValueExtendedPropertiesRequest) Skip(skip int32) ApiGroupsCalendarViewListSingleValueExtendedPropertiesRequest {
	r.skip = &skip
	return r
}
// Search items by search phrases
func (r ApiGroupsCalendarViewListSingleValueExtendedPropertiesRequest) Search(search string) ApiGroupsCalendarViewListSingleValueExtendedPropertiesRequest {
	r.search = &search
	return r
}
// Filter items by property values
func (r ApiGroupsCalendarViewListSingleValueExtendedPropertiesRequest) Filter(filter string) ApiGroupsCalendarViewListSingleValueExtendedPropertiesRequest {
	r.filter = &filter
	return r
}
// Include count of items
func (r ApiGroupsCalendarViewListSingleValueExtendedPropertiesRequest) Count(count bool) ApiGroupsCalendarViewListSingleValueExtendedPropertiesRequest {
	r.count = &count
	return r
}
// Order items by property values
func (r ApiGroupsCalendarViewListSingleValueExtendedPropertiesRequest) Orderby(orderby []string) ApiGroupsCalendarViewListSingleValueExtendedPropertiesRequest {
	r.orderby = &orderby
	return r
}
// Select properties to be returned
func (r ApiGroupsCalendarViewListSingleValueExtendedPropertiesRequest) Select_(select_ []string) ApiGroupsCalendarViewListSingleValueExtendedPropertiesRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiGroupsCalendarViewListSingleValueExtendedPropertiesRequest) Expand(expand []string) ApiGroupsCalendarViewListSingleValueExtendedPropertiesRequest {
	r.expand = &expand
	return r
}

func (r ApiGroupsCalendarViewListSingleValueExtendedPropertiesRequest) Execute() (CollectionOfSingleValueLegacyExtendedProperty, *_nethttp.Response, error) {
	return r.ApiService.GroupsCalendarViewListSingleValueExtendedPropertiesExecute(r)
}

/*
GroupsCalendarViewListSingleValueExtendedProperties Get singleValueExtendedProperties from groups

The collection of single-value extended properties defined for the event. Read-only. Nullable.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupId key: id of group
 @param eventId key: id of event
 @return ApiGroupsCalendarViewListSingleValueExtendedPropertiesRequest
*/
func (a *GroupsEventApiService) GroupsCalendarViewListSingleValueExtendedProperties(ctx _context.Context, groupId string, eventId string) ApiGroupsCalendarViewListSingleValueExtendedPropertiesRequest {
	return ApiGroupsCalendarViewListSingleValueExtendedPropertiesRequest{
		ApiService: a,
		ctx: ctx,
		groupId: groupId,
		eventId: eventId,
	}
}

// Execute executes the request
//  @return CollectionOfSingleValueLegacyExtendedProperty
func (a *GroupsEventApiService) GroupsCalendarViewListSingleValueExtendedPropertiesExecute(r ApiGroupsCalendarViewListSingleValueExtendedPropertiesRequest) (CollectionOfSingleValueLegacyExtendedProperty, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  CollectionOfSingleValueLegacyExtendedProperty
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GroupsEventApiService.GroupsCalendarViewListSingleValueExtendedProperties")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/groups/{group-id}/calendarView/{event-id}/singleValueExtendedProperties"
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.top != nil {
		localVarQueryParams.Add("$top", parameterToString(*r.top, ""))
	}
	if r.skip != nil {
		localVarQueryParams.Add("$skip", parameterToString(*r.skip, ""))
	}
	if r.search != nil {
		localVarQueryParams.Add("$search", parameterToString(*r.search, ""))
	}
	if r.filter != nil {
		localVarQueryParams.Add("$filter", parameterToString(*r.filter, ""))
	}
	if r.count != nil {
		localVarQueryParams.Add("$count", parameterToString(*r.count, ""))
	}
	if r.orderby != nil {
		localVarQueryParams.Add("$orderby", parameterToString(*r.orderby, "csv"))
	}
	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGroupsCalendarViewUpdateAttachmentsRequest struct {
	ctx _context.Context
	ApiService *GroupsEventApiService
	groupId string
	eventId string
	attachmentId string
	microsoftGraphAttachment *MicrosoftGraphAttachment
}

// New navigation property values
func (r ApiGroupsCalendarViewUpdateAttachmentsRequest) MicrosoftGraphAttachment(microsoftGraphAttachment MicrosoftGraphAttachment) ApiGroupsCalendarViewUpdateAttachmentsRequest {
	r.microsoftGraphAttachment = &microsoftGraphAttachment
	return r
}

func (r ApiGroupsCalendarViewUpdateAttachmentsRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.GroupsCalendarViewUpdateAttachmentsExecute(r)
}

/*
GroupsCalendarViewUpdateAttachments Update the navigation property attachments in groups

The collection of FileAttachment, ItemAttachment, and referenceAttachment attachments for the event. Navigation property. Read-only. Nullable.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupId key: id of group
 @param eventId key: id of event
 @param attachmentId key: id of attachment
 @return ApiGroupsCalendarViewUpdateAttachmentsRequest
*/
func (a *GroupsEventApiService) GroupsCalendarViewUpdateAttachments(ctx _context.Context, groupId string, eventId string, attachmentId string) ApiGroupsCalendarViewUpdateAttachmentsRequest {
	return ApiGroupsCalendarViewUpdateAttachmentsRequest{
		ApiService: a,
		ctx: ctx,
		groupId: groupId,
		eventId: eventId,
		attachmentId: attachmentId,
	}
}

// Execute executes the request
func (a *GroupsEventApiService) GroupsCalendarViewUpdateAttachmentsExecute(r ApiGroupsCalendarViewUpdateAttachmentsRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPatch
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GroupsEventApiService.GroupsCalendarViewUpdateAttachments")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/groups/{group-id}/calendarView/{event-id}/attachments/{attachment-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"attachment-id"+"}", _neturl.PathEscape(parameterToString(r.attachmentId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphAttachment == nil {
		return nil, reportError("microsoftGraphAttachment is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphAttachment
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGroupsCalendarViewUpdateCalendarRequest struct {
	ctx _context.Context
	ApiService *GroupsEventApiService
	groupId string
	eventId string
	microsoftGraphCalendar *MicrosoftGraphCalendar
}

// New navigation property values
func (r ApiGroupsCalendarViewUpdateCalendarRequest) MicrosoftGraphCalendar(microsoftGraphCalendar MicrosoftGraphCalendar) ApiGroupsCalendarViewUpdateCalendarRequest {
	r.microsoftGraphCalendar = &microsoftGraphCalendar
	return r
}

func (r ApiGroupsCalendarViewUpdateCalendarRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.GroupsCalendarViewUpdateCalendarExecute(r)
}

/*
GroupsCalendarViewUpdateCalendar Update the navigation property calendar in groups

The calendar that contains the event. Navigation property. Read-only.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupId key: id of group
 @param eventId key: id of event
 @return ApiGroupsCalendarViewUpdateCalendarRequest
*/
func (a *GroupsEventApiService) GroupsCalendarViewUpdateCalendar(ctx _context.Context, groupId string, eventId string) ApiGroupsCalendarViewUpdateCalendarRequest {
	return ApiGroupsCalendarViewUpdateCalendarRequest{
		ApiService: a,
		ctx: ctx,
		groupId: groupId,
		eventId: eventId,
	}
}

// Execute executes the request
func (a *GroupsEventApiService) GroupsCalendarViewUpdateCalendarExecute(r ApiGroupsCalendarViewUpdateCalendarRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPatch
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GroupsEventApiService.GroupsCalendarViewUpdateCalendar")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/groups/{group-id}/calendarView/{event-id}/calendar"
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphCalendar == nil {
		return nil, reportError("microsoftGraphCalendar is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphCalendar
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGroupsCalendarViewUpdateExtensionsRequest struct {
	ctx _context.Context
	ApiService *GroupsEventApiService
	groupId string
	eventId string
	extensionId string
	microsoftGraphExtension *MicrosoftGraphExtension
}

// New navigation property values
func (r ApiGroupsCalendarViewUpdateExtensionsRequest) MicrosoftGraphExtension(microsoftGraphExtension MicrosoftGraphExtension) ApiGroupsCalendarViewUpdateExtensionsRequest {
	r.microsoftGraphExtension = &microsoftGraphExtension
	return r
}

func (r ApiGroupsCalendarViewUpdateExtensionsRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.GroupsCalendarViewUpdateExtensionsExecute(r)
}

/*
GroupsCalendarViewUpdateExtensions Update the navigation property extensions in groups

The collection of open extensions defined for the event. Nullable.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupId key: id of group
 @param eventId key: id of event
 @param extensionId key: id of extension
 @return ApiGroupsCalendarViewUpdateExtensionsRequest
*/
func (a *GroupsEventApiService) GroupsCalendarViewUpdateExtensions(ctx _context.Context, groupId string, eventId string, extensionId string) ApiGroupsCalendarViewUpdateExtensionsRequest {
	return ApiGroupsCalendarViewUpdateExtensionsRequest{
		ApiService: a,
		ctx: ctx,
		groupId: groupId,
		eventId: eventId,
		extensionId: extensionId,
	}
}

// Execute executes the request
func (a *GroupsEventApiService) GroupsCalendarViewUpdateExtensionsExecute(r ApiGroupsCalendarViewUpdateExtensionsRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPatch
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GroupsEventApiService.GroupsCalendarViewUpdateExtensions")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/groups/{group-id}/calendarView/{event-id}/extensions/{extension-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"extension-id"+"}", _neturl.PathEscape(parameterToString(r.extensionId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphExtension == nil {
		return nil, reportError("microsoftGraphExtension is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphExtension
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGroupsCalendarViewUpdateInstancesRequest struct {
	ctx _context.Context
	ApiService *GroupsEventApiService
	groupId string
	eventId string
	eventId1 string
	microsoftGraphEvent *MicrosoftGraphEvent
}

// New navigation property values
func (r ApiGroupsCalendarViewUpdateInstancesRequest) MicrosoftGraphEvent(microsoftGraphEvent MicrosoftGraphEvent) ApiGroupsCalendarViewUpdateInstancesRequest {
	r.microsoftGraphEvent = &microsoftGraphEvent
	return r
}

func (r ApiGroupsCalendarViewUpdateInstancesRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.GroupsCalendarViewUpdateInstancesExecute(r)
}

/*
GroupsCalendarViewUpdateInstances Update the navigation property instances in groups

The occurrences of a recurring series, if the event is a series master. This property includes occurrences that are part of the recurrence pattern, and exceptions that have been modified, but does not include occurrences that have been cancelled from the series. Navigation property. Read-only. Nullable.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupId key: id of group
 @param eventId key: id of event
 @param eventId1 key: id of event
 @return ApiGroupsCalendarViewUpdateInstancesRequest
*/
func (a *GroupsEventApiService) GroupsCalendarViewUpdateInstances(ctx _context.Context, groupId string, eventId string, eventId1 string) ApiGroupsCalendarViewUpdateInstancesRequest {
	return ApiGroupsCalendarViewUpdateInstancesRequest{
		ApiService: a,
		ctx: ctx,
		groupId: groupId,
		eventId: eventId,
		eventId1: eventId1,
	}
}

// Execute executes the request
func (a *GroupsEventApiService) GroupsCalendarViewUpdateInstancesExecute(r ApiGroupsCalendarViewUpdateInstancesRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPatch
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GroupsEventApiService.GroupsCalendarViewUpdateInstances")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/groups/{group-id}/calendarView/{event-id}/instances/{event-id1}"
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id1"+"}", _neturl.PathEscape(parameterToString(r.eventId1, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphEvent == nil {
		return nil, reportError("microsoftGraphEvent is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphEvent
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGroupsCalendarViewUpdateMultiValueExtendedPropertiesRequest struct {
	ctx _context.Context
	ApiService *GroupsEventApiService
	groupId string
	eventId string
	multiValueLegacyExtendedPropertyId string
	microsoftGraphMultiValueLegacyExtendedProperty *MicrosoftGraphMultiValueLegacyExtendedProperty
}

// New navigation property values
func (r ApiGroupsCalendarViewUpdateMultiValueExtendedPropertiesRequest) MicrosoftGraphMultiValueLegacyExtendedProperty(microsoftGraphMultiValueLegacyExtendedProperty MicrosoftGraphMultiValueLegacyExtendedProperty) ApiGroupsCalendarViewUpdateMultiValueExtendedPropertiesRequest {
	r.microsoftGraphMultiValueLegacyExtendedProperty = &microsoftGraphMultiValueLegacyExtendedProperty
	return r
}

func (r ApiGroupsCalendarViewUpdateMultiValueExtendedPropertiesRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.GroupsCalendarViewUpdateMultiValueExtendedPropertiesExecute(r)
}

/*
GroupsCalendarViewUpdateMultiValueExtendedProperties Update the navigation property multiValueExtendedProperties in groups

The collection of multi-value extended properties defined for the event. Read-only. Nullable.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupId key: id of group
 @param eventId key: id of event
 @param multiValueLegacyExtendedPropertyId key: id of multiValueLegacyExtendedProperty
 @return ApiGroupsCalendarViewUpdateMultiValueExtendedPropertiesRequest
*/
func (a *GroupsEventApiService) GroupsCalendarViewUpdateMultiValueExtendedProperties(ctx _context.Context, groupId string, eventId string, multiValueLegacyExtendedPropertyId string) ApiGroupsCalendarViewUpdateMultiValueExtendedPropertiesRequest {
	return ApiGroupsCalendarViewUpdateMultiValueExtendedPropertiesRequest{
		ApiService: a,
		ctx: ctx,
		groupId: groupId,
		eventId: eventId,
		multiValueLegacyExtendedPropertyId: multiValueLegacyExtendedPropertyId,
	}
}

// Execute executes the request
func (a *GroupsEventApiService) GroupsCalendarViewUpdateMultiValueExtendedPropertiesExecute(r ApiGroupsCalendarViewUpdateMultiValueExtendedPropertiesRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPatch
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GroupsEventApiService.GroupsCalendarViewUpdateMultiValueExtendedProperties")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/groups/{group-id}/calendarView/{event-id}/multiValueExtendedProperties/{multiValueLegacyExtendedProperty-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"multiValueLegacyExtendedProperty-id"+"}", _neturl.PathEscape(parameterToString(r.multiValueLegacyExtendedPropertyId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphMultiValueLegacyExtendedProperty == nil {
		return nil, reportError("microsoftGraphMultiValueLegacyExtendedProperty is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphMultiValueLegacyExtendedProperty
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGroupsCalendarViewUpdateSingleValueExtendedPropertiesRequest struct {
	ctx _context.Context
	ApiService *GroupsEventApiService
	groupId string
	eventId string
	singleValueLegacyExtendedPropertyId string
	microsoftGraphSingleValueLegacyExtendedProperty *MicrosoftGraphSingleValueLegacyExtendedProperty
}

// New navigation property values
func (r ApiGroupsCalendarViewUpdateSingleValueExtendedPropertiesRequest) MicrosoftGraphSingleValueLegacyExtendedProperty(microsoftGraphSingleValueLegacyExtendedProperty MicrosoftGraphSingleValueLegacyExtendedProperty) ApiGroupsCalendarViewUpdateSingleValueExtendedPropertiesRequest {
	r.microsoftGraphSingleValueLegacyExtendedProperty = &microsoftGraphSingleValueLegacyExtendedProperty
	return r
}

func (r ApiGroupsCalendarViewUpdateSingleValueExtendedPropertiesRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.GroupsCalendarViewUpdateSingleValueExtendedPropertiesExecute(r)
}

/*
GroupsCalendarViewUpdateSingleValueExtendedProperties Update the navigation property singleValueExtendedProperties in groups

The collection of single-value extended properties defined for the event. Read-only. Nullable.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupId key: id of group
 @param eventId key: id of event
 @param singleValueLegacyExtendedPropertyId key: id of singleValueLegacyExtendedProperty
 @return ApiGroupsCalendarViewUpdateSingleValueExtendedPropertiesRequest
*/
func (a *GroupsEventApiService) GroupsCalendarViewUpdateSingleValueExtendedProperties(ctx _context.Context, groupId string, eventId string, singleValueLegacyExtendedPropertyId string) ApiGroupsCalendarViewUpdateSingleValueExtendedPropertiesRequest {
	return ApiGroupsCalendarViewUpdateSingleValueExtendedPropertiesRequest{
		ApiService: a,
		ctx: ctx,
		groupId: groupId,
		eventId: eventId,
		singleValueLegacyExtendedPropertyId: singleValueLegacyExtendedPropertyId,
	}
}

// Execute executes the request
func (a *GroupsEventApiService) GroupsCalendarViewUpdateSingleValueExtendedPropertiesExecute(r ApiGroupsCalendarViewUpdateSingleValueExtendedPropertiesRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPatch
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GroupsEventApiService.GroupsCalendarViewUpdateSingleValueExtendedProperties")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/groups/{group-id}/calendarView/{event-id}/singleValueExtendedProperties/{singleValueLegacyExtendedProperty-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"singleValueLegacyExtendedProperty-id"+"}", _neturl.PathEscape(parameterToString(r.singleValueLegacyExtendedPropertyId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphSingleValueLegacyExtendedProperty == nil {
		return nil, reportError("microsoftGraphSingleValueLegacyExtendedProperty is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphSingleValueLegacyExtendedProperty
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGroupsCreateCalendarViewRequest struct {
	ctx _context.Context
	ApiService *GroupsEventApiService
	groupId string
	microsoftGraphEvent *MicrosoftGraphEvent
}

// New navigation property
func (r ApiGroupsCreateCalendarViewRequest) MicrosoftGraphEvent(microsoftGraphEvent MicrosoftGraphEvent) ApiGroupsCreateCalendarViewRequest {
	r.microsoftGraphEvent = &microsoftGraphEvent
	return r
}

func (r ApiGroupsCreateCalendarViewRequest) Execute() (MicrosoftGraphEvent, *_nethttp.Response, error) {
	return r.ApiService.GroupsCreateCalendarViewExecute(r)
}

/*
GroupsCreateCalendarView Create new navigation property to calendarView for groups

The calendar view for the calendar. Read-only.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupId key: id of group
 @return ApiGroupsCreateCalendarViewRequest
*/
func (a *GroupsEventApiService) GroupsCreateCalendarView(ctx _context.Context, groupId string) ApiGroupsCreateCalendarViewRequest {
	return ApiGroupsCreateCalendarViewRequest{
		ApiService: a,
		ctx: ctx,
		groupId: groupId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphEvent
func (a *GroupsEventApiService) GroupsCreateCalendarViewExecute(r ApiGroupsCreateCalendarViewRequest) (MicrosoftGraphEvent, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphEvent
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GroupsEventApiService.GroupsCreateCalendarView")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/groups/{group-id}/calendarView"
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphEvent == nil {
		return localVarReturnValue, nil, reportError("microsoftGraphEvent is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphEvent
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGroupsCreateEventsRequest struct {
	ctx _context.Context
	ApiService *GroupsEventApiService
	groupId string
	microsoftGraphEvent *MicrosoftGraphEvent
}

// New navigation property
func (r ApiGroupsCreateEventsRequest) MicrosoftGraphEvent(microsoftGraphEvent MicrosoftGraphEvent) ApiGroupsCreateEventsRequest {
	r.microsoftGraphEvent = &microsoftGraphEvent
	return r
}

func (r ApiGroupsCreateEventsRequest) Execute() (MicrosoftGraphEvent, *_nethttp.Response, error) {
	return r.ApiService.GroupsCreateEventsExecute(r)
}

/*
GroupsCreateEvents Create new navigation property to events for groups

The group's calendar events.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupId key: id of group
 @return ApiGroupsCreateEventsRequest
*/
func (a *GroupsEventApiService) GroupsCreateEvents(ctx _context.Context, groupId string) ApiGroupsCreateEventsRequest {
	return ApiGroupsCreateEventsRequest{
		ApiService: a,
		ctx: ctx,
		groupId: groupId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphEvent
func (a *GroupsEventApiService) GroupsCreateEventsExecute(r ApiGroupsCreateEventsRequest) (MicrosoftGraphEvent, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphEvent
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GroupsEventApiService.GroupsCreateEvents")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/groups/{group-id}/events"
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphEvent == nil {
		return localVarReturnValue, nil, reportError("microsoftGraphEvent is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphEvent
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGroupsDeleteCalendarViewRequest struct {
	ctx _context.Context
	ApiService *GroupsEventApiService
	groupId string
	eventId string
	ifMatch *string
}

// ETag
func (r ApiGroupsDeleteCalendarViewRequest) IfMatch(ifMatch string) ApiGroupsDeleteCalendarViewRequest {
	r.ifMatch = &ifMatch
	return r
}

func (r ApiGroupsDeleteCalendarViewRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.GroupsDeleteCalendarViewExecute(r)
}

/*
GroupsDeleteCalendarView Delete navigation property calendarView for groups

The calendar view for the calendar. Read-only.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupId key: id of group
 @param eventId key: id of event
 @return ApiGroupsDeleteCalendarViewRequest
*/
func (a *GroupsEventApiService) GroupsDeleteCalendarView(ctx _context.Context, groupId string, eventId string) ApiGroupsDeleteCalendarViewRequest {
	return ApiGroupsDeleteCalendarViewRequest{
		ApiService: a,
		ctx: ctx,
		groupId: groupId,
		eventId: eventId,
	}
}

// Execute executes the request
func (a *GroupsEventApiService) GroupsDeleteCalendarViewExecute(r ApiGroupsDeleteCalendarViewRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GroupsEventApiService.GroupsDeleteCalendarView")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/groups/{group-id}/calendarView/{event-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ifMatch != nil {
		localVarHeaderParams["If-Match"] = parameterToString(*r.ifMatch, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGroupsDeleteEventsRequest struct {
	ctx _context.Context
	ApiService *GroupsEventApiService
	groupId string
	eventId string
	ifMatch *string
}

// ETag
func (r ApiGroupsDeleteEventsRequest) IfMatch(ifMatch string) ApiGroupsDeleteEventsRequest {
	r.ifMatch = &ifMatch
	return r
}

func (r ApiGroupsDeleteEventsRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.GroupsDeleteEventsExecute(r)
}

/*
GroupsDeleteEvents Delete navigation property events for groups

The group's calendar events.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupId key: id of group
 @param eventId key: id of event
 @return ApiGroupsDeleteEventsRequest
*/
func (a *GroupsEventApiService) GroupsDeleteEvents(ctx _context.Context, groupId string, eventId string) ApiGroupsDeleteEventsRequest {
	return ApiGroupsDeleteEventsRequest{
		ApiService: a,
		ctx: ctx,
		groupId: groupId,
		eventId: eventId,
	}
}

// Execute executes the request
func (a *GroupsEventApiService) GroupsDeleteEventsExecute(r ApiGroupsDeleteEventsRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GroupsEventApiService.GroupsDeleteEvents")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/groups/{group-id}/events/{event-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ifMatch != nil {
		localVarHeaderParams["If-Match"] = parameterToString(*r.ifMatch, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGroupsEventsCalendarCreateCalendarPermissionsRequest struct {
	ctx _context.Context
	ApiService *GroupsEventApiService
	groupId string
	eventId string
	microsoftGraphCalendarPermission *MicrosoftGraphCalendarPermission
}

// New navigation property
func (r ApiGroupsEventsCalendarCreateCalendarPermissionsRequest) MicrosoftGraphCalendarPermission(microsoftGraphCalendarPermission MicrosoftGraphCalendarPermission) ApiGroupsEventsCalendarCreateCalendarPermissionsRequest {
	r.microsoftGraphCalendarPermission = &microsoftGraphCalendarPermission
	return r
}

func (r ApiGroupsEventsCalendarCreateCalendarPermissionsRequest) Execute() (MicrosoftGraphCalendarPermission, *_nethttp.Response, error) {
	return r.ApiService.GroupsEventsCalendarCreateCalendarPermissionsExecute(r)
}

/*
GroupsEventsCalendarCreateCalendarPermissions Create new navigation property to calendarPermissions for groups

The permissions of the users with whom the calendar is shared.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupId key: id of group
 @param eventId key: id of event
 @return ApiGroupsEventsCalendarCreateCalendarPermissionsRequest
*/
func (a *GroupsEventApiService) GroupsEventsCalendarCreateCalendarPermissions(ctx _context.Context, groupId string, eventId string) ApiGroupsEventsCalendarCreateCalendarPermissionsRequest {
	return ApiGroupsEventsCalendarCreateCalendarPermissionsRequest{
		ApiService: a,
		ctx: ctx,
		groupId: groupId,
		eventId: eventId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphCalendarPermission
func (a *GroupsEventApiService) GroupsEventsCalendarCreateCalendarPermissionsExecute(r ApiGroupsEventsCalendarCreateCalendarPermissionsRequest) (MicrosoftGraphCalendarPermission, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphCalendarPermission
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GroupsEventApiService.GroupsEventsCalendarCreateCalendarPermissions")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/groups/{group-id}/events/{event-id}/calendar/calendarPermissions"
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphCalendarPermission == nil {
		return localVarReturnValue, nil, reportError("microsoftGraphCalendarPermission is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphCalendarPermission
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGroupsEventsCalendarCreateCalendarViewRequest struct {
	ctx _context.Context
	ApiService *GroupsEventApiService
	groupId string
	eventId string
	microsoftGraphEvent *MicrosoftGraphEvent
}

// New navigation property
func (r ApiGroupsEventsCalendarCreateCalendarViewRequest) MicrosoftGraphEvent(microsoftGraphEvent MicrosoftGraphEvent) ApiGroupsEventsCalendarCreateCalendarViewRequest {
	r.microsoftGraphEvent = &microsoftGraphEvent
	return r
}

func (r ApiGroupsEventsCalendarCreateCalendarViewRequest) Execute() (MicrosoftGraphEvent, *_nethttp.Response, error) {
	return r.ApiService.GroupsEventsCalendarCreateCalendarViewExecute(r)
}

/*
GroupsEventsCalendarCreateCalendarView Create new navigation property to calendarView for groups

The calendar view for the calendar. Navigation property. Read-only.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupId key: id of group
 @param eventId key: id of event
 @return ApiGroupsEventsCalendarCreateCalendarViewRequest
*/
func (a *GroupsEventApiService) GroupsEventsCalendarCreateCalendarView(ctx _context.Context, groupId string, eventId string) ApiGroupsEventsCalendarCreateCalendarViewRequest {
	return ApiGroupsEventsCalendarCreateCalendarViewRequest{
		ApiService: a,
		ctx: ctx,
		groupId: groupId,
		eventId: eventId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphEvent
func (a *GroupsEventApiService) GroupsEventsCalendarCreateCalendarViewExecute(r ApiGroupsEventsCalendarCreateCalendarViewRequest) (MicrosoftGraphEvent, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphEvent
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GroupsEventApiService.GroupsEventsCalendarCreateCalendarView")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/groups/{group-id}/events/{event-id}/calendar/calendarView"
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphEvent == nil {
		return localVarReturnValue, nil, reportError("microsoftGraphEvent is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphEvent
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGroupsEventsCalendarCreateEventsRequest struct {
	ctx _context.Context
	ApiService *GroupsEventApiService
	groupId string
	eventId string
	microsoftGraphEvent *MicrosoftGraphEvent
}

// New navigation property
func (r ApiGroupsEventsCalendarCreateEventsRequest) MicrosoftGraphEvent(microsoftGraphEvent MicrosoftGraphEvent) ApiGroupsEventsCalendarCreateEventsRequest {
	r.microsoftGraphEvent = &microsoftGraphEvent
	return r
}

func (r ApiGroupsEventsCalendarCreateEventsRequest) Execute() (MicrosoftGraphEvent, *_nethttp.Response, error) {
	return r.ApiService.GroupsEventsCalendarCreateEventsExecute(r)
}

/*
GroupsEventsCalendarCreateEvents Create new navigation property to events for groups

The events in the calendar. Navigation property. Read-only.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupId key: id of group
 @param eventId key: id of event
 @return ApiGroupsEventsCalendarCreateEventsRequest
*/
func (a *GroupsEventApiService) GroupsEventsCalendarCreateEvents(ctx _context.Context, groupId string, eventId string) ApiGroupsEventsCalendarCreateEventsRequest {
	return ApiGroupsEventsCalendarCreateEventsRequest{
		ApiService: a,
		ctx: ctx,
		groupId: groupId,
		eventId: eventId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphEvent
func (a *GroupsEventApiService) GroupsEventsCalendarCreateEventsExecute(r ApiGroupsEventsCalendarCreateEventsRequest) (MicrosoftGraphEvent, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphEvent
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GroupsEventApiService.GroupsEventsCalendarCreateEvents")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/groups/{group-id}/events/{event-id}/calendar/events"
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphEvent == nil {
		return localVarReturnValue, nil, reportError("microsoftGraphEvent is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphEvent
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGroupsEventsCalendarCreateMultiValueExtendedPropertiesRequest struct {
	ctx _context.Context
	ApiService *GroupsEventApiService
	groupId string
	eventId string
	microsoftGraphMultiValueLegacyExtendedProperty *MicrosoftGraphMultiValueLegacyExtendedProperty
}

// New navigation property
func (r ApiGroupsEventsCalendarCreateMultiValueExtendedPropertiesRequest) MicrosoftGraphMultiValueLegacyExtendedProperty(microsoftGraphMultiValueLegacyExtendedProperty MicrosoftGraphMultiValueLegacyExtendedProperty) ApiGroupsEventsCalendarCreateMultiValueExtendedPropertiesRequest {
	r.microsoftGraphMultiValueLegacyExtendedProperty = &microsoftGraphMultiValueLegacyExtendedProperty
	return r
}

func (r ApiGroupsEventsCalendarCreateMultiValueExtendedPropertiesRequest) Execute() (MicrosoftGraphMultiValueLegacyExtendedProperty, *_nethttp.Response, error) {
	return r.ApiService.GroupsEventsCalendarCreateMultiValueExtendedPropertiesExecute(r)
}

/*
GroupsEventsCalendarCreateMultiValueExtendedProperties Create new navigation property to multiValueExtendedProperties for groups

The collection of multi-value extended properties defined for the calendar. Read-only. Nullable.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupId key: id of group
 @param eventId key: id of event
 @return ApiGroupsEventsCalendarCreateMultiValueExtendedPropertiesRequest
*/
func (a *GroupsEventApiService) GroupsEventsCalendarCreateMultiValueExtendedProperties(ctx _context.Context, groupId string, eventId string) ApiGroupsEventsCalendarCreateMultiValueExtendedPropertiesRequest {
	return ApiGroupsEventsCalendarCreateMultiValueExtendedPropertiesRequest{
		ApiService: a,
		ctx: ctx,
		groupId: groupId,
		eventId: eventId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphMultiValueLegacyExtendedProperty
func (a *GroupsEventApiService) GroupsEventsCalendarCreateMultiValueExtendedPropertiesExecute(r ApiGroupsEventsCalendarCreateMultiValueExtendedPropertiesRequest) (MicrosoftGraphMultiValueLegacyExtendedProperty, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphMultiValueLegacyExtendedProperty
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GroupsEventApiService.GroupsEventsCalendarCreateMultiValueExtendedProperties")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/groups/{group-id}/events/{event-id}/calendar/multiValueExtendedProperties"
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphMultiValueLegacyExtendedProperty == nil {
		return localVarReturnValue, nil, reportError("microsoftGraphMultiValueLegacyExtendedProperty is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphMultiValueLegacyExtendedProperty
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGroupsEventsCalendarCreateSingleValueExtendedPropertiesRequest struct {
	ctx _context.Context
	ApiService *GroupsEventApiService
	groupId string
	eventId string
	microsoftGraphSingleValueLegacyExtendedProperty *MicrosoftGraphSingleValueLegacyExtendedProperty
}

// New navigation property
func (r ApiGroupsEventsCalendarCreateSingleValueExtendedPropertiesRequest) MicrosoftGraphSingleValueLegacyExtendedProperty(microsoftGraphSingleValueLegacyExtendedProperty MicrosoftGraphSingleValueLegacyExtendedProperty) ApiGroupsEventsCalendarCreateSingleValueExtendedPropertiesRequest {
	r.microsoftGraphSingleValueLegacyExtendedProperty = &microsoftGraphSingleValueLegacyExtendedProperty
	return r
}

func (r ApiGroupsEventsCalendarCreateSingleValueExtendedPropertiesRequest) Execute() (MicrosoftGraphSingleValueLegacyExtendedProperty, *_nethttp.Response, error) {
	return r.ApiService.GroupsEventsCalendarCreateSingleValueExtendedPropertiesExecute(r)
}

/*
GroupsEventsCalendarCreateSingleValueExtendedProperties Create new navigation property to singleValueExtendedProperties for groups

The collection of single-value extended properties defined for the calendar. Read-only. Nullable.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupId key: id of group
 @param eventId key: id of event
 @return ApiGroupsEventsCalendarCreateSingleValueExtendedPropertiesRequest
*/
func (a *GroupsEventApiService) GroupsEventsCalendarCreateSingleValueExtendedProperties(ctx _context.Context, groupId string, eventId string) ApiGroupsEventsCalendarCreateSingleValueExtendedPropertiesRequest {
	return ApiGroupsEventsCalendarCreateSingleValueExtendedPropertiesRequest{
		ApiService: a,
		ctx: ctx,
		groupId: groupId,
		eventId: eventId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphSingleValueLegacyExtendedProperty
func (a *GroupsEventApiService) GroupsEventsCalendarCreateSingleValueExtendedPropertiesExecute(r ApiGroupsEventsCalendarCreateSingleValueExtendedPropertiesRequest) (MicrosoftGraphSingleValueLegacyExtendedProperty, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphSingleValueLegacyExtendedProperty
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GroupsEventApiService.GroupsEventsCalendarCreateSingleValueExtendedProperties")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/groups/{group-id}/events/{event-id}/calendar/singleValueExtendedProperties"
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphSingleValueLegacyExtendedProperty == nil {
		return localVarReturnValue, nil, reportError("microsoftGraphSingleValueLegacyExtendedProperty is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphSingleValueLegacyExtendedProperty
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGroupsEventsCalendarDeleteCalendarPermissionsRequest struct {
	ctx _context.Context
	ApiService *GroupsEventApiService
	groupId string
	eventId string
	calendarPermissionId string
	ifMatch *string
}

// ETag
func (r ApiGroupsEventsCalendarDeleteCalendarPermissionsRequest) IfMatch(ifMatch string) ApiGroupsEventsCalendarDeleteCalendarPermissionsRequest {
	r.ifMatch = &ifMatch
	return r
}

func (r ApiGroupsEventsCalendarDeleteCalendarPermissionsRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.GroupsEventsCalendarDeleteCalendarPermissionsExecute(r)
}

/*
GroupsEventsCalendarDeleteCalendarPermissions Delete navigation property calendarPermissions for groups

The permissions of the users with whom the calendar is shared.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupId key: id of group
 @param eventId key: id of event
 @param calendarPermissionId key: id of calendarPermission
 @return ApiGroupsEventsCalendarDeleteCalendarPermissionsRequest
*/
func (a *GroupsEventApiService) GroupsEventsCalendarDeleteCalendarPermissions(ctx _context.Context, groupId string, eventId string, calendarPermissionId string) ApiGroupsEventsCalendarDeleteCalendarPermissionsRequest {
	return ApiGroupsEventsCalendarDeleteCalendarPermissionsRequest{
		ApiService: a,
		ctx: ctx,
		groupId: groupId,
		eventId: eventId,
		calendarPermissionId: calendarPermissionId,
	}
}

// Execute executes the request
func (a *GroupsEventApiService) GroupsEventsCalendarDeleteCalendarPermissionsExecute(r ApiGroupsEventsCalendarDeleteCalendarPermissionsRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GroupsEventApiService.GroupsEventsCalendarDeleteCalendarPermissions")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/groups/{group-id}/events/{event-id}/calendar/calendarPermissions/{calendarPermission-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"calendarPermission-id"+"}", _neturl.PathEscape(parameterToString(r.calendarPermissionId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ifMatch != nil {
		localVarHeaderParams["If-Match"] = parameterToString(*r.ifMatch, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGroupsEventsCalendarDeleteCalendarViewRequest struct {
	ctx _context.Context
	ApiService *GroupsEventApiService
	groupId string
	eventId string
	eventId1 string
	ifMatch *string
}

// ETag
func (r ApiGroupsEventsCalendarDeleteCalendarViewRequest) IfMatch(ifMatch string) ApiGroupsEventsCalendarDeleteCalendarViewRequest {
	r.ifMatch = &ifMatch
	return r
}

func (r ApiGroupsEventsCalendarDeleteCalendarViewRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.GroupsEventsCalendarDeleteCalendarViewExecute(r)
}

/*
GroupsEventsCalendarDeleteCalendarView Delete navigation property calendarView for groups

The calendar view for the calendar. Navigation property. Read-only.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupId key: id of group
 @param eventId key: id of event
 @param eventId1 key: id of event
 @return ApiGroupsEventsCalendarDeleteCalendarViewRequest
*/
func (a *GroupsEventApiService) GroupsEventsCalendarDeleteCalendarView(ctx _context.Context, groupId string, eventId string, eventId1 string) ApiGroupsEventsCalendarDeleteCalendarViewRequest {
	return ApiGroupsEventsCalendarDeleteCalendarViewRequest{
		ApiService: a,
		ctx: ctx,
		groupId: groupId,
		eventId: eventId,
		eventId1: eventId1,
	}
}

// Execute executes the request
func (a *GroupsEventApiService) GroupsEventsCalendarDeleteCalendarViewExecute(r ApiGroupsEventsCalendarDeleteCalendarViewRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GroupsEventApiService.GroupsEventsCalendarDeleteCalendarView")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/groups/{group-id}/events/{event-id}/calendar/calendarView/{event-id1}"
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id1"+"}", _neturl.PathEscape(parameterToString(r.eventId1, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ifMatch != nil {
		localVarHeaderParams["If-Match"] = parameterToString(*r.ifMatch, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGroupsEventsCalendarDeleteEventsRequest struct {
	ctx _context.Context
	ApiService *GroupsEventApiService
	groupId string
	eventId string
	eventId1 string
	ifMatch *string
}

// ETag
func (r ApiGroupsEventsCalendarDeleteEventsRequest) IfMatch(ifMatch string) ApiGroupsEventsCalendarDeleteEventsRequest {
	r.ifMatch = &ifMatch
	return r
}

func (r ApiGroupsEventsCalendarDeleteEventsRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.GroupsEventsCalendarDeleteEventsExecute(r)
}

/*
GroupsEventsCalendarDeleteEvents Delete navigation property events for groups

The events in the calendar. Navigation property. Read-only.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupId key: id of group
 @param eventId key: id of event
 @param eventId1 key: id of event
 @return ApiGroupsEventsCalendarDeleteEventsRequest
*/
func (a *GroupsEventApiService) GroupsEventsCalendarDeleteEvents(ctx _context.Context, groupId string, eventId string, eventId1 string) ApiGroupsEventsCalendarDeleteEventsRequest {
	return ApiGroupsEventsCalendarDeleteEventsRequest{
		ApiService: a,
		ctx: ctx,
		groupId: groupId,
		eventId: eventId,
		eventId1: eventId1,
	}
}

// Execute executes the request
func (a *GroupsEventApiService) GroupsEventsCalendarDeleteEventsExecute(r ApiGroupsEventsCalendarDeleteEventsRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GroupsEventApiService.GroupsEventsCalendarDeleteEvents")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/groups/{group-id}/events/{event-id}/calendar/events/{event-id1}"
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id1"+"}", _neturl.PathEscape(parameterToString(r.eventId1, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ifMatch != nil {
		localVarHeaderParams["If-Match"] = parameterToString(*r.ifMatch, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGroupsEventsCalendarDeleteMultiValueExtendedPropertiesRequest struct {
	ctx _context.Context
	ApiService *GroupsEventApiService
	groupId string
	eventId string
	multiValueLegacyExtendedPropertyId string
	ifMatch *string
}

// ETag
func (r ApiGroupsEventsCalendarDeleteMultiValueExtendedPropertiesRequest) IfMatch(ifMatch string) ApiGroupsEventsCalendarDeleteMultiValueExtendedPropertiesRequest {
	r.ifMatch = &ifMatch
	return r
}

func (r ApiGroupsEventsCalendarDeleteMultiValueExtendedPropertiesRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.GroupsEventsCalendarDeleteMultiValueExtendedPropertiesExecute(r)
}

/*
GroupsEventsCalendarDeleteMultiValueExtendedProperties Delete navigation property multiValueExtendedProperties for groups

The collection of multi-value extended properties defined for the calendar. Read-only. Nullable.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupId key: id of group
 @param eventId key: id of event
 @param multiValueLegacyExtendedPropertyId key: id of multiValueLegacyExtendedProperty
 @return ApiGroupsEventsCalendarDeleteMultiValueExtendedPropertiesRequest
*/
func (a *GroupsEventApiService) GroupsEventsCalendarDeleteMultiValueExtendedProperties(ctx _context.Context, groupId string, eventId string, multiValueLegacyExtendedPropertyId string) ApiGroupsEventsCalendarDeleteMultiValueExtendedPropertiesRequest {
	return ApiGroupsEventsCalendarDeleteMultiValueExtendedPropertiesRequest{
		ApiService: a,
		ctx: ctx,
		groupId: groupId,
		eventId: eventId,
		multiValueLegacyExtendedPropertyId: multiValueLegacyExtendedPropertyId,
	}
}

// Execute executes the request
func (a *GroupsEventApiService) GroupsEventsCalendarDeleteMultiValueExtendedPropertiesExecute(r ApiGroupsEventsCalendarDeleteMultiValueExtendedPropertiesRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GroupsEventApiService.GroupsEventsCalendarDeleteMultiValueExtendedProperties")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/groups/{group-id}/events/{event-id}/calendar/multiValueExtendedProperties/{multiValueLegacyExtendedProperty-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"multiValueLegacyExtendedProperty-id"+"}", _neturl.PathEscape(parameterToString(r.multiValueLegacyExtendedPropertyId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ifMatch != nil {
		localVarHeaderParams["If-Match"] = parameterToString(*r.ifMatch, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGroupsEventsCalendarDeleteSingleValueExtendedPropertiesRequest struct {
	ctx _context.Context
	ApiService *GroupsEventApiService
	groupId string
	eventId string
	singleValueLegacyExtendedPropertyId string
	ifMatch *string
}

// ETag
func (r ApiGroupsEventsCalendarDeleteSingleValueExtendedPropertiesRequest) IfMatch(ifMatch string) ApiGroupsEventsCalendarDeleteSingleValueExtendedPropertiesRequest {
	r.ifMatch = &ifMatch
	return r
}

func (r ApiGroupsEventsCalendarDeleteSingleValueExtendedPropertiesRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.GroupsEventsCalendarDeleteSingleValueExtendedPropertiesExecute(r)
}

/*
GroupsEventsCalendarDeleteSingleValueExtendedProperties Delete navigation property singleValueExtendedProperties for groups

The collection of single-value extended properties defined for the calendar. Read-only. Nullable.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupId key: id of group
 @param eventId key: id of event
 @param singleValueLegacyExtendedPropertyId key: id of singleValueLegacyExtendedProperty
 @return ApiGroupsEventsCalendarDeleteSingleValueExtendedPropertiesRequest
*/
func (a *GroupsEventApiService) GroupsEventsCalendarDeleteSingleValueExtendedProperties(ctx _context.Context, groupId string, eventId string, singleValueLegacyExtendedPropertyId string) ApiGroupsEventsCalendarDeleteSingleValueExtendedPropertiesRequest {
	return ApiGroupsEventsCalendarDeleteSingleValueExtendedPropertiesRequest{
		ApiService: a,
		ctx: ctx,
		groupId: groupId,
		eventId: eventId,
		singleValueLegacyExtendedPropertyId: singleValueLegacyExtendedPropertyId,
	}
}

// Execute executes the request
func (a *GroupsEventApiService) GroupsEventsCalendarDeleteSingleValueExtendedPropertiesExecute(r ApiGroupsEventsCalendarDeleteSingleValueExtendedPropertiesRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GroupsEventApiService.GroupsEventsCalendarDeleteSingleValueExtendedProperties")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/groups/{group-id}/events/{event-id}/calendar/singleValueExtendedProperties/{singleValueLegacyExtendedProperty-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"singleValueLegacyExtendedProperty-id"+"}", _neturl.PathEscape(parameterToString(r.singleValueLegacyExtendedPropertyId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ifMatch != nil {
		localVarHeaderParams["If-Match"] = parameterToString(*r.ifMatch, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGroupsEventsCalendarGetCalendarPermissionsRequest struct {
	ctx _context.Context
	ApiService *GroupsEventApiService
	groupId string
	eventId string
	calendarPermissionId string
	select_ *[]string
}

// Select properties to be returned
func (r ApiGroupsEventsCalendarGetCalendarPermissionsRequest) Select_(select_ []string) ApiGroupsEventsCalendarGetCalendarPermissionsRequest {
	r.select_ = &select_
	return r
}

func (r ApiGroupsEventsCalendarGetCalendarPermissionsRequest) Execute() (MicrosoftGraphCalendarPermission, *_nethttp.Response, error) {
	return r.ApiService.GroupsEventsCalendarGetCalendarPermissionsExecute(r)
}

/*
GroupsEventsCalendarGetCalendarPermissions Get calendarPermissions from groups

The permissions of the users with whom the calendar is shared.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupId key: id of group
 @param eventId key: id of event
 @param calendarPermissionId key: id of calendarPermission
 @return ApiGroupsEventsCalendarGetCalendarPermissionsRequest
*/
func (a *GroupsEventApiService) GroupsEventsCalendarGetCalendarPermissions(ctx _context.Context, groupId string, eventId string, calendarPermissionId string) ApiGroupsEventsCalendarGetCalendarPermissionsRequest {
	return ApiGroupsEventsCalendarGetCalendarPermissionsRequest{
		ApiService: a,
		ctx: ctx,
		groupId: groupId,
		eventId: eventId,
		calendarPermissionId: calendarPermissionId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphCalendarPermission
func (a *GroupsEventApiService) GroupsEventsCalendarGetCalendarPermissionsExecute(r ApiGroupsEventsCalendarGetCalendarPermissionsRequest) (MicrosoftGraphCalendarPermission, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphCalendarPermission
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GroupsEventApiService.GroupsEventsCalendarGetCalendarPermissions")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/groups/{group-id}/events/{event-id}/calendar/calendarPermissions/{calendarPermission-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"calendarPermission-id"+"}", _neturl.PathEscape(parameterToString(r.calendarPermissionId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGroupsEventsCalendarGetCalendarViewRequest struct {
	ctx _context.Context
	ApiService *GroupsEventApiService
	groupId string
	eventId string
	eventId1 string
	select_ *[]string
}

// Select properties to be returned
func (r ApiGroupsEventsCalendarGetCalendarViewRequest) Select_(select_ []string) ApiGroupsEventsCalendarGetCalendarViewRequest {
	r.select_ = &select_
	return r
}

func (r ApiGroupsEventsCalendarGetCalendarViewRequest) Execute() (MicrosoftGraphEvent, *_nethttp.Response, error) {
	return r.ApiService.GroupsEventsCalendarGetCalendarViewExecute(r)
}

/*
GroupsEventsCalendarGetCalendarView Get calendarView from groups

The calendar view for the calendar. Navigation property. Read-only.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupId key: id of group
 @param eventId key: id of event
 @param eventId1 key: id of event
 @return ApiGroupsEventsCalendarGetCalendarViewRequest
*/
func (a *GroupsEventApiService) GroupsEventsCalendarGetCalendarView(ctx _context.Context, groupId string, eventId string, eventId1 string) ApiGroupsEventsCalendarGetCalendarViewRequest {
	return ApiGroupsEventsCalendarGetCalendarViewRequest{
		ApiService: a,
		ctx: ctx,
		groupId: groupId,
		eventId: eventId,
		eventId1: eventId1,
	}
}

// Execute executes the request
//  @return MicrosoftGraphEvent
func (a *GroupsEventApiService) GroupsEventsCalendarGetCalendarViewExecute(r ApiGroupsEventsCalendarGetCalendarViewRequest) (MicrosoftGraphEvent, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphEvent
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GroupsEventApiService.GroupsEventsCalendarGetCalendarView")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/groups/{group-id}/events/{event-id}/calendar/calendarView/{event-id1}"
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id1"+"}", _neturl.PathEscape(parameterToString(r.eventId1, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGroupsEventsCalendarGetEventsRequest struct {
	ctx _context.Context
	ApiService *GroupsEventApiService
	groupId string
	eventId string
	eventId1 string
	select_ *[]string
}

// Select properties to be returned
func (r ApiGroupsEventsCalendarGetEventsRequest) Select_(select_ []string) ApiGroupsEventsCalendarGetEventsRequest {
	r.select_ = &select_
	return r
}

func (r ApiGroupsEventsCalendarGetEventsRequest) Execute() (MicrosoftGraphEvent, *_nethttp.Response, error) {
	return r.ApiService.GroupsEventsCalendarGetEventsExecute(r)
}

/*
GroupsEventsCalendarGetEvents Get events from groups

The events in the calendar. Navigation property. Read-only.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupId key: id of group
 @param eventId key: id of event
 @param eventId1 key: id of event
 @return ApiGroupsEventsCalendarGetEventsRequest
*/
func (a *GroupsEventApiService) GroupsEventsCalendarGetEvents(ctx _context.Context, groupId string, eventId string, eventId1 string) ApiGroupsEventsCalendarGetEventsRequest {
	return ApiGroupsEventsCalendarGetEventsRequest{
		ApiService: a,
		ctx: ctx,
		groupId: groupId,
		eventId: eventId,
		eventId1: eventId1,
	}
}

// Execute executes the request
//  @return MicrosoftGraphEvent
func (a *GroupsEventApiService) GroupsEventsCalendarGetEventsExecute(r ApiGroupsEventsCalendarGetEventsRequest) (MicrosoftGraphEvent, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphEvent
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GroupsEventApiService.GroupsEventsCalendarGetEvents")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/groups/{group-id}/events/{event-id}/calendar/events/{event-id1}"
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id1"+"}", _neturl.PathEscape(parameterToString(r.eventId1, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGroupsEventsCalendarGetMultiValueExtendedPropertiesRequest struct {
	ctx _context.Context
	ApiService *GroupsEventApiService
	groupId string
	eventId string
	multiValueLegacyExtendedPropertyId string
	select_ *[]string
	expand *[]string
}

// Select properties to be returned
func (r ApiGroupsEventsCalendarGetMultiValueExtendedPropertiesRequest) Select_(select_ []string) ApiGroupsEventsCalendarGetMultiValueExtendedPropertiesRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiGroupsEventsCalendarGetMultiValueExtendedPropertiesRequest) Expand(expand []string) ApiGroupsEventsCalendarGetMultiValueExtendedPropertiesRequest {
	r.expand = &expand
	return r
}

func (r ApiGroupsEventsCalendarGetMultiValueExtendedPropertiesRequest) Execute() (MicrosoftGraphMultiValueLegacyExtendedProperty, *_nethttp.Response, error) {
	return r.ApiService.GroupsEventsCalendarGetMultiValueExtendedPropertiesExecute(r)
}

/*
GroupsEventsCalendarGetMultiValueExtendedProperties Get multiValueExtendedProperties from groups

The collection of multi-value extended properties defined for the calendar. Read-only. Nullable.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupId key: id of group
 @param eventId key: id of event
 @param multiValueLegacyExtendedPropertyId key: id of multiValueLegacyExtendedProperty
 @return ApiGroupsEventsCalendarGetMultiValueExtendedPropertiesRequest
*/
func (a *GroupsEventApiService) GroupsEventsCalendarGetMultiValueExtendedProperties(ctx _context.Context, groupId string, eventId string, multiValueLegacyExtendedPropertyId string) ApiGroupsEventsCalendarGetMultiValueExtendedPropertiesRequest {
	return ApiGroupsEventsCalendarGetMultiValueExtendedPropertiesRequest{
		ApiService: a,
		ctx: ctx,
		groupId: groupId,
		eventId: eventId,
		multiValueLegacyExtendedPropertyId: multiValueLegacyExtendedPropertyId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphMultiValueLegacyExtendedProperty
func (a *GroupsEventApiService) GroupsEventsCalendarGetMultiValueExtendedPropertiesExecute(r ApiGroupsEventsCalendarGetMultiValueExtendedPropertiesRequest) (MicrosoftGraphMultiValueLegacyExtendedProperty, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphMultiValueLegacyExtendedProperty
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GroupsEventApiService.GroupsEventsCalendarGetMultiValueExtendedProperties")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/groups/{group-id}/events/{event-id}/calendar/multiValueExtendedProperties/{multiValueLegacyExtendedProperty-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"multiValueLegacyExtendedProperty-id"+"}", _neturl.PathEscape(parameterToString(r.multiValueLegacyExtendedPropertyId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGroupsEventsCalendarGetSingleValueExtendedPropertiesRequest struct {
	ctx _context.Context
	ApiService *GroupsEventApiService
	groupId string
	eventId string
	singleValueLegacyExtendedPropertyId string
	select_ *[]string
	expand *[]string
}

// Select properties to be returned
func (r ApiGroupsEventsCalendarGetSingleValueExtendedPropertiesRequest) Select_(select_ []string) ApiGroupsEventsCalendarGetSingleValueExtendedPropertiesRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiGroupsEventsCalendarGetSingleValueExtendedPropertiesRequest) Expand(expand []string) ApiGroupsEventsCalendarGetSingleValueExtendedPropertiesRequest {
	r.expand = &expand
	return r
}

func (r ApiGroupsEventsCalendarGetSingleValueExtendedPropertiesRequest) Execute() (MicrosoftGraphSingleValueLegacyExtendedProperty, *_nethttp.Response, error) {
	return r.ApiService.GroupsEventsCalendarGetSingleValueExtendedPropertiesExecute(r)
}

/*
GroupsEventsCalendarGetSingleValueExtendedProperties Get singleValueExtendedProperties from groups

The collection of single-value extended properties defined for the calendar. Read-only. Nullable.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupId key: id of group
 @param eventId key: id of event
 @param singleValueLegacyExtendedPropertyId key: id of singleValueLegacyExtendedProperty
 @return ApiGroupsEventsCalendarGetSingleValueExtendedPropertiesRequest
*/
func (a *GroupsEventApiService) GroupsEventsCalendarGetSingleValueExtendedProperties(ctx _context.Context, groupId string, eventId string, singleValueLegacyExtendedPropertyId string) ApiGroupsEventsCalendarGetSingleValueExtendedPropertiesRequest {
	return ApiGroupsEventsCalendarGetSingleValueExtendedPropertiesRequest{
		ApiService: a,
		ctx: ctx,
		groupId: groupId,
		eventId: eventId,
		singleValueLegacyExtendedPropertyId: singleValueLegacyExtendedPropertyId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphSingleValueLegacyExtendedProperty
func (a *GroupsEventApiService) GroupsEventsCalendarGetSingleValueExtendedPropertiesExecute(r ApiGroupsEventsCalendarGetSingleValueExtendedPropertiesRequest) (MicrosoftGraphSingleValueLegacyExtendedProperty, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphSingleValueLegacyExtendedProperty
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GroupsEventApiService.GroupsEventsCalendarGetSingleValueExtendedProperties")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/groups/{group-id}/events/{event-id}/calendar/singleValueExtendedProperties/{singleValueLegacyExtendedProperty-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"singleValueLegacyExtendedProperty-id"+"}", _neturl.PathEscape(parameterToString(r.singleValueLegacyExtendedPropertyId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGroupsEventsCalendarListCalendarPermissionsRequest struct {
	ctx _context.Context
	ApiService *GroupsEventApiService
	groupId string
	eventId string
	top *int32
	skip *int32
	filter *string
	count *bool
	orderby *[]string
	select_ *[]string
}

// Show only the first n items
func (r ApiGroupsEventsCalendarListCalendarPermissionsRequest) Top(top int32) ApiGroupsEventsCalendarListCalendarPermissionsRequest {
	r.top = &top
	return r
}
// Skip the first n items
func (r ApiGroupsEventsCalendarListCalendarPermissionsRequest) Skip(skip int32) ApiGroupsEventsCalendarListCalendarPermissionsRequest {
	r.skip = &skip
	return r
}
// Filter items by property values
func (r ApiGroupsEventsCalendarListCalendarPermissionsRequest) Filter(filter string) ApiGroupsEventsCalendarListCalendarPermissionsRequest {
	r.filter = &filter
	return r
}
// Include count of items
func (r ApiGroupsEventsCalendarListCalendarPermissionsRequest) Count(count bool) ApiGroupsEventsCalendarListCalendarPermissionsRequest {
	r.count = &count
	return r
}
// Order items by property values
func (r ApiGroupsEventsCalendarListCalendarPermissionsRequest) Orderby(orderby []string) ApiGroupsEventsCalendarListCalendarPermissionsRequest {
	r.orderby = &orderby
	return r
}
// Select properties to be returned
func (r ApiGroupsEventsCalendarListCalendarPermissionsRequest) Select_(select_ []string) ApiGroupsEventsCalendarListCalendarPermissionsRequest {
	r.select_ = &select_
	return r
}

func (r ApiGroupsEventsCalendarListCalendarPermissionsRequest) Execute() (CollectionOfCalendarPermission, *_nethttp.Response, error) {
	return r.ApiService.GroupsEventsCalendarListCalendarPermissionsExecute(r)
}

/*
GroupsEventsCalendarListCalendarPermissions Get calendarPermissions from groups

The permissions of the users with whom the calendar is shared.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupId key: id of group
 @param eventId key: id of event
 @return ApiGroupsEventsCalendarListCalendarPermissionsRequest
*/
func (a *GroupsEventApiService) GroupsEventsCalendarListCalendarPermissions(ctx _context.Context, groupId string, eventId string) ApiGroupsEventsCalendarListCalendarPermissionsRequest {
	return ApiGroupsEventsCalendarListCalendarPermissionsRequest{
		ApiService: a,
		ctx: ctx,
		groupId: groupId,
		eventId: eventId,
	}
}

// Execute executes the request
//  @return CollectionOfCalendarPermission
func (a *GroupsEventApiService) GroupsEventsCalendarListCalendarPermissionsExecute(r ApiGroupsEventsCalendarListCalendarPermissionsRequest) (CollectionOfCalendarPermission, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  CollectionOfCalendarPermission
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GroupsEventApiService.GroupsEventsCalendarListCalendarPermissions")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/groups/{group-id}/events/{event-id}/calendar/calendarPermissions"
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.top != nil {
		localVarQueryParams.Add("$top", parameterToString(*r.top, ""))
	}
	if r.skip != nil {
		localVarQueryParams.Add("$skip", parameterToString(*r.skip, ""))
	}
	if r.filter != nil {
		localVarQueryParams.Add("$filter", parameterToString(*r.filter, ""))
	}
	if r.count != nil {
		localVarQueryParams.Add("$count", parameterToString(*r.count, ""))
	}
	if r.orderby != nil {
		localVarQueryParams.Add("$orderby", parameterToString(*r.orderby, "csv"))
	}
	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGroupsEventsCalendarListCalendarViewRequest struct {
	ctx _context.Context
	ApiService *GroupsEventApiService
	groupId string
	eventId string
	top *int32
	skip *int32
	filter *string
	count *bool
	orderby *[]string
	select_ *[]string
}

// Show only the first n items
func (r ApiGroupsEventsCalendarListCalendarViewRequest) Top(top int32) ApiGroupsEventsCalendarListCalendarViewRequest {
	r.top = &top
	return r
}
// Skip the first n items
func (r ApiGroupsEventsCalendarListCalendarViewRequest) Skip(skip int32) ApiGroupsEventsCalendarListCalendarViewRequest {
	r.skip = &skip
	return r
}
// Filter items by property values
func (r ApiGroupsEventsCalendarListCalendarViewRequest) Filter(filter string) ApiGroupsEventsCalendarListCalendarViewRequest {
	r.filter = &filter
	return r
}
// Include count of items
func (r ApiGroupsEventsCalendarListCalendarViewRequest) Count(count bool) ApiGroupsEventsCalendarListCalendarViewRequest {
	r.count = &count
	return r
}
// Order items by property values
func (r ApiGroupsEventsCalendarListCalendarViewRequest) Orderby(orderby []string) ApiGroupsEventsCalendarListCalendarViewRequest {
	r.orderby = &orderby
	return r
}
// Select properties to be returned
func (r ApiGroupsEventsCalendarListCalendarViewRequest) Select_(select_ []string) ApiGroupsEventsCalendarListCalendarViewRequest {
	r.select_ = &select_
	return r
}

func (r ApiGroupsEventsCalendarListCalendarViewRequest) Execute() (CollectionOfEvent, *_nethttp.Response, error) {
	return r.ApiService.GroupsEventsCalendarListCalendarViewExecute(r)
}

/*
GroupsEventsCalendarListCalendarView Get calendarView from groups

The calendar view for the calendar. Navigation property. Read-only.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupId key: id of group
 @param eventId key: id of event
 @return ApiGroupsEventsCalendarListCalendarViewRequest
*/
func (a *GroupsEventApiService) GroupsEventsCalendarListCalendarView(ctx _context.Context, groupId string, eventId string) ApiGroupsEventsCalendarListCalendarViewRequest {
	return ApiGroupsEventsCalendarListCalendarViewRequest{
		ApiService: a,
		ctx: ctx,
		groupId: groupId,
		eventId: eventId,
	}
}

// Execute executes the request
//  @return CollectionOfEvent
func (a *GroupsEventApiService) GroupsEventsCalendarListCalendarViewExecute(r ApiGroupsEventsCalendarListCalendarViewRequest) (CollectionOfEvent, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  CollectionOfEvent
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GroupsEventApiService.GroupsEventsCalendarListCalendarView")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/groups/{group-id}/events/{event-id}/calendar/calendarView"
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.top != nil {
		localVarQueryParams.Add("$top", parameterToString(*r.top, ""))
	}
	if r.skip != nil {
		localVarQueryParams.Add("$skip", parameterToString(*r.skip, ""))
	}
	if r.filter != nil {
		localVarQueryParams.Add("$filter", parameterToString(*r.filter, ""))
	}
	if r.count != nil {
		localVarQueryParams.Add("$count", parameterToString(*r.count, ""))
	}
	if r.orderby != nil {
		localVarQueryParams.Add("$orderby", parameterToString(*r.orderby, "csv"))
	}
	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGroupsEventsCalendarListEventsRequest struct {
	ctx _context.Context
	ApiService *GroupsEventApiService
	groupId string
	eventId string
	top *int32
	skip *int32
	filter *string
	count *bool
	orderby *[]string
	select_ *[]string
}

// Show only the first n items
func (r ApiGroupsEventsCalendarListEventsRequest) Top(top int32) ApiGroupsEventsCalendarListEventsRequest {
	r.top = &top
	return r
}
// Skip the first n items
func (r ApiGroupsEventsCalendarListEventsRequest) Skip(skip int32) ApiGroupsEventsCalendarListEventsRequest {
	r.skip = &skip
	return r
}
// Filter items by property values
func (r ApiGroupsEventsCalendarListEventsRequest) Filter(filter string) ApiGroupsEventsCalendarListEventsRequest {
	r.filter = &filter
	return r
}
// Include count of items
func (r ApiGroupsEventsCalendarListEventsRequest) Count(count bool) ApiGroupsEventsCalendarListEventsRequest {
	r.count = &count
	return r
}
// Order items by property values
func (r ApiGroupsEventsCalendarListEventsRequest) Orderby(orderby []string) ApiGroupsEventsCalendarListEventsRequest {
	r.orderby = &orderby
	return r
}
// Select properties to be returned
func (r ApiGroupsEventsCalendarListEventsRequest) Select_(select_ []string) ApiGroupsEventsCalendarListEventsRequest {
	r.select_ = &select_
	return r
}

func (r ApiGroupsEventsCalendarListEventsRequest) Execute() (CollectionOfEvent, *_nethttp.Response, error) {
	return r.ApiService.GroupsEventsCalendarListEventsExecute(r)
}

/*
GroupsEventsCalendarListEvents Get events from groups

The events in the calendar. Navigation property. Read-only.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupId key: id of group
 @param eventId key: id of event
 @return ApiGroupsEventsCalendarListEventsRequest
*/
func (a *GroupsEventApiService) GroupsEventsCalendarListEvents(ctx _context.Context, groupId string, eventId string) ApiGroupsEventsCalendarListEventsRequest {
	return ApiGroupsEventsCalendarListEventsRequest{
		ApiService: a,
		ctx: ctx,
		groupId: groupId,
		eventId: eventId,
	}
}

// Execute executes the request
//  @return CollectionOfEvent
func (a *GroupsEventApiService) GroupsEventsCalendarListEventsExecute(r ApiGroupsEventsCalendarListEventsRequest) (CollectionOfEvent, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  CollectionOfEvent
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GroupsEventApiService.GroupsEventsCalendarListEvents")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/groups/{group-id}/events/{event-id}/calendar/events"
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.top != nil {
		localVarQueryParams.Add("$top", parameterToString(*r.top, ""))
	}
	if r.skip != nil {
		localVarQueryParams.Add("$skip", parameterToString(*r.skip, ""))
	}
	if r.filter != nil {
		localVarQueryParams.Add("$filter", parameterToString(*r.filter, ""))
	}
	if r.count != nil {
		localVarQueryParams.Add("$count", parameterToString(*r.count, ""))
	}
	if r.orderby != nil {
		localVarQueryParams.Add("$orderby", parameterToString(*r.orderby, "csv"))
	}
	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGroupsEventsCalendarListMultiValueExtendedPropertiesRequest struct {
	ctx _context.Context
	ApiService *GroupsEventApiService
	groupId string
	eventId string
	top *int32
	skip *int32
	search *string
	filter *string
	count *bool
	orderby *[]string
	select_ *[]string
	expand *[]string
}

// Show only the first n items
func (r ApiGroupsEventsCalendarListMultiValueExtendedPropertiesRequest) Top(top int32) ApiGroupsEventsCalendarListMultiValueExtendedPropertiesRequest {
	r.top = &top
	return r
}
// Skip the first n items
func (r ApiGroupsEventsCalendarListMultiValueExtendedPropertiesRequest) Skip(skip int32) ApiGroupsEventsCalendarListMultiValueExtendedPropertiesRequest {
	r.skip = &skip
	return r
}
// Search items by search phrases
func (r ApiGroupsEventsCalendarListMultiValueExtendedPropertiesRequest) Search(search string) ApiGroupsEventsCalendarListMultiValueExtendedPropertiesRequest {
	r.search = &search
	return r
}
// Filter items by property values
func (r ApiGroupsEventsCalendarListMultiValueExtendedPropertiesRequest) Filter(filter string) ApiGroupsEventsCalendarListMultiValueExtendedPropertiesRequest {
	r.filter = &filter
	return r
}
// Include count of items
func (r ApiGroupsEventsCalendarListMultiValueExtendedPropertiesRequest) Count(count bool) ApiGroupsEventsCalendarListMultiValueExtendedPropertiesRequest {
	r.count = &count
	return r
}
// Order items by property values
func (r ApiGroupsEventsCalendarListMultiValueExtendedPropertiesRequest) Orderby(orderby []string) ApiGroupsEventsCalendarListMultiValueExtendedPropertiesRequest {
	r.orderby = &orderby
	return r
}
// Select properties to be returned
func (r ApiGroupsEventsCalendarListMultiValueExtendedPropertiesRequest) Select_(select_ []string) ApiGroupsEventsCalendarListMultiValueExtendedPropertiesRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiGroupsEventsCalendarListMultiValueExtendedPropertiesRequest) Expand(expand []string) ApiGroupsEventsCalendarListMultiValueExtendedPropertiesRequest {
	r.expand = &expand
	return r
}

func (r ApiGroupsEventsCalendarListMultiValueExtendedPropertiesRequest) Execute() (CollectionOfMultiValueLegacyExtendedProperty, *_nethttp.Response, error) {
	return r.ApiService.GroupsEventsCalendarListMultiValueExtendedPropertiesExecute(r)
}

/*
GroupsEventsCalendarListMultiValueExtendedProperties Get multiValueExtendedProperties from groups

The collection of multi-value extended properties defined for the calendar. Read-only. Nullable.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupId key: id of group
 @param eventId key: id of event
 @return ApiGroupsEventsCalendarListMultiValueExtendedPropertiesRequest
*/
func (a *GroupsEventApiService) GroupsEventsCalendarListMultiValueExtendedProperties(ctx _context.Context, groupId string, eventId string) ApiGroupsEventsCalendarListMultiValueExtendedPropertiesRequest {
	return ApiGroupsEventsCalendarListMultiValueExtendedPropertiesRequest{
		ApiService: a,
		ctx: ctx,
		groupId: groupId,
		eventId: eventId,
	}
}

// Execute executes the request
//  @return CollectionOfMultiValueLegacyExtendedProperty
func (a *GroupsEventApiService) GroupsEventsCalendarListMultiValueExtendedPropertiesExecute(r ApiGroupsEventsCalendarListMultiValueExtendedPropertiesRequest) (CollectionOfMultiValueLegacyExtendedProperty, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  CollectionOfMultiValueLegacyExtendedProperty
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GroupsEventApiService.GroupsEventsCalendarListMultiValueExtendedProperties")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/groups/{group-id}/events/{event-id}/calendar/multiValueExtendedProperties"
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.top != nil {
		localVarQueryParams.Add("$top", parameterToString(*r.top, ""))
	}
	if r.skip != nil {
		localVarQueryParams.Add("$skip", parameterToString(*r.skip, ""))
	}
	if r.search != nil {
		localVarQueryParams.Add("$search", parameterToString(*r.search, ""))
	}
	if r.filter != nil {
		localVarQueryParams.Add("$filter", parameterToString(*r.filter, ""))
	}
	if r.count != nil {
		localVarQueryParams.Add("$count", parameterToString(*r.count, ""))
	}
	if r.orderby != nil {
		localVarQueryParams.Add("$orderby", parameterToString(*r.orderby, "csv"))
	}
	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGroupsEventsCalendarListSingleValueExtendedPropertiesRequest struct {
	ctx _context.Context
	ApiService *GroupsEventApiService
	groupId string
	eventId string
	top *int32
	skip *int32
	search *string
	filter *string
	count *bool
	orderby *[]string
	select_ *[]string
	expand *[]string
}

// Show only the first n items
func (r ApiGroupsEventsCalendarListSingleValueExtendedPropertiesRequest) Top(top int32) ApiGroupsEventsCalendarListSingleValueExtendedPropertiesRequest {
	r.top = &top
	return r
}
// Skip the first n items
func (r ApiGroupsEventsCalendarListSingleValueExtendedPropertiesRequest) Skip(skip int32) ApiGroupsEventsCalendarListSingleValueExtendedPropertiesRequest {
	r.skip = &skip
	return r
}
// Search items by search phrases
func (r ApiGroupsEventsCalendarListSingleValueExtendedPropertiesRequest) Search(search string) ApiGroupsEventsCalendarListSingleValueExtendedPropertiesRequest {
	r.search = &search
	return r
}
// Filter items by property values
func (r ApiGroupsEventsCalendarListSingleValueExtendedPropertiesRequest) Filter(filter string) ApiGroupsEventsCalendarListSingleValueExtendedPropertiesRequest {
	r.filter = &filter
	return r
}
// Include count of items
func (r ApiGroupsEventsCalendarListSingleValueExtendedPropertiesRequest) Count(count bool) ApiGroupsEventsCalendarListSingleValueExtendedPropertiesRequest {
	r.count = &count
	return r
}
// Order items by property values
func (r ApiGroupsEventsCalendarListSingleValueExtendedPropertiesRequest) Orderby(orderby []string) ApiGroupsEventsCalendarListSingleValueExtendedPropertiesRequest {
	r.orderby = &orderby
	return r
}
// Select properties to be returned
func (r ApiGroupsEventsCalendarListSingleValueExtendedPropertiesRequest) Select_(select_ []string) ApiGroupsEventsCalendarListSingleValueExtendedPropertiesRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiGroupsEventsCalendarListSingleValueExtendedPropertiesRequest) Expand(expand []string) ApiGroupsEventsCalendarListSingleValueExtendedPropertiesRequest {
	r.expand = &expand
	return r
}

func (r ApiGroupsEventsCalendarListSingleValueExtendedPropertiesRequest) Execute() (CollectionOfSingleValueLegacyExtendedProperty, *_nethttp.Response, error) {
	return r.ApiService.GroupsEventsCalendarListSingleValueExtendedPropertiesExecute(r)
}

/*
GroupsEventsCalendarListSingleValueExtendedProperties Get singleValueExtendedProperties from groups

The collection of single-value extended properties defined for the calendar. Read-only. Nullable.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupId key: id of group
 @param eventId key: id of event
 @return ApiGroupsEventsCalendarListSingleValueExtendedPropertiesRequest
*/
func (a *GroupsEventApiService) GroupsEventsCalendarListSingleValueExtendedProperties(ctx _context.Context, groupId string, eventId string) ApiGroupsEventsCalendarListSingleValueExtendedPropertiesRequest {
	return ApiGroupsEventsCalendarListSingleValueExtendedPropertiesRequest{
		ApiService: a,
		ctx: ctx,
		groupId: groupId,
		eventId: eventId,
	}
}

// Execute executes the request
//  @return CollectionOfSingleValueLegacyExtendedProperty
func (a *GroupsEventApiService) GroupsEventsCalendarListSingleValueExtendedPropertiesExecute(r ApiGroupsEventsCalendarListSingleValueExtendedPropertiesRequest) (CollectionOfSingleValueLegacyExtendedProperty, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  CollectionOfSingleValueLegacyExtendedProperty
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GroupsEventApiService.GroupsEventsCalendarListSingleValueExtendedProperties")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/groups/{group-id}/events/{event-id}/calendar/singleValueExtendedProperties"
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.top != nil {
		localVarQueryParams.Add("$top", parameterToString(*r.top, ""))
	}
	if r.skip != nil {
		localVarQueryParams.Add("$skip", parameterToString(*r.skip, ""))
	}
	if r.search != nil {
		localVarQueryParams.Add("$search", parameterToString(*r.search, ""))
	}
	if r.filter != nil {
		localVarQueryParams.Add("$filter", parameterToString(*r.filter, ""))
	}
	if r.count != nil {
		localVarQueryParams.Add("$count", parameterToString(*r.count, ""))
	}
	if r.orderby != nil {
		localVarQueryParams.Add("$orderby", parameterToString(*r.orderby, "csv"))
	}
	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGroupsEventsCalendarUpdateCalendarPermissionsRequest struct {
	ctx _context.Context
	ApiService *GroupsEventApiService
	groupId string
	eventId string
	calendarPermissionId string
	microsoftGraphCalendarPermission *MicrosoftGraphCalendarPermission
}

// New navigation property values
func (r ApiGroupsEventsCalendarUpdateCalendarPermissionsRequest) MicrosoftGraphCalendarPermission(microsoftGraphCalendarPermission MicrosoftGraphCalendarPermission) ApiGroupsEventsCalendarUpdateCalendarPermissionsRequest {
	r.microsoftGraphCalendarPermission = &microsoftGraphCalendarPermission
	return r
}

func (r ApiGroupsEventsCalendarUpdateCalendarPermissionsRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.GroupsEventsCalendarUpdateCalendarPermissionsExecute(r)
}

/*
GroupsEventsCalendarUpdateCalendarPermissions Update the navigation property calendarPermissions in groups

The permissions of the users with whom the calendar is shared.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupId key: id of group
 @param eventId key: id of event
 @param calendarPermissionId key: id of calendarPermission
 @return ApiGroupsEventsCalendarUpdateCalendarPermissionsRequest
*/
func (a *GroupsEventApiService) GroupsEventsCalendarUpdateCalendarPermissions(ctx _context.Context, groupId string, eventId string, calendarPermissionId string) ApiGroupsEventsCalendarUpdateCalendarPermissionsRequest {
	return ApiGroupsEventsCalendarUpdateCalendarPermissionsRequest{
		ApiService: a,
		ctx: ctx,
		groupId: groupId,
		eventId: eventId,
		calendarPermissionId: calendarPermissionId,
	}
}

// Execute executes the request
func (a *GroupsEventApiService) GroupsEventsCalendarUpdateCalendarPermissionsExecute(r ApiGroupsEventsCalendarUpdateCalendarPermissionsRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPatch
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GroupsEventApiService.GroupsEventsCalendarUpdateCalendarPermissions")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/groups/{group-id}/events/{event-id}/calendar/calendarPermissions/{calendarPermission-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"calendarPermission-id"+"}", _neturl.PathEscape(parameterToString(r.calendarPermissionId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphCalendarPermission == nil {
		return nil, reportError("microsoftGraphCalendarPermission is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphCalendarPermission
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGroupsEventsCalendarUpdateCalendarViewRequest struct {
	ctx _context.Context
	ApiService *GroupsEventApiService
	groupId string
	eventId string
	eventId1 string
	microsoftGraphEvent *MicrosoftGraphEvent
}

// New navigation property values
func (r ApiGroupsEventsCalendarUpdateCalendarViewRequest) MicrosoftGraphEvent(microsoftGraphEvent MicrosoftGraphEvent) ApiGroupsEventsCalendarUpdateCalendarViewRequest {
	r.microsoftGraphEvent = &microsoftGraphEvent
	return r
}

func (r ApiGroupsEventsCalendarUpdateCalendarViewRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.GroupsEventsCalendarUpdateCalendarViewExecute(r)
}

/*
GroupsEventsCalendarUpdateCalendarView Update the navigation property calendarView in groups

The calendar view for the calendar. Navigation property. Read-only.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupId key: id of group
 @param eventId key: id of event
 @param eventId1 key: id of event
 @return ApiGroupsEventsCalendarUpdateCalendarViewRequest
*/
func (a *GroupsEventApiService) GroupsEventsCalendarUpdateCalendarView(ctx _context.Context, groupId string, eventId string, eventId1 string) ApiGroupsEventsCalendarUpdateCalendarViewRequest {
	return ApiGroupsEventsCalendarUpdateCalendarViewRequest{
		ApiService: a,
		ctx: ctx,
		groupId: groupId,
		eventId: eventId,
		eventId1: eventId1,
	}
}

// Execute executes the request
func (a *GroupsEventApiService) GroupsEventsCalendarUpdateCalendarViewExecute(r ApiGroupsEventsCalendarUpdateCalendarViewRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPatch
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GroupsEventApiService.GroupsEventsCalendarUpdateCalendarView")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/groups/{group-id}/events/{event-id}/calendar/calendarView/{event-id1}"
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id1"+"}", _neturl.PathEscape(parameterToString(r.eventId1, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphEvent == nil {
		return nil, reportError("microsoftGraphEvent is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphEvent
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGroupsEventsCalendarUpdateEventsRequest struct {
	ctx _context.Context
	ApiService *GroupsEventApiService
	groupId string
	eventId string
	eventId1 string
	microsoftGraphEvent *MicrosoftGraphEvent
}

// New navigation property values
func (r ApiGroupsEventsCalendarUpdateEventsRequest) MicrosoftGraphEvent(microsoftGraphEvent MicrosoftGraphEvent) ApiGroupsEventsCalendarUpdateEventsRequest {
	r.microsoftGraphEvent = &microsoftGraphEvent
	return r
}

func (r ApiGroupsEventsCalendarUpdateEventsRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.GroupsEventsCalendarUpdateEventsExecute(r)
}

/*
GroupsEventsCalendarUpdateEvents Update the navigation property events in groups

The events in the calendar. Navigation property. Read-only.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupId key: id of group
 @param eventId key: id of event
 @param eventId1 key: id of event
 @return ApiGroupsEventsCalendarUpdateEventsRequest
*/
func (a *GroupsEventApiService) GroupsEventsCalendarUpdateEvents(ctx _context.Context, groupId string, eventId string, eventId1 string) ApiGroupsEventsCalendarUpdateEventsRequest {
	return ApiGroupsEventsCalendarUpdateEventsRequest{
		ApiService: a,
		ctx: ctx,
		groupId: groupId,
		eventId: eventId,
		eventId1: eventId1,
	}
}

// Execute executes the request
func (a *GroupsEventApiService) GroupsEventsCalendarUpdateEventsExecute(r ApiGroupsEventsCalendarUpdateEventsRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPatch
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GroupsEventApiService.GroupsEventsCalendarUpdateEvents")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/groups/{group-id}/events/{event-id}/calendar/events/{event-id1}"
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id1"+"}", _neturl.PathEscape(parameterToString(r.eventId1, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphEvent == nil {
		return nil, reportError("microsoftGraphEvent is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphEvent
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGroupsEventsCalendarUpdateMultiValueExtendedPropertiesRequest struct {
	ctx _context.Context
	ApiService *GroupsEventApiService
	groupId string
	eventId string
	multiValueLegacyExtendedPropertyId string
	microsoftGraphMultiValueLegacyExtendedProperty *MicrosoftGraphMultiValueLegacyExtendedProperty
}

// New navigation property values
func (r ApiGroupsEventsCalendarUpdateMultiValueExtendedPropertiesRequest) MicrosoftGraphMultiValueLegacyExtendedProperty(microsoftGraphMultiValueLegacyExtendedProperty MicrosoftGraphMultiValueLegacyExtendedProperty) ApiGroupsEventsCalendarUpdateMultiValueExtendedPropertiesRequest {
	r.microsoftGraphMultiValueLegacyExtendedProperty = &microsoftGraphMultiValueLegacyExtendedProperty
	return r
}

func (r ApiGroupsEventsCalendarUpdateMultiValueExtendedPropertiesRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.GroupsEventsCalendarUpdateMultiValueExtendedPropertiesExecute(r)
}

/*
GroupsEventsCalendarUpdateMultiValueExtendedProperties Update the navigation property multiValueExtendedProperties in groups

The collection of multi-value extended properties defined for the calendar. Read-only. Nullable.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupId key: id of group
 @param eventId key: id of event
 @param multiValueLegacyExtendedPropertyId key: id of multiValueLegacyExtendedProperty
 @return ApiGroupsEventsCalendarUpdateMultiValueExtendedPropertiesRequest
*/
func (a *GroupsEventApiService) GroupsEventsCalendarUpdateMultiValueExtendedProperties(ctx _context.Context, groupId string, eventId string, multiValueLegacyExtendedPropertyId string) ApiGroupsEventsCalendarUpdateMultiValueExtendedPropertiesRequest {
	return ApiGroupsEventsCalendarUpdateMultiValueExtendedPropertiesRequest{
		ApiService: a,
		ctx: ctx,
		groupId: groupId,
		eventId: eventId,
		multiValueLegacyExtendedPropertyId: multiValueLegacyExtendedPropertyId,
	}
}

// Execute executes the request
func (a *GroupsEventApiService) GroupsEventsCalendarUpdateMultiValueExtendedPropertiesExecute(r ApiGroupsEventsCalendarUpdateMultiValueExtendedPropertiesRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPatch
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GroupsEventApiService.GroupsEventsCalendarUpdateMultiValueExtendedProperties")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/groups/{group-id}/events/{event-id}/calendar/multiValueExtendedProperties/{multiValueLegacyExtendedProperty-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"multiValueLegacyExtendedProperty-id"+"}", _neturl.PathEscape(parameterToString(r.multiValueLegacyExtendedPropertyId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphMultiValueLegacyExtendedProperty == nil {
		return nil, reportError("microsoftGraphMultiValueLegacyExtendedProperty is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphMultiValueLegacyExtendedProperty
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGroupsEventsCalendarUpdateSingleValueExtendedPropertiesRequest struct {
	ctx _context.Context
	ApiService *GroupsEventApiService
	groupId string
	eventId string
	singleValueLegacyExtendedPropertyId string
	microsoftGraphSingleValueLegacyExtendedProperty *MicrosoftGraphSingleValueLegacyExtendedProperty
}

// New navigation property values
func (r ApiGroupsEventsCalendarUpdateSingleValueExtendedPropertiesRequest) MicrosoftGraphSingleValueLegacyExtendedProperty(microsoftGraphSingleValueLegacyExtendedProperty MicrosoftGraphSingleValueLegacyExtendedProperty) ApiGroupsEventsCalendarUpdateSingleValueExtendedPropertiesRequest {
	r.microsoftGraphSingleValueLegacyExtendedProperty = &microsoftGraphSingleValueLegacyExtendedProperty
	return r
}

func (r ApiGroupsEventsCalendarUpdateSingleValueExtendedPropertiesRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.GroupsEventsCalendarUpdateSingleValueExtendedPropertiesExecute(r)
}

/*
GroupsEventsCalendarUpdateSingleValueExtendedProperties Update the navigation property singleValueExtendedProperties in groups

The collection of single-value extended properties defined for the calendar. Read-only. Nullable.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupId key: id of group
 @param eventId key: id of event
 @param singleValueLegacyExtendedPropertyId key: id of singleValueLegacyExtendedProperty
 @return ApiGroupsEventsCalendarUpdateSingleValueExtendedPropertiesRequest
*/
func (a *GroupsEventApiService) GroupsEventsCalendarUpdateSingleValueExtendedProperties(ctx _context.Context, groupId string, eventId string, singleValueLegacyExtendedPropertyId string) ApiGroupsEventsCalendarUpdateSingleValueExtendedPropertiesRequest {
	return ApiGroupsEventsCalendarUpdateSingleValueExtendedPropertiesRequest{
		ApiService: a,
		ctx: ctx,
		groupId: groupId,
		eventId: eventId,
		singleValueLegacyExtendedPropertyId: singleValueLegacyExtendedPropertyId,
	}
}

// Execute executes the request
func (a *GroupsEventApiService) GroupsEventsCalendarUpdateSingleValueExtendedPropertiesExecute(r ApiGroupsEventsCalendarUpdateSingleValueExtendedPropertiesRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPatch
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GroupsEventApiService.GroupsEventsCalendarUpdateSingleValueExtendedProperties")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/groups/{group-id}/events/{event-id}/calendar/singleValueExtendedProperties/{singleValueLegacyExtendedProperty-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"singleValueLegacyExtendedProperty-id"+"}", _neturl.PathEscape(parameterToString(r.singleValueLegacyExtendedPropertyId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphSingleValueLegacyExtendedProperty == nil {
		return nil, reportError("microsoftGraphSingleValueLegacyExtendedProperty is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphSingleValueLegacyExtendedProperty
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGroupsEventsCreateAttachmentsRequest struct {
	ctx _context.Context
	ApiService *GroupsEventApiService
	groupId string
	eventId string
	microsoftGraphAttachment *MicrosoftGraphAttachment
}

// New navigation property
func (r ApiGroupsEventsCreateAttachmentsRequest) MicrosoftGraphAttachment(microsoftGraphAttachment MicrosoftGraphAttachment) ApiGroupsEventsCreateAttachmentsRequest {
	r.microsoftGraphAttachment = &microsoftGraphAttachment
	return r
}

func (r ApiGroupsEventsCreateAttachmentsRequest) Execute() (MicrosoftGraphAttachment, *_nethttp.Response, error) {
	return r.ApiService.GroupsEventsCreateAttachmentsExecute(r)
}

/*
GroupsEventsCreateAttachments Create new navigation property to attachments for groups

The collection of FileAttachment, ItemAttachment, and referenceAttachment attachments for the event. Navigation property. Read-only. Nullable.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupId key: id of group
 @param eventId key: id of event
 @return ApiGroupsEventsCreateAttachmentsRequest
*/
func (a *GroupsEventApiService) GroupsEventsCreateAttachments(ctx _context.Context, groupId string, eventId string) ApiGroupsEventsCreateAttachmentsRequest {
	return ApiGroupsEventsCreateAttachmentsRequest{
		ApiService: a,
		ctx: ctx,
		groupId: groupId,
		eventId: eventId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphAttachment
func (a *GroupsEventApiService) GroupsEventsCreateAttachmentsExecute(r ApiGroupsEventsCreateAttachmentsRequest) (MicrosoftGraphAttachment, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphAttachment
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GroupsEventApiService.GroupsEventsCreateAttachments")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/groups/{group-id}/events/{event-id}/attachments"
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphAttachment == nil {
		return localVarReturnValue, nil, reportError("microsoftGraphAttachment is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphAttachment
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGroupsEventsCreateExtensionsRequest struct {
	ctx _context.Context
	ApiService *GroupsEventApiService
	groupId string
	eventId string
	microsoftGraphExtension *MicrosoftGraphExtension
}

// New navigation property
func (r ApiGroupsEventsCreateExtensionsRequest) MicrosoftGraphExtension(microsoftGraphExtension MicrosoftGraphExtension) ApiGroupsEventsCreateExtensionsRequest {
	r.microsoftGraphExtension = &microsoftGraphExtension
	return r
}

func (r ApiGroupsEventsCreateExtensionsRequest) Execute() (MicrosoftGraphExtension, *_nethttp.Response, error) {
	return r.ApiService.GroupsEventsCreateExtensionsExecute(r)
}

/*
GroupsEventsCreateExtensions Create new navigation property to extensions for groups

The collection of open extensions defined for the event. Nullable.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupId key: id of group
 @param eventId key: id of event
 @return ApiGroupsEventsCreateExtensionsRequest
*/
func (a *GroupsEventApiService) GroupsEventsCreateExtensions(ctx _context.Context, groupId string, eventId string) ApiGroupsEventsCreateExtensionsRequest {
	return ApiGroupsEventsCreateExtensionsRequest{
		ApiService: a,
		ctx: ctx,
		groupId: groupId,
		eventId: eventId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphExtension
func (a *GroupsEventApiService) GroupsEventsCreateExtensionsExecute(r ApiGroupsEventsCreateExtensionsRequest) (MicrosoftGraphExtension, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphExtension
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GroupsEventApiService.GroupsEventsCreateExtensions")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/groups/{group-id}/events/{event-id}/extensions"
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphExtension == nil {
		return localVarReturnValue, nil, reportError("microsoftGraphExtension is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphExtension
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGroupsEventsCreateInstancesRequest struct {
	ctx _context.Context
	ApiService *GroupsEventApiService
	groupId string
	eventId string
	microsoftGraphEvent *MicrosoftGraphEvent
}

// New navigation property
func (r ApiGroupsEventsCreateInstancesRequest) MicrosoftGraphEvent(microsoftGraphEvent MicrosoftGraphEvent) ApiGroupsEventsCreateInstancesRequest {
	r.microsoftGraphEvent = &microsoftGraphEvent
	return r
}

func (r ApiGroupsEventsCreateInstancesRequest) Execute() (MicrosoftGraphEvent, *_nethttp.Response, error) {
	return r.ApiService.GroupsEventsCreateInstancesExecute(r)
}

/*
GroupsEventsCreateInstances Create new navigation property to instances for groups

The occurrences of a recurring series, if the event is a series master. This property includes occurrences that are part of the recurrence pattern, and exceptions that have been modified, but does not include occurrences that have been cancelled from the series. Navigation property. Read-only. Nullable.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupId key: id of group
 @param eventId key: id of event
 @return ApiGroupsEventsCreateInstancesRequest
*/
func (a *GroupsEventApiService) GroupsEventsCreateInstances(ctx _context.Context, groupId string, eventId string) ApiGroupsEventsCreateInstancesRequest {
	return ApiGroupsEventsCreateInstancesRequest{
		ApiService: a,
		ctx: ctx,
		groupId: groupId,
		eventId: eventId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphEvent
func (a *GroupsEventApiService) GroupsEventsCreateInstancesExecute(r ApiGroupsEventsCreateInstancesRequest) (MicrosoftGraphEvent, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphEvent
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GroupsEventApiService.GroupsEventsCreateInstances")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/groups/{group-id}/events/{event-id}/instances"
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphEvent == nil {
		return localVarReturnValue, nil, reportError("microsoftGraphEvent is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphEvent
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGroupsEventsCreateMultiValueExtendedPropertiesRequest struct {
	ctx _context.Context
	ApiService *GroupsEventApiService
	groupId string
	eventId string
	microsoftGraphMultiValueLegacyExtendedProperty *MicrosoftGraphMultiValueLegacyExtendedProperty
}

// New navigation property
func (r ApiGroupsEventsCreateMultiValueExtendedPropertiesRequest) MicrosoftGraphMultiValueLegacyExtendedProperty(microsoftGraphMultiValueLegacyExtendedProperty MicrosoftGraphMultiValueLegacyExtendedProperty) ApiGroupsEventsCreateMultiValueExtendedPropertiesRequest {
	r.microsoftGraphMultiValueLegacyExtendedProperty = &microsoftGraphMultiValueLegacyExtendedProperty
	return r
}

func (r ApiGroupsEventsCreateMultiValueExtendedPropertiesRequest) Execute() (MicrosoftGraphMultiValueLegacyExtendedProperty, *_nethttp.Response, error) {
	return r.ApiService.GroupsEventsCreateMultiValueExtendedPropertiesExecute(r)
}

/*
GroupsEventsCreateMultiValueExtendedProperties Create new navigation property to multiValueExtendedProperties for groups

The collection of multi-value extended properties defined for the event. Read-only. Nullable.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupId key: id of group
 @param eventId key: id of event
 @return ApiGroupsEventsCreateMultiValueExtendedPropertiesRequest
*/
func (a *GroupsEventApiService) GroupsEventsCreateMultiValueExtendedProperties(ctx _context.Context, groupId string, eventId string) ApiGroupsEventsCreateMultiValueExtendedPropertiesRequest {
	return ApiGroupsEventsCreateMultiValueExtendedPropertiesRequest{
		ApiService: a,
		ctx: ctx,
		groupId: groupId,
		eventId: eventId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphMultiValueLegacyExtendedProperty
func (a *GroupsEventApiService) GroupsEventsCreateMultiValueExtendedPropertiesExecute(r ApiGroupsEventsCreateMultiValueExtendedPropertiesRequest) (MicrosoftGraphMultiValueLegacyExtendedProperty, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphMultiValueLegacyExtendedProperty
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GroupsEventApiService.GroupsEventsCreateMultiValueExtendedProperties")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/groups/{group-id}/events/{event-id}/multiValueExtendedProperties"
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphMultiValueLegacyExtendedProperty == nil {
		return localVarReturnValue, nil, reportError("microsoftGraphMultiValueLegacyExtendedProperty is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphMultiValueLegacyExtendedProperty
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGroupsEventsCreateSingleValueExtendedPropertiesRequest struct {
	ctx _context.Context
	ApiService *GroupsEventApiService
	groupId string
	eventId string
	microsoftGraphSingleValueLegacyExtendedProperty *MicrosoftGraphSingleValueLegacyExtendedProperty
}

// New navigation property
func (r ApiGroupsEventsCreateSingleValueExtendedPropertiesRequest) MicrosoftGraphSingleValueLegacyExtendedProperty(microsoftGraphSingleValueLegacyExtendedProperty MicrosoftGraphSingleValueLegacyExtendedProperty) ApiGroupsEventsCreateSingleValueExtendedPropertiesRequest {
	r.microsoftGraphSingleValueLegacyExtendedProperty = &microsoftGraphSingleValueLegacyExtendedProperty
	return r
}

func (r ApiGroupsEventsCreateSingleValueExtendedPropertiesRequest) Execute() (MicrosoftGraphSingleValueLegacyExtendedProperty, *_nethttp.Response, error) {
	return r.ApiService.GroupsEventsCreateSingleValueExtendedPropertiesExecute(r)
}

/*
GroupsEventsCreateSingleValueExtendedProperties Create new navigation property to singleValueExtendedProperties for groups

The collection of single-value extended properties defined for the event. Read-only. Nullable.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupId key: id of group
 @param eventId key: id of event
 @return ApiGroupsEventsCreateSingleValueExtendedPropertiesRequest
*/
func (a *GroupsEventApiService) GroupsEventsCreateSingleValueExtendedProperties(ctx _context.Context, groupId string, eventId string) ApiGroupsEventsCreateSingleValueExtendedPropertiesRequest {
	return ApiGroupsEventsCreateSingleValueExtendedPropertiesRequest{
		ApiService: a,
		ctx: ctx,
		groupId: groupId,
		eventId: eventId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphSingleValueLegacyExtendedProperty
func (a *GroupsEventApiService) GroupsEventsCreateSingleValueExtendedPropertiesExecute(r ApiGroupsEventsCreateSingleValueExtendedPropertiesRequest) (MicrosoftGraphSingleValueLegacyExtendedProperty, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphSingleValueLegacyExtendedProperty
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GroupsEventApiService.GroupsEventsCreateSingleValueExtendedProperties")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/groups/{group-id}/events/{event-id}/singleValueExtendedProperties"
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphSingleValueLegacyExtendedProperty == nil {
		return localVarReturnValue, nil, reportError("microsoftGraphSingleValueLegacyExtendedProperty is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphSingleValueLegacyExtendedProperty
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGroupsEventsDeleteAttachmentsRequest struct {
	ctx _context.Context
	ApiService *GroupsEventApiService
	groupId string
	eventId string
	attachmentId string
	ifMatch *string
}

// ETag
func (r ApiGroupsEventsDeleteAttachmentsRequest) IfMatch(ifMatch string) ApiGroupsEventsDeleteAttachmentsRequest {
	r.ifMatch = &ifMatch
	return r
}

func (r ApiGroupsEventsDeleteAttachmentsRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.GroupsEventsDeleteAttachmentsExecute(r)
}

/*
GroupsEventsDeleteAttachments Delete navigation property attachments for groups

The collection of FileAttachment, ItemAttachment, and referenceAttachment attachments for the event. Navigation property. Read-only. Nullable.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupId key: id of group
 @param eventId key: id of event
 @param attachmentId key: id of attachment
 @return ApiGroupsEventsDeleteAttachmentsRequest
*/
func (a *GroupsEventApiService) GroupsEventsDeleteAttachments(ctx _context.Context, groupId string, eventId string, attachmentId string) ApiGroupsEventsDeleteAttachmentsRequest {
	return ApiGroupsEventsDeleteAttachmentsRequest{
		ApiService: a,
		ctx: ctx,
		groupId: groupId,
		eventId: eventId,
		attachmentId: attachmentId,
	}
}

// Execute executes the request
func (a *GroupsEventApiService) GroupsEventsDeleteAttachmentsExecute(r ApiGroupsEventsDeleteAttachmentsRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GroupsEventApiService.GroupsEventsDeleteAttachments")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/groups/{group-id}/events/{event-id}/attachments/{attachment-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"attachment-id"+"}", _neturl.PathEscape(parameterToString(r.attachmentId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ifMatch != nil {
		localVarHeaderParams["If-Match"] = parameterToString(*r.ifMatch, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGroupsEventsDeleteCalendarRequest struct {
	ctx _context.Context
	ApiService *GroupsEventApiService
	groupId string
	eventId string
	ifMatch *string
}

// ETag
func (r ApiGroupsEventsDeleteCalendarRequest) IfMatch(ifMatch string) ApiGroupsEventsDeleteCalendarRequest {
	r.ifMatch = &ifMatch
	return r
}

func (r ApiGroupsEventsDeleteCalendarRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.GroupsEventsDeleteCalendarExecute(r)
}

/*
GroupsEventsDeleteCalendar Delete navigation property calendar for groups

The calendar that contains the event. Navigation property. Read-only.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupId key: id of group
 @param eventId key: id of event
 @return ApiGroupsEventsDeleteCalendarRequest
*/
func (a *GroupsEventApiService) GroupsEventsDeleteCalendar(ctx _context.Context, groupId string, eventId string) ApiGroupsEventsDeleteCalendarRequest {
	return ApiGroupsEventsDeleteCalendarRequest{
		ApiService: a,
		ctx: ctx,
		groupId: groupId,
		eventId: eventId,
	}
}

// Execute executes the request
func (a *GroupsEventApiService) GroupsEventsDeleteCalendarExecute(r ApiGroupsEventsDeleteCalendarRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GroupsEventApiService.GroupsEventsDeleteCalendar")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/groups/{group-id}/events/{event-id}/calendar"
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ifMatch != nil {
		localVarHeaderParams["If-Match"] = parameterToString(*r.ifMatch, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGroupsEventsDeleteExtensionsRequest struct {
	ctx _context.Context
	ApiService *GroupsEventApiService
	groupId string
	eventId string
	extensionId string
	ifMatch *string
}

// ETag
func (r ApiGroupsEventsDeleteExtensionsRequest) IfMatch(ifMatch string) ApiGroupsEventsDeleteExtensionsRequest {
	r.ifMatch = &ifMatch
	return r
}

func (r ApiGroupsEventsDeleteExtensionsRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.GroupsEventsDeleteExtensionsExecute(r)
}

/*
GroupsEventsDeleteExtensions Delete navigation property extensions for groups

The collection of open extensions defined for the event. Nullable.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupId key: id of group
 @param eventId key: id of event
 @param extensionId key: id of extension
 @return ApiGroupsEventsDeleteExtensionsRequest
*/
func (a *GroupsEventApiService) GroupsEventsDeleteExtensions(ctx _context.Context, groupId string, eventId string, extensionId string) ApiGroupsEventsDeleteExtensionsRequest {
	return ApiGroupsEventsDeleteExtensionsRequest{
		ApiService: a,
		ctx: ctx,
		groupId: groupId,
		eventId: eventId,
		extensionId: extensionId,
	}
}

// Execute executes the request
func (a *GroupsEventApiService) GroupsEventsDeleteExtensionsExecute(r ApiGroupsEventsDeleteExtensionsRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GroupsEventApiService.GroupsEventsDeleteExtensions")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/groups/{group-id}/events/{event-id}/extensions/{extension-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"extension-id"+"}", _neturl.PathEscape(parameterToString(r.extensionId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ifMatch != nil {
		localVarHeaderParams["If-Match"] = parameterToString(*r.ifMatch, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGroupsEventsDeleteInstancesRequest struct {
	ctx _context.Context
	ApiService *GroupsEventApiService
	groupId string
	eventId string
	eventId1 string
	ifMatch *string
}

// ETag
func (r ApiGroupsEventsDeleteInstancesRequest) IfMatch(ifMatch string) ApiGroupsEventsDeleteInstancesRequest {
	r.ifMatch = &ifMatch
	return r
}

func (r ApiGroupsEventsDeleteInstancesRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.GroupsEventsDeleteInstancesExecute(r)
}

/*
GroupsEventsDeleteInstances Delete navigation property instances for groups

The occurrences of a recurring series, if the event is a series master. This property includes occurrences that are part of the recurrence pattern, and exceptions that have been modified, but does not include occurrences that have been cancelled from the series. Navigation property. Read-only. Nullable.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupId key: id of group
 @param eventId key: id of event
 @param eventId1 key: id of event
 @return ApiGroupsEventsDeleteInstancesRequest
*/
func (a *GroupsEventApiService) GroupsEventsDeleteInstances(ctx _context.Context, groupId string, eventId string, eventId1 string) ApiGroupsEventsDeleteInstancesRequest {
	return ApiGroupsEventsDeleteInstancesRequest{
		ApiService: a,
		ctx: ctx,
		groupId: groupId,
		eventId: eventId,
		eventId1: eventId1,
	}
}

// Execute executes the request
func (a *GroupsEventApiService) GroupsEventsDeleteInstancesExecute(r ApiGroupsEventsDeleteInstancesRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GroupsEventApiService.GroupsEventsDeleteInstances")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/groups/{group-id}/events/{event-id}/instances/{event-id1}"
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id1"+"}", _neturl.PathEscape(parameterToString(r.eventId1, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ifMatch != nil {
		localVarHeaderParams["If-Match"] = parameterToString(*r.ifMatch, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGroupsEventsDeleteMultiValueExtendedPropertiesRequest struct {
	ctx _context.Context
	ApiService *GroupsEventApiService
	groupId string
	eventId string
	multiValueLegacyExtendedPropertyId string
	ifMatch *string
}

// ETag
func (r ApiGroupsEventsDeleteMultiValueExtendedPropertiesRequest) IfMatch(ifMatch string) ApiGroupsEventsDeleteMultiValueExtendedPropertiesRequest {
	r.ifMatch = &ifMatch
	return r
}

func (r ApiGroupsEventsDeleteMultiValueExtendedPropertiesRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.GroupsEventsDeleteMultiValueExtendedPropertiesExecute(r)
}

/*
GroupsEventsDeleteMultiValueExtendedProperties Delete navigation property multiValueExtendedProperties for groups

The collection of multi-value extended properties defined for the event. Read-only. Nullable.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupId key: id of group
 @param eventId key: id of event
 @param multiValueLegacyExtendedPropertyId key: id of multiValueLegacyExtendedProperty
 @return ApiGroupsEventsDeleteMultiValueExtendedPropertiesRequest
*/
func (a *GroupsEventApiService) GroupsEventsDeleteMultiValueExtendedProperties(ctx _context.Context, groupId string, eventId string, multiValueLegacyExtendedPropertyId string) ApiGroupsEventsDeleteMultiValueExtendedPropertiesRequest {
	return ApiGroupsEventsDeleteMultiValueExtendedPropertiesRequest{
		ApiService: a,
		ctx: ctx,
		groupId: groupId,
		eventId: eventId,
		multiValueLegacyExtendedPropertyId: multiValueLegacyExtendedPropertyId,
	}
}

// Execute executes the request
func (a *GroupsEventApiService) GroupsEventsDeleteMultiValueExtendedPropertiesExecute(r ApiGroupsEventsDeleteMultiValueExtendedPropertiesRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GroupsEventApiService.GroupsEventsDeleteMultiValueExtendedProperties")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/groups/{group-id}/events/{event-id}/multiValueExtendedProperties/{multiValueLegacyExtendedProperty-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"multiValueLegacyExtendedProperty-id"+"}", _neturl.PathEscape(parameterToString(r.multiValueLegacyExtendedPropertyId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ifMatch != nil {
		localVarHeaderParams["If-Match"] = parameterToString(*r.ifMatch, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGroupsEventsDeleteSingleValueExtendedPropertiesRequest struct {
	ctx _context.Context
	ApiService *GroupsEventApiService
	groupId string
	eventId string
	singleValueLegacyExtendedPropertyId string
	ifMatch *string
}

// ETag
func (r ApiGroupsEventsDeleteSingleValueExtendedPropertiesRequest) IfMatch(ifMatch string) ApiGroupsEventsDeleteSingleValueExtendedPropertiesRequest {
	r.ifMatch = &ifMatch
	return r
}

func (r ApiGroupsEventsDeleteSingleValueExtendedPropertiesRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.GroupsEventsDeleteSingleValueExtendedPropertiesExecute(r)
}

/*
GroupsEventsDeleteSingleValueExtendedProperties Delete navigation property singleValueExtendedProperties for groups

The collection of single-value extended properties defined for the event. Read-only. Nullable.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupId key: id of group
 @param eventId key: id of event
 @param singleValueLegacyExtendedPropertyId key: id of singleValueLegacyExtendedProperty
 @return ApiGroupsEventsDeleteSingleValueExtendedPropertiesRequest
*/
func (a *GroupsEventApiService) GroupsEventsDeleteSingleValueExtendedProperties(ctx _context.Context, groupId string, eventId string, singleValueLegacyExtendedPropertyId string) ApiGroupsEventsDeleteSingleValueExtendedPropertiesRequest {
	return ApiGroupsEventsDeleteSingleValueExtendedPropertiesRequest{
		ApiService: a,
		ctx: ctx,
		groupId: groupId,
		eventId: eventId,
		singleValueLegacyExtendedPropertyId: singleValueLegacyExtendedPropertyId,
	}
}

// Execute executes the request
func (a *GroupsEventApiService) GroupsEventsDeleteSingleValueExtendedPropertiesExecute(r ApiGroupsEventsDeleteSingleValueExtendedPropertiesRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GroupsEventApiService.GroupsEventsDeleteSingleValueExtendedProperties")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/groups/{group-id}/events/{event-id}/singleValueExtendedProperties/{singleValueLegacyExtendedProperty-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"singleValueLegacyExtendedProperty-id"+"}", _neturl.PathEscape(parameterToString(r.singleValueLegacyExtendedPropertyId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ifMatch != nil {
		localVarHeaderParams["If-Match"] = parameterToString(*r.ifMatch, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGroupsEventsGetAttachmentsRequest struct {
	ctx _context.Context
	ApiService *GroupsEventApiService
	groupId string
	eventId string
	attachmentId string
	select_ *[]string
	expand *[]string
}

// Select properties to be returned
func (r ApiGroupsEventsGetAttachmentsRequest) Select_(select_ []string) ApiGroupsEventsGetAttachmentsRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiGroupsEventsGetAttachmentsRequest) Expand(expand []string) ApiGroupsEventsGetAttachmentsRequest {
	r.expand = &expand
	return r
}

func (r ApiGroupsEventsGetAttachmentsRequest) Execute() (MicrosoftGraphAttachment, *_nethttp.Response, error) {
	return r.ApiService.GroupsEventsGetAttachmentsExecute(r)
}

/*
GroupsEventsGetAttachments Get attachments from groups

The collection of FileAttachment, ItemAttachment, and referenceAttachment attachments for the event. Navigation property. Read-only. Nullable.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupId key: id of group
 @param eventId key: id of event
 @param attachmentId key: id of attachment
 @return ApiGroupsEventsGetAttachmentsRequest
*/
func (a *GroupsEventApiService) GroupsEventsGetAttachments(ctx _context.Context, groupId string, eventId string, attachmentId string) ApiGroupsEventsGetAttachmentsRequest {
	return ApiGroupsEventsGetAttachmentsRequest{
		ApiService: a,
		ctx: ctx,
		groupId: groupId,
		eventId: eventId,
		attachmentId: attachmentId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphAttachment
func (a *GroupsEventApiService) GroupsEventsGetAttachmentsExecute(r ApiGroupsEventsGetAttachmentsRequest) (MicrosoftGraphAttachment, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphAttachment
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GroupsEventApiService.GroupsEventsGetAttachments")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/groups/{group-id}/events/{event-id}/attachments/{attachment-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"attachment-id"+"}", _neturl.PathEscape(parameterToString(r.attachmentId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGroupsEventsGetCalendarRequest struct {
	ctx _context.Context
	ApiService *GroupsEventApiService
	groupId string
	eventId string
	select_ *[]string
}

// Select properties to be returned
func (r ApiGroupsEventsGetCalendarRequest) Select_(select_ []string) ApiGroupsEventsGetCalendarRequest {
	r.select_ = &select_
	return r
}

func (r ApiGroupsEventsGetCalendarRequest) Execute() (MicrosoftGraphCalendar, *_nethttp.Response, error) {
	return r.ApiService.GroupsEventsGetCalendarExecute(r)
}

/*
GroupsEventsGetCalendar Get calendar from groups

The calendar that contains the event. Navigation property. Read-only.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupId key: id of group
 @param eventId key: id of event
 @return ApiGroupsEventsGetCalendarRequest
*/
func (a *GroupsEventApiService) GroupsEventsGetCalendar(ctx _context.Context, groupId string, eventId string) ApiGroupsEventsGetCalendarRequest {
	return ApiGroupsEventsGetCalendarRequest{
		ApiService: a,
		ctx: ctx,
		groupId: groupId,
		eventId: eventId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphCalendar
func (a *GroupsEventApiService) GroupsEventsGetCalendarExecute(r ApiGroupsEventsGetCalendarRequest) (MicrosoftGraphCalendar, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphCalendar
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GroupsEventApiService.GroupsEventsGetCalendar")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/groups/{group-id}/events/{event-id}/calendar"
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGroupsEventsGetExtensionsRequest struct {
	ctx _context.Context
	ApiService *GroupsEventApiService
	groupId string
	eventId string
	extensionId string
	select_ *[]string
	expand *[]string
}

// Select properties to be returned
func (r ApiGroupsEventsGetExtensionsRequest) Select_(select_ []string) ApiGroupsEventsGetExtensionsRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiGroupsEventsGetExtensionsRequest) Expand(expand []string) ApiGroupsEventsGetExtensionsRequest {
	r.expand = &expand
	return r
}

func (r ApiGroupsEventsGetExtensionsRequest) Execute() (MicrosoftGraphExtension, *_nethttp.Response, error) {
	return r.ApiService.GroupsEventsGetExtensionsExecute(r)
}

/*
GroupsEventsGetExtensions Get extensions from groups

The collection of open extensions defined for the event. Nullable.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupId key: id of group
 @param eventId key: id of event
 @param extensionId key: id of extension
 @return ApiGroupsEventsGetExtensionsRequest
*/
func (a *GroupsEventApiService) GroupsEventsGetExtensions(ctx _context.Context, groupId string, eventId string, extensionId string) ApiGroupsEventsGetExtensionsRequest {
	return ApiGroupsEventsGetExtensionsRequest{
		ApiService: a,
		ctx: ctx,
		groupId: groupId,
		eventId: eventId,
		extensionId: extensionId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphExtension
func (a *GroupsEventApiService) GroupsEventsGetExtensionsExecute(r ApiGroupsEventsGetExtensionsRequest) (MicrosoftGraphExtension, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphExtension
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GroupsEventApiService.GroupsEventsGetExtensions")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/groups/{group-id}/events/{event-id}/extensions/{extension-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"extension-id"+"}", _neturl.PathEscape(parameterToString(r.extensionId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGroupsEventsGetInstancesRequest struct {
	ctx _context.Context
	ApiService *GroupsEventApiService
	groupId string
	eventId string
	eventId1 string
	select_ *[]string
}

// Select properties to be returned
func (r ApiGroupsEventsGetInstancesRequest) Select_(select_ []string) ApiGroupsEventsGetInstancesRequest {
	r.select_ = &select_
	return r
}

func (r ApiGroupsEventsGetInstancesRequest) Execute() (MicrosoftGraphEvent, *_nethttp.Response, error) {
	return r.ApiService.GroupsEventsGetInstancesExecute(r)
}

/*
GroupsEventsGetInstances Get instances from groups

The occurrences of a recurring series, if the event is a series master. This property includes occurrences that are part of the recurrence pattern, and exceptions that have been modified, but does not include occurrences that have been cancelled from the series. Navigation property. Read-only. Nullable.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupId key: id of group
 @param eventId key: id of event
 @param eventId1 key: id of event
 @return ApiGroupsEventsGetInstancesRequest
*/
func (a *GroupsEventApiService) GroupsEventsGetInstances(ctx _context.Context, groupId string, eventId string, eventId1 string) ApiGroupsEventsGetInstancesRequest {
	return ApiGroupsEventsGetInstancesRequest{
		ApiService: a,
		ctx: ctx,
		groupId: groupId,
		eventId: eventId,
		eventId1: eventId1,
	}
}

// Execute executes the request
//  @return MicrosoftGraphEvent
func (a *GroupsEventApiService) GroupsEventsGetInstancesExecute(r ApiGroupsEventsGetInstancesRequest) (MicrosoftGraphEvent, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphEvent
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GroupsEventApiService.GroupsEventsGetInstances")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/groups/{group-id}/events/{event-id}/instances/{event-id1}"
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id1"+"}", _neturl.PathEscape(parameterToString(r.eventId1, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGroupsEventsGetMultiValueExtendedPropertiesRequest struct {
	ctx _context.Context
	ApiService *GroupsEventApiService
	groupId string
	eventId string
	multiValueLegacyExtendedPropertyId string
	select_ *[]string
	expand *[]string
}

// Select properties to be returned
func (r ApiGroupsEventsGetMultiValueExtendedPropertiesRequest) Select_(select_ []string) ApiGroupsEventsGetMultiValueExtendedPropertiesRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiGroupsEventsGetMultiValueExtendedPropertiesRequest) Expand(expand []string) ApiGroupsEventsGetMultiValueExtendedPropertiesRequest {
	r.expand = &expand
	return r
}

func (r ApiGroupsEventsGetMultiValueExtendedPropertiesRequest) Execute() (MicrosoftGraphMultiValueLegacyExtendedProperty, *_nethttp.Response, error) {
	return r.ApiService.GroupsEventsGetMultiValueExtendedPropertiesExecute(r)
}

/*
GroupsEventsGetMultiValueExtendedProperties Get multiValueExtendedProperties from groups

The collection of multi-value extended properties defined for the event. Read-only. Nullable.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupId key: id of group
 @param eventId key: id of event
 @param multiValueLegacyExtendedPropertyId key: id of multiValueLegacyExtendedProperty
 @return ApiGroupsEventsGetMultiValueExtendedPropertiesRequest
*/
func (a *GroupsEventApiService) GroupsEventsGetMultiValueExtendedProperties(ctx _context.Context, groupId string, eventId string, multiValueLegacyExtendedPropertyId string) ApiGroupsEventsGetMultiValueExtendedPropertiesRequest {
	return ApiGroupsEventsGetMultiValueExtendedPropertiesRequest{
		ApiService: a,
		ctx: ctx,
		groupId: groupId,
		eventId: eventId,
		multiValueLegacyExtendedPropertyId: multiValueLegacyExtendedPropertyId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphMultiValueLegacyExtendedProperty
func (a *GroupsEventApiService) GroupsEventsGetMultiValueExtendedPropertiesExecute(r ApiGroupsEventsGetMultiValueExtendedPropertiesRequest) (MicrosoftGraphMultiValueLegacyExtendedProperty, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphMultiValueLegacyExtendedProperty
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GroupsEventApiService.GroupsEventsGetMultiValueExtendedProperties")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/groups/{group-id}/events/{event-id}/multiValueExtendedProperties/{multiValueLegacyExtendedProperty-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"multiValueLegacyExtendedProperty-id"+"}", _neturl.PathEscape(parameterToString(r.multiValueLegacyExtendedPropertyId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGroupsEventsGetSingleValueExtendedPropertiesRequest struct {
	ctx _context.Context
	ApiService *GroupsEventApiService
	groupId string
	eventId string
	singleValueLegacyExtendedPropertyId string
	select_ *[]string
	expand *[]string
}

// Select properties to be returned
func (r ApiGroupsEventsGetSingleValueExtendedPropertiesRequest) Select_(select_ []string) ApiGroupsEventsGetSingleValueExtendedPropertiesRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiGroupsEventsGetSingleValueExtendedPropertiesRequest) Expand(expand []string) ApiGroupsEventsGetSingleValueExtendedPropertiesRequest {
	r.expand = &expand
	return r
}

func (r ApiGroupsEventsGetSingleValueExtendedPropertiesRequest) Execute() (MicrosoftGraphSingleValueLegacyExtendedProperty, *_nethttp.Response, error) {
	return r.ApiService.GroupsEventsGetSingleValueExtendedPropertiesExecute(r)
}

/*
GroupsEventsGetSingleValueExtendedProperties Get singleValueExtendedProperties from groups

The collection of single-value extended properties defined for the event. Read-only. Nullable.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupId key: id of group
 @param eventId key: id of event
 @param singleValueLegacyExtendedPropertyId key: id of singleValueLegacyExtendedProperty
 @return ApiGroupsEventsGetSingleValueExtendedPropertiesRequest
*/
func (a *GroupsEventApiService) GroupsEventsGetSingleValueExtendedProperties(ctx _context.Context, groupId string, eventId string, singleValueLegacyExtendedPropertyId string) ApiGroupsEventsGetSingleValueExtendedPropertiesRequest {
	return ApiGroupsEventsGetSingleValueExtendedPropertiesRequest{
		ApiService: a,
		ctx: ctx,
		groupId: groupId,
		eventId: eventId,
		singleValueLegacyExtendedPropertyId: singleValueLegacyExtendedPropertyId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphSingleValueLegacyExtendedProperty
func (a *GroupsEventApiService) GroupsEventsGetSingleValueExtendedPropertiesExecute(r ApiGroupsEventsGetSingleValueExtendedPropertiesRequest) (MicrosoftGraphSingleValueLegacyExtendedProperty, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphSingleValueLegacyExtendedProperty
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GroupsEventApiService.GroupsEventsGetSingleValueExtendedProperties")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/groups/{group-id}/events/{event-id}/singleValueExtendedProperties/{singleValueLegacyExtendedProperty-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"singleValueLegacyExtendedProperty-id"+"}", _neturl.PathEscape(parameterToString(r.singleValueLegacyExtendedPropertyId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGroupsEventsListAttachmentsRequest struct {
	ctx _context.Context
	ApiService *GroupsEventApiService
	groupId string
	eventId string
	top *int32
	skip *int32
	filter *string
	count *bool
	orderby *[]string
	select_ *[]string
	expand *[]string
}

// Show only the first n items
func (r ApiGroupsEventsListAttachmentsRequest) Top(top int32) ApiGroupsEventsListAttachmentsRequest {
	r.top = &top
	return r
}
// Skip the first n items
func (r ApiGroupsEventsListAttachmentsRequest) Skip(skip int32) ApiGroupsEventsListAttachmentsRequest {
	r.skip = &skip
	return r
}
// Filter items by property values
func (r ApiGroupsEventsListAttachmentsRequest) Filter(filter string) ApiGroupsEventsListAttachmentsRequest {
	r.filter = &filter
	return r
}
// Include count of items
func (r ApiGroupsEventsListAttachmentsRequest) Count(count bool) ApiGroupsEventsListAttachmentsRequest {
	r.count = &count
	return r
}
// Order items by property values
func (r ApiGroupsEventsListAttachmentsRequest) Orderby(orderby []string) ApiGroupsEventsListAttachmentsRequest {
	r.orderby = &orderby
	return r
}
// Select properties to be returned
func (r ApiGroupsEventsListAttachmentsRequest) Select_(select_ []string) ApiGroupsEventsListAttachmentsRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiGroupsEventsListAttachmentsRequest) Expand(expand []string) ApiGroupsEventsListAttachmentsRequest {
	r.expand = &expand
	return r
}

func (r ApiGroupsEventsListAttachmentsRequest) Execute() (CollectionOfAttachment, *_nethttp.Response, error) {
	return r.ApiService.GroupsEventsListAttachmentsExecute(r)
}

/*
GroupsEventsListAttachments Get attachments from groups

The collection of FileAttachment, ItemAttachment, and referenceAttachment attachments for the event. Navigation property. Read-only. Nullable.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupId key: id of group
 @param eventId key: id of event
 @return ApiGroupsEventsListAttachmentsRequest
*/
func (a *GroupsEventApiService) GroupsEventsListAttachments(ctx _context.Context, groupId string, eventId string) ApiGroupsEventsListAttachmentsRequest {
	return ApiGroupsEventsListAttachmentsRequest{
		ApiService: a,
		ctx: ctx,
		groupId: groupId,
		eventId: eventId,
	}
}

// Execute executes the request
//  @return CollectionOfAttachment
func (a *GroupsEventApiService) GroupsEventsListAttachmentsExecute(r ApiGroupsEventsListAttachmentsRequest) (CollectionOfAttachment, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  CollectionOfAttachment
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GroupsEventApiService.GroupsEventsListAttachments")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/groups/{group-id}/events/{event-id}/attachments"
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.top != nil {
		localVarQueryParams.Add("$top", parameterToString(*r.top, ""))
	}
	if r.skip != nil {
		localVarQueryParams.Add("$skip", parameterToString(*r.skip, ""))
	}
	if r.filter != nil {
		localVarQueryParams.Add("$filter", parameterToString(*r.filter, ""))
	}
	if r.count != nil {
		localVarQueryParams.Add("$count", parameterToString(*r.count, ""))
	}
	if r.orderby != nil {
		localVarQueryParams.Add("$orderby", parameterToString(*r.orderby, "csv"))
	}
	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGroupsEventsListExtensionsRequest struct {
	ctx _context.Context
	ApiService *GroupsEventApiService
	groupId string
	eventId string
	top *int32
	skip *int32
	filter *string
	count *bool
	orderby *[]string
	select_ *[]string
	expand *[]string
}

// Show only the first n items
func (r ApiGroupsEventsListExtensionsRequest) Top(top int32) ApiGroupsEventsListExtensionsRequest {
	r.top = &top
	return r
}
// Skip the first n items
func (r ApiGroupsEventsListExtensionsRequest) Skip(skip int32) ApiGroupsEventsListExtensionsRequest {
	r.skip = &skip
	return r
}
// Filter items by property values
func (r ApiGroupsEventsListExtensionsRequest) Filter(filter string) ApiGroupsEventsListExtensionsRequest {
	r.filter = &filter
	return r
}
// Include count of items
func (r ApiGroupsEventsListExtensionsRequest) Count(count bool) ApiGroupsEventsListExtensionsRequest {
	r.count = &count
	return r
}
// Order items by property values
func (r ApiGroupsEventsListExtensionsRequest) Orderby(orderby []string) ApiGroupsEventsListExtensionsRequest {
	r.orderby = &orderby
	return r
}
// Select properties to be returned
func (r ApiGroupsEventsListExtensionsRequest) Select_(select_ []string) ApiGroupsEventsListExtensionsRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiGroupsEventsListExtensionsRequest) Expand(expand []string) ApiGroupsEventsListExtensionsRequest {
	r.expand = &expand
	return r
}

func (r ApiGroupsEventsListExtensionsRequest) Execute() (CollectionOfExtension, *_nethttp.Response, error) {
	return r.ApiService.GroupsEventsListExtensionsExecute(r)
}

/*
GroupsEventsListExtensions Get extensions from groups

The collection of open extensions defined for the event. Nullable.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupId key: id of group
 @param eventId key: id of event
 @return ApiGroupsEventsListExtensionsRequest
*/
func (a *GroupsEventApiService) GroupsEventsListExtensions(ctx _context.Context, groupId string, eventId string) ApiGroupsEventsListExtensionsRequest {
	return ApiGroupsEventsListExtensionsRequest{
		ApiService: a,
		ctx: ctx,
		groupId: groupId,
		eventId: eventId,
	}
}

// Execute executes the request
//  @return CollectionOfExtension
func (a *GroupsEventApiService) GroupsEventsListExtensionsExecute(r ApiGroupsEventsListExtensionsRequest) (CollectionOfExtension, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  CollectionOfExtension
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GroupsEventApiService.GroupsEventsListExtensions")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/groups/{group-id}/events/{event-id}/extensions"
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.top != nil {
		localVarQueryParams.Add("$top", parameterToString(*r.top, ""))
	}
	if r.skip != nil {
		localVarQueryParams.Add("$skip", parameterToString(*r.skip, ""))
	}
	if r.filter != nil {
		localVarQueryParams.Add("$filter", parameterToString(*r.filter, ""))
	}
	if r.count != nil {
		localVarQueryParams.Add("$count", parameterToString(*r.count, ""))
	}
	if r.orderby != nil {
		localVarQueryParams.Add("$orderby", parameterToString(*r.orderby, "csv"))
	}
	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGroupsEventsListInstancesRequest struct {
	ctx _context.Context
	ApiService *GroupsEventApiService
	groupId string
	eventId string
	top *int32
	skip *int32
	filter *string
	count *bool
	orderby *[]string
	select_ *[]string
}

// Show only the first n items
func (r ApiGroupsEventsListInstancesRequest) Top(top int32) ApiGroupsEventsListInstancesRequest {
	r.top = &top
	return r
}
// Skip the first n items
func (r ApiGroupsEventsListInstancesRequest) Skip(skip int32) ApiGroupsEventsListInstancesRequest {
	r.skip = &skip
	return r
}
// Filter items by property values
func (r ApiGroupsEventsListInstancesRequest) Filter(filter string) ApiGroupsEventsListInstancesRequest {
	r.filter = &filter
	return r
}
// Include count of items
func (r ApiGroupsEventsListInstancesRequest) Count(count bool) ApiGroupsEventsListInstancesRequest {
	r.count = &count
	return r
}
// Order items by property values
func (r ApiGroupsEventsListInstancesRequest) Orderby(orderby []string) ApiGroupsEventsListInstancesRequest {
	r.orderby = &orderby
	return r
}
// Select properties to be returned
func (r ApiGroupsEventsListInstancesRequest) Select_(select_ []string) ApiGroupsEventsListInstancesRequest {
	r.select_ = &select_
	return r
}

func (r ApiGroupsEventsListInstancesRequest) Execute() (CollectionOfEvent, *_nethttp.Response, error) {
	return r.ApiService.GroupsEventsListInstancesExecute(r)
}

/*
GroupsEventsListInstances Get instances from groups

The occurrences of a recurring series, if the event is a series master. This property includes occurrences that are part of the recurrence pattern, and exceptions that have been modified, but does not include occurrences that have been cancelled from the series. Navigation property. Read-only. Nullable.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupId key: id of group
 @param eventId key: id of event
 @return ApiGroupsEventsListInstancesRequest
*/
func (a *GroupsEventApiService) GroupsEventsListInstances(ctx _context.Context, groupId string, eventId string) ApiGroupsEventsListInstancesRequest {
	return ApiGroupsEventsListInstancesRequest{
		ApiService: a,
		ctx: ctx,
		groupId: groupId,
		eventId: eventId,
	}
}

// Execute executes the request
//  @return CollectionOfEvent
func (a *GroupsEventApiService) GroupsEventsListInstancesExecute(r ApiGroupsEventsListInstancesRequest) (CollectionOfEvent, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  CollectionOfEvent
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GroupsEventApiService.GroupsEventsListInstances")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/groups/{group-id}/events/{event-id}/instances"
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.top != nil {
		localVarQueryParams.Add("$top", parameterToString(*r.top, ""))
	}
	if r.skip != nil {
		localVarQueryParams.Add("$skip", parameterToString(*r.skip, ""))
	}
	if r.filter != nil {
		localVarQueryParams.Add("$filter", parameterToString(*r.filter, ""))
	}
	if r.count != nil {
		localVarQueryParams.Add("$count", parameterToString(*r.count, ""))
	}
	if r.orderby != nil {
		localVarQueryParams.Add("$orderby", parameterToString(*r.orderby, "csv"))
	}
	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGroupsEventsListMultiValueExtendedPropertiesRequest struct {
	ctx _context.Context
	ApiService *GroupsEventApiService
	groupId string
	eventId string
	top *int32
	skip *int32
	search *string
	filter *string
	count *bool
	orderby *[]string
	select_ *[]string
	expand *[]string
}

// Show only the first n items
func (r ApiGroupsEventsListMultiValueExtendedPropertiesRequest) Top(top int32) ApiGroupsEventsListMultiValueExtendedPropertiesRequest {
	r.top = &top
	return r
}
// Skip the first n items
func (r ApiGroupsEventsListMultiValueExtendedPropertiesRequest) Skip(skip int32) ApiGroupsEventsListMultiValueExtendedPropertiesRequest {
	r.skip = &skip
	return r
}
// Search items by search phrases
func (r ApiGroupsEventsListMultiValueExtendedPropertiesRequest) Search(search string) ApiGroupsEventsListMultiValueExtendedPropertiesRequest {
	r.search = &search
	return r
}
// Filter items by property values
func (r ApiGroupsEventsListMultiValueExtendedPropertiesRequest) Filter(filter string) ApiGroupsEventsListMultiValueExtendedPropertiesRequest {
	r.filter = &filter
	return r
}
// Include count of items
func (r ApiGroupsEventsListMultiValueExtendedPropertiesRequest) Count(count bool) ApiGroupsEventsListMultiValueExtendedPropertiesRequest {
	r.count = &count
	return r
}
// Order items by property values
func (r ApiGroupsEventsListMultiValueExtendedPropertiesRequest) Orderby(orderby []string) ApiGroupsEventsListMultiValueExtendedPropertiesRequest {
	r.orderby = &orderby
	return r
}
// Select properties to be returned
func (r ApiGroupsEventsListMultiValueExtendedPropertiesRequest) Select_(select_ []string) ApiGroupsEventsListMultiValueExtendedPropertiesRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiGroupsEventsListMultiValueExtendedPropertiesRequest) Expand(expand []string) ApiGroupsEventsListMultiValueExtendedPropertiesRequest {
	r.expand = &expand
	return r
}

func (r ApiGroupsEventsListMultiValueExtendedPropertiesRequest) Execute() (CollectionOfMultiValueLegacyExtendedProperty, *_nethttp.Response, error) {
	return r.ApiService.GroupsEventsListMultiValueExtendedPropertiesExecute(r)
}

/*
GroupsEventsListMultiValueExtendedProperties Get multiValueExtendedProperties from groups

The collection of multi-value extended properties defined for the event. Read-only. Nullable.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupId key: id of group
 @param eventId key: id of event
 @return ApiGroupsEventsListMultiValueExtendedPropertiesRequest
*/
func (a *GroupsEventApiService) GroupsEventsListMultiValueExtendedProperties(ctx _context.Context, groupId string, eventId string) ApiGroupsEventsListMultiValueExtendedPropertiesRequest {
	return ApiGroupsEventsListMultiValueExtendedPropertiesRequest{
		ApiService: a,
		ctx: ctx,
		groupId: groupId,
		eventId: eventId,
	}
}

// Execute executes the request
//  @return CollectionOfMultiValueLegacyExtendedProperty
func (a *GroupsEventApiService) GroupsEventsListMultiValueExtendedPropertiesExecute(r ApiGroupsEventsListMultiValueExtendedPropertiesRequest) (CollectionOfMultiValueLegacyExtendedProperty, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  CollectionOfMultiValueLegacyExtendedProperty
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GroupsEventApiService.GroupsEventsListMultiValueExtendedProperties")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/groups/{group-id}/events/{event-id}/multiValueExtendedProperties"
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.top != nil {
		localVarQueryParams.Add("$top", parameterToString(*r.top, ""))
	}
	if r.skip != nil {
		localVarQueryParams.Add("$skip", parameterToString(*r.skip, ""))
	}
	if r.search != nil {
		localVarQueryParams.Add("$search", parameterToString(*r.search, ""))
	}
	if r.filter != nil {
		localVarQueryParams.Add("$filter", parameterToString(*r.filter, ""))
	}
	if r.count != nil {
		localVarQueryParams.Add("$count", parameterToString(*r.count, ""))
	}
	if r.orderby != nil {
		localVarQueryParams.Add("$orderby", parameterToString(*r.orderby, "csv"))
	}
	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGroupsEventsListSingleValueExtendedPropertiesRequest struct {
	ctx _context.Context
	ApiService *GroupsEventApiService
	groupId string
	eventId string
	top *int32
	skip *int32
	search *string
	filter *string
	count *bool
	orderby *[]string
	select_ *[]string
	expand *[]string
}

// Show only the first n items
func (r ApiGroupsEventsListSingleValueExtendedPropertiesRequest) Top(top int32) ApiGroupsEventsListSingleValueExtendedPropertiesRequest {
	r.top = &top
	return r
}
// Skip the first n items
func (r ApiGroupsEventsListSingleValueExtendedPropertiesRequest) Skip(skip int32) ApiGroupsEventsListSingleValueExtendedPropertiesRequest {
	r.skip = &skip
	return r
}
// Search items by search phrases
func (r ApiGroupsEventsListSingleValueExtendedPropertiesRequest) Search(search string) ApiGroupsEventsListSingleValueExtendedPropertiesRequest {
	r.search = &search
	return r
}
// Filter items by property values
func (r ApiGroupsEventsListSingleValueExtendedPropertiesRequest) Filter(filter string) ApiGroupsEventsListSingleValueExtendedPropertiesRequest {
	r.filter = &filter
	return r
}
// Include count of items
func (r ApiGroupsEventsListSingleValueExtendedPropertiesRequest) Count(count bool) ApiGroupsEventsListSingleValueExtendedPropertiesRequest {
	r.count = &count
	return r
}
// Order items by property values
func (r ApiGroupsEventsListSingleValueExtendedPropertiesRequest) Orderby(orderby []string) ApiGroupsEventsListSingleValueExtendedPropertiesRequest {
	r.orderby = &orderby
	return r
}
// Select properties to be returned
func (r ApiGroupsEventsListSingleValueExtendedPropertiesRequest) Select_(select_ []string) ApiGroupsEventsListSingleValueExtendedPropertiesRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiGroupsEventsListSingleValueExtendedPropertiesRequest) Expand(expand []string) ApiGroupsEventsListSingleValueExtendedPropertiesRequest {
	r.expand = &expand
	return r
}

func (r ApiGroupsEventsListSingleValueExtendedPropertiesRequest) Execute() (CollectionOfSingleValueLegacyExtendedProperty, *_nethttp.Response, error) {
	return r.ApiService.GroupsEventsListSingleValueExtendedPropertiesExecute(r)
}

/*
GroupsEventsListSingleValueExtendedProperties Get singleValueExtendedProperties from groups

The collection of single-value extended properties defined for the event. Read-only. Nullable.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupId key: id of group
 @param eventId key: id of event
 @return ApiGroupsEventsListSingleValueExtendedPropertiesRequest
*/
func (a *GroupsEventApiService) GroupsEventsListSingleValueExtendedProperties(ctx _context.Context, groupId string, eventId string) ApiGroupsEventsListSingleValueExtendedPropertiesRequest {
	return ApiGroupsEventsListSingleValueExtendedPropertiesRequest{
		ApiService: a,
		ctx: ctx,
		groupId: groupId,
		eventId: eventId,
	}
}

// Execute executes the request
//  @return CollectionOfSingleValueLegacyExtendedProperty
func (a *GroupsEventApiService) GroupsEventsListSingleValueExtendedPropertiesExecute(r ApiGroupsEventsListSingleValueExtendedPropertiesRequest) (CollectionOfSingleValueLegacyExtendedProperty, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  CollectionOfSingleValueLegacyExtendedProperty
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GroupsEventApiService.GroupsEventsListSingleValueExtendedProperties")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/groups/{group-id}/events/{event-id}/singleValueExtendedProperties"
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.top != nil {
		localVarQueryParams.Add("$top", parameterToString(*r.top, ""))
	}
	if r.skip != nil {
		localVarQueryParams.Add("$skip", parameterToString(*r.skip, ""))
	}
	if r.search != nil {
		localVarQueryParams.Add("$search", parameterToString(*r.search, ""))
	}
	if r.filter != nil {
		localVarQueryParams.Add("$filter", parameterToString(*r.filter, ""))
	}
	if r.count != nil {
		localVarQueryParams.Add("$count", parameterToString(*r.count, ""))
	}
	if r.orderby != nil {
		localVarQueryParams.Add("$orderby", parameterToString(*r.orderby, "csv"))
	}
	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGroupsEventsUpdateAttachmentsRequest struct {
	ctx _context.Context
	ApiService *GroupsEventApiService
	groupId string
	eventId string
	attachmentId string
	microsoftGraphAttachment *MicrosoftGraphAttachment
}

// New navigation property values
func (r ApiGroupsEventsUpdateAttachmentsRequest) MicrosoftGraphAttachment(microsoftGraphAttachment MicrosoftGraphAttachment) ApiGroupsEventsUpdateAttachmentsRequest {
	r.microsoftGraphAttachment = &microsoftGraphAttachment
	return r
}

func (r ApiGroupsEventsUpdateAttachmentsRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.GroupsEventsUpdateAttachmentsExecute(r)
}

/*
GroupsEventsUpdateAttachments Update the navigation property attachments in groups

The collection of FileAttachment, ItemAttachment, and referenceAttachment attachments for the event. Navigation property. Read-only. Nullable.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupId key: id of group
 @param eventId key: id of event
 @param attachmentId key: id of attachment
 @return ApiGroupsEventsUpdateAttachmentsRequest
*/
func (a *GroupsEventApiService) GroupsEventsUpdateAttachments(ctx _context.Context, groupId string, eventId string, attachmentId string) ApiGroupsEventsUpdateAttachmentsRequest {
	return ApiGroupsEventsUpdateAttachmentsRequest{
		ApiService: a,
		ctx: ctx,
		groupId: groupId,
		eventId: eventId,
		attachmentId: attachmentId,
	}
}

// Execute executes the request
func (a *GroupsEventApiService) GroupsEventsUpdateAttachmentsExecute(r ApiGroupsEventsUpdateAttachmentsRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPatch
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GroupsEventApiService.GroupsEventsUpdateAttachments")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/groups/{group-id}/events/{event-id}/attachments/{attachment-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"attachment-id"+"}", _neturl.PathEscape(parameterToString(r.attachmentId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphAttachment == nil {
		return nil, reportError("microsoftGraphAttachment is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphAttachment
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGroupsEventsUpdateCalendarRequest struct {
	ctx _context.Context
	ApiService *GroupsEventApiService
	groupId string
	eventId string
	microsoftGraphCalendar *MicrosoftGraphCalendar
}

// New navigation property values
func (r ApiGroupsEventsUpdateCalendarRequest) MicrosoftGraphCalendar(microsoftGraphCalendar MicrosoftGraphCalendar) ApiGroupsEventsUpdateCalendarRequest {
	r.microsoftGraphCalendar = &microsoftGraphCalendar
	return r
}

func (r ApiGroupsEventsUpdateCalendarRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.GroupsEventsUpdateCalendarExecute(r)
}

/*
GroupsEventsUpdateCalendar Update the navigation property calendar in groups

The calendar that contains the event. Navigation property. Read-only.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupId key: id of group
 @param eventId key: id of event
 @return ApiGroupsEventsUpdateCalendarRequest
*/
func (a *GroupsEventApiService) GroupsEventsUpdateCalendar(ctx _context.Context, groupId string, eventId string) ApiGroupsEventsUpdateCalendarRequest {
	return ApiGroupsEventsUpdateCalendarRequest{
		ApiService: a,
		ctx: ctx,
		groupId: groupId,
		eventId: eventId,
	}
}

// Execute executes the request
func (a *GroupsEventApiService) GroupsEventsUpdateCalendarExecute(r ApiGroupsEventsUpdateCalendarRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPatch
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GroupsEventApiService.GroupsEventsUpdateCalendar")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/groups/{group-id}/events/{event-id}/calendar"
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphCalendar == nil {
		return nil, reportError("microsoftGraphCalendar is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphCalendar
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGroupsEventsUpdateExtensionsRequest struct {
	ctx _context.Context
	ApiService *GroupsEventApiService
	groupId string
	eventId string
	extensionId string
	microsoftGraphExtension *MicrosoftGraphExtension
}

// New navigation property values
func (r ApiGroupsEventsUpdateExtensionsRequest) MicrosoftGraphExtension(microsoftGraphExtension MicrosoftGraphExtension) ApiGroupsEventsUpdateExtensionsRequest {
	r.microsoftGraphExtension = &microsoftGraphExtension
	return r
}

func (r ApiGroupsEventsUpdateExtensionsRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.GroupsEventsUpdateExtensionsExecute(r)
}

/*
GroupsEventsUpdateExtensions Update the navigation property extensions in groups

The collection of open extensions defined for the event. Nullable.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupId key: id of group
 @param eventId key: id of event
 @param extensionId key: id of extension
 @return ApiGroupsEventsUpdateExtensionsRequest
*/
func (a *GroupsEventApiService) GroupsEventsUpdateExtensions(ctx _context.Context, groupId string, eventId string, extensionId string) ApiGroupsEventsUpdateExtensionsRequest {
	return ApiGroupsEventsUpdateExtensionsRequest{
		ApiService: a,
		ctx: ctx,
		groupId: groupId,
		eventId: eventId,
		extensionId: extensionId,
	}
}

// Execute executes the request
func (a *GroupsEventApiService) GroupsEventsUpdateExtensionsExecute(r ApiGroupsEventsUpdateExtensionsRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPatch
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GroupsEventApiService.GroupsEventsUpdateExtensions")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/groups/{group-id}/events/{event-id}/extensions/{extension-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"extension-id"+"}", _neturl.PathEscape(parameterToString(r.extensionId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphExtension == nil {
		return nil, reportError("microsoftGraphExtension is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphExtension
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGroupsEventsUpdateInstancesRequest struct {
	ctx _context.Context
	ApiService *GroupsEventApiService
	groupId string
	eventId string
	eventId1 string
	microsoftGraphEvent *MicrosoftGraphEvent
}

// New navigation property values
func (r ApiGroupsEventsUpdateInstancesRequest) MicrosoftGraphEvent(microsoftGraphEvent MicrosoftGraphEvent) ApiGroupsEventsUpdateInstancesRequest {
	r.microsoftGraphEvent = &microsoftGraphEvent
	return r
}

func (r ApiGroupsEventsUpdateInstancesRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.GroupsEventsUpdateInstancesExecute(r)
}

/*
GroupsEventsUpdateInstances Update the navigation property instances in groups

The occurrences of a recurring series, if the event is a series master. This property includes occurrences that are part of the recurrence pattern, and exceptions that have been modified, but does not include occurrences that have been cancelled from the series. Navigation property. Read-only. Nullable.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupId key: id of group
 @param eventId key: id of event
 @param eventId1 key: id of event
 @return ApiGroupsEventsUpdateInstancesRequest
*/
func (a *GroupsEventApiService) GroupsEventsUpdateInstances(ctx _context.Context, groupId string, eventId string, eventId1 string) ApiGroupsEventsUpdateInstancesRequest {
	return ApiGroupsEventsUpdateInstancesRequest{
		ApiService: a,
		ctx: ctx,
		groupId: groupId,
		eventId: eventId,
		eventId1: eventId1,
	}
}

// Execute executes the request
func (a *GroupsEventApiService) GroupsEventsUpdateInstancesExecute(r ApiGroupsEventsUpdateInstancesRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPatch
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GroupsEventApiService.GroupsEventsUpdateInstances")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/groups/{group-id}/events/{event-id}/instances/{event-id1}"
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id1"+"}", _neturl.PathEscape(parameterToString(r.eventId1, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphEvent == nil {
		return nil, reportError("microsoftGraphEvent is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphEvent
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGroupsEventsUpdateMultiValueExtendedPropertiesRequest struct {
	ctx _context.Context
	ApiService *GroupsEventApiService
	groupId string
	eventId string
	multiValueLegacyExtendedPropertyId string
	microsoftGraphMultiValueLegacyExtendedProperty *MicrosoftGraphMultiValueLegacyExtendedProperty
}

// New navigation property values
func (r ApiGroupsEventsUpdateMultiValueExtendedPropertiesRequest) MicrosoftGraphMultiValueLegacyExtendedProperty(microsoftGraphMultiValueLegacyExtendedProperty MicrosoftGraphMultiValueLegacyExtendedProperty) ApiGroupsEventsUpdateMultiValueExtendedPropertiesRequest {
	r.microsoftGraphMultiValueLegacyExtendedProperty = &microsoftGraphMultiValueLegacyExtendedProperty
	return r
}

func (r ApiGroupsEventsUpdateMultiValueExtendedPropertiesRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.GroupsEventsUpdateMultiValueExtendedPropertiesExecute(r)
}

/*
GroupsEventsUpdateMultiValueExtendedProperties Update the navigation property multiValueExtendedProperties in groups

The collection of multi-value extended properties defined for the event. Read-only. Nullable.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupId key: id of group
 @param eventId key: id of event
 @param multiValueLegacyExtendedPropertyId key: id of multiValueLegacyExtendedProperty
 @return ApiGroupsEventsUpdateMultiValueExtendedPropertiesRequest
*/
func (a *GroupsEventApiService) GroupsEventsUpdateMultiValueExtendedProperties(ctx _context.Context, groupId string, eventId string, multiValueLegacyExtendedPropertyId string) ApiGroupsEventsUpdateMultiValueExtendedPropertiesRequest {
	return ApiGroupsEventsUpdateMultiValueExtendedPropertiesRequest{
		ApiService: a,
		ctx: ctx,
		groupId: groupId,
		eventId: eventId,
		multiValueLegacyExtendedPropertyId: multiValueLegacyExtendedPropertyId,
	}
}

// Execute executes the request
func (a *GroupsEventApiService) GroupsEventsUpdateMultiValueExtendedPropertiesExecute(r ApiGroupsEventsUpdateMultiValueExtendedPropertiesRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPatch
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GroupsEventApiService.GroupsEventsUpdateMultiValueExtendedProperties")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/groups/{group-id}/events/{event-id}/multiValueExtendedProperties/{multiValueLegacyExtendedProperty-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"multiValueLegacyExtendedProperty-id"+"}", _neturl.PathEscape(parameterToString(r.multiValueLegacyExtendedPropertyId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphMultiValueLegacyExtendedProperty == nil {
		return nil, reportError("microsoftGraphMultiValueLegacyExtendedProperty is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphMultiValueLegacyExtendedProperty
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGroupsEventsUpdateSingleValueExtendedPropertiesRequest struct {
	ctx _context.Context
	ApiService *GroupsEventApiService
	groupId string
	eventId string
	singleValueLegacyExtendedPropertyId string
	microsoftGraphSingleValueLegacyExtendedProperty *MicrosoftGraphSingleValueLegacyExtendedProperty
}

// New navigation property values
func (r ApiGroupsEventsUpdateSingleValueExtendedPropertiesRequest) MicrosoftGraphSingleValueLegacyExtendedProperty(microsoftGraphSingleValueLegacyExtendedProperty MicrosoftGraphSingleValueLegacyExtendedProperty) ApiGroupsEventsUpdateSingleValueExtendedPropertiesRequest {
	r.microsoftGraphSingleValueLegacyExtendedProperty = &microsoftGraphSingleValueLegacyExtendedProperty
	return r
}

func (r ApiGroupsEventsUpdateSingleValueExtendedPropertiesRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.GroupsEventsUpdateSingleValueExtendedPropertiesExecute(r)
}

/*
GroupsEventsUpdateSingleValueExtendedProperties Update the navigation property singleValueExtendedProperties in groups

The collection of single-value extended properties defined for the event. Read-only. Nullable.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupId key: id of group
 @param eventId key: id of event
 @param singleValueLegacyExtendedPropertyId key: id of singleValueLegacyExtendedProperty
 @return ApiGroupsEventsUpdateSingleValueExtendedPropertiesRequest
*/
func (a *GroupsEventApiService) GroupsEventsUpdateSingleValueExtendedProperties(ctx _context.Context, groupId string, eventId string, singleValueLegacyExtendedPropertyId string) ApiGroupsEventsUpdateSingleValueExtendedPropertiesRequest {
	return ApiGroupsEventsUpdateSingleValueExtendedPropertiesRequest{
		ApiService: a,
		ctx: ctx,
		groupId: groupId,
		eventId: eventId,
		singleValueLegacyExtendedPropertyId: singleValueLegacyExtendedPropertyId,
	}
}

// Execute executes the request
func (a *GroupsEventApiService) GroupsEventsUpdateSingleValueExtendedPropertiesExecute(r ApiGroupsEventsUpdateSingleValueExtendedPropertiesRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPatch
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GroupsEventApiService.GroupsEventsUpdateSingleValueExtendedProperties")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/groups/{group-id}/events/{event-id}/singleValueExtendedProperties/{singleValueLegacyExtendedProperty-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"singleValueLegacyExtendedProperty-id"+"}", _neturl.PathEscape(parameterToString(r.singleValueLegacyExtendedPropertyId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphSingleValueLegacyExtendedProperty == nil {
		return nil, reportError("microsoftGraphSingleValueLegacyExtendedProperty is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphSingleValueLegacyExtendedProperty
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGroupsGetCalendarViewRequest struct {
	ctx _context.Context
	ApiService *GroupsEventApiService
	groupId string
	eventId string
	startDateTime *string
	endDateTime *string
	select_ *[]string
}

// The start date and time of the time range, represented in ISO 8601 format. For example, 2019-11-08T19:00:00-08:00
func (r ApiGroupsGetCalendarViewRequest) StartDateTime(startDateTime string) ApiGroupsGetCalendarViewRequest {
	r.startDateTime = &startDateTime
	return r
}
// The end date and time of the time range, represented in ISO 8601 format. For example, 2019-11-08T20:00:00-08:00
func (r ApiGroupsGetCalendarViewRequest) EndDateTime(endDateTime string) ApiGroupsGetCalendarViewRequest {
	r.endDateTime = &endDateTime
	return r
}
// Select properties to be returned
func (r ApiGroupsGetCalendarViewRequest) Select_(select_ []string) ApiGroupsGetCalendarViewRequest {
	r.select_ = &select_
	return r
}

func (r ApiGroupsGetCalendarViewRequest) Execute() (MicrosoftGraphEvent, *_nethttp.Response, error) {
	return r.ApiService.GroupsGetCalendarViewExecute(r)
}

/*
GroupsGetCalendarView Get calendarView from groups

The calendar view for the calendar. Read-only.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupId key: id of group
 @param eventId key: id of event
 @return ApiGroupsGetCalendarViewRequest
*/
func (a *GroupsEventApiService) GroupsGetCalendarView(ctx _context.Context, groupId string, eventId string) ApiGroupsGetCalendarViewRequest {
	return ApiGroupsGetCalendarViewRequest{
		ApiService: a,
		ctx: ctx,
		groupId: groupId,
		eventId: eventId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphEvent
func (a *GroupsEventApiService) GroupsGetCalendarViewExecute(r ApiGroupsGetCalendarViewRequest) (MicrosoftGraphEvent, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphEvent
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GroupsEventApiService.GroupsGetCalendarView")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/groups/{group-id}/calendarView/{event-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.startDateTime == nil {
		return localVarReturnValue, nil, reportError("startDateTime is required and must be specified")
	}
	if r.endDateTime == nil {
		return localVarReturnValue, nil, reportError("endDateTime is required and must be specified")
	}

	localVarQueryParams.Add("startDateTime", parameterToString(*r.startDateTime, ""))
	localVarQueryParams.Add("endDateTime", parameterToString(*r.endDateTime, ""))
	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGroupsGetEventsRequest struct {
	ctx _context.Context
	ApiService *GroupsEventApiService
	groupId string
	eventId string
	select_ *[]string
}

// Select properties to be returned
func (r ApiGroupsGetEventsRequest) Select_(select_ []string) ApiGroupsGetEventsRequest {
	r.select_ = &select_
	return r
}

func (r ApiGroupsGetEventsRequest) Execute() (MicrosoftGraphEvent, *_nethttp.Response, error) {
	return r.ApiService.GroupsGetEventsExecute(r)
}

/*
GroupsGetEvents Get events from groups

The group's calendar events.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupId key: id of group
 @param eventId key: id of event
 @return ApiGroupsGetEventsRequest
*/
func (a *GroupsEventApiService) GroupsGetEvents(ctx _context.Context, groupId string, eventId string) ApiGroupsGetEventsRequest {
	return ApiGroupsGetEventsRequest{
		ApiService: a,
		ctx: ctx,
		groupId: groupId,
		eventId: eventId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphEvent
func (a *GroupsEventApiService) GroupsGetEventsExecute(r ApiGroupsGetEventsRequest) (MicrosoftGraphEvent, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphEvent
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GroupsEventApiService.GroupsGetEvents")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/groups/{group-id}/events/{event-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGroupsListCalendarViewRequest struct {
	ctx _context.Context
	ApiService *GroupsEventApiService
	groupId string
	startDateTime *string
	endDateTime *string
	top *int32
	skip *int32
	filter *string
	count *bool
	orderby *[]string
	select_ *[]string
}

// The start date and time of the time range, represented in ISO 8601 format. For example, 2019-11-08T19:00:00-08:00
func (r ApiGroupsListCalendarViewRequest) StartDateTime(startDateTime string) ApiGroupsListCalendarViewRequest {
	r.startDateTime = &startDateTime
	return r
}
// The end date and time of the time range, represented in ISO 8601 format. For example, 2019-11-08T20:00:00-08:00
func (r ApiGroupsListCalendarViewRequest) EndDateTime(endDateTime string) ApiGroupsListCalendarViewRequest {
	r.endDateTime = &endDateTime
	return r
}
// Show only the first n items
func (r ApiGroupsListCalendarViewRequest) Top(top int32) ApiGroupsListCalendarViewRequest {
	r.top = &top
	return r
}
// Skip the first n items
func (r ApiGroupsListCalendarViewRequest) Skip(skip int32) ApiGroupsListCalendarViewRequest {
	r.skip = &skip
	return r
}
// Filter items by property values
func (r ApiGroupsListCalendarViewRequest) Filter(filter string) ApiGroupsListCalendarViewRequest {
	r.filter = &filter
	return r
}
// Include count of items
func (r ApiGroupsListCalendarViewRequest) Count(count bool) ApiGroupsListCalendarViewRequest {
	r.count = &count
	return r
}
// Order items by property values
func (r ApiGroupsListCalendarViewRequest) Orderby(orderby []string) ApiGroupsListCalendarViewRequest {
	r.orderby = &orderby
	return r
}
// Select properties to be returned
func (r ApiGroupsListCalendarViewRequest) Select_(select_ []string) ApiGroupsListCalendarViewRequest {
	r.select_ = &select_
	return r
}

func (r ApiGroupsListCalendarViewRequest) Execute() (CollectionOfEvent, *_nethttp.Response, error) {
	return r.ApiService.GroupsListCalendarViewExecute(r)
}

/*
GroupsListCalendarView Get calendarView from groups

The calendar view for the calendar. Read-only.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupId key: id of group
 @return ApiGroupsListCalendarViewRequest
*/
func (a *GroupsEventApiService) GroupsListCalendarView(ctx _context.Context, groupId string) ApiGroupsListCalendarViewRequest {
	return ApiGroupsListCalendarViewRequest{
		ApiService: a,
		ctx: ctx,
		groupId: groupId,
	}
}

// Execute executes the request
//  @return CollectionOfEvent
func (a *GroupsEventApiService) GroupsListCalendarViewExecute(r ApiGroupsListCalendarViewRequest) (CollectionOfEvent, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  CollectionOfEvent
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GroupsEventApiService.GroupsListCalendarView")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/groups/{group-id}/calendarView"
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.startDateTime == nil {
		return localVarReturnValue, nil, reportError("startDateTime is required and must be specified")
	}
	if r.endDateTime == nil {
		return localVarReturnValue, nil, reportError("endDateTime is required and must be specified")
	}

	localVarQueryParams.Add("startDateTime", parameterToString(*r.startDateTime, ""))
	localVarQueryParams.Add("endDateTime", parameterToString(*r.endDateTime, ""))
	if r.top != nil {
		localVarQueryParams.Add("$top", parameterToString(*r.top, ""))
	}
	if r.skip != nil {
		localVarQueryParams.Add("$skip", parameterToString(*r.skip, ""))
	}
	if r.filter != nil {
		localVarQueryParams.Add("$filter", parameterToString(*r.filter, ""))
	}
	if r.count != nil {
		localVarQueryParams.Add("$count", parameterToString(*r.count, ""))
	}
	if r.orderby != nil {
		localVarQueryParams.Add("$orderby", parameterToString(*r.orderby, "csv"))
	}
	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGroupsListEventsRequest struct {
	ctx _context.Context
	ApiService *GroupsEventApiService
	groupId string
	top *int32
	skip *int32
	filter *string
	count *bool
	orderby *[]string
	select_ *[]string
}

// Show only the first n items
func (r ApiGroupsListEventsRequest) Top(top int32) ApiGroupsListEventsRequest {
	r.top = &top
	return r
}
// Skip the first n items
func (r ApiGroupsListEventsRequest) Skip(skip int32) ApiGroupsListEventsRequest {
	r.skip = &skip
	return r
}
// Filter items by property values
func (r ApiGroupsListEventsRequest) Filter(filter string) ApiGroupsListEventsRequest {
	r.filter = &filter
	return r
}
// Include count of items
func (r ApiGroupsListEventsRequest) Count(count bool) ApiGroupsListEventsRequest {
	r.count = &count
	return r
}
// Order items by property values
func (r ApiGroupsListEventsRequest) Orderby(orderby []string) ApiGroupsListEventsRequest {
	r.orderby = &orderby
	return r
}
// Select properties to be returned
func (r ApiGroupsListEventsRequest) Select_(select_ []string) ApiGroupsListEventsRequest {
	r.select_ = &select_
	return r
}

func (r ApiGroupsListEventsRequest) Execute() (CollectionOfEvent, *_nethttp.Response, error) {
	return r.ApiService.GroupsListEventsExecute(r)
}

/*
GroupsListEvents Get events from groups

The group's calendar events.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupId key: id of group
 @return ApiGroupsListEventsRequest
*/
func (a *GroupsEventApiService) GroupsListEvents(ctx _context.Context, groupId string) ApiGroupsListEventsRequest {
	return ApiGroupsListEventsRequest{
		ApiService: a,
		ctx: ctx,
		groupId: groupId,
	}
}

// Execute executes the request
//  @return CollectionOfEvent
func (a *GroupsEventApiService) GroupsListEventsExecute(r ApiGroupsListEventsRequest) (CollectionOfEvent, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  CollectionOfEvent
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GroupsEventApiService.GroupsListEvents")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/groups/{group-id}/events"
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.top != nil {
		localVarQueryParams.Add("$top", parameterToString(*r.top, ""))
	}
	if r.skip != nil {
		localVarQueryParams.Add("$skip", parameterToString(*r.skip, ""))
	}
	if r.filter != nil {
		localVarQueryParams.Add("$filter", parameterToString(*r.filter, ""))
	}
	if r.count != nil {
		localVarQueryParams.Add("$count", parameterToString(*r.count, ""))
	}
	if r.orderby != nil {
		localVarQueryParams.Add("$orderby", parameterToString(*r.orderby, "csv"))
	}
	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGroupsUpdateCalendarViewRequest struct {
	ctx _context.Context
	ApiService *GroupsEventApiService
	groupId string
	eventId string
	microsoftGraphEvent *MicrosoftGraphEvent
}

// New navigation property values
func (r ApiGroupsUpdateCalendarViewRequest) MicrosoftGraphEvent(microsoftGraphEvent MicrosoftGraphEvent) ApiGroupsUpdateCalendarViewRequest {
	r.microsoftGraphEvent = &microsoftGraphEvent
	return r
}

func (r ApiGroupsUpdateCalendarViewRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.GroupsUpdateCalendarViewExecute(r)
}

/*
GroupsUpdateCalendarView Update the navigation property calendarView in groups

The calendar view for the calendar. Read-only.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupId key: id of group
 @param eventId key: id of event
 @return ApiGroupsUpdateCalendarViewRequest
*/
func (a *GroupsEventApiService) GroupsUpdateCalendarView(ctx _context.Context, groupId string, eventId string) ApiGroupsUpdateCalendarViewRequest {
	return ApiGroupsUpdateCalendarViewRequest{
		ApiService: a,
		ctx: ctx,
		groupId: groupId,
		eventId: eventId,
	}
}

// Execute executes the request
func (a *GroupsEventApiService) GroupsUpdateCalendarViewExecute(r ApiGroupsUpdateCalendarViewRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPatch
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GroupsEventApiService.GroupsUpdateCalendarView")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/groups/{group-id}/calendarView/{event-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphEvent == nil {
		return nil, reportError("microsoftGraphEvent is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphEvent
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGroupsUpdateEventsRequest struct {
	ctx _context.Context
	ApiService *GroupsEventApiService
	groupId string
	eventId string
	microsoftGraphEvent *MicrosoftGraphEvent
}

// New navigation property values
func (r ApiGroupsUpdateEventsRequest) MicrosoftGraphEvent(microsoftGraphEvent MicrosoftGraphEvent) ApiGroupsUpdateEventsRequest {
	r.microsoftGraphEvent = &microsoftGraphEvent
	return r
}

func (r ApiGroupsUpdateEventsRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.GroupsUpdateEventsExecute(r)
}

/*
GroupsUpdateEvents Update the navigation property events in groups

The group's calendar events.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupId key: id of group
 @param eventId key: id of event
 @return ApiGroupsUpdateEventsRequest
*/
func (a *GroupsEventApiService) GroupsUpdateEvents(ctx _context.Context, groupId string, eventId string) ApiGroupsUpdateEventsRequest {
	return ApiGroupsUpdateEventsRequest{
		ApiService: a,
		ctx: ctx,
		groupId: groupId,
		eventId: eventId,
	}
}

// Execute executes the request
func (a *GroupsEventApiService) GroupsUpdateEventsExecute(r ApiGroupsUpdateEventsRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPatch
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GroupsEventApiService.GroupsUpdateEvents")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/groups/{group-id}/events/{event-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphEvent == nil {
		return nil, reportError("microsoftGraphEvent is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphEvent
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}
