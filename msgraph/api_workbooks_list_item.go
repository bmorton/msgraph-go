/*
Partial Graph API

No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

API version: v1.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package openapi

import (
	"bytes"
	_context "context"
	_ioutil "io/ioutil"
	_nethttp "net/http"
	_neturl "net/url"
	"strings"
	"os"
)

// Linger please
var (
	_ _context.Context
)

// WorkbooksListItemApiService WorkbooksListItemApi service
type WorkbooksListItemApiService service

type ApiWorkbooksDeleteListItemRequest struct {
	ctx _context.Context
	ApiService *WorkbooksListItemApiService
	driveItemId string
	ifMatch *string
}

// ETag
func (r ApiWorkbooksDeleteListItemRequest) IfMatch(ifMatch string) ApiWorkbooksDeleteListItemRequest {
	r.ifMatch = &ifMatch
	return r
}

func (r ApiWorkbooksDeleteListItemRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.WorkbooksDeleteListItemExecute(r)
}

/*
WorkbooksDeleteListItem Delete navigation property listItem for workbooks

For drives in SharePoint, the associated document library list item. Read-only. Nullable.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param driveItemId key: id of driveItem
 @return ApiWorkbooksDeleteListItemRequest
*/
func (a *WorkbooksListItemApiService) WorkbooksDeleteListItem(ctx _context.Context, driveItemId string) ApiWorkbooksDeleteListItemRequest {
	return ApiWorkbooksDeleteListItemRequest{
		ApiService: a,
		ctx: ctx,
		driveItemId: driveItemId,
	}
}

// Execute executes the request
func (a *WorkbooksListItemApiService) WorkbooksDeleteListItemExecute(r ApiWorkbooksDeleteListItemRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "WorkbooksListItemApiService.WorkbooksDeleteListItem")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/workbooks/{driveItem-id}/listItem"
	localVarPath = strings.Replace(localVarPath, "{"+"driveItem-id"+"}", _neturl.PathEscape(parameterToString(r.driveItemId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ifMatch != nil {
		localVarHeaderParams["If-Match"] = parameterToString(*r.ifMatch, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiWorkbooksGetListItemRequest struct {
	ctx _context.Context
	ApiService *WorkbooksListItemApiService
	driveItemId string
	select_ *[]string
	expand *[]string
}

// Select properties to be returned
func (r ApiWorkbooksGetListItemRequest) Select_(select_ []string) ApiWorkbooksGetListItemRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiWorkbooksGetListItemRequest) Expand(expand []string) ApiWorkbooksGetListItemRequest {
	r.expand = &expand
	return r
}

func (r ApiWorkbooksGetListItemRequest) Execute() (MicrosoftGraphListItem, *_nethttp.Response, error) {
	return r.ApiService.WorkbooksGetListItemExecute(r)
}

/*
WorkbooksGetListItem Get listItem from workbooks

For drives in SharePoint, the associated document library list item. Read-only. Nullable.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param driveItemId key: id of driveItem
 @return ApiWorkbooksGetListItemRequest
*/
func (a *WorkbooksListItemApiService) WorkbooksGetListItem(ctx _context.Context, driveItemId string) ApiWorkbooksGetListItemRequest {
	return ApiWorkbooksGetListItemRequest{
		ApiService: a,
		ctx: ctx,
		driveItemId: driveItemId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphListItem
func (a *WorkbooksListItemApiService) WorkbooksGetListItemExecute(r ApiWorkbooksGetListItemRequest) (MicrosoftGraphListItem, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphListItem
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "WorkbooksListItemApiService.WorkbooksGetListItem")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/workbooks/{driveItem-id}/listItem"
	localVarPath = strings.Replace(localVarPath, "{"+"driveItem-id"+"}", _neturl.PathEscape(parameterToString(r.driveItemId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiWorkbooksListItemCreateVersionsRequest struct {
	ctx _context.Context
	ApiService *WorkbooksListItemApiService
	driveItemId string
	microsoftGraphListItemVersion *MicrosoftGraphListItemVersion
}

// New navigation property
func (r ApiWorkbooksListItemCreateVersionsRequest) MicrosoftGraphListItemVersion(microsoftGraphListItemVersion MicrosoftGraphListItemVersion) ApiWorkbooksListItemCreateVersionsRequest {
	r.microsoftGraphListItemVersion = &microsoftGraphListItemVersion
	return r
}

func (r ApiWorkbooksListItemCreateVersionsRequest) Execute() (MicrosoftGraphListItemVersion, *_nethttp.Response, error) {
	return r.ApiService.WorkbooksListItemCreateVersionsExecute(r)
}

/*
WorkbooksListItemCreateVersions Create new navigation property to versions for workbooks

The list of previous versions of the list item.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param driveItemId key: id of driveItem
 @return ApiWorkbooksListItemCreateVersionsRequest
*/
func (a *WorkbooksListItemApiService) WorkbooksListItemCreateVersions(ctx _context.Context, driveItemId string) ApiWorkbooksListItemCreateVersionsRequest {
	return ApiWorkbooksListItemCreateVersionsRequest{
		ApiService: a,
		ctx: ctx,
		driveItemId: driveItemId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphListItemVersion
func (a *WorkbooksListItemApiService) WorkbooksListItemCreateVersionsExecute(r ApiWorkbooksListItemCreateVersionsRequest) (MicrosoftGraphListItemVersion, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphListItemVersion
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "WorkbooksListItemApiService.WorkbooksListItemCreateVersions")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/workbooks/{driveItem-id}/listItem/versions"
	localVarPath = strings.Replace(localVarPath, "{"+"driveItem-id"+"}", _neturl.PathEscape(parameterToString(r.driveItemId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphListItemVersion == nil {
		return localVarReturnValue, nil, reportError("microsoftGraphListItemVersion is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphListItemVersion
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiWorkbooksListItemDeleteDriveItemRequest struct {
	ctx _context.Context
	ApiService *WorkbooksListItemApiService
	driveItemId string
	ifMatch *string
}

// ETag
func (r ApiWorkbooksListItemDeleteDriveItemRequest) IfMatch(ifMatch string) ApiWorkbooksListItemDeleteDriveItemRequest {
	r.ifMatch = &ifMatch
	return r
}

func (r ApiWorkbooksListItemDeleteDriveItemRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.WorkbooksListItemDeleteDriveItemExecute(r)
}

/*
WorkbooksListItemDeleteDriveItem Delete navigation property driveItem for workbooks

For document libraries, the driveItem relationship exposes the listItem as a [driveItem][]

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param driveItemId key: id of driveItem
 @return ApiWorkbooksListItemDeleteDriveItemRequest
*/
func (a *WorkbooksListItemApiService) WorkbooksListItemDeleteDriveItem(ctx _context.Context, driveItemId string) ApiWorkbooksListItemDeleteDriveItemRequest {
	return ApiWorkbooksListItemDeleteDriveItemRequest{
		ApiService: a,
		ctx: ctx,
		driveItemId: driveItemId,
	}
}

// Execute executes the request
func (a *WorkbooksListItemApiService) WorkbooksListItemDeleteDriveItemExecute(r ApiWorkbooksListItemDeleteDriveItemRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "WorkbooksListItemApiService.WorkbooksListItemDeleteDriveItem")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/workbooks/{driveItem-id}/listItem/driveItem"
	localVarPath = strings.Replace(localVarPath, "{"+"driveItem-id"+"}", _neturl.PathEscape(parameterToString(r.driveItemId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ifMatch != nil {
		localVarHeaderParams["If-Match"] = parameterToString(*r.ifMatch, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiWorkbooksListItemDeleteFieldsRequest struct {
	ctx _context.Context
	ApiService *WorkbooksListItemApiService
	driveItemId string
	ifMatch *string
}

// ETag
func (r ApiWorkbooksListItemDeleteFieldsRequest) IfMatch(ifMatch string) ApiWorkbooksListItemDeleteFieldsRequest {
	r.ifMatch = &ifMatch
	return r
}

func (r ApiWorkbooksListItemDeleteFieldsRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.WorkbooksListItemDeleteFieldsExecute(r)
}

/*
WorkbooksListItemDeleteFields Delete navigation property fields for workbooks

The values of the columns set on this list item.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param driveItemId key: id of driveItem
 @return ApiWorkbooksListItemDeleteFieldsRequest
*/
func (a *WorkbooksListItemApiService) WorkbooksListItemDeleteFields(ctx _context.Context, driveItemId string) ApiWorkbooksListItemDeleteFieldsRequest {
	return ApiWorkbooksListItemDeleteFieldsRequest{
		ApiService: a,
		ctx: ctx,
		driveItemId: driveItemId,
	}
}

// Execute executes the request
func (a *WorkbooksListItemApiService) WorkbooksListItemDeleteFieldsExecute(r ApiWorkbooksListItemDeleteFieldsRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "WorkbooksListItemApiService.WorkbooksListItemDeleteFields")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/workbooks/{driveItem-id}/listItem/fields"
	localVarPath = strings.Replace(localVarPath, "{"+"driveItem-id"+"}", _neturl.PathEscape(parameterToString(r.driveItemId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ifMatch != nil {
		localVarHeaderParams["If-Match"] = parameterToString(*r.ifMatch, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiWorkbooksListItemDeleteRefAnalyticsRequest struct {
	ctx _context.Context
	ApiService *WorkbooksListItemApiService
	driveItemId string
	ifMatch *string
}

// ETag
func (r ApiWorkbooksListItemDeleteRefAnalyticsRequest) IfMatch(ifMatch string) ApiWorkbooksListItemDeleteRefAnalyticsRequest {
	r.ifMatch = &ifMatch
	return r
}

func (r ApiWorkbooksListItemDeleteRefAnalyticsRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.WorkbooksListItemDeleteRefAnalyticsExecute(r)
}

/*
WorkbooksListItemDeleteRefAnalytics Delete ref of navigation property analytics for workbooks

Analytics about the view activities that took place on this item.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param driveItemId key: id of driveItem
 @return ApiWorkbooksListItemDeleteRefAnalyticsRequest
*/
func (a *WorkbooksListItemApiService) WorkbooksListItemDeleteRefAnalytics(ctx _context.Context, driveItemId string) ApiWorkbooksListItemDeleteRefAnalyticsRequest {
	return ApiWorkbooksListItemDeleteRefAnalyticsRequest{
		ApiService: a,
		ctx: ctx,
		driveItemId: driveItemId,
	}
}

// Execute executes the request
func (a *WorkbooksListItemApiService) WorkbooksListItemDeleteRefAnalyticsExecute(r ApiWorkbooksListItemDeleteRefAnalyticsRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "WorkbooksListItemApiService.WorkbooksListItemDeleteRefAnalytics")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/workbooks/{driveItem-id}/listItem/analytics/$ref"
	localVarPath = strings.Replace(localVarPath, "{"+"driveItem-id"+"}", _neturl.PathEscape(parameterToString(r.driveItemId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ifMatch != nil {
		localVarHeaderParams["If-Match"] = parameterToString(*r.ifMatch, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiWorkbooksListItemDeleteVersionsRequest struct {
	ctx _context.Context
	ApiService *WorkbooksListItemApiService
	driveItemId string
	listItemVersionId string
	ifMatch *string
}

// ETag
func (r ApiWorkbooksListItemDeleteVersionsRequest) IfMatch(ifMatch string) ApiWorkbooksListItemDeleteVersionsRequest {
	r.ifMatch = &ifMatch
	return r
}

func (r ApiWorkbooksListItemDeleteVersionsRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.WorkbooksListItemDeleteVersionsExecute(r)
}

/*
WorkbooksListItemDeleteVersions Delete navigation property versions for workbooks

The list of previous versions of the list item.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param driveItemId key: id of driveItem
 @param listItemVersionId key: id of listItemVersion
 @return ApiWorkbooksListItemDeleteVersionsRequest
*/
func (a *WorkbooksListItemApiService) WorkbooksListItemDeleteVersions(ctx _context.Context, driveItemId string, listItemVersionId string) ApiWorkbooksListItemDeleteVersionsRequest {
	return ApiWorkbooksListItemDeleteVersionsRequest{
		ApiService: a,
		ctx: ctx,
		driveItemId: driveItemId,
		listItemVersionId: listItemVersionId,
	}
}

// Execute executes the request
func (a *WorkbooksListItemApiService) WorkbooksListItemDeleteVersionsExecute(r ApiWorkbooksListItemDeleteVersionsRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "WorkbooksListItemApiService.WorkbooksListItemDeleteVersions")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/workbooks/{driveItem-id}/listItem/versions/{listItemVersion-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"driveItem-id"+"}", _neturl.PathEscape(parameterToString(r.driveItemId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"listItemVersion-id"+"}", _neturl.PathEscape(parameterToString(r.listItemVersionId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ifMatch != nil {
		localVarHeaderParams["If-Match"] = parameterToString(*r.ifMatch, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiWorkbooksListItemGetAnalyticsRequest struct {
	ctx _context.Context
	ApiService *WorkbooksListItemApiService
	driveItemId string
	select_ *[]string
	expand *[]string
}

// Select properties to be returned
func (r ApiWorkbooksListItemGetAnalyticsRequest) Select_(select_ []string) ApiWorkbooksListItemGetAnalyticsRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiWorkbooksListItemGetAnalyticsRequest) Expand(expand []string) ApiWorkbooksListItemGetAnalyticsRequest {
	r.expand = &expand
	return r
}

func (r ApiWorkbooksListItemGetAnalyticsRequest) Execute() (MicrosoftGraphItemAnalytics, *_nethttp.Response, error) {
	return r.ApiService.WorkbooksListItemGetAnalyticsExecute(r)
}

/*
WorkbooksListItemGetAnalytics Get analytics from workbooks

Analytics about the view activities that took place on this item.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param driveItemId key: id of driveItem
 @return ApiWorkbooksListItemGetAnalyticsRequest
*/
func (a *WorkbooksListItemApiService) WorkbooksListItemGetAnalytics(ctx _context.Context, driveItemId string) ApiWorkbooksListItemGetAnalyticsRequest {
	return ApiWorkbooksListItemGetAnalyticsRequest{
		ApiService: a,
		ctx: ctx,
		driveItemId: driveItemId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphItemAnalytics
func (a *WorkbooksListItemApiService) WorkbooksListItemGetAnalyticsExecute(r ApiWorkbooksListItemGetAnalyticsRequest) (MicrosoftGraphItemAnalytics, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphItemAnalytics
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "WorkbooksListItemApiService.WorkbooksListItemGetAnalytics")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/workbooks/{driveItem-id}/listItem/analytics"
	localVarPath = strings.Replace(localVarPath, "{"+"driveItem-id"+"}", _neturl.PathEscape(parameterToString(r.driveItemId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiWorkbooksListItemGetDriveItemRequest struct {
	ctx _context.Context
	ApiService *WorkbooksListItemApiService
	driveItemId string
	select_ *[]string
	expand *[]string
}

// Select properties to be returned
func (r ApiWorkbooksListItemGetDriveItemRequest) Select_(select_ []string) ApiWorkbooksListItemGetDriveItemRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiWorkbooksListItemGetDriveItemRequest) Expand(expand []string) ApiWorkbooksListItemGetDriveItemRequest {
	r.expand = &expand
	return r
}

func (r ApiWorkbooksListItemGetDriveItemRequest) Execute() (MicrosoftGraphDriveItem, *_nethttp.Response, error) {
	return r.ApiService.WorkbooksListItemGetDriveItemExecute(r)
}

/*
WorkbooksListItemGetDriveItem Get driveItem from workbooks

For document libraries, the driveItem relationship exposes the listItem as a [driveItem][]

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param driveItemId key: id of driveItem
 @return ApiWorkbooksListItemGetDriveItemRequest
*/
func (a *WorkbooksListItemApiService) WorkbooksListItemGetDriveItem(ctx _context.Context, driveItemId string) ApiWorkbooksListItemGetDriveItemRequest {
	return ApiWorkbooksListItemGetDriveItemRequest{
		ApiService: a,
		ctx: ctx,
		driveItemId: driveItemId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphDriveItem
func (a *WorkbooksListItemApiService) WorkbooksListItemGetDriveItemExecute(r ApiWorkbooksListItemGetDriveItemRequest) (MicrosoftGraphDriveItem, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphDriveItem
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "WorkbooksListItemApiService.WorkbooksListItemGetDriveItem")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/workbooks/{driveItem-id}/listItem/driveItem"
	localVarPath = strings.Replace(localVarPath, "{"+"driveItem-id"+"}", _neturl.PathEscape(parameterToString(r.driveItemId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiWorkbooksListItemGetDriveItemContentRequest struct {
	ctx _context.Context
	ApiService *WorkbooksListItemApiService
	driveItemId string
}


func (r ApiWorkbooksListItemGetDriveItemContentRequest) Execute() (*os.File, *_nethttp.Response, error) {
	return r.ApiService.WorkbooksListItemGetDriveItemContentExecute(r)
}

/*
WorkbooksListItemGetDriveItemContent Get media content for the navigation property driveItem from workbooks

The content stream, if the item represents a file.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param driveItemId key: id of driveItem
 @return ApiWorkbooksListItemGetDriveItemContentRequest
*/
func (a *WorkbooksListItemApiService) WorkbooksListItemGetDriveItemContent(ctx _context.Context, driveItemId string) ApiWorkbooksListItemGetDriveItemContentRequest {
	return ApiWorkbooksListItemGetDriveItemContentRequest{
		ApiService: a,
		ctx: ctx,
		driveItemId: driveItemId,
	}
}

// Execute executes the request
//  @return *os.File
func (a *WorkbooksListItemApiService) WorkbooksListItemGetDriveItemContentExecute(r ApiWorkbooksListItemGetDriveItemContentRequest) (*os.File, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  *os.File
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "WorkbooksListItemApiService.WorkbooksListItemGetDriveItemContent")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/workbooks/{driveItem-id}/listItem/driveItem/content"
	localVarPath = strings.Replace(localVarPath, "{"+"driveItem-id"+"}", _neturl.PathEscape(parameterToString(r.driveItemId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/octet-stream", "application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiWorkbooksListItemGetFieldsRequest struct {
	ctx _context.Context
	ApiService *WorkbooksListItemApiService
	driveItemId string
	select_ *[]string
	expand *[]string
}

// Select properties to be returned
func (r ApiWorkbooksListItemGetFieldsRequest) Select_(select_ []string) ApiWorkbooksListItemGetFieldsRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiWorkbooksListItemGetFieldsRequest) Expand(expand []string) ApiWorkbooksListItemGetFieldsRequest {
	r.expand = &expand
	return r
}

func (r ApiWorkbooksListItemGetFieldsRequest) Execute() (MicrosoftGraphFieldValueSet, *_nethttp.Response, error) {
	return r.ApiService.WorkbooksListItemGetFieldsExecute(r)
}

/*
WorkbooksListItemGetFields Get fields from workbooks

The values of the columns set on this list item.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param driveItemId key: id of driveItem
 @return ApiWorkbooksListItemGetFieldsRequest
*/
func (a *WorkbooksListItemApiService) WorkbooksListItemGetFields(ctx _context.Context, driveItemId string) ApiWorkbooksListItemGetFieldsRequest {
	return ApiWorkbooksListItemGetFieldsRequest{
		ApiService: a,
		ctx: ctx,
		driveItemId: driveItemId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphFieldValueSet
func (a *WorkbooksListItemApiService) WorkbooksListItemGetFieldsExecute(r ApiWorkbooksListItemGetFieldsRequest) (MicrosoftGraphFieldValueSet, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphFieldValueSet
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "WorkbooksListItemApiService.WorkbooksListItemGetFields")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/workbooks/{driveItem-id}/listItem/fields"
	localVarPath = strings.Replace(localVarPath, "{"+"driveItem-id"+"}", _neturl.PathEscape(parameterToString(r.driveItemId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiWorkbooksListItemGetRefAnalyticsRequest struct {
	ctx _context.Context
	ApiService *WorkbooksListItemApiService
	driveItemId string
}


func (r ApiWorkbooksListItemGetRefAnalyticsRequest) Execute() (string, *_nethttp.Response, error) {
	return r.ApiService.WorkbooksListItemGetRefAnalyticsExecute(r)
}

/*
WorkbooksListItemGetRefAnalytics Get ref of analytics from workbooks

Analytics about the view activities that took place on this item.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param driveItemId key: id of driveItem
 @return ApiWorkbooksListItemGetRefAnalyticsRequest
*/
func (a *WorkbooksListItemApiService) WorkbooksListItemGetRefAnalytics(ctx _context.Context, driveItemId string) ApiWorkbooksListItemGetRefAnalyticsRequest {
	return ApiWorkbooksListItemGetRefAnalyticsRequest{
		ApiService: a,
		ctx: ctx,
		driveItemId: driveItemId,
	}
}

// Execute executes the request
//  @return string
func (a *WorkbooksListItemApiService) WorkbooksListItemGetRefAnalyticsExecute(r ApiWorkbooksListItemGetRefAnalyticsRequest) (string, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  string
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "WorkbooksListItemApiService.WorkbooksListItemGetRefAnalytics")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/workbooks/{driveItem-id}/listItem/analytics/$ref"
	localVarPath = strings.Replace(localVarPath, "{"+"driveItem-id"+"}", _neturl.PathEscape(parameterToString(r.driveItemId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiWorkbooksListItemGetVersionsRequest struct {
	ctx _context.Context
	ApiService *WorkbooksListItemApiService
	driveItemId string
	listItemVersionId string
	select_ *[]string
	expand *[]string
}

// Select properties to be returned
func (r ApiWorkbooksListItemGetVersionsRequest) Select_(select_ []string) ApiWorkbooksListItemGetVersionsRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiWorkbooksListItemGetVersionsRequest) Expand(expand []string) ApiWorkbooksListItemGetVersionsRequest {
	r.expand = &expand
	return r
}

func (r ApiWorkbooksListItemGetVersionsRequest) Execute() (MicrosoftGraphListItemVersion, *_nethttp.Response, error) {
	return r.ApiService.WorkbooksListItemGetVersionsExecute(r)
}

/*
WorkbooksListItemGetVersions Get versions from workbooks

The list of previous versions of the list item.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param driveItemId key: id of driveItem
 @param listItemVersionId key: id of listItemVersion
 @return ApiWorkbooksListItemGetVersionsRequest
*/
func (a *WorkbooksListItemApiService) WorkbooksListItemGetVersions(ctx _context.Context, driveItemId string, listItemVersionId string) ApiWorkbooksListItemGetVersionsRequest {
	return ApiWorkbooksListItemGetVersionsRequest{
		ApiService: a,
		ctx: ctx,
		driveItemId: driveItemId,
		listItemVersionId: listItemVersionId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphListItemVersion
func (a *WorkbooksListItemApiService) WorkbooksListItemGetVersionsExecute(r ApiWorkbooksListItemGetVersionsRequest) (MicrosoftGraphListItemVersion, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphListItemVersion
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "WorkbooksListItemApiService.WorkbooksListItemGetVersions")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/workbooks/{driveItem-id}/listItem/versions/{listItemVersion-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"driveItem-id"+"}", _neturl.PathEscape(parameterToString(r.driveItemId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"listItemVersion-id"+"}", _neturl.PathEscape(parameterToString(r.listItemVersionId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiWorkbooksListItemListVersionsRequest struct {
	ctx _context.Context
	ApiService *WorkbooksListItemApiService
	driveItemId string
	top *int32
	skip *int32
	search *string
	filter *string
	count *bool
	orderby *[]string
	select_ *[]string
	expand *[]string
}

// Show only the first n items
func (r ApiWorkbooksListItemListVersionsRequest) Top(top int32) ApiWorkbooksListItemListVersionsRequest {
	r.top = &top
	return r
}
// Skip the first n items
func (r ApiWorkbooksListItemListVersionsRequest) Skip(skip int32) ApiWorkbooksListItemListVersionsRequest {
	r.skip = &skip
	return r
}
// Search items by search phrases
func (r ApiWorkbooksListItemListVersionsRequest) Search(search string) ApiWorkbooksListItemListVersionsRequest {
	r.search = &search
	return r
}
// Filter items by property values
func (r ApiWorkbooksListItemListVersionsRequest) Filter(filter string) ApiWorkbooksListItemListVersionsRequest {
	r.filter = &filter
	return r
}
// Include count of items
func (r ApiWorkbooksListItemListVersionsRequest) Count(count bool) ApiWorkbooksListItemListVersionsRequest {
	r.count = &count
	return r
}
// Order items by property values
func (r ApiWorkbooksListItemListVersionsRequest) Orderby(orderby []string) ApiWorkbooksListItemListVersionsRequest {
	r.orderby = &orderby
	return r
}
// Select properties to be returned
func (r ApiWorkbooksListItemListVersionsRequest) Select_(select_ []string) ApiWorkbooksListItemListVersionsRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiWorkbooksListItemListVersionsRequest) Expand(expand []string) ApiWorkbooksListItemListVersionsRequest {
	r.expand = &expand
	return r
}

func (r ApiWorkbooksListItemListVersionsRequest) Execute() (CollectionOfListItemVersion, *_nethttp.Response, error) {
	return r.ApiService.WorkbooksListItemListVersionsExecute(r)
}

/*
WorkbooksListItemListVersions Get versions from workbooks

The list of previous versions of the list item.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param driveItemId key: id of driveItem
 @return ApiWorkbooksListItemListVersionsRequest
*/
func (a *WorkbooksListItemApiService) WorkbooksListItemListVersions(ctx _context.Context, driveItemId string) ApiWorkbooksListItemListVersionsRequest {
	return ApiWorkbooksListItemListVersionsRequest{
		ApiService: a,
		ctx: ctx,
		driveItemId: driveItemId,
	}
}

// Execute executes the request
//  @return CollectionOfListItemVersion
func (a *WorkbooksListItemApiService) WorkbooksListItemListVersionsExecute(r ApiWorkbooksListItemListVersionsRequest) (CollectionOfListItemVersion, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  CollectionOfListItemVersion
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "WorkbooksListItemApiService.WorkbooksListItemListVersions")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/workbooks/{driveItem-id}/listItem/versions"
	localVarPath = strings.Replace(localVarPath, "{"+"driveItem-id"+"}", _neturl.PathEscape(parameterToString(r.driveItemId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.top != nil {
		localVarQueryParams.Add("$top", parameterToString(*r.top, ""))
	}
	if r.skip != nil {
		localVarQueryParams.Add("$skip", parameterToString(*r.skip, ""))
	}
	if r.search != nil {
		localVarQueryParams.Add("$search", parameterToString(*r.search, ""))
	}
	if r.filter != nil {
		localVarQueryParams.Add("$filter", parameterToString(*r.filter, ""))
	}
	if r.count != nil {
		localVarQueryParams.Add("$count", parameterToString(*r.count, ""))
	}
	if r.orderby != nil {
		localVarQueryParams.Add("$orderby", parameterToString(*r.orderby, "csv"))
	}
	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiWorkbooksListItemUpdateDriveItemRequest struct {
	ctx _context.Context
	ApiService *WorkbooksListItemApiService
	driveItemId string
	microsoftGraphDriveItem *MicrosoftGraphDriveItem
}

// New navigation property values
func (r ApiWorkbooksListItemUpdateDriveItemRequest) MicrosoftGraphDriveItem(microsoftGraphDriveItem MicrosoftGraphDriveItem) ApiWorkbooksListItemUpdateDriveItemRequest {
	r.microsoftGraphDriveItem = &microsoftGraphDriveItem
	return r
}

func (r ApiWorkbooksListItemUpdateDriveItemRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.WorkbooksListItemUpdateDriveItemExecute(r)
}

/*
WorkbooksListItemUpdateDriveItem Update the navigation property driveItem in workbooks

For document libraries, the driveItem relationship exposes the listItem as a [driveItem][]

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param driveItemId key: id of driveItem
 @return ApiWorkbooksListItemUpdateDriveItemRequest
*/
func (a *WorkbooksListItemApiService) WorkbooksListItemUpdateDriveItem(ctx _context.Context, driveItemId string) ApiWorkbooksListItemUpdateDriveItemRequest {
	return ApiWorkbooksListItemUpdateDriveItemRequest{
		ApiService: a,
		ctx: ctx,
		driveItemId: driveItemId,
	}
}

// Execute executes the request
func (a *WorkbooksListItemApiService) WorkbooksListItemUpdateDriveItemExecute(r ApiWorkbooksListItemUpdateDriveItemRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPatch
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "WorkbooksListItemApiService.WorkbooksListItemUpdateDriveItem")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/workbooks/{driveItem-id}/listItem/driveItem"
	localVarPath = strings.Replace(localVarPath, "{"+"driveItem-id"+"}", _neturl.PathEscape(parameterToString(r.driveItemId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphDriveItem == nil {
		return nil, reportError("microsoftGraphDriveItem is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphDriveItem
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiWorkbooksListItemUpdateDriveItemContentRequest struct {
	ctx _context.Context
	ApiService *WorkbooksListItemApiService
	driveItemId string
	body **os.File
}

// New media content.
func (r ApiWorkbooksListItemUpdateDriveItemContentRequest) Body(body *os.File) ApiWorkbooksListItemUpdateDriveItemContentRequest {
	r.body = &body
	return r
}

func (r ApiWorkbooksListItemUpdateDriveItemContentRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.WorkbooksListItemUpdateDriveItemContentExecute(r)
}

/*
WorkbooksListItemUpdateDriveItemContent Update media content for the navigation property driveItem in workbooks

The content stream, if the item represents a file.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param driveItemId key: id of driveItem
 @return ApiWorkbooksListItemUpdateDriveItemContentRequest
*/
func (a *WorkbooksListItemApiService) WorkbooksListItemUpdateDriveItemContent(ctx _context.Context, driveItemId string) ApiWorkbooksListItemUpdateDriveItemContentRequest {
	return ApiWorkbooksListItemUpdateDriveItemContentRequest{
		ApiService: a,
		ctx: ctx,
		driveItemId: driveItemId,
	}
}

// Execute executes the request
func (a *WorkbooksListItemApiService) WorkbooksListItemUpdateDriveItemContentExecute(r ApiWorkbooksListItemUpdateDriveItemContentRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPut
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "WorkbooksListItemApiService.WorkbooksListItemUpdateDriveItemContent")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/workbooks/{driveItem-id}/listItem/driveItem/content"
	localVarPath = strings.Replace(localVarPath, "{"+"driveItem-id"+"}", _neturl.PathEscape(parameterToString(r.driveItemId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.body == nil {
		return nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/octet-stream"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiWorkbooksListItemUpdateFieldsRequest struct {
	ctx _context.Context
	ApiService *WorkbooksListItemApiService
	driveItemId string
	microsoftGraphFieldValueSet *MicrosoftGraphFieldValueSet
}

// New navigation property values
func (r ApiWorkbooksListItemUpdateFieldsRequest) MicrosoftGraphFieldValueSet(microsoftGraphFieldValueSet MicrosoftGraphFieldValueSet) ApiWorkbooksListItemUpdateFieldsRequest {
	r.microsoftGraphFieldValueSet = &microsoftGraphFieldValueSet
	return r
}

func (r ApiWorkbooksListItemUpdateFieldsRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.WorkbooksListItemUpdateFieldsExecute(r)
}

/*
WorkbooksListItemUpdateFields Update the navigation property fields in workbooks

The values of the columns set on this list item.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param driveItemId key: id of driveItem
 @return ApiWorkbooksListItemUpdateFieldsRequest
*/
func (a *WorkbooksListItemApiService) WorkbooksListItemUpdateFields(ctx _context.Context, driveItemId string) ApiWorkbooksListItemUpdateFieldsRequest {
	return ApiWorkbooksListItemUpdateFieldsRequest{
		ApiService: a,
		ctx: ctx,
		driveItemId: driveItemId,
	}
}

// Execute executes the request
func (a *WorkbooksListItemApiService) WorkbooksListItemUpdateFieldsExecute(r ApiWorkbooksListItemUpdateFieldsRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPatch
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "WorkbooksListItemApiService.WorkbooksListItemUpdateFields")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/workbooks/{driveItem-id}/listItem/fields"
	localVarPath = strings.Replace(localVarPath, "{"+"driveItem-id"+"}", _neturl.PathEscape(parameterToString(r.driveItemId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphFieldValueSet == nil {
		return nil, reportError("microsoftGraphFieldValueSet is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphFieldValueSet
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiWorkbooksListItemUpdateRefAnalyticsRequest struct {
	ctx _context.Context
	ApiService *WorkbooksListItemApiService
	driveItemId string
	requestBody *map[string]map[string]interface{}
}

// New navigation property ref values
func (r ApiWorkbooksListItemUpdateRefAnalyticsRequest) RequestBody(requestBody map[string]map[string]interface{}) ApiWorkbooksListItemUpdateRefAnalyticsRequest {
	r.requestBody = &requestBody
	return r
}

func (r ApiWorkbooksListItemUpdateRefAnalyticsRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.WorkbooksListItemUpdateRefAnalyticsExecute(r)
}

/*
WorkbooksListItemUpdateRefAnalytics Update the ref of navigation property analytics in workbooks

Analytics about the view activities that took place on this item.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param driveItemId key: id of driveItem
 @return ApiWorkbooksListItemUpdateRefAnalyticsRequest
*/
func (a *WorkbooksListItemApiService) WorkbooksListItemUpdateRefAnalytics(ctx _context.Context, driveItemId string) ApiWorkbooksListItemUpdateRefAnalyticsRequest {
	return ApiWorkbooksListItemUpdateRefAnalyticsRequest{
		ApiService: a,
		ctx: ctx,
		driveItemId: driveItemId,
	}
}

// Execute executes the request
func (a *WorkbooksListItemApiService) WorkbooksListItemUpdateRefAnalyticsExecute(r ApiWorkbooksListItemUpdateRefAnalyticsRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPut
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "WorkbooksListItemApiService.WorkbooksListItemUpdateRefAnalytics")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/workbooks/{driveItem-id}/listItem/analytics/$ref"
	localVarPath = strings.Replace(localVarPath, "{"+"driveItem-id"+"}", _neturl.PathEscape(parameterToString(r.driveItemId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.requestBody == nil {
		return nil, reportError("requestBody is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.requestBody
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiWorkbooksListItemUpdateVersionsRequest struct {
	ctx _context.Context
	ApiService *WorkbooksListItemApiService
	driveItemId string
	listItemVersionId string
	microsoftGraphListItemVersion *MicrosoftGraphListItemVersion
}

// New navigation property values
func (r ApiWorkbooksListItemUpdateVersionsRequest) MicrosoftGraphListItemVersion(microsoftGraphListItemVersion MicrosoftGraphListItemVersion) ApiWorkbooksListItemUpdateVersionsRequest {
	r.microsoftGraphListItemVersion = &microsoftGraphListItemVersion
	return r
}

func (r ApiWorkbooksListItemUpdateVersionsRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.WorkbooksListItemUpdateVersionsExecute(r)
}

/*
WorkbooksListItemUpdateVersions Update the navigation property versions in workbooks

The list of previous versions of the list item.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param driveItemId key: id of driveItem
 @param listItemVersionId key: id of listItemVersion
 @return ApiWorkbooksListItemUpdateVersionsRequest
*/
func (a *WorkbooksListItemApiService) WorkbooksListItemUpdateVersions(ctx _context.Context, driveItemId string, listItemVersionId string) ApiWorkbooksListItemUpdateVersionsRequest {
	return ApiWorkbooksListItemUpdateVersionsRequest{
		ApiService: a,
		ctx: ctx,
		driveItemId: driveItemId,
		listItemVersionId: listItemVersionId,
	}
}

// Execute executes the request
func (a *WorkbooksListItemApiService) WorkbooksListItemUpdateVersionsExecute(r ApiWorkbooksListItemUpdateVersionsRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPatch
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "WorkbooksListItemApiService.WorkbooksListItemUpdateVersions")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/workbooks/{driveItem-id}/listItem/versions/{listItemVersion-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"driveItem-id"+"}", _neturl.PathEscape(parameterToString(r.driveItemId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"listItemVersion-id"+"}", _neturl.PathEscape(parameterToString(r.listItemVersionId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphListItemVersion == nil {
		return nil, reportError("microsoftGraphListItemVersion is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphListItemVersion
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiWorkbooksListItemVersionsDeleteFieldsRequest struct {
	ctx _context.Context
	ApiService *WorkbooksListItemApiService
	driveItemId string
	listItemVersionId string
	ifMatch *string
}

// ETag
func (r ApiWorkbooksListItemVersionsDeleteFieldsRequest) IfMatch(ifMatch string) ApiWorkbooksListItemVersionsDeleteFieldsRequest {
	r.ifMatch = &ifMatch
	return r
}

func (r ApiWorkbooksListItemVersionsDeleteFieldsRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.WorkbooksListItemVersionsDeleteFieldsExecute(r)
}

/*
WorkbooksListItemVersionsDeleteFields Delete navigation property fields for workbooks

A collection of the fields and values for this version of the list item.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param driveItemId key: id of driveItem
 @param listItemVersionId key: id of listItemVersion
 @return ApiWorkbooksListItemVersionsDeleteFieldsRequest
*/
func (a *WorkbooksListItemApiService) WorkbooksListItemVersionsDeleteFields(ctx _context.Context, driveItemId string, listItemVersionId string) ApiWorkbooksListItemVersionsDeleteFieldsRequest {
	return ApiWorkbooksListItemVersionsDeleteFieldsRequest{
		ApiService: a,
		ctx: ctx,
		driveItemId: driveItemId,
		listItemVersionId: listItemVersionId,
	}
}

// Execute executes the request
func (a *WorkbooksListItemApiService) WorkbooksListItemVersionsDeleteFieldsExecute(r ApiWorkbooksListItemVersionsDeleteFieldsRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "WorkbooksListItemApiService.WorkbooksListItemVersionsDeleteFields")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/workbooks/{driveItem-id}/listItem/versions/{listItemVersion-id}/fields"
	localVarPath = strings.Replace(localVarPath, "{"+"driveItem-id"+"}", _neturl.PathEscape(parameterToString(r.driveItemId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"listItemVersion-id"+"}", _neturl.PathEscape(parameterToString(r.listItemVersionId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ifMatch != nil {
		localVarHeaderParams["If-Match"] = parameterToString(*r.ifMatch, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiWorkbooksListItemVersionsGetFieldsRequest struct {
	ctx _context.Context
	ApiService *WorkbooksListItemApiService
	driveItemId string
	listItemVersionId string
	select_ *[]string
	expand *[]string
}

// Select properties to be returned
func (r ApiWorkbooksListItemVersionsGetFieldsRequest) Select_(select_ []string) ApiWorkbooksListItemVersionsGetFieldsRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiWorkbooksListItemVersionsGetFieldsRequest) Expand(expand []string) ApiWorkbooksListItemVersionsGetFieldsRequest {
	r.expand = &expand
	return r
}

func (r ApiWorkbooksListItemVersionsGetFieldsRequest) Execute() (MicrosoftGraphFieldValueSet, *_nethttp.Response, error) {
	return r.ApiService.WorkbooksListItemVersionsGetFieldsExecute(r)
}

/*
WorkbooksListItemVersionsGetFields Get fields from workbooks

A collection of the fields and values for this version of the list item.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param driveItemId key: id of driveItem
 @param listItemVersionId key: id of listItemVersion
 @return ApiWorkbooksListItemVersionsGetFieldsRequest
*/
func (a *WorkbooksListItemApiService) WorkbooksListItemVersionsGetFields(ctx _context.Context, driveItemId string, listItemVersionId string) ApiWorkbooksListItemVersionsGetFieldsRequest {
	return ApiWorkbooksListItemVersionsGetFieldsRequest{
		ApiService: a,
		ctx: ctx,
		driveItemId: driveItemId,
		listItemVersionId: listItemVersionId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphFieldValueSet
func (a *WorkbooksListItemApiService) WorkbooksListItemVersionsGetFieldsExecute(r ApiWorkbooksListItemVersionsGetFieldsRequest) (MicrosoftGraphFieldValueSet, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphFieldValueSet
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "WorkbooksListItemApiService.WorkbooksListItemVersionsGetFields")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/workbooks/{driveItem-id}/listItem/versions/{listItemVersion-id}/fields"
	localVarPath = strings.Replace(localVarPath, "{"+"driveItem-id"+"}", _neturl.PathEscape(parameterToString(r.driveItemId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"listItemVersion-id"+"}", _neturl.PathEscape(parameterToString(r.listItemVersionId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiWorkbooksListItemVersionsUpdateFieldsRequest struct {
	ctx _context.Context
	ApiService *WorkbooksListItemApiService
	driveItemId string
	listItemVersionId string
	microsoftGraphFieldValueSet *MicrosoftGraphFieldValueSet
}

// New navigation property values
func (r ApiWorkbooksListItemVersionsUpdateFieldsRequest) MicrosoftGraphFieldValueSet(microsoftGraphFieldValueSet MicrosoftGraphFieldValueSet) ApiWorkbooksListItemVersionsUpdateFieldsRequest {
	r.microsoftGraphFieldValueSet = &microsoftGraphFieldValueSet
	return r
}

func (r ApiWorkbooksListItemVersionsUpdateFieldsRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.WorkbooksListItemVersionsUpdateFieldsExecute(r)
}

/*
WorkbooksListItemVersionsUpdateFields Update the navigation property fields in workbooks

A collection of the fields and values for this version of the list item.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param driveItemId key: id of driveItem
 @param listItemVersionId key: id of listItemVersion
 @return ApiWorkbooksListItemVersionsUpdateFieldsRequest
*/
func (a *WorkbooksListItemApiService) WorkbooksListItemVersionsUpdateFields(ctx _context.Context, driveItemId string, listItemVersionId string) ApiWorkbooksListItemVersionsUpdateFieldsRequest {
	return ApiWorkbooksListItemVersionsUpdateFieldsRequest{
		ApiService: a,
		ctx: ctx,
		driveItemId: driveItemId,
		listItemVersionId: listItemVersionId,
	}
}

// Execute executes the request
func (a *WorkbooksListItemApiService) WorkbooksListItemVersionsUpdateFieldsExecute(r ApiWorkbooksListItemVersionsUpdateFieldsRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPatch
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "WorkbooksListItemApiService.WorkbooksListItemVersionsUpdateFields")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/workbooks/{driveItem-id}/listItem/versions/{listItemVersion-id}/fields"
	localVarPath = strings.Replace(localVarPath, "{"+"driveItem-id"+"}", _neturl.PathEscape(parameterToString(r.driveItemId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"listItemVersion-id"+"}", _neturl.PathEscape(parameterToString(r.listItemVersionId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphFieldValueSet == nil {
		return nil, reportError("microsoftGraphFieldValueSet is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphFieldValueSet
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiWorkbooksUpdateListItemRequest struct {
	ctx _context.Context
	ApiService *WorkbooksListItemApiService
	driveItemId string
	microsoftGraphListItem *MicrosoftGraphListItem
}

// New navigation property values
func (r ApiWorkbooksUpdateListItemRequest) MicrosoftGraphListItem(microsoftGraphListItem MicrosoftGraphListItem) ApiWorkbooksUpdateListItemRequest {
	r.microsoftGraphListItem = &microsoftGraphListItem
	return r
}

func (r ApiWorkbooksUpdateListItemRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.WorkbooksUpdateListItemExecute(r)
}

/*
WorkbooksUpdateListItem Update the navigation property listItem in workbooks

For drives in SharePoint, the associated document library list item. Read-only. Nullable.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param driveItemId key: id of driveItem
 @return ApiWorkbooksUpdateListItemRequest
*/
func (a *WorkbooksListItemApiService) WorkbooksUpdateListItem(ctx _context.Context, driveItemId string) ApiWorkbooksUpdateListItemRequest {
	return ApiWorkbooksUpdateListItemRequest{
		ApiService: a,
		ctx: ctx,
		driveItemId: driveItemId,
	}
}

// Execute executes the request
func (a *WorkbooksListItemApiService) WorkbooksUpdateListItemExecute(r ApiWorkbooksUpdateListItemRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPatch
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "WorkbooksListItemApiService.WorkbooksUpdateListItem")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/workbooks/{driveItem-id}/listItem"
	localVarPath = strings.Replace(localVarPath, "{"+"driveItem-id"+"}", _neturl.PathEscape(parameterToString(r.driveItemId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphListItem == nil {
		return nil, reportError("microsoftGraphListItem is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphListItem
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}
