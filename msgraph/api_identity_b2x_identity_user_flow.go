/*
Partial Graph API

No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

API version: v1.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package openapi

import (
	"bytes"
	_context "context"
	_ioutil "io/ioutil"
	_nethttp "net/http"
	_neturl "net/url"
	"strings"
	"os"
)

// Linger please
var (
	_ _context.Context
)

// IdentityB2xIdentityUserFlowApiService IdentityB2xIdentityUserFlowApi service
type IdentityB2xIdentityUserFlowApiService service

type ApiIdentityB2xUserFlowsCreateLanguagesRequest struct {
	ctx _context.Context
	ApiService *IdentityB2xIdentityUserFlowApiService
	b2xIdentityUserFlowId string
	microsoftGraphUserFlowLanguageConfiguration *MicrosoftGraphUserFlowLanguageConfiguration
}

// New navigation property
func (r ApiIdentityB2xUserFlowsCreateLanguagesRequest) MicrosoftGraphUserFlowLanguageConfiguration(microsoftGraphUserFlowLanguageConfiguration MicrosoftGraphUserFlowLanguageConfiguration) ApiIdentityB2xUserFlowsCreateLanguagesRequest {
	r.microsoftGraphUserFlowLanguageConfiguration = &microsoftGraphUserFlowLanguageConfiguration
	return r
}

func (r ApiIdentityB2xUserFlowsCreateLanguagesRequest) Execute() (MicrosoftGraphUserFlowLanguageConfiguration, *_nethttp.Response, error) {
	return r.ApiService.IdentityB2xUserFlowsCreateLanguagesExecute(r)
}

/*
IdentityB2xUserFlowsCreateLanguages Create new navigation property to languages for identity

The languages supported for customization within the user flow. Language customization is enabled by default in self-service sign-up user flow. You cannot create custom languages in self-service sign-up user flows.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param b2xIdentityUserFlowId key: id of b2xIdentityUserFlow
 @return ApiIdentityB2xUserFlowsCreateLanguagesRequest
*/
func (a *IdentityB2xIdentityUserFlowApiService) IdentityB2xUserFlowsCreateLanguages(ctx _context.Context, b2xIdentityUserFlowId string) ApiIdentityB2xUserFlowsCreateLanguagesRequest {
	return ApiIdentityB2xUserFlowsCreateLanguagesRequest{
		ApiService: a,
		ctx: ctx,
		b2xIdentityUserFlowId: b2xIdentityUserFlowId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphUserFlowLanguageConfiguration
func (a *IdentityB2xIdentityUserFlowApiService) IdentityB2xUserFlowsCreateLanguagesExecute(r ApiIdentityB2xUserFlowsCreateLanguagesRequest) (MicrosoftGraphUserFlowLanguageConfiguration, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphUserFlowLanguageConfiguration
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IdentityB2xIdentityUserFlowApiService.IdentityB2xUserFlowsCreateLanguages")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/identity/b2xUserFlows/{b2xIdentityUserFlow-id}/languages"
	localVarPath = strings.Replace(localVarPath, "{"+"b2xIdentityUserFlow-id"+"}", _neturl.PathEscape(parameterToString(r.b2xIdentityUserFlowId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphUserFlowLanguageConfiguration == nil {
		return localVarReturnValue, nil, reportError("microsoftGraphUserFlowLanguageConfiguration is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphUserFlowLanguageConfiguration
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIdentityB2xUserFlowsCreateRefIdentityProvidersRequest struct {
	ctx _context.Context
	ApiService *IdentityB2xIdentityUserFlowApiService
	b2xIdentityUserFlowId string
	requestBody *map[string]map[string]interface{}
}

// New navigation property ref value
func (r ApiIdentityB2xUserFlowsCreateRefIdentityProvidersRequest) RequestBody(requestBody map[string]map[string]interface{}) ApiIdentityB2xUserFlowsCreateRefIdentityProvidersRequest {
	r.requestBody = &requestBody
	return r
}

func (r ApiIdentityB2xUserFlowsCreateRefIdentityProvidersRequest) Execute() (map[string]interface{}, *_nethttp.Response, error) {
	return r.ApiService.IdentityB2xUserFlowsCreateRefIdentityProvidersExecute(r)
}

/*
IdentityB2xUserFlowsCreateRefIdentityProviders Create new navigation property ref to identityProviders for identity

The identity providers included in the user flow.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param b2xIdentityUserFlowId key: id of b2xIdentityUserFlow
 @return ApiIdentityB2xUserFlowsCreateRefIdentityProvidersRequest
*/
func (a *IdentityB2xIdentityUserFlowApiService) IdentityB2xUserFlowsCreateRefIdentityProviders(ctx _context.Context, b2xIdentityUserFlowId string) ApiIdentityB2xUserFlowsCreateRefIdentityProvidersRequest {
	return ApiIdentityB2xUserFlowsCreateRefIdentityProvidersRequest{
		ApiService: a,
		ctx: ctx,
		b2xIdentityUserFlowId: b2xIdentityUserFlowId,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *IdentityB2xIdentityUserFlowApiService) IdentityB2xUserFlowsCreateRefIdentityProvidersExecute(r ApiIdentityB2xUserFlowsCreateRefIdentityProvidersRequest) (map[string]interface{}, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IdentityB2xIdentityUserFlowApiService.IdentityB2xUserFlowsCreateRefIdentityProviders")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/identity/b2xUserFlows/{b2xIdentityUserFlow-id}/identityProviders/$ref"
	localVarPath = strings.Replace(localVarPath, "{"+"b2xIdentityUserFlow-id"+"}", _neturl.PathEscape(parameterToString(r.b2xIdentityUserFlowId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.requestBody == nil {
		return localVarReturnValue, nil, reportError("requestBody is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.requestBody
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIdentityB2xUserFlowsCreateRefUserFlowIdentityProvidersRequest struct {
	ctx _context.Context
	ApiService *IdentityB2xIdentityUserFlowApiService
	b2xIdentityUserFlowId string
	requestBody *map[string]map[string]interface{}
}

// New navigation property ref value
func (r ApiIdentityB2xUserFlowsCreateRefUserFlowIdentityProvidersRequest) RequestBody(requestBody map[string]map[string]interface{}) ApiIdentityB2xUserFlowsCreateRefUserFlowIdentityProvidersRequest {
	r.requestBody = &requestBody
	return r
}

func (r ApiIdentityB2xUserFlowsCreateRefUserFlowIdentityProvidersRequest) Execute() (map[string]interface{}, *_nethttp.Response, error) {
	return r.ApiService.IdentityB2xUserFlowsCreateRefUserFlowIdentityProvidersExecute(r)
}

/*
IdentityB2xUserFlowsCreateRefUserFlowIdentityProviders Create new navigation property ref to userFlowIdentityProviders for identity

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param b2xIdentityUserFlowId key: id of b2xIdentityUserFlow
 @return ApiIdentityB2xUserFlowsCreateRefUserFlowIdentityProvidersRequest
*/
func (a *IdentityB2xIdentityUserFlowApiService) IdentityB2xUserFlowsCreateRefUserFlowIdentityProviders(ctx _context.Context, b2xIdentityUserFlowId string) ApiIdentityB2xUserFlowsCreateRefUserFlowIdentityProvidersRequest {
	return ApiIdentityB2xUserFlowsCreateRefUserFlowIdentityProvidersRequest{
		ApiService: a,
		ctx: ctx,
		b2xIdentityUserFlowId: b2xIdentityUserFlowId,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *IdentityB2xIdentityUserFlowApiService) IdentityB2xUserFlowsCreateRefUserFlowIdentityProvidersExecute(r ApiIdentityB2xUserFlowsCreateRefUserFlowIdentityProvidersRequest) (map[string]interface{}, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IdentityB2xIdentityUserFlowApiService.IdentityB2xUserFlowsCreateRefUserFlowIdentityProviders")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/identity/b2xUserFlows/{b2xIdentityUserFlow-id}/userFlowIdentityProviders/$ref"
	localVarPath = strings.Replace(localVarPath, "{"+"b2xIdentityUserFlow-id"+"}", _neturl.PathEscape(parameterToString(r.b2xIdentityUserFlowId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.requestBody == nil {
		return localVarReturnValue, nil, reportError("requestBody is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.requestBody
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIdentityB2xUserFlowsCreateUserAttributeAssignmentsRequest struct {
	ctx _context.Context
	ApiService *IdentityB2xIdentityUserFlowApiService
	b2xIdentityUserFlowId string
	microsoftGraphIdentityUserFlowAttributeAssignment *MicrosoftGraphIdentityUserFlowAttributeAssignment
}

// New navigation property
func (r ApiIdentityB2xUserFlowsCreateUserAttributeAssignmentsRequest) MicrosoftGraphIdentityUserFlowAttributeAssignment(microsoftGraphIdentityUserFlowAttributeAssignment MicrosoftGraphIdentityUserFlowAttributeAssignment) ApiIdentityB2xUserFlowsCreateUserAttributeAssignmentsRequest {
	r.microsoftGraphIdentityUserFlowAttributeAssignment = &microsoftGraphIdentityUserFlowAttributeAssignment
	return r
}

func (r ApiIdentityB2xUserFlowsCreateUserAttributeAssignmentsRequest) Execute() (MicrosoftGraphIdentityUserFlowAttributeAssignment, *_nethttp.Response, error) {
	return r.ApiService.IdentityB2xUserFlowsCreateUserAttributeAssignmentsExecute(r)
}

/*
IdentityB2xUserFlowsCreateUserAttributeAssignments Create new navigation property to userAttributeAssignments for identity

The user attribute assignments included in the user flow.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param b2xIdentityUserFlowId key: id of b2xIdentityUserFlow
 @return ApiIdentityB2xUserFlowsCreateUserAttributeAssignmentsRequest
*/
func (a *IdentityB2xIdentityUserFlowApiService) IdentityB2xUserFlowsCreateUserAttributeAssignments(ctx _context.Context, b2xIdentityUserFlowId string) ApiIdentityB2xUserFlowsCreateUserAttributeAssignmentsRequest {
	return ApiIdentityB2xUserFlowsCreateUserAttributeAssignmentsRequest{
		ApiService: a,
		ctx: ctx,
		b2xIdentityUserFlowId: b2xIdentityUserFlowId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphIdentityUserFlowAttributeAssignment
func (a *IdentityB2xIdentityUserFlowApiService) IdentityB2xUserFlowsCreateUserAttributeAssignmentsExecute(r ApiIdentityB2xUserFlowsCreateUserAttributeAssignmentsRequest) (MicrosoftGraphIdentityUserFlowAttributeAssignment, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphIdentityUserFlowAttributeAssignment
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IdentityB2xIdentityUserFlowApiService.IdentityB2xUserFlowsCreateUserAttributeAssignments")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/identity/b2xUserFlows/{b2xIdentityUserFlow-id}/userAttributeAssignments"
	localVarPath = strings.Replace(localVarPath, "{"+"b2xIdentityUserFlow-id"+"}", _neturl.PathEscape(parameterToString(r.b2xIdentityUserFlowId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphIdentityUserFlowAttributeAssignment == nil {
		return localVarReturnValue, nil, reportError("microsoftGraphIdentityUserFlowAttributeAssignment is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphIdentityUserFlowAttributeAssignment
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIdentityB2xUserFlowsDeleteLanguagesRequest struct {
	ctx _context.Context
	ApiService *IdentityB2xIdentityUserFlowApiService
	b2xIdentityUserFlowId string
	userFlowLanguageConfigurationId string
	ifMatch *string
}

// ETag
func (r ApiIdentityB2xUserFlowsDeleteLanguagesRequest) IfMatch(ifMatch string) ApiIdentityB2xUserFlowsDeleteLanguagesRequest {
	r.ifMatch = &ifMatch
	return r
}

func (r ApiIdentityB2xUserFlowsDeleteLanguagesRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.IdentityB2xUserFlowsDeleteLanguagesExecute(r)
}

/*
IdentityB2xUserFlowsDeleteLanguages Delete navigation property languages for identity

The languages supported for customization within the user flow. Language customization is enabled by default in self-service sign-up user flow. You cannot create custom languages in self-service sign-up user flows.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param b2xIdentityUserFlowId key: id of b2xIdentityUserFlow
 @param userFlowLanguageConfigurationId key: id of userFlowLanguageConfiguration
 @return ApiIdentityB2xUserFlowsDeleteLanguagesRequest
*/
func (a *IdentityB2xIdentityUserFlowApiService) IdentityB2xUserFlowsDeleteLanguages(ctx _context.Context, b2xIdentityUserFlowId string, userFlowLanguageConfigurationId string) ApiIdentityB2xUserFlowsDeleteLanguagesRequest {
	return ApiIdentityB2xUserFlowsDeleteLanguagesRequest{
		ApiService: a,
		ctx: ctx,
		b2xIdentityUserFlowId: b2xIdentityUserFlowId,
		userFlowLanguageConfigurationId: userFlowLanguageConfigurationId,
	}
}

// Execute executes the request
func (a *IdentityB2xIdentityUserFlowApiService) IdentityB2xUserFlowsDeleteLanguagesExecute(r ApiIdentityB2xUserFlowsDeleteLanguagesRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IdentityB2xIdentityUserFlowApiService.IdentityB2xUserFlowsDeleteLanguages")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/identity/b2xUserFlows/{b2xIdentityUserFlow-id}/languages/{userFlowLanguageConfiguration-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"b2xIdentityUserFlow-id"+"}", _neturl.PathEscape(parameterToString(r.b2xIdentityUserFlowId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"userFlowLanguageConfiguration-id"+"}", _neturl.PathEscape(parameterToString(r.userFlowLanguageConfigurationId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ifMatch != nil {
		localVarHeaderParams["If-Match"] = parameterToString(*r.ifMatch, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiIdentityB2xUserFlowsDeleteUserAttributeAssignmentsRequest struct {
	ctx _context.Context
	ApiService *IdentityB2xIdentityUserFlowApiService
	b2xIdentityUserFlowId string
	identityUserFlowAttributeAssignmentId string
	ifMatch *string
}

// ETag
func (r ApiIdentityB2xUserFlowsDeleteUserAttributeAssignmentsRequest) IfMatch(ifMatch string) ApiIdentityB2xUserFlowsDeleteUserAttributeAssignmentsRequest {
	r.ifMatch = &ifMatch
	return r
}

func (r ApiIdentityB2xUserFlowsDeleteUserAttributeAssignmentsRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.IdentityB2xUserFlowsDeleteUserAttributeAssignmentsExecute(r)
}

/*
IdentityB2xUserFlowsDeleteUserAttributeAssignments Delete navigation property userAttributeAssignments for identity

The user attribute assignments included in the user flow.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param b2xIdentityUserFlowId key: id of b2xIdentityUserFlow
 @param identityUserFlowAttributeAssignmentId key: id of identityUserFlowAttributeAssignment
 @return ApiIdentityB2xUserFlowsDeleteUserAttributeAssignmentsRequest
*/
func (a *IdentityB2xIdentityUserFlowApiService) IdentityB2xUserFlowsDeleteUserAttributeAssignments(ctx _context.Context, b2xIdentityUserFlowId string, identityUserFlowAttributeAssignmentId string) ApiIdentityB2xUserFlowsDeleteUserAttributeAssignmentsRequest {
	return ApiIdentityB2xUserFlowsDeleteUserAttributeAssignmentsRequest{
		ApiService: a,
		ctx: ctx,
		b2xIdentityUserFlowId: b2xIdentityUserFlowId,
		identityUserFlowAttributeAssignmentId: identityUserFlowAttributeAssignmentId,
	}
}

// Execute executes the request
func (a *IdentityB2xIdentityUserFlowApiService) IdentityB2xUserFlowsDeleteUserAttributeAssignmentsExecute(r ApiIdentityB2xUserFlowsDeleteUserAttributeAssignmentsRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IdentityB2xIdentityUserFlowApiService.IdentityB2xUserFlowsDeleteUserAttributeAssignments")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/identity/b2xUserFlows/{b2xIdentityUserFlow-id}/userAttributeAssignments/{identityUserFlowAttributeAssignment-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"b2xIdentityUserFlow-id"+"}", _neturl.PathEscape(parameterToString(r.b2xIdentityUserFlowId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"identityUserFlowAttributeAssignment-id"+"}", _neturl.PathEscape(parameterToString(r.identityUserFlowAttributeAssignmentId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ifMatch != nil {
		localVarHeaderParams["If-Match"] = parameterToString(*r.ifMatch, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiIdentityB2xUserFlowsGetLanguagesRequest struct {
	ctx _context.Context
	ApiService *IdentityB2xIdentityUserFlowApiService
	b2xIdentityUserFlowId string
	userFlowLanguageConfigurationId string
	select_ *[]string
	expand *[]string
}

// Select properties to be returned
func (r ApiIdentityB2xUserFlowsGetLanguagesRequest) Select_(select_ []string) ApiIdentityB2xUserFlowsGetLanguagesRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiIdentityB2xUserFlowsGetLanguagesRequest) Expand(expand []string) ApiIdentityB2xUserFlowsGetLanguagesRequest {
	r.expand = &expand
	return r
}

func (r ApiIdentityB2xUserFlowsGetLanguagesRequest) Execute() (MicrosoftGraphUserFlowLanguageConfiguration, *_nethttp.Response, error) {
	return r.ApiService.IdentityB2xUserFlowsGetLanguagesExecute(r)
}

/*
IdentityB2xUserFlowsGetLanguages Get languages from identity

The languages supported for customization within the user flow. Language customization is enabled by default in self-service sign-up user flow. You cannot create custom languages in self-service sign-up user flows.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param b2xIdentityUserFlowId key: id of b2xIdentityUserFlow
 @param userFlowLanguageConfigurationId key: id of userFlowLanguageConfiguration
 @return ApiIdentityB2xUserFlowsGetLanguagesRequest
*/
func (a *IdentityB2xIdentityUserFlowApiService) IdentityB2xUserFlowsGetLanguages(ctx _context.Context, b2xIdentityUserFlowId string, userFlowLanguageConfigurationId string) ApiIdentityB2xUserFlowsGetLanguagesRequest {
	return ApiIdentityB2xUserFlowsGetLanguagesRequest{
		ApiService: a,
		ctx: ctx,
		b2xIdentityUserFlowId: b2xIdentityUserFlowId,
		userFlowLanguageConfigurationId: userFlowLanguageConfigurationId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphUserFlowLanguageConfiguration
func (a *IdentityB2xIdentityUserFlowApiService) IdentityB2xUserFlowsGetLanguagesExecute(r ApiIdentityB2xUserFlowsGetLanguagesRequest) (MicrosoftGraphUserFlowLanguageConfiguration, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphUserFlowLanguageConfiguration
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IdentityB2xIdentityUserFlowApiService.IdentityB2xUserFlowsGetLanguages")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/identity/b2xUserFlows/{b2xIdentityUserFlow-id}/languages/{userFlowLanguageConfiguration-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"b2xIdentityUserFlow-id"+"}", _neturl.PathEscape(parameterToString(r.b2xIdentityUserFlowId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"userFlowLanguageConfiguration-id"+"}", _neturl.PathEscape(parameterToString(r.userFlowLanguageConfigurationId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIdentityB2xUserFlowsGetUserAttributeAssignmentsRequest struct {
	ctx _context.Context
	ApiService *IdentityB2xIdentityUserFlowApiService
	b2xIdentityUserFlowId string
	identityUserFlowAttributeAssignmentId string
	select_ *[]string
	expand *[]string
}

// Select properties to be returned
func (r ApiIdentityB2xUserFlowsGetUserAttributeAssignmentsRequest) Select_(select_ []string) ApiIdentityB2xUserFlowsGetUserAttributeAssignmentsRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiIdentityB2xUserFlowsGetUserAttributeAssignmentsRequest) Expand(expand []string) ApiIdentityB2xUserFlowsGetUserAttributeAssignmentsRequest {
	r.expand = &expand
	return r
}

func (r ApiIdentityB2xUserFlowsGetUserAttributeAssignmentsRequest) Execute() (MicrosoftGraphIdentityUserFlowAttributeAssignment, *_nethttp.Response, error) {
	return r.ApiService.IdentityB2xUserFlowsGetUserAttributeAssignmentsExecute(r)
}

/*
IdentityB2xUserFlowsGetUserAttributeAssignments Get userAttributeAssignments from identity

The user attribute assignments included in the user flow.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param b2xIdentityUserFlowId key: id of b2xIdentityUserFlow
 @param identityUserFlowAttributeAssignmentId key: id of identityUserFlowAttributeAssignment
 @return ApiIdentityB2xUserFlowsGetUserAttributeAssignmentsRequest
*/
func (a *IdentityB2xIdentityUserFlowApiService) IdentityB2xUserFlowsGetUserAttributeAssignments(ctx _context.Context, b2xIdentityUserFlowId string, identityUserFlowAttributeAssignmentId string) ApiIdentityB2xUserFlowsGetUserAttributeAssignmentsRequest {
	return ApiIdentityB2xUserFlowsGetUserAttributeAssignmentsRequest{
		ApiService: a,
		ctx: ctx,
		b2xIdentityUserFlowId: b2xIdentityUserFlowId,
		identityUserFlowAttributeAssignmentId: identityUserFlowAttributeAssignmentId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphIdentityUserFlowAttributeAssignment
func (a *IdentityB2xIdentityUserFlowApiService) IdentityB2xUserFlowsGetUserAttributeAssignmentsExecute(r ApiIdentityB2xUserFlowsGetUserAttributeAssignmentsRequest) (MicrosoftGraphIdentityUserFlowAttributeAssignment, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphIdentityUserFlowAttributeAssignment
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IdentityB2xIdentityUserFlowApiService.IdentityB2xUserFlowsGetUserAttributeAssignments")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/identity/b2xUserFlows/{b2xIdentityUserFlow-id}/userAttributeAssignments/{identityUserFlowAttributeAssignment-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"b2xIdentityUserFlow-id"+"}", _neturl.PathEscape(parameterToString(r.b2xIdentityUserFlowId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"identityUserFlowAttributeAssignment-id"+"}", _neturl.PathEscape(parameterToString(r.identityUserFlowAttributeAssignmentId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIdentityB2xUserFlowsLanguagesCreateDefaultPagesRequest struct {
	ctx _context.Context
	ApiService *IdentityB2xIdentityUserFlowApiService
	b2xIdentityUserFlowId string
	userFlowLanguageConfigurationId string
	microsoftGraphUserFlowLanguagePage *MicrosoftGraphUserFlowLanguagePage
}

// New navigation property
func (r ApiIdentityB2xUserFlowsLanguagesCreateDefaultPagesRequest) MicrosoftGraphUserFlowLanguagePage(microsoftGraphUserFlowLanguagePage MicrosoftGraphUserFlowLanguagePage) ApiIdentityB2xUserFlowsLanguagesCreateDefaultPagesRequest {
	r.microsoftGraphUserFlowLanguagePage = &microsoftGraphUserFlowLanguagePage
	return r
}

func (r ApiIdentityB2xUserFlowsLanguagesCreateDefaultPagesRequest) Execute() (MicrosoftGraphUserFlowLanguagePage, *_nethttp.Response, error) {
	return r.ApiService.IdentityB2xUserFlowsLanguagesCreateDefaultPagesExecute(r)
}

/*
IdentityB2xUserFlowsLanguagesCreateDefaultPages Create new navigation property to defaultPages for identity

Collection of pages with the default content to display in a user flow for a specified language. This collection does not allow any kind of modification.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param b2xIdentityUserFlowId key: id of b2xIdentityUserFlow
 @param userFlowLanguageConfigurationId key: id of userFlowLanguageConfiguration
 @return ApiIdentityB2xUserFlowsLanguagesCreateDefaultPagesRequest
*/
func (a *IdentityB2xIdentityUserFlowApiService) IdentityB2xUserFlowsLanguagesCreateDefaultPages(ctx _context.Context, b2xIdentityUserFlowId string, userFlowLanguageConfigurationId string) ApiIdentityB2xUserFlowsLanguagesCreateDefaultPagesRequest {
	return ApiIdentityB2xUserFlowsLanguagesCreateDefaultPagesRequest{
		ApiService: a,
		ctx: ctx,
		b2xIdentityUserFlowId: b2xIdentityUserFlowId,
		userFlowLanguageConfigurationId: userFlowLanguageConfigurationId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphUserFlowLanguagePage
func (a *IdentityB2xIdentityUserFlowApiService) IdentityB2xUserFlowsLanguagesCreateDefaultPagesExecute(r ApiIdentityB2xUserFlowsLanguagesCreateDefaultPagesRequest) (MicrosoftGraphUserFlowLanguagePage, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphUserFlowLanguagePage
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IdentityB2xIdentityUserFlowApiService.IdentityB2xUserFlowsLanguagesCreateDefaultPages")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/identity/b2xUserFlows/{b2xIdentityUserFlow-id}/languages/{userFlowLanguageConfiguration-id}/defaultPages"
	localVarPath = strings.Replace(localVarPath, "{"+"b2xIdentityUserFlow-id"+"}", _neturl.PathEscape(parameterToString(r.b2xIdentityUserFlowId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"userFlowLanguageConfiguration-id"+"}", _neturl.PathEscape(parameterToString(r.userFlowLanguageConfigurationId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphUserFlowLanguagePage == nil {
		return localVarReturnValue, nil, reportError("microsoftGraphUserFlowLanguagePage is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphUserFlowLanguagePage
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIdentityB2xUserFlowsLanguagesCreateOverridesPagesRequest struct {
	ctx _context.Context
	ApiService *IdentityB2xIdentityUserFlowApiService
	b2xIdentityUserFlowId string
	userFlowLanguageConfigurationId string
	microsoftGraphUserFlowLanguagePage *MicrosoftGraphUserFlowLanguagePage
}

// New navigation property
func (r ApiIdentityB2xUserFlowsLanguagesCreateOverridesPagesRequest) MicrosoftGraphUserFlowLanguagePage(microsoftGraphUserFlowLanguagePage MicrosoftGraphUserFlowLanguagePage) ApiIdentityB2xUserFlowsLanguagesCreateOverridesPagesRequest {
	r.microsoftGraphUserFlowLanguagePage = &microsoftGraphUserFlowLanguagePage
	return r
}

func (r ApiIdentityB2xUserFlowsLanguagesCreateOverridesPagesRequest) Execute() (MicrosoftGraphUserFlowLanguagePage, *_nethttp.Response, error) {
	return r.ApiService.IdentityB2xUserFlowsLanguagesCreateOverridesPagesExecute(r)
}

/*
IdentityB2xUserFlowsLanguagesCreateOverridesPages Create new navigation property to overridesPages for identity

Collection of pages with the overrides messages to display in a user flow for a specified language. This collection only allows to modify the content of the page, any other modification is not allowed (creation or deletion of pages).

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param b2xIdentityUserFlowId key: id of b2xIdentityUserFlow
 @param userFlowLanguageConfigurationId key: id of userFlowLanguageConfiguration
 @return ApiIdentityB2xUserFlowsLanguagesCreateOverridesPagesRequest
*/
func (a *IdentityB2xIdentityUserFlowApiService) IdentityB2xUserFlowsLanguagesCreateOverridesPages(ctx _context.Context, b2xIdentityUserFlowId string, userFlowLanguageConfigurationId string) ApiIdentityB2xUserFlowsLanguagesCreateOverridesPagesRequest {
	return ApiIdentityB2xUserFlowsLanguagesCreateOverridesPagesRequest{
		ApiService: a,
		ctx: ctx,
		b2xIdentityUserFlowId: b2xIdentityUserFlowId,
		userFlowLanguageConfigurationId: userFlowLanguageConfigurationId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphUserFlowLanguagePage
func (a *IdentityB2xIdentityUserFlowApiService) IdentityB2xUserFlowsLanguagesCreateOverridesPagesExecute(r ApiIdentityB2xUserFlowsLanguagesCreateOverridesPagesRequest) (MicrosoftGraphUserFlowLanguagePage, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphUserFlowLanguagePage
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IdentityB2xIdentityUserFlowApiService.IdentityB2xUserFlowsLanguagesCreateOverridesPages")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/identity/b2xUserFlows/{b2xIdentityUserFlow-id}/languages/{userFlowLanguageConfiguration-id}/overridesPages"
	localVarPath = strings.Replace(localVarPath, "{"+"b2xIdentityUserFlow-id"+"}", _neturl.PathEscape(parameterToString(r.b2xIdentityUserFlowId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"userFlowLanguageConfiguration-id"+"}", _neturl.PathEscape(parameterToString(r.userFlowLanguageConfigurationId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphUserFlowLanguagePage == nil {
		return localVarReturnValue, nil, reportError("microsoftGraphUserFlowLanguagePage is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphUserFlowLanguagePage
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIdentityB2xUserFlowsLanguagesDeleteDefaultPagesRequest struct {
	ctx _context.Context
	ApiService *IdentityB2xIdentityUserFlowApiService
	b2xIdentityUserFlowId string
	userFlowLanguageConfigurationId string
	userFlowLanguagePageId string
	ifMatch *string
}

// ETag
func (r ApiIdentityB2xUserFlowsLanguagesDeleteDefaultPagesRequest) IfMatch(ifMatch string) ApiIdentityB2xUserFlowsLanguagesDeleteDefaultPagesRequest {
	r.ifMatch = &ifMatch
	return r
}

func (r ApiIdentityB2xUserFlowsLanguagesDeleteDefaultPagesRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.IdentityB2xUserFlowsLanguagesDeleteDefaultPagesExecute(r)
}

/*
IdentityB2xUserFlowsLanguagesDeleteDefaultPages Delete navigation property defaultPages for identity

Collection of pages with the default content to display in a user flow for a specified language. This collection does not allow any kind of modification.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param b2xIdentityUserFlowId key: id of b2xIdentityUserFlow
 @param userFlowLanguageConfigurationId key: id of userFlowLanguageConfiguration
 @param userFlowLanguagePageId key: id of userFlowLanguagePage
 @return ApiIdentityB2xUserFlowsLanguagesDeleteDefaultPagesRequest
*/
func (a *IdentityB2xIdentityUserFlowApiService) IdentityB2xUserFlowsLanguagesDeleteDefaultPages(ctx _context.Context, b2xIdentityUserFlowId string, userFlowLanguageConfigurationId string, userFlowLanguagePageId string) ApiIdentityB2xUserFlowsLanguagesDeleteDefaultPagesRequest {
	return ApiIdentityB2xUserFlowsLanguagesDeleteDefaultPagesRequest{
		ApiService: a,
		ctx: ctx,
		b2xIdentityUserFlowId: b2xIdentityUserFlowId,
		userFlowLanguageConfigurationId: userFlowLanguageConfigurationId,
		userFlowLanguagePageId: userFlowLanguagePageId,
	}
}

// Execute executes the request
func (a *IdentityB2xIdentityUserFlowApiService) IdentityB2xUserFlowsLanguagesDeleteDefaultPagesExecute(r ApiIdentityB2xUserFlowsLanguagesDeleteDefaultPagesRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IdentityB2xIdentityUserFlowApiService.IdentityB2xUserFlowsLanguagesDeleteDefaultPages")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/identity/b2xUserFlows/{b2xIdentityUserFlow-id}/languages/{userFlowLanguageConfiguration-id}/defaultPages/{userFlowLanguagePage-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"b2xIdentityUserFlow-id"+"}", _neturl.PathEscape(parameterToString(r.b2xIdentityUserFlowId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"userFlowLanguageConfiguration-id"+"}", _neturl.PathEscape(parameterToString(r.userFlowLanguageConfigurationId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"userFlowLanguagePage-id"+"}", _neturl.PathEscape(parameterToString(r.userFlowLanguagePageId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ifMatch != nil {
		localVarHeaderParams["If-Match"] = parameterToString(*r.ifMatch, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiIdentityB2xUserFlowsLanguagesDeleteOverridesPagesRequest struct {
	ctx _context.Context
	ApiService *IdentityB2xIdentityUserFlowApiService
	b2xIdentityUserFlowId string
	userFlowLanguageConfigurationId string
	userFlowLanguagePageId string
	ifMatch *string
}

// ETag
func (r ApiIdentityB2xUserFlowsLanguagesDeleteOverridesPagesRequest) IfMatch(ifMatch string) ApiIdentityB2xUserFlowsLanguagesDeleteOverridesPagesRequest {
	r.ifMatch = &ifMatch
	return r
}

func (r ApiIdentityB2xUserFlowsLanguagesDeleteOverridesPagesRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.IdentityB2xUserFlowsLanguagesDeleteOverridesPagesExecute(r)
}

/*
IdentityB2xUserFlowsLanguagesDeleteOverridesPages Delete navigation property overridesPages for identity

Collection of pages with the overrides messages to display in a user flow for a specified language. This collection only allows to modify the content of the page, any other modification is not allowed (creation or deletion of pages).

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param b2xIdentityUserFlowId key: id of b2xIdentityUserFlow
 @param userFlowLanguageConfigurationId key: id of userFlowLanguageConfiguration
 @param userFlowLanguagePageId key: id of userFlowLanguagePage
 @return ApiIdentityB2xUserFlowsLanguagesDeleteOverridesPagesRequest
*/
func (a *IdentityB2xIdentityUserFlowApiService) IdentityB2xUserFlowsLanguagesDeleteOverridesPages(ctx _context.Context, b2xIdentityUserFlowId string, userFlowLanguageConfigurationId string, userFlowLanguagePageId string) ApiIdentityB2xUserFlowsLanguagesDeleteOverridesPagesRequest {
	return ApiIdentityB2xUserFlowsLanguagesDeleteOverridesPagesRequest{
		ApiService: a,
		ctx: ctx,
		b2xIdentityUserFlowId: b2xIdentityUserFlowId,
		userFlowLanguageConfigurationId: userFlowLanguageConfigurationId,
		userFlowLanguagePageId: userFlowLanguagePageId,
	}
}

// Execute executes the request
func (a *IdentityB2xIdentityUserFlowApiService) IdentityB2xUserFlowsLanguagesDeleteOverridesPagesExecute(r ApiIdentityB2xUserFlowsLanguagesDeleteOverridesPagesRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IdentityB2xIdentityUserFlowApiService.IdentityB2xUserFlowsLanguagesDeleteOverridesPages")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/identity/b2xUserFlows/{b2xIdentityUserFlow-id}/languages/{userFlowLanguageConfiguration-id}/overridesPages/{userFlowLanguagePage-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"b2xIdentityUserFlow-id"+"}", _neturl.PathEscape(parameterToString(r.b2xIdentityUserFlowId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"userFlowLanguageConfiguration-id"+"}", _neturl.PathEscape(parameterToString(r.userFlowLanguageConfigurationId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"userFlowLanguagePage-id"+"}", _neturl.PathEscape(parameterToString(r.userFlowLanguagePageId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ifMatch != nil {
		localVarHeaderParams["If-Match"] = parameterToString(*r.ifMatch, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiIdentityB2xUserFlowsLanguagesGetDefaultPagesRequest struct {
	ctx _context.Context
	ApiService *IdentityB2xIdentityUserFlowApiService
	b2xIdentityUserFlowId string
	userFlowLanguageConfigurationId string
	userFlowLanguagePageId string
	select_ *[]string
	expand *[]string
}

// Select properties to be returned
func (r ApiIdentityB2xUserFlowsLanguagesGetDefaultPagesRequest) Select_(select_ []string) ApiIdentityB2xUserFlowsLanguagesGetDefaultPagesRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiIdentityB2xUserFlowsLanguagesGetDefaultPagesRequest) Expand(expand []string) ApiIdentityB2xUserFlowsLanguagesGetDefaultPagesRequest {
	r.expand = &expand
	return r
}

func (r ApiIdentityB2xUserFlowsLanguagesGetDefaultPagesRequest) Execute() (MicrosoftGraphUserFlowLanguagePage, *_nethttp.Response, error) {
	return r.ApiService.IdentityB2xUserFlowsLanguagesGetDefaultPagesExecute(r)
}

/*
IdentityB2xUserFlowsLanguagesGetDefaultPages Get defaultPages from identity

Collection of pages with the default content to display in a user flow for a specified language. This collection does not allow any kind of modification.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param b2xIdentityUserFlowId key: id of b2xIdentityUserFlow
 @param userFlowLanguageConfigurationId key: id of userFlowLanguageConfiguration
 @param userFlowLanguagePageId key: id of userFlowLanguagePage
 @return ApiIdentityB2xUserFlowsLanguagesGetDefaultPagesRequest
*/
func (a *IdentityB2xIdentityUserFlowApiService) IdentityB2xUserFlowsLanguagesGetDefaultPages(ctx _context.Context, b2xIdentityUserFlowId string, userFlowLanguageConfigurationId string, userFlowLanguagePageId string) ApiIdentityB2xUserFlowsLanguagesGetDefaultPagesRequest {
	return ApiIdentityB2xUserFlowsLanguagesGetDefaultPagesRequest{
		ApiService: a,
		ctx: ctx,
		b2xIdentityUserFlowId: b2xIdentityUserFlowId,
		userFlowLanguageConfigurationId: userFlowLanguageConfigurationId,
		userFlowLanguagePageId: userFlowLanguagePageId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphUserFlowLanguagePage
func (a *IdentityB2xIdentityUserFlowApiService) IdentityB2xUserFlowsLanguagesGetDefaultPagesExecute(r ApiIdentityB2xUserFlowsLanguagesGetDefaultPagesRequest) (MicrosoftGraphUserFlowLanguagePage, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphUserFlowLanguagePage
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IdentityB2xIdentityUserFlowApiService.IdentityB2xUserFlowsLanguagesGetDefaultPages")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/identity/b2xUserFlows/{b2xIdentityUserFlow-id}/languages/{userFlowLanguageConfiguration-id}/defaultPages/{userFlowLanguagePage-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"b2xIdentityUserFlow-id"+"}", _neturl.PathEscape(parameterToString(r.b2xIdentityUserFlowId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"userFlowLanguageConfiguration-id"+"}", _neturl.PathEscape(parameterToString(r.userFlowLanguageConfigurationId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"userFlowLanguagePage-id"+"}", _neturl.PathEscape(parameterToString(r.userFlowLanguagePageId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIdentityB2xUserFlowsLanguagesGetDefaultPagesContentRequest struct {
	ctx _context.Context
	ApiService *IdentityB2xIdentityUserFlowApiService
	b2xIdentityUserFlowId string
	userFlowLanguageConfigurationId string
	userFlowLanguagePageId string
}


func (r ApiIdentityB2xUserFlowsLanguagesGetDefaultPagesContentRequest) Execute() (*os.File, *_nethttp.Response, error) {
	return r.ApiService.IdentityB2xUserFlowsLanguagesGetDefaultPagesContentExecute(r)
}

/*
IdentityB2xUserFlowsLanguagesGetDefaultPagesContent Get media content for the navigation property defaultPages from identity

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param b2xIdentityUserFlowId key: id of b2xIdentityUserFlow
 @param userFlowLanguageConfigurationId key: id of userFlowLanguageConfiguration
 @param userFlowLanguagePageId key: id of userFlowLanguagePage
 @return ApiIdentityB2xUserFlowsLanguagesGetDefaultPagesContentRequest
*/
func (a *IdentityB2xIdentityUserFlowApiService) IdentityB2xUserFlowsLanguagesGetDefaultPagesContent(ctx _context.Context, b2xIdentityUserFlowId string, userFlowLanguageConfigurationId string, userFlowLanguagePageId string) ApiIdentityB2xUserFlowsLanguagesGetDefaultPagesContentRequest {
	return ApiIdentityB2xUserFlowsLanguagesGetDefaultPagesContentRequest{
		ApiService: a,
		ctx: ctx,
		b2xIdentityUserFlowId: b2xIdentityUserFlowId,
		userFlowLanguageConfigurationId: userFlowLanguageConfigurationId,
		userFlowLanguagePageId: userFlowLanguagePageId,
	}
}

// Execute executes the request
//  @return *os.File
func (a *IdentityB2xIdentityUserFlowApiService) IdentityB2xUserFlowsLanguagesGetDefaultPagesContentExecute(r ApiIdentityB2xUserFlowsLanguagesGetDefaultPagesContentRequest) (*os.File, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  *os.File
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IdentityB2xIdentityUserFlowApiService.IdentityB2xUserFlowsLanguagesGetDefaultPagesContent")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/identity/b2xUserFlows/{b2xIdentityUserFlow-id}/languages/{userFlowLanguageConfiguration-id}/defaultPages/{userFlowLanguagePage-id}/$value"
	localVarPath = strings.Replace(localVarPath, "{"+"b2xIdentityUserFlow-id"+"}", _neturl.PathEscape(parameterToString(r.b2xIdentityUserFlowId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"userFlowLanguageConfiguration-id"+"}", _neturl.PathEscape(parameterToString(r.userFlowLanguageConfigurationId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"userFlowLanguagePage-id"+"}", _neturl.PathEscape(parameterToString(r.userFlowLanguagePageId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/octet-stream", "application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIdentityB2xUserFlowsLanguagesGetOverridesPagesRequest struct {
	ctx _context.Context
	ApiService *IdentityB2xIdentityUserFlowApiService
	b2xIdentityUserFlowId string
	userFlowLanguageConfigurationId string
	userFlowLanguagePageId string
	select_ *[]string
	expand *[]string
}

// Select properties to be returned
func (r ApiIdentityB2xUserFlowsLanguagesGetOverridesPagesRequest) Select_(select_ []string) ApiIdentityB2xUserFlowsLanguagesGetOverridesPagesRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiIdentityB2xUserFlowsLanguagesGetOverridesPagesRequest) Expand(expand []string) ApiIdentityB2xUserFlowsLanguagesGetOverridesPagesRequest {
	r.expand = &expand
	return r
}

func (r ApiIdentityB2xUserFlowsLanguagesGetOverridesPagesRequest) Execute() (MicrosoftGraphUserFlowLanguagePage, *_nethttp.Response, error) {
	return r.ApiService.IdentityB2xUserFlowsLanguagesGetOverridesPagesExecute(r)
}

/*
IdentityB2xUserFlowsLanguagesGetOverridesPages Get overridesPages from identity

Collection of pages with the overrides messages to display in a user flow for a specified language. This collection only allows to modify the content of the page, any other modification is not allowed (creation or deletion of pages).

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param b2xIdentityUserFlowId key: id of b2xIdentityUserFlow
 @param userFlowLanguageConfigurationId key: id of userFlowLanguageConfiguration
 @param userFlowLanguagePageId key: id of userFlowLanguagePage
 @return ApiIdentityB2xUserFlowsLanguagesGetOverridesPagesRequest
*/
func (a *IdentityB2xIdentityUserFlowApiService) IdentityB2xUserFlowsLanguagesGetOverridesPages(ctx _context.Context, b2xIdentityUserFlowId string, userFlowLanguageConfigurationId string, userFlowLanguagePageId string) ApiIdentityB2xUserFlowsLanguagesGetOverridesPagesRequest {
	return ApiIdentityB2xUserFlowsLanguagesGetOverridesPagesRequest{
		ApiService: a,
		ctx: ctx,
		b2xIdentityUserFlowId: b2xIdentityUserFlowId,
		userFlowLanguageConfigurationId: userFlowLanguageConfigurationId,
		userFlowLanguagePageId: userFlowLanguagePageId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphUserFlowLanguagePage
func (a *IdentityB2xIdentityUserFlowApiService) IdentityB2xUserFlowsLanguagesGetOverridesPagesExecute(r ApiIdentityB2xUserFlowsLanguagesGetOverridesPagesRequest) (MicrosoftGraphUserFlowLanguagePage, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphUserFlowLanguagePage
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IdentityB2xIdentityUserFlowApiService.IdentityB2xUserFlowsLanguagesGetOverridesPages")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/identity/b2xUserFlows/{b2xIdentityUserFlow-id}/languages/{userFlowLanguageConfiguration-id}/overridesPages/{userFlowLanguagePage-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"b2xIdentityUserFlow-id"+"}", _neturl.PathEscape(parameterToString(r.b2xIdentityUserFlowId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"userFlowLanguageConfiguration-id"+"}", _neturl.PathEscape(parameterToString(r.userFlowLanguageConfigurationId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"userFlowLanguagePage-id"+"}", _neturl.PathEscape(parameterToString(r.userFlowLanguagePageId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIdentityB2xUserFlowsLanguagesGetOverridesPagesContentRequest struct {
	ctx _context.Context
	ApiService *IdentityB2xIdentityUserFlowApiService
	b2xIdentityUserFlowId string
	userFlowLanguageConfigurationId string
	userFlowLanguagePageId string
}


func (r ApiIdentityB2xUserFlowsLanguagesGetOverridesPagesContentRequest) Execute() (*os.File, *_nethttp.Response, error) {
	return r.ApiService.IdentityB2xUserFlowsLanguagesGetOverridesPagesContentExecute(r)
}

/*
IdentityB2xUserFlowsLanguagesGetOverridesPagesContent Get media content for the navigation property overridesPages from identity

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param b2xIdentityUserFlowId key: id of b2xIdentityUserFlow
 @param userFlowLanguageConfigurationId key: id of userFlowLanguageConfiguration
 @param userFlowLanguagePageId key: id of userFlowLanguagePage
 @return ApiIdentityB2xUserFlowsLanguagesGetOverridesPagesContentRequest
*/
func (a *IdentityB2xIdentityUserFlowApiService) IdentityB2xUserFlowsLanguagesGetOverridesPagesContent(ctx _context.Context, b2xIdentityUserFlowId string, userFlowLanguageConfigurationId string, userFlowLanguagePageId string) ApiIdentityB2xUserFlowsLanguagesGetOverridesPagesContentRequest {
	return ApiIdentityB2xUserFlowsLanguagesGetOverridesPagesContentRequest{
		ApiService: a,
		ctx: ctx,
		b2xIdentityUserFlowId: b2xIdentityUserFlowId,
		userFlowLanguageConfigurationId: userFlowLanguageConfigurationId,
		userFlowLanguagePageId: userFlowLanguagePageId,
	}
}

// Execute executes the request
//  @return *os.File
func (a *IdentityB2xIdentityUserFlowApiService) IdentityB2xUserFlowsLanguagesGetOverridesPagesContentExecute(r ApiIdentityB2xUserFlowsLanguagesGetOverridesPagesContentRequest) (*os.File, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  *os.File
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IdentityB2xIdentityUserFlowApiService.IdentityB2xUserFlowsLanguagesGetOverridesPagesContent")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/identity/b2xUserFlows/{b2xIdentityUserFlow-id}/languages/{userFlowLanguageConfiguration-id}/overridesPages/{userFlowLanguagePage-id}/$value"
	localVarPath = strings.Replace(localVarPath, "{"+"b2xIdentityUserFlow-id"+"}", _neturl.PathEscape(parameterToString(r.b2xIdentityUserFlowId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"userFlowLanguageConfiguration-id"+"}", _neturl.PathEscape(parameterToString(r.userFlowLanguageConfigurationId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"userFlowLanguagePage-id"+"}", _neturl.PathEscape(parameterToString(r.userFlowLanguagePageId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/octet-stream", "application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIdentityB2xUserFlowsLanguagesListDefaultPagesRequest struct {
	ctx _context.Context
	ApiService *IdentityB2xIdentityUserFlowApiService
	b2xIdentityUserFlowId string
	userFlowLanguageConfigurationId string
	top *int32
	skip *int32
	search *string
	filter *string
	count *bool
	orderby *[]string
	select_ *[]string
	expand *[]string
}

// Show only the first n items
func (r ApiIdentityB2xUserFlowsLanguagesListDefaultPagesRequest) Top(top int32) ApiIdentityB2xUserFlowsLanguagesListDefaultPagesRequest {
	r.top = &top
	return r
}
// Skip the first n items
func (r ApiIdentityB2xUserFlowsLanguagesListDefaultPagesRequest) Skip(skip int32) ApiIdentityB2xUserFlowsLanguagesListDefaultPagesRequest {
	r.skip = &skip
	return r
}
// Search items by search phrases
func (r ApiIdentityB2xUserFlowsLanguagesListDefaultPagesRequest) Search(search string) ApiIdentityB2xUserFlowsLanguagesListDefaultPagesRequest {
	r.search = &search
	return r
}
// Filter items by property values
func (r ApiIdentityB2xUserFlowsLanguagesListDefaultPagesRequest) Filter(filter string) ApiIdentityB2xUserFlowsLanguagesListDefaultPagesRequest {
	r.filter = &filter
	return r
}
// Include count of items
func (r ApiIdentityB2xUserFlowsLanguagesListDefaultPagesRequest) Count(count bool) ApiIdentityB2xUserFlowsLanguagesListDefaultPagesRequest {
	r.count = &count
	return r
}
// Order items by property values
func (r ApiIdentityB2xUserFlowsLanguagesListDefaultPagesRequest) Orderby(orderby []string) ApiIdentityB2xUserFlowsLanguagesListDefaultPagesRequest {
	r.orderby = &orderby
	return r
}
// Select properties to be returned
func (r ApiIdentityB2xUserFlowsLanguagesListDefaultPagesRequest) Select_(select_ []string) ApiIdentityB2xUserFlowsLanguagesListDefaultPagesRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiIdentityB2xUserFlowsLanguagesListDefaultPagesRequest) Expand(expand []string) ApiIdentityB2xUserFlowsLanguagesListDefaultPagesRequest {
	r.expand = &expand
	return r
}

func (r ApiIdentityB2xUserFlowsLanguagesListDefaultPagesRequest) Execute() (CollectionOfUserFlowLanguagePage, *_nethttp.Response, error) {
	return r.ApiService.IdentityB2xUserFlowsLanguagesListDefaultPagesExecute(r)
}

/*
IdentityB2xUserFlowsLanguagesListDefaultPages Get defaultPages from identity

Collection of pages with the default content to display in a user flow for a specified language. This collection does not allow any kind of modification.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param b2xIdentityUserFlowId key: id of b2xIdentityUserFlow
 @param userFlowLanguageConfigurationId key: id of userFlowLanguageConfiguration
 @return ApiIdentityB2xUserFlowsLanguagesListDefaultPagesRequest
*/
func (a *IdentityB2xIdentityUserFlowApiService) IdentityB2xUserFlowsLanguagesListDefaultPages(ctx _context.Context, b2xIdentityUserFlowId string, userFlowLanguageConfigurationId string) ApiIdentityB2xUserFlowsLanguagesListDefaultPagesRequest {
	return ApiIdentityB2xUserFlowsLanguagesListDefaultPagesRequest{
		ApiService: a,
		ctx: ctx,
		b2xIdentityUserFlowId: b2xIdentityUserFlowId,
		userFlowLanguageConfigurationId: userFlowLanguageConfigurationId,
	}
}

// Execute executes the request
//  @return CollectionOfUserFlowLanguagePage
func (a *IdentityB2xIdentityUserFlowApiService) IdentityB2xUserFlowsLanguagesListDefaultPagesExecute(r ApiIdentityB2xUserFlowsLanguagesListDefaultPagesRequest) (CollectionOfUserFlowLanguagePage, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  CollectionOfUserFlowLanguagePage
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IdentityB2xIdentityUserFlowApiService.IdentityB2xUserFlowsLanguagesListDefaultPages")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/identity/b2xUserFlows/{b2xIdentityUserFlow-id}/languages/{userFlowLanguageConfiguration-id}/defaultPages"
	localVarPath = strings.Replace(localVarPath, "{"+"b2xIdentityUserFlow-id"+"}", _neturl.PathEscape(parameterToString(r.b2xIdentityUserFlowId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"userFlowLanguageConfiguration-id"+"}", _neturl.PathEscape(parameterToString(r.userFlowLanguageConfigurationId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.top != nil {
		localVarQueryParams.Add("$top", parameterToString(*r.top, ""))
	}
	if r.skip != nil {
		localVarQueryParams.Add("$skip", parameterToString(*r.skip, ""))
	}
	if r.search != nil {
		localVarQueryParams.Add("$search", parameterToString(*r.search, ""))
	}
	if r.filter != nil {
		localVarQueryParams.Add("$filter", parameterToString(*r.filter, ""))
	}
	if r.count != nil {
		localVarQueryParams.Add("$count", parameterToString(*r.count, ""))
	}
	if r.orderby != nil {
		localVarQueryParams.Add("$orderby", parameterToString(*r.orderby, "csv"))
	}
	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIdentityB2xUserFlowsLanguagesListOverridesPagesRequest struct {
	ctx _context.Context
	ApiService *IdentityB2xIdentityUserFlowApiService
	b2xIdentityUserFlowId string
	userFlowLanguageConfigurationId string
	top *int32
	skip *int32
	search *string
	filter *string
	count *bool
	orderby *[]string
	select_ *[]string
	expand *[]string
}

// Show only the first n items
func (r ApiIdentityB2xUserFlowsLanguagesListOverridesPagesRequest) Top(top int32) ApiIdentityB2xUserFlowsLanguagesListOverridesPagesRequest {
	r.top = &top
	return r
}
// Skip the first n items
func (r ApiIdentityB2xUserFlowsLanguagesListOverridesPagesRequest) Skip(skip int32) ApiIdentityB2xUserFlowsLanguagesListOverridesPagesRequest {
	r.skip = &skip
	return r
}
// Search items by search phrases
func (r ApiIdentityB2xUserFlowsLanguagesListOverridesPagesRequest) Search(search string) ApiIdentityB2xUserFlowsLanguagesListOverridesPagesRequest {
	r.search = &search
	return r
}
// Filter items by property values
func (r ApiIdentityB2xUserFlowsLanguagesListOverridesPagesRequest) Filter(filter string) ApiIdentityB2xUserFlowsLanguagesListOverridesPagesRequest {
	r.filter = &filter
	return r
}
// Include count of items
func (r ApiIdentityB2xUserFlowsLanguagesListOverridesPagesRequest) Count(count bool) ApiIdentityB2xUserFlowsLanguagesListOverridesPagesRequest {
	r.count = &count
	return r
}
// Order items by property values
func (r ApiIdentityB2xUserFlowsLanguagesListOverridesPagesRequest) Orderby(orderby []string) ApiIdentityB2xUserFlowsLanguagesListOverridesPagesRequest {
	r.orderby = &orderby
	return r
}
// Select properties to be returned
func (r ApiIdentityB2xUserFlowsLanguagesListOverridesPagesRequest) Select_(select_ []string) ApiIdentityB2xUserFlowsLanguagesListOverridesPagesRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiIdentityB2xUserFlowsLanguagesListOverridesPagesRequest) Expand(expand []string) ApiIdentityB2xUserFlowsLanguagesListOverridesPagesRequest {
	r.expand = &expand
	return r
}

func (r ApiIdentityB2xUserFlowsLanguagesListOverridesPagesRequest) Execute() (CollectionOfUserFlowLanguagePage, *_nethttp.Response, error) {
	return r.ApiService.IdentityB2xUserFlowsLanguagesListOverridesPagesExecute(r)
}

/*
IdentityB2xUserFlowsLanguagesListOverridesPages Get overridesPages from identity

Collection of pages with the overrides messages to display in a user flow for a specified language. This collection only allows to modify the content of the page, any other modification is not allowed (creation or deletion of pages).

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param b2xIdentityUserFlowId key: id of b2xIdentityUserFlow
 @param userFlowLanguageConfigurationId key: id of userFlowLanguageConfiguration
 @return ApiIdentityB2xUserFlowsLanguagesListOverridesPagesRequest
*/
func (a *IdentityB2xIdentityUserFlowApiService) IdentityB2xUserFlowsLanguagesListOverridesPages(ctx _context.Context, b2xIdentityUserFlowId string, userFlowLanguageConfigurationId string) ApiIdentityB2xUserFlowsLanguagesListOverridesPagesRequest {
	return ApiIdentityB2xUserFlowsLanguagesListOverridesPagesRequest{
		ApiService: a,
		ctx: ctx,
		b2xIdentityUserFlowId: b2xIdentityUserFlowId,
		userFlowLanguageConfigurationId: userFlowLanguageConfigurationId,
	}
}

// Execute executes the request
//  @return CollectionOfUserFlowLanguagePage
func (a *IdentityB2xIdentityUserFlowApiService) IdentityB2xUserFlowsLanguagesListOverridesPagesExecute(r ApiIdentityB2xUserFlowsLanguagesListOverridesPagesRequest) (CollectionOfUserFlowLanguagePage, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  CollectionOfUserFlowLanguagePage
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IdentityB2xIdentityUserFlowApiService.IdentityB2xUserFlowsLanguagesListOverridesPages")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/identity/b2xUserFlows/{b2xIdentityUserFlow-id}/languages/{userFlowLanguageConfiguration-id}/overridesPages"
	localVarPath = strings.Replace(localVarPath, "{"+"b2xIdentityUserFlow-id"+"}", _neturl.PathEscape(parameterToString(r.b2xIdentityUserFlowId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"userFlowLanguageConfiguration-id"+"}", _neturl.PathEscape(parameterToString(r.userFlowLanguageConfigurationId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.top != nil {
		localVarQueryParams.Add("$top", parameterToString(*r.top, ""))
	}
	if r.skip != nil {
		localVarQueryParams.Add("$skip", parameterToString(*r.skip, ""))
	}
	if r.search != nil {
		localVarQueryParams.Add("$search", parameterToString(*r.search, ""))
	}
	if r.filter != nil {
		localVarQueryParams.Add("$filter", parameterToString(*r.filter, ""))
	}
	if r.count != nil {
		localVarQueryParams.Add("$count", parameterToString(*r.count, ""))
	}
	if r.orderby != nil {
		localVarQueryParams.Add("$orderby", parameterToString(*r.orderby, "csv"))
	}
	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIdentityB2xUserFlowsLanguagesUpdateDefaultPagesRequest struct {
	ctx _context.Context
	ApiService *IdentityB2xIdentityUserFlowApiService
	b2xIdentityUserFlowId string
	userFlowLanguageConfigurationId string
	userFlowLanguagePageId string
	microsoftGraphUserFlowLanguagePage *MicrosoftGraphUserFlowLanguagePage
}

// New navigation property values
func (r ApiIdentityB2xUserFlowsLanguagesUpdateDefaultPagesRequest) MicrosoftGraphUserFlowLanguagePage(microsoftGraphUserFlowLanguagePage MicrosoftGraphUserFlowLanguagePage) ApiIdentityB2xUserFlowsLanguagesUpdateDefaultPagesRequest {
	r.microsoftGraphUserFlowLanguagePage = &microsoftGraphUserFlowLanguagePage
	return r
}

func (r ApiIdentityB2xUserFlowsLanguagesUpdateDefaultPagesRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.IdentityB2xUserFlowsLanguagesUpdateDefaultPagesExecute(r)
}

/*
IdentityB2xUserFlowsLanguagesUpdateDefaultPages Update the navigation property defaultPages in identity

Collection of pages with the default content to display in a user flow for a specified language. This collection does not allow any kind of modification.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param b2xIdentityUserFlowId key: id of b2xIdentityUserFlow
 @param userFlowLanguageConfigurationId key: id of userFlowLanguageConfiguration
 @param userFlowLanguagePageId key: id of userFlowLanguagePage
 @return ApiIdentityB2xUserFlowsLanguagesUpdateDefaultPagesRequest
*/
func (a *IdentityB2xIdentityUserFlowApiService) IdentityB2xUserFlowsLanguagesUpdateDefaultPages(ctx _context.Context, b2xIdentityUserFlowId string, userFlowLanguageConfigurationId string, userFlowLanguagePageId string) ApiIdentityB2xUserFlowsLanguagesUpdateDefaultPagesRequest {
	return ApiIdentityB2xUserFlowsLanguagesUpdateDefaultPagesRequest{
		ApiService: a,
		ctx: ctx,
		b2xIdentityUserFlowId: b2xIdentityUserFlowId,
		userFlowLanguageConfigurationId: userFlowLanguageConfigurationId,
		userFlowLanguagePageId: userFlowLanguagePageId,
	}
}

// Execute executes the request
func (a *IdentityB2xIdentityUserFlowApiService) IdentityB2xUserFlowsLanguagesUpdateDefaultPagesExecute(r ApiIdentityB2xUserFlowsLanguagesUpdateDefaultPagesRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPatch
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IdentityB2xIdentityUserFlowApiService.IdentityB2xUserFlowsLanguagesUpdateDefaultPages")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/identity/b2xUserFlows/{b2xIdentityUserFlow-id}/languages/{userFlowLanguageConfiguration-id}/defaultPages/{userFlowLanguagePage-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"b2xIdentityUserFlow-id"+"}", _neturl.PathEscape(parameterToString(r.b2xIdentityUserFlowId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"userFlowLanguageConfiguration-id"+"}", _neturl.PathEscape(parameterToString(r.userFlowLanguageConfigurationId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"userFlowLanguagePage-id"+"}", _neturl.PathEscape(parameterToString(r.userFlowLanguagePageId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphUserFlowLanguagePage == nil {
		return nil, reportError("microsoftGraphUserFlowLanguagePage is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphUserFlowLanguagePage
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiIdentityB2xUserFlowsLanguagesUpdateDefaultPagesContentRequest struct {
	ctx _context.Context
	ApiService *IdentityB2xIdentityUserFlowApiService
	b2xIdentityUserFlowId string
	userFlowLanguageConfigurationId string
	userFlowLanguagePageId string
	body **os.File
}

// New media content.
func (r ApiIdentityB2xUserFlowsLanguagesUpdateDefaultPagesContentRequest) Body(body *os.File) ApiIdentityB2xUserFlowsLanguagesUpdateDefaultPagesContentRequest {
	r.body = &body
	return r
}

func (r ApiIdentityB2xUserFlowsLanguagesUpdateDefaultPagesContentRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.IdentityB2xUserFlowsLanguagesUpdateDefaultPagesContentExecute(r)
}

/*
IdentityB2xUserFlowsLanguagesUpdateDefaultPagesContent Update media content for the navigation property defaultPages in identity

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param b2xIdentityUserFlowId key: id of b2xIdentityUserFlow
 @param userFlowLanguageConfigurationId key: id of userFlowLanguageConfiguration
 @param userFlowLanguagePageId key: id of userFlowLanguagePage
 @return ApiIdentityB2xUserFlowsLanguagesUpdateDefaultPagesContentRequest
*/
func (a *IdentityB2xIdentityUserFlowApiService) IdentityB2xUserFlowsLanguagesUpdateDefaultPagesContent(ctx _context.Context, b2xIdentityUserFlowId string, userFlowLanguageConfigurationId string, userFlowLanguagePageId string) ApiIdentityB2xUserFlowsLanguagesUpdateDefaultPagesContentRequest {
	return ApiIdentityB2xUserFlowsLanguagesUpdateDefaultPagesContentRequest{
		ApiService: a,
		ctx: ctx,
		b2xIdentityUserFlowId: b2xIdentityUserFlowId,
		userFlowLanguageConfigurationId: userFlowLanguageConfigurationId,
		userFlowLanguagePageId: userFlowLanguagePageId,
	}
}

// Execute executes the request
func (a *IdentityB2xIdentityUserFlowApiService) IdentityB2xUserFlowsLanguagesUpdateDefaultPagesContentExecute(r ApiIdentityB2xUserFlowsLanguagesUpdateDefaultPagesContentRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPut
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IdentityB2xIdentityUserFlowApiService.IdentityB2xUserFlowsLanguagesUpdateDefaultPagesContent")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/identity/b2xUserFlows/{b2xIdentityUserFlow-id}/languages/{userFlowLanguageConfiguration-id}/defaultPages/{userFlowLanguagePage-id}/$value"
	localVarPath = strings.Replace(localVarPath, "{"+"b2xIdentityUserFlow-id"+"}", _neturl.PathEscape(parameterToString(r.b2xIdentityUserFlowId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"userFlowLanguageConfiguration-id"+"}", _neturl.PathEscape(parameterToString(r.userFlowLanguageConfigurationId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"userFlowLanguagePage-id"+"}", _neturl.PathEscape(parameterToString(r.userFlowLanguagePageId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.body == nil {
		return nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/octet-stream"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiIdentityB2xUserFlowsLanguagesUpdateOverridesPagesRequest struct {
	ctx _context.Context
	ApiService *IdentityB2xIdentityUserFlowApiService
	b2xIdentityUserFlowId string
	userFlowLanguageConfigurationId string
	userFlowLanguagePageId string
	microsoftGraphUserFlowLanguagePage *MicrosoftGraphUserFlowLanguagePage
}

// New navigation property values
func (r ApiIdentityB2xUserFlowsLanguagesUpdateOverridesPagesRequest) MicrosoftGraphUserFlowLanguagePage(microsoftGraphUserFlowLanguagePage MicrosoftGraphUserFlowLanguagePage) ApiIdentityB2xUserFlowsLanguagesUpdateOverridesPagesRequest {
	r.microsoftGraphUserFlowLanguagePage = &microsoftGraphUserFlowLanguagePage
	return r
}

func (r ApiIdentityB2xUserFlowsLanguagesUpdateOverridesPagesRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.IdentityB2xUserFlowsLanguagesUpdateOverridesPagesExecute(r)
}

/*
IdentityB2xUserFlowsLanguagesUpdateOverridesPages Update the navigation property overridesPages in identity

Collection of pages with the overrides messages to display in a user flow for a specified language. This collection only allows to modify the content of the page, any other modification is not allowed (creation or deletion of pages).

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param b2xIdentityUserFlowId key: id of b2xIdentityUserFlow
 @param userFlowLanguageConfigurationId key: id of userFlowLanguageConfiguration
 @param userFlowLanguagePageId key: id of userFlowLanguagePage
 @return ApiIdentityB2xUserFlowsLanguagesUpdateOverridesPagesRequest
*/
func (a *IdentityB2xIdentityUserFlowApiService) IdentityB2xUserFlowsLanguagesUpdateOverridesPages(ctx _context.Context, b2xIdentityUserFlowId string, userFlowLanguageConfigurationId string, userFlowLanguagePageId string) ApiIdentityB2xUserFlowsLanguagesUpdateOverridesPagesRequest {
	return ApiIdentityB2xUserFlowsLanguagesUpdateOverridesPagesRequest{
		ApiService: a,
		ctx: ctx,
		b2xIdentityUserFlowId: b2xIdentityUserFlowId,
		userFlowLanguageConfigurationId: userFlowLanguageConfigurationId,
		userFlowLanguagePageId: userFlowLanguagePageId,
	}
}

// Execute executes the request
func (a *IdentityB2xIdentityUserFlowApiService) IdentityB2xUserFlowsLanguagesUpdateOverridesPagesExecute(r ApiIdentityB2xUserFlowsLanguagesUpdateOverridesPagesRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPatch
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IdentityB2xIdentityUserFlowApiService.IdentityB2xUserFlowsLanguagesUpdateOverridesPages")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/identity/b2xUserFlows/{b2xIdentityUserFlow-id}/languages/{userFlowLanguageConfiguration-id}/overridesPages/{userFlowLanguagePage-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"b2xIdentityUserFlow-id"+"}", _neturl.PathEscape(parameterToString(r.b2xIdentityUserFlowId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"userFlowLanguageConfiguration-id"+"}", _neturl.PathEscape(parameterToString(r.userFlowLanguageConfigurationId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"userFlowLanguagePage-id"+"}", _neturl.PathEscape(parameterToString(r.userFlowLanguagePageId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphUserFlowLanguagePage == nil {
		return nil, reportError("microsoftGraphUserFlowLanguagePage is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphUserFlowLanguagePage
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiIdentityB2xUserFlowsLanguagesUpdateOverridesPagesContentRequest struct {
	ctx _context.Context
	ApiService *IdentityB2xIdentityUserFlowApiService
	b2xIdentityUserFlowId string
	userFlowLanguageConfigurationId string
	userFlowLanguagePageId string
	body **os.File
}

// New media content.
func (r ApiIdentityB2xUserFlowsLanguagesUpdateOverridesPagesContentRequest) Body(body *os.File) ApiIdentityB2xUserFlowsLanguagesUpdateOverridesPagesContentRequest {
	r.body = &body
	return r
}

func (r ApiIdentityB2xUserFlowsLanguagesUpdateOverridesPagesContentRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.IdentityB2xUserFlowsLanguagesUpdateOverridesPagesContentExecute(r)
}

/*
IdentityB2xUserFlowsLanguagesUpdateOverridesPagesContent Update media content for the navigation property overridesPages in identity

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param b2xIdentityUserFlowId key: id of b2xIdentityUserFlow
 @param userFlowLanguageConfigurationId key: id of userFlowLanguageConfiguration
 @param userFlowLanguagePageId key: id of userFlowLanguagePage
 @return ApiIdentityB2xUserFlowsLanguagesUpdateOverridesPagesContentRequest
*/
func (a *IdentityB2xIdentityUserFlowApiService) IdentityB2xUserFlowsLanguagesUpdateOverridesPagesContent(ctx _context.Context, b2xIdentityUserFlowId string, userFlowLanguageConfigurationId string, userFlowLanguagePageId string) ApiIdentityB2xUserFlowsLanguagesUpdateOverridesPagesContentRequest {
	return ApiIdentityB2xUserFlowsLanguagesUpdateOverridesPagesContentRequest{
		ApiService: a,
		ctx: ctx,
		b2xIdentityUserFlowId: b2xIdentityUserFlowId,
		userFlowLanguageConfigurationId: userFlowLanguageConfigurationId,
		userFlowLanguagePageId: userFlowLanguagePageId,
	}
}

// Execute executes the request
func (a *IdentityB2xIdentityUserFlowApiService) IdentityB2xUserFlowsLanguagesUpdateOverridesPagesContentExecute(r ApiIdentityB2xUserFlowsLanguagesUpdateOverridesPagesContentRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPut
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IdentityB2xIdentityUserFlowApiService.IdentityB2xUserFlowsLanguagesUpdateOverridesPagesContent")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/identity/b2xUserFlows/{b2xIdentityUserFlow-id}/languages/{userFlowLanguageConfiguration-id}/overridesPages/{userFlowLanguagePage-id}/$value"
	localVarPath = strings.Replace(localVarPath, "{"+"b2xIdentityUserFlow-id"+"}", _neturl.PathEscape(parameterToString(r.b2xIdentityUserFlowId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"userFlowLanguageConfiguration-id"+"}", _neturl.PathEscape(parameterToString(r.userFlowLanguageConfigurationId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"userFlowLanguagePage-id"+"}", _neturl.PathEscape(parameterToString(r.userFlowLanguagePageId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.body == nil {
		return nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/octet-stream"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiIdentityB2xUserFlowsListIdentityProvidersRequest struct {
	ctx _context.Context
	ApiService *IdentityB2xIdentityUserFlowApiService
	b2xIdentityUserFlowId string
	top *int32
	skip *int32
	search *string
	filter *string
	count *bool
	orderby *[]string
	select_ *[]string
	expand *[]string
}

// Show only the first n items
func (r ApiIdentityB2xUserFlowsListIdentityProvidersRequest) Top(top int32) ApiIdentityB2xUserFlowsListIdentityProvidersRequest {
	r.top = &top
	return r
}
// Skip the first n items
func (r ApiIdentityB2xUserFlowsListIdentityProvidersRequest) Skip(skip int32) ApiIdentityB2xUserFlowsListIdentityProvidersRequest {
	r.skip = &skip
	return r
}
// Search items by search phrases
func (r ApiIdentityB2xUserFlowsListIdentityProvidersRequest) Search(search string) ApiIdentityB2xUserFlowsListIdentityProvidersRequest {
	r.search = &search
	return r
}
// Filter items by property values
func (r ApiIdentityB2xUserFlowsListIdentityProvidersRequest) Filter(filter string) ApiIdentityB2xUserFlowsListIdentityProvidersRequest {
	r.filter = &filter
	return r
}
// Include count of items
func (r ApiIdentityB2xUserFlowsListIdentityProvidersRequest) Count(count bool) ApiIdentityB2xUserFlowsListIdentityProvidersRequest {
	r.count = &count
	return r
}
// Order items by property values
func (r ApiIdentityB2xUserFlowsListIdentityProvidersRequest) Orderby(orderby []string) ApiIdentityB2xUserFlowsListIdentityProvidersRequest {
	r.orderby = &orderby
	return r
}
// Select properties to be returned
func (r ApiIdentityB2xUserFlowsListIdentityProvidersRequest) Select_(select_ []string) ApiIdentityB2xUserFlowsListIdentityProvidersRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiIdentityB2xUserFlowsListIdentityProvidersRequest) Expand(expand []string) ApiIdentityB2xUserFlowsListIdentityProvidersRequest {
	r.expand = &expand
	return r
}

func (r ApiIdentityB2xUserFlowsListIdentityProvidersRequest) Execute() (CollectionOfIdentityProvider, *_nethttp.Response, error) {
	return r.ApiService.IdentityB2xUserFlowsListIdentityProvidersExecute(r)
}

/*
IdentityB2xUserFlowsListIdentityProviders Get identityProviders from identity

The identity providers included in the user flow.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param b2xIdentityUserFlowId key: id of b2xIdentityUserFlow
 @return ApiIdentityB2xUserFlowsListIdentityProvidersRequest
*/
func (a *IdentityB2xIdentityUserFlowApiService) IdentityB2xUserFlowsListIdentityProviders(ctx _context.Context, b2xIdentityUserFlowId string) ApiIdentityB2xUserFlowsListIdentityProvidersRequest {
	return ApiIdentityB2xUserFlowsListIdentityProvidersRequest{
		ApiService: a,
		ctx: ctx,
		b2xIdentityUserFlowId: b2xIdentityUserFlowId,
	}
}

// Execute executes the request
//  @return CollectionOfIdentityProvider
func (a *IdentityB2xIdentityUserFlowApiService) IdentityB2xUserFlowsListIdentityProvidersExecute(r ApiIdentityB2xUserFlowsListIdentityProvidersRequest) (CollectionOfIdentityProvider, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  CollectionOfIdentityProvider
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IdentityB2xIdentityUserFlowApiService.IdentityB2xUserFlowsListIdentityProviders")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/identity/b2xUserFlows/{b2xIdentityUserFlow-id}/identityProviders"
	localVarPath = strings.Replace(localVarPath, "{"+"b2xIdentityUserFlow-id"+"}", _neturl.PathEscape(parameterToString(r.b2xIdentityUserFlowId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.top != nil {
		localVarQueryParams.Add("$top", parameterToString(*r.top, ""))
	}
	if r.skip != nil {
		localVarQueryParams.Add("$skip", parameterToString(*r.skip, ""))
	}
	if r.search != nil {
		localVarQueryParams.Add("$search", parameterToString(*r.search, ""))
	}
	if r.filter != nil {
		localVarQueryParams.Add("$filter", parameterToString(*r.filter, ""))
	}
	if r.count != nil {
		localVarQueryParams.Add("$count", parameterToString(*r.count, ""))
	}
	if r.orderby != nil {
		localVarQueryParams.Add("$orderby", parameterToString(*r.orderby, "csv"))
	}
	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIdentityB2xUserFlowsListLanguagesRequest struct {
	ctx _context.Context
	ApiService *IdentityB2xIdentityUserFlowApiService
	b2xIdentityUserFlowId string
	top *int32
	skip *int32
	search *string
	filter *string
	count *bool
	orderby *[]string
	select_ *[]string
	expand *[]string
}

// Show only the first n items
func (r ApiIdentityB2xUserFlowsListLanguagesRequest) Top(top int32) ApiIdentityB2xUserFlowsListLanguagesRequest {
	r.top = &top
	return r
}
// Skip the first n items
func (r ApiIdentityB2xUserFlowsListLanguagesRequest) Skip(skip int32) ApiIdentityB2xUserFlowsListLanguagesRequest {
	r.skip = &skip
	return r
}
// Search items by search phrases
func (r ApiIdentityB2xUserFlowsListLanguagesRequest) Search(search string) ApiIdentityB2xUserFlowsListLanguagesRequest {
	r.search = &search
	return r
}
// Filter items by property values
func (r ApiIdentityB2xUserFlowsListLanguagesRequest) Filter(filter string) ApiIdentityB2xUserFlowsListLanguagesRequest {
	r.filter = &filter
	return r
}
// Include count of items
func (r ApiIdentityB2xUserFlowsListLanguagesRequest) Count(count bool) ApiIdentityB2xUserFlowsListLanguagesRequest {
	r.count = &count
	return r
}
// Order items by property values
func (r ApiIdentityB2xUserFlowsListLanguagesRequest) Orderby(orderby []string) ApiIdentityB2xUserFlowsListLanguagesRequest {
	r.orderby = &orderby
	return r
}
// Select properties to be returned
func (r ApiIdentityB2xUserFlowsListLanguagesRequest) Select_(select_ []string) ApiIdentityB2xUserFlowsListLanguagesRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiIdentityB2xUserFlowsListLanguagesRequest) Expand(expand []string) ApiIdentityB2xUserFlowsListLanguagesRequest {
	r.expand = &expand
	return r
}

func (r ApiIdentityB2xUserFlowsListLanguagesRequest) Execute() (CollectionOfUserFlowLanguageConfiguration, *_nethttp.Response, error) {
	return r.ApiService.IdentityB2xUserFlowsListLanguagesExecute(r)
}

/*
IdentityB2xUserFlowsListLanguages Get languages from identity

The languages supported for customization within the user flow. Language customization is enabled by default in self-service sign-up user flow. You cannot create custom languages in self-service sign-up user flows.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param b2xIdentityUserFlowId key: id of b2xIdentityUserFlow
 @return ApiIdentityB2xUserFlowsListLanguagesRequest
*/
func (a *IdentityB2xIdentityUserFlowApiService) IdentityB2xUserFlowsListLanguages(ctx _context.Context, b2xIdentityUserFlowId string) ApiIdentityB2xUserFlowsListLanguagesRequest {
	return ApiIdentityB2xUserFlowsListLanguagesRequest{
		ApiService: a,
		ctx: ctx,
		b2xIdentityUserFlowId: b2xIdentityUserFlowId,
	}
}

// Execute executes the request
//  @return CollectionOfUserFlowLanguageConfiguration
func (a *IdentityB2xIdentityUserFlowApiService) IdentityB2xUserFlowsListLanguagesExecute(r ApiIdentityB2xUserFlowsListLanguagesRequest) (CollectionOfUserFlowLanguageConfiguration, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  CollectionOfUserFlowLanguageConfiguration
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IdentityB2xIdentityUserFlowApiService.IdentityB2xUserFlowsListLanguages")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/identity/b2xUserFlows/{b2xIdentityUserFlow-id}/languages"
	localVarPath = strings.Replace(localVarPath, "{"+"b2xIdentityUserFlow-id"+"}", _neturl.PathEscape(parameterToString(r.b2xIdentityUserFlowId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.top != nil {
		localVarQueryParams.Add("$top", parameterToString(*r.top, ""))
	}
	if r.skip != nil {
		localVarQueryParams.Add("$skip", parameterToString(*r.skip, ""))
	}
	if r.search != nil {
		localVarQueryParams.Add("$search", parameterToString(*r.search, ""))
	}
	if r.filter != nil {
		localVarQueryParams.Add("$filter", parameterToString(*r.filter, ""))
	}
	if r.count != nil {
		localVarQueryParams.Add("$count", parameterToString(*r.count, ""))
	}
	if r.orderby != nil {
		localVarQueryParams.Add("$orderby", parameterToString(*r.orderby, "csv"))
	}
	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIdentityB2xUserFlowsListRefIdentityProvidersRequest struct {
	ctx _context.Context
	ApiService *IdentityB2xIdentityUserFlowApiService
	b2xIdentityUserFlowId string
	top *int32
	skip *int32
	search *string
	filter *string
	count *bool
	orderby *[]string
}

// Show only the first n items
func (r ApiIdentityB2xUserFlowsListRefIdentityProvidersRequest) Top(top int32) ApiIdentityB2xUserFlowsListRefIdentityProvidersRequest {
	r.top = &top
	return r
}
// Skip the first n items
func (r ApiIdentityB2xUserFlowsListRefIdentityProvidersRequest) Skip(skip int32) ApiIdentityB2xUserFlowsListRefIdentityProvidersRequest {
	r.skip = &skip
	return r
}
// Search items by search phrases
func (r ApiIdentityB2xUserFlowsListRefIdentityProvidersRequest) Search(search string) ApiIdentityB2xUserFlowsListRefIdentityProvidersRequest {
	r.search = &search
	return r
}
// Filter items by property values
func (r ApiIdentityB2xUserFlowsListRefIdentityProvidersRequest) Filter(filter string) ApiIdentityB2xUserFlowsListRefIdentityProvidersRequest {
	r.filter = &filter
	return r
}
// Include count of items
func (r ApiIdentityB2xUserFlowsListRefIdentityProvidersRequest) Count(count bool) ApiIdentityB2xUserFlowsListRefIdentityProvidersRequest {
	r.count = &count
	return r
}
// Order items by property values
func (r ApiIdentityB2xUserFlowsListRefIdentityProvidersRequest) Orderby(orderby []string) ApiIdentityB2xUserFlowsListRefIdentityProvidersRequest {
	r.orderby = &orderby
	return r
}

func (r ApiIdentityB2xUserFlowsListRefIdentityProvidersRequest) Execute() (CollectionOfLinksOfIdentityProvider, *_nethttp.Response, error) {
	return r.ApiService.IdentityB2xUserFlowsListRefIdentityProvidersExecute(r)
}

/*
IdentityB2xUserFlowsListRefIdentityProviders Get ref of identityProviders from identity

The identity providers included in the user flow.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param b2xIdentityUserFlowId key: id of b2xIdentityUserFlow
 @return ApiIdentityB2xUserFlowsListRefIdentityProvidersRequest
*/
func (a *IdentityB2xIdentityUserFlowApiService) IdentityB2xUserFlowsListRefIdentityProviders(ctx _context.Context, b2xIdentityUserFlowId string) ApiIdentityB2xUserFlowsListRefIdentityProvidersRequest {
	return ApiIdentityB2xUserFlowsListRefIdentityProvidersRequest{
		ApiService: a,
		ctx: ctx,
		b2xIdentityUserFlowId: b2xIdentityUserFlowId,
	}
}

// Execute executes the request
//  @return CollectionOfLinksOfIdentityProvider
func (a *IdentityB2xIdentityUserFlowApiService) IdentityB2xUserFlowsListRefIdentityProvidersExecute(r ApiIdentityB2xUserFlowsListRefIdentityProvidersRequest) (CollectionOfLinksOfIdentityProvider, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  CollectionOfLinksOfIdentityProvider
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IdentityB2xIdentityUserFlowApiService.IdentityB2xUserFlowsListRefIdentityProviders")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/identity/b2xUserFlows/{b2xIdentityUserFlow-id}/identityProviders/$ref"
	localVarPath = strings.Replace(localVarPath, "{"+"b2xIdentityUserFlow-id"+"}", _neturl.PathEscape(parameterToString(r.b2xIdentityUserFlowId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.top != nil {
		localVarQueryParams.Add("$top", parameterToString(*r.top, ""))
	}
	if r.skip != nil {
		localVarQueryParams.Add("$skip", parameterToString(*r.skip, ""))
	}
	if r.search != nil {
		localVarQueryParams.Add("$search", parameterToString(*r.search, ""))
	}
	if r.filter != nil {
		localVarQueryParams.Add("$filter", parameterToString(*r.filter, ""))
	}
	if r.count != nil {
		localVarQueryParams.Add("$count", parameterToString(*r.count, ""))
	}
	if r.orderby != nil {
		localVarQueryParams.Add("$orderby", parameterToString(*r.orderby, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIdentityB2xUserFlowsListRefUserFlowIdentityProvidersRequest struct {
	ctx _context.Context
	ApiService *IdentityB2xIdentityUserFlowApiService
	b2xIdentityUserFlowId string
	top *int32
	skip *int32
	search *string
	filter *string
	count *bool
	orderby *[]string
}

// Show only the first n items
func (r ApiIdentityB2xUserFlowsListRefUserFlowIdentityProvidersRequest) Top(top int32) ApiIdentityB2xUserFlowsListRefUserFlowIdentityProvidersRequest {
	r.top = &top
	return r
}
// Skip the first n items
func (r ApiIdentityB2xUserFlowsListRefUserFlowIdentityProvidersRequest) Skip(skip int32) ApiIdentityB2xUserFlowsListRefUserFlowIdentityProvidersRequest {
	r.skip = &skip
	return r
}
// Search items by search phrases
func (r ApiIdentityB2xUserFlowsListRefUserFlowIdentityProvidersRequest) Search(search string) ApiIdentityB2xUserFlowsListRefUserFlowIdentityProvidersRequest {
	r.search = &search
	return r
}
// Filter items by property values
func (r ApiIdentityB2xUserFlowsListRefUserFlowIdentityProvidersRequest) Filter(filter string) ApiIdentityB2xUserFlowsListRefUserFlowIdentityProvidersRequest {
	r.filter = &filter
	return r
}
// Include count of items
func (r ApiIdentityB2xUserFlowsListRefUserFlowIdentityProvidersRequest) Count(count bool) ApiIdentityB2xUserFlowsListRefUserFlowIdentityProvidersRequest {
	r.count = &count
	return r
}
// Order items by property values
func (r ApiIdentityB2xUserFlowsListRefUserFlowIdentityProvidersRequest) Orderby(orderby []string) ApiIdentityB2xUserFlowsListRefUserFlowIdentityProvidersRequest {
	r.orderby = &orderby
	return r
}

func (r ApiIdentityB2xUserFlowsListRefUserFlowIdentityProvidersRequest) Execute() (CollectionOfLinksOfIdentityProviderBase, *_nethttp.Response, error) {
	return r.ApiService.IdentityB2xUserFlowsListRefUserFlowIdentityProvidersExecute(r)
}

/*
IdentityB2xUserFlowsListRefUserFlowIdentityProviders Get ref of userFlowIdentityProviders from identity

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param b2xIdentityUserFlowId key: id of b2xIdentityUserFlow
 @return ApiIdentityB2xUserFlowsListRefUserFlowIdentityProvidersRequest
*/
func (a *IdentityB2xIdentityUserFlowApiService) IdentityB2xUserFlowsListRefUserFlowIdentityProviders(ctx _context.Context, b2xIdentityUserFlowId string) ApiIdentityB2xUserFlowsListRefUserFlowIdentityProvidersRequest {
	return ApiIdentityB2xUserFlowsListRefUserFlowIdentityProvidersRequest{
		ApiService: a,
		ctx: ctx,
		b2xIdentityUserFlowId: b2xIdentityUserFlowId,
	}
}

// Execute executes the request
//  @return CollectionOfLinksOfIdentityProviderBase
func (a *IdentityB2xIdentityUserFlowApiService) IdentityB2xUserFlowsListRefUserFlowIdentityProvidersExecute(r ApiIdentityB2xUserFlowsListRefUserFlowIdentityProvidersRequest) (CollectionOfLinksOfIdentityProviderBase, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  CollectionOfLinksOfIdentityProviderBase
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IdentityB2xIdentityUserFlowApiService.IdentityB2xUserFlowsListRefUserFlowIdentityProviders")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/identity/b2xUserFlows/{b2xIdentityUserFlow-id}/userFlowIdentityProviders/$ref"
	localVarPath = strings.Replace(localVarPath, "{"+"b2xIdentityUserFlow-id"+"}", _neturl.PathEscape(parameterToString(r.b2xIdentityUserFlowId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.top != nil {
		localVarQueryParams.Add("$top", parameterToString(*r.top, ""))
	}
	if r.skip != nil {
		localVarQueryParams.Add("$skip", parameterToString(*r.skip, ""))
	}
	if r.search != nil {
		localVarQueryParams.Add("$search", parameterToString(*r.search, ""))
	}
	if r.filter != nil {
		localVarQueryParams.Add("$filter", parameterToString(*r.filter, ""))
	}
	if r.count != nil {
		localVarQueryParams.Add("$count", parameterToString(*r.count, ""))
	}
	if r.orderby != nil {
		localVarQueryParams.Add("$orderby", parameterToString(*r.orderby, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIdentityB2xUserFlowsListUserAttributeAssignmentsRequest struct {
	ctx _context.Context
	ApiService *IdentityB2xIdentityUserFlowApiService
	b2xIdentityUserFlowId string
	top *int32
	skip *int32
	search *string
	filter *string
	count *bool
	orderby *[]string
	select_ *[]string
	expand *[]string
}

// Show only the first n items
func (r ApiIdentityB2xUserFlowsListUserAttributeAssignmentsRequest) Top(top int32) ApiIdentityB2xUserFlowsListUserAttributeAssignmentsRequest {
	r.top = &top
	return r
}
// Skip the first n items
func (r ApiIdentityB2xUserFlowsListUserAttributeAssignmentsRequest) Skip(skip int32) ApiIdentityB2xUserFlowsListUserAttributeAssignmentsRequest {
	r.skip = &skip
	return r
}
// Search items by search phrases
func (r ApiIdentityB2xUserFlowsListUserAttributeAssignmentsRequest) Search(search string) ApiIdentityB2xUserFlowsListUserAttributeAssignmentsRequest {
	r.search = &search
	return r
}
// Filter items by property values
func (r ApiIdentityB2xUserFlowsListUserAttributeAssignmentsRequest) Filter(filter string) ApiIdentityB2xUserFlowsListUserAttributeAssignmentsRequest {
	r.filter = &filter
	return r
}
// Include count of items
func (r ApiIdentityB2xUserFlowsListUserAttributeAssignmentsRequest) Count(count bool) ApiIdentityB2xUserFlowsListUserAttributeAssignmentsRequest {
	r.count = &count
	return r
}
// Order items by property values
func (r ApiIdentityB2xUserFlowsListUserAttributeAssignmentsRequest) Orderby(orderby []string) ApiIdentityB2xUserFlowsListUserAttributeAssignmentsRequest {
	r.orderby = &orderby
	return r
}
// Select properties to be returned
func (r ApiIdentityB2xUserFlowsListUserAttributeAssignmentsRequest) Select_(select_ []string) ApiIdentityB2xUserFlowsListUserAttributeAssignmentsRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiIdentityB2xUserFlowsListUserAttributeAssignmentsRequest) Expand(expand []string) ApiIdentityB2xUserFlowsListUserAttributeAssignmentsRequest {
	r.expand = &expand
	return r
}

func (r ApiIdentityB2xUserFlowsListUserAttributeAssignmentsRequest) Execute() (CollectionOfIdentityUserFlowAttributeAssignment, *_nethttp.Response, error) {
	return r.ApiService.IdentityB2xUserFlowsListUserAttributeAssignmentsExecute(r)
}

/*
IdentityB2xUserFlowsListUserAttributeAssignments Get userAttributeAssignments from identity

The user attribute assignments included in the user flow.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param b2xIdentityUserFlowId key: id of b2xIdentityUserFlow
 @return ApiIdentityB2xUserFlowsListUserAttributeAssignmentsRequest
*/
func (a *IdentityB2xIdentityUserFlowApiService) IdentityB2xUserFlowsListUserAttributeAssignments(ctx _context.Context, b2xIdentityUserFlowId string) ApiIdentityB2xUserFlowsListUserAttributeAssignmentsRequest {
	return ApiIdentityB2xUserFlowsListUserAttributeAssignmentsRequest{
		ApiService: a,
		ctx: ctx,
		b2xIdentityUserFlowId: b2xIdentityUserFlowId,
	}
}

// Execute executes the request
//  @return CollectionOfIdentityUserFlowAttributeAssignment
func (a *IdentityB2xIdentityUserFlowApiService) IdentityB2xUserFlowsListUserAttributeAssignmentsExecute(r ApiIdentityB2xUserFlowsListUserAttributeAssignmentsRequest) (CollectionOfIdentityUserFlowAttributeAssignment, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  CollectionOfIdentityUserFlowAttributeAssignment
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IdentityB2xIdentityUserFlowApiService.IdentityB2xUserFlowsListUserAttributeAssignments")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/identity/b2xUserFlows/{b2xIdentityUserFlow-id}/userAttributeAssignments"
	localVarPath = strings.Replace(localVarPath, "{"+"b2xIdentityUserFlow-id"+"}", _neturl.PathEscape(parameterToString(r.b2xIdentityUserFlowId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.top != nil {
		localVarQueryParams.Add("$top", parameterToString(*r.top, ""))
	}
	if r.skip != nil {
		localVarQueryParams.Add("$skip", parameterToString(*r.skip, ""))
	}
	if r.search != nil {
		localVarQueryParams.Add("$search", parameterToString(*r.search, ""))
	}
	if r.filter != nil {
		localVarQueryParams.Add("$filter", parameterToString(*r.filter, ""))
	}
	if r.count != nil {
		localVarQueryParams.Add("$count", parameterToString(*r.count, ""))
	}
	if r.orderby != nil {
		localVarQueryParams.Add("$orderby", parameterToString(*r.orderby, "csv"))
	}
	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIdentityB2xUserFlowsListUserFlowIdentityProvidersRequest struct {
	ctx _context.Context
	ApiService *IdentityB2xIdentityUserFlowApiService
	b2xIdentityUserFlowId string
	top *int32
	skip *int32
	search *string
	filter *string
	count *bool
	orderby *[]string
	select_ *[]string
	expand *[]string
}

// Show only the first n items
func (r ApiIdentityB2xUserFlowsListUserFlowIdentityProvidersRequest) Top(top int32) ApiIdentityB2xUserFlowsListUserFlowIdentityProvidersRequest {
	r.top = &top
	return r
}
// Skip the first n items
func (r ApiIdentityB2xUserFlowsListUserFlowIdentityProvidersRequest) Skip(skip int32) ApiIdentityB2xUserFlowsListUserFlowIdentityProvidersRequest {
	r.skip = &skip
	return r
}
// Search items by search phrases
func (r ApiIdentityB2xUserFlowsListUserFlowIdentityProvidersRequest) Search(search string) ApiIdentityB2xUserFlowsListUserFlowIdentityProvidersRequest {
	r.search = &search
	return r
}
// Filter items by property values
func (r ApiIdentityB2xUserFlowsListUserFlowIdentityProvidersRequest) Filter(filter string) ApiIdentityB2xUserFlowsListUserFlowIdentityProvidersRequest {
	r.filter = &filter
	return r
}
// Include count of items
func (r ApiIdentityB2xUserFlowsListUserFlowIdentityProvidersRequest) Count(count bool) ApiIdentityB2xUserFlowsListUserFlowIdentityProvidersRequest {
	r.count = &count
	return r
}
// Order items by property values
func (r ApiIdentityB2xUserFlowsListUserFlowIdentityProvidersRequest) Orderby(orderby []string) ApiIdentityB2xUserFlowsListUserFlowIdentityProvidersRequest {
	r.orderby = &orderby
	return r
}
// Select properties to be returned
func (r ApiIdentityB2xUserFlowsListUserFlowIdentityProvidersRequest) Select_(select_ []string) ApiIdentityB2xUserFlowsListUserFlowIdentityProvidersRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiIdentityB2xUserFlowsListUserFlowIdentityProvidersRequest) Expand(expand []string) ApiIdentityB2xUserFlowsListUserFlowIdentityProvidersRequest {
	r.expand = &expand
	return r
}

func (r ApiIdentityB2xUserFlowsListUserFlowIdentityProvidersRequest) Execute() (CollectionOfIdentityProviderBase, *_nethttp.Response, error) {
	return r.ApiService.IdentityB2xUserFlowsListUserFlowIdentityProvidersExecute(r)
}

/*
IdentityB2xUserFlowsListUserFlowIdentityProviders Get userFlowIdentityProviders from identity

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param b2xIdentityUserFlowId key: id of b2xIdentityUserFlow
 @return ApiIdentityB2xUserFlowsListUserFlowIdentityProvidersRequest
*/
func (a *IdentityB2xIdentityUserFlowApiService) IdentityB2xUserFlowsListUserFlowIdentityProviders(ctx _context.Context, b2xIdentityUserFlowId string) ApiIdentityB2xUserFlowsListUserFlowIdentityProvidersRequest {
	return ApiIdentityB2xUserFlowsListUserFlowIdentityProvidersRequest{
		ApiService: a,
		ctx: ctx,
		b2xIdentityUserFlowId: b2xIdentityUserFlowId,
	}
}

// Execute executes the request
//  @return CollectionOfIdentityProviderBase
func (a *IdentityB2xIdentityUserFlowApiService) IdentityB2xUserFlowsListUserFlowIdentityProvidersExecute(r ApiIdentityB2xUserFlowsListUserFlowIdentityProvidersRequest) (CollectionOfIdentityProviderBase, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  CollectionOfIdentityProviderBase
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IdentityB2xIdentityUserFlowApiService.IdentityB2xUserFlowsListUserFlowIdentityProviders")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/identity/b2xUserFlows/{b2xIdentityUserFlow-id}/userFlowIdentityProviders"
	localVarPath = strings.Replace(localVarPath, "{"+"b2xIdentityUserFlow-id"+"}", _neturl.PathEscape(parameterToString(r.b2xIdentityUserFlowId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.top != nil {
		localVarQueryParams.Add("$top", parameterToString(*r.top, ""))
	}
	if r.skip != nil {
		localVarQueryParams.Add("$skip", parameterToString(*r.skip, ""))
	}
	if r.search != nil {
		localVarQueryParams.Add("$search", parameterToString(*r.search, ""))
	}
	if r.filter != nil {
		localVarQueryParams.Add("$filter", parameterToString(*r.filter, ""))
	}
	if r.count != nil {
		localVarQueryParams.Add("$count", parameterToString(*r.count, ""))
	}
	if r.orderby != nil {
		localVarQueryParams.Add("$orderby", parameterToString(*r.orderby, "csv"))
	}
	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIdentityB2xUserFlowsUpdateLanguagesRequest struct {
	ctx _context.Context
	ApiService *IdentityB2xIdentityUserFlowApiService
	b2xIdentityUserFlowId string
	userFlowLanguageConfigurationId string
	microsoftGraphUserFlowLanguageConfiguration *MicrosoftGraphUserFlowLanguageConfiguration
}

// New navigation property values
func (r ApiIdentityB2xUserFlowsUpdateLanguagesRequest) MicrosoftGraphUserFlowLanguageConfiguration(microsoftGraphUserFlowLanguageConfiguration MicrosoftGraphUserFlowLanguageConfiguration) ApiIdentityB2xUserFlowsUpdateLanguagesRequest {
	r.microsoftGraphUserFlowLanguageConfiguration = &microsoftGraphUserFlowLanguageConfiguration
	return r
}

func (r ApiIdentityB2xUserFlowsUpdateLanguagesRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.IdentityB2xUserFlowsUpdateLanguagesExecute(r)
}

/*
IdentityB2xUserFlowsUpdateLanguages Update the navigation property languages in identity

The languages supported for customization within the user flow. Language customization is enabled by default in self-service sign-up user flow. You cannot create custom languages in self-service sign-up user flows.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param b2xIdentityUserFlowId key: id of b2xIdentityUserFlow
 @param userFlowLanguageConfigurationId key: id of userFlowLanguageConfiguration
 @return ApiIdentityB2xUserFlowsUpdateLanguagesRequest
*/
func (a *IdentityB2xIdentityUserFlowApiService) IdentityB2xUserFlowsUpdateLanguages(ctx _context.Context, b2xIdentityUserFlowId string, userFlowLanguageConfigurationId string) ApiIdentityB2xUserFlowsUpdateLanguagesRequest {
	return ApiIdentityB2xUserFlowsUpdateLanguagesRequest{
		ApiService: a,
		ctx: ctx,
		b2xIdentityUserFlowId: b2xIdentityUserFlowId,
		userFlowLanguageConfigurationId: userFlowLanguageConfigurationId,
	}
}

// Execute executes the request
func (a *IdentityB2xIdentityUserFlowApiService) IdentityB2xUserFlowsUpdateLanguagesExecute(r ApiIdentityB2xUserFlowsUpdateLanguagesRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPatch
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IdentityB2xIdentityUserFlowApiService.IdentityB2xUserFlowsUpdateLanguages")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/identity/b2xUserFlows/{b2xIdentityUserFlow-id}/languages/{userFlowLanguageConfiguration-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"b2xIdentityUserFlow-id"+"}", _neturl.PathEscape(parameterToString(r.b2xIdentityUserFlowId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"userFlowLanguageConfiguration-id"+"}", _neturl.PathEscape(parameterToString(r.userFlowLanguageConfigurationId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphUserFlowLanguageConfiguration == nil {
		return nil, reportError("microsoftGraphUserFlowLanguageConfiguration is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphUserFlowLanguageConfiguration
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiIdentityB2xUserFlowsUpdateUserAttributeAssignmentsRequest struct {
	ctx _context.Context
	ApiService *IdentityB2xIdentityUserFlowApiService
	b2xIdentityUserFlowId string
	identityUserFlowAttributeAssignmentId string
	microsoftGraphIdentityUserFlowAttributeAssignment *MicrosoftGraphIdentityUserFlowAttributeAssignment
}

// New navigation property values
func (r ApiIdentityB2xUserFlowsUpdateUserAttributeAssignmentsRequest) MicrosoftGraphIdentityUserFlowAttributeAssignment(microsoftGraphIdentityUserFlowAttributeAssignment MicrosoftGraphIdentityUserFlowAttributeAssignment) ApiIdentityB2xUserFlowsUpdateUserAttributeAssignmentsRequest {
	r.microsoftGraphIdentityUserFlowAttributeAssignment = &microsoftGraphIdentityUserFlowAttributeAssignment
	return r
}

func (r ApiIdentityB2xUserFlowsUpdateUserAttributeAssignmentsRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.IdentityB2xUserFlowsUpdateUserAttributeAssignmentsExecute(r)
}

/*
IdentityB2xUserFlowsUpdateUserAttributeAssignments Update the navigation property userAttributeAssignments in identity

The user attribute assignments included in the user flow.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param b2xIdentityUserFlowId key: id of b2xIdentityUserFlow
 @param identityUserFlowAttributeAssignmentId key: id of identityUserFlowAttributeAssignment
 @return ApiIdentityB2xUserFlowsUpdateUserAttributeAssignmentsRequest
*/
func (a *IdentityB2xIdentityUserFlowApiService) IdentityB2xUserFlowsUpdateUserAttributeAssignments(ctx _context.Context, b2xIdentityUserFlowId string, identityUserFlowAttributeAssignmentId string) ApiIdentityB2xUserFlowsUpdateUserAttributeAssignmentsRequest {
	return ApiIdentityB2xUserFlowsUpdateUserAttributeAssignmentsRequest{
		ApiService: a,
		ctx: ctx,
		b2xIdentityUserFlowId: b2xIdentityUserFlowId,
		identityUserFlowAttributeAssignmentId: identityUserFlowAttributeAssignmentId,
	}
}

// Execute executes the request
func (a *IdentityB2xIdentityUserFlowApiService) IdentityB2xUserFlowsUpdateUserAttributeAssignmentsExecute(r ApiIdentityB2xUserFlowsUpdateUserAttributeAssignmentsRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPatch
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IdentityB2xIdentityUserFlowApiService.IdentityB2xUserFlowsUpdateUserAttributeAssignments")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/identity/b2xUserFlows/{b2xIdentityUserFlow-id}/userAttributeAssignments/{identityUserFlowAttributeAssignment-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"b2xIdentityUserFlow-id"+"}", _neturl.PathEscape(parameterToString(r.b2xIdentityUserFlowId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"identityUserFlowAttributeAssignment-id"+"}", _neturl.PathEscape(parameterToString(r.identityUserFlowAttributeAssignmentId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphIdentityUserFlowAttributeAssignment == nil {
		return nil, reportError("microsoftGraphIdentityUserFlowAttributeAssignment is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphIdentityUserFlowAttributeAssignment
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiIdentityB2xUserFlowsUserAttributeAssignmentsDeleteRefUserAttributeRequest struct {
	ctx _context.Context
	ApiService *IdentityB2xIdentityUserFlowApiService
	b2xIdentityUserFlowId string
	identityUserFlowAttributeAssignmentId string
	ifMatch *string
}

// ETag
func (r ApiIdentityB2xUserFlowsUserAttributeAssignmentsDeleteRefUserAttributeRequest) IfMatch(ifMatch string) ApiIdentityB2xUserFlowsUserAttributeAssignmentsDeleteRefUserAttributeRequest {
	r.ifMatch = &ifMatch
	return r
}

func (r ApiIdentityB2xUserFlowsUserAttributeAssignmentsDeleteRefUserAttributeRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.IdentityB2xUserFlowsUserAttributeAssignmentsDeleteRefUserAttributeExecute(r)
}

/*
IdentityB2xUserFlowsUserAttributeAssignmentsDeleteRefUserAttribute Delete ref of navigation property userAttribute for identity

The user attribute that you want to add to your user flow.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param b2xIdentityUserFlowId key: id of b2xIdentityUserFlow
 @param identityUserFlowAttributeAssignmentId key: id of identityUserFlowAttributeAssignment
 @return ApiIdentityB2xUserFlowsUserAttributeAssignmentsDeleteRefUserAttributeRequest
*/
func (a *IdentityB2xIdentityUserFlowApiService) IdentityB2xUserFlowsUserAttributeAssignmentsDeleteRefUserAttribute(ctx _context.Context, b2xIdentityUserFlowId string, identityUserFlowAttributeAssignmentId string) ApiIdentityB2xUserFlowsUserAttributeAssignmentsDeleteRefUserAttributeRequest {
	return ApiIdentityB2xUserFlowsUserAttributeAssignmentsDeleteRefUserAttributeRequest{
		ApiService: a,
		ctx: ctx,
		b2xIdentityUserFlowId: b2xIdentityUserFlowId,
		identityUserFlowAttributeAssignmentId: identityUserFlowAttributeAssignmentId,
	}
}

// Execute executes the request
func (a *IdentityB2xIdentityUserFlowApiService) IdentityB2xUserFlowsUserAttributeAssignmentsDeleteRefUserAttributeExecute(r ApiIdentityB2xUserFlowsUserAttributeAssignmentsDeleteRefUserAttributeRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IdentityB2xIdentityUserFlowApiService.IdentityB2xUserFlowsUserAttributeAssignmentsDeleteRefUserAttribute")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/identity/b2xUserFlows/{b2xIdentityUserFlow-id}/userAttributeAssignments/{identityUserFlowAttributeAssignment-id}/userAttribute/$ref"
	localVarPath = strings.Replace(localVarPath, "{"+"b2xIdentityUserFlow-id"+"}", _neturl.PathEscape(parameterToString(r.b2xIdentityUserFlowId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"identityUserFlowAttributeAssignment-id"+"}", _neturl.PathEscape(parameterToString(r.identityUserFlowAttributeAssignmentId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ifMatch != nil {
		localVarHeaderParams["If-Match"] = parameterToString(*r.ifMatch, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiIdentityB2xUserFlowsUserAttributeAssignmentsGetRefUserAttributeRequest struct {
	ctx _context.Context
	ApiService *IdentityB2xIdentityUserFlowApiService
	b2xIdentityUserFlowId string
	identityUserFlowAttributeAssignmentId string
}


func (r ApiIdentityB2xUserFlowsUserAttributeAssignmentsGetRefUserAttributeRequest) Execute() (string, *_nethttp.Response, error) {
	return r.ApiService.IdentityB2xUserFlowsUserAttributeAssignmentsGetRefUserAttributeExecute(r)
}

/*
IdentityB2xUserFlowsUserAttributeAssignmentsGetRefUserAttribute Get ref of userAttribute from identity

The user attribute that you want to add to your user flow.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param b2xIdentityUserFlowId key: id of b2xIdentityUserFlow
 @param identityUserFlowAttributeAssignmentId key: id of identityUserFlowAttributeAssignment
 @return ApiIdentityB2xUserFlowsUserAttributeAssignmentsGetRefUserAttributeRequest
*/
func (a *IdentityB2xIdentityUserFlowApiService) IdentityB2xUserFlowsUserAttributeAssignmentsGetRefUserAttribute(ctx _context.Context, b2xIdentityUserFlowId string, identityUserFlowAttributeAssignmentId string) ApiIdentityB2xUserFlowsUserAttributeAssignmentsGetRefUserAttributeRequest {
	return ApiIdentityB2xUserFlowsUserAttributeAssignmentsGetRefUserAttributeRequest{
		ApiService: a,
		ctx: ctx,
		b2xIdentityUserFlowId: b2xIdentityUserFlowId,
		identityUserFlowAttributeAssignmentId: identityUserFlowAttributeAssignmentId,
	}
}

// Execute executes the request
//  @return string
func (a *IdentityB2xIdentityUserFlowApiService) IdentityB2xUserFlowsUserAttributeAssignmentsGetRefUserAttributeExecute(r ApiIdentityB2xUserFlowsUserAttributeAssignmentsGetRefUserAttributeRequest) (string, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  string
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IdentityB2xIdentityUserFlowApiService.IdentityB2xUserFlowsUserAttributeAssignmentsGetRefUserAttribute")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/identity/b2xUserFlows/{b2xIdentityUserFlow-id}/userAttributeAssignments/{identityUserFlowAttributeAssignment-id}/userAttribute/$ref"
	localVarPath = strings.Replace(localVarPath, "{"+"b2xIdentityUserFlow-id"+"}", _neturl.PathEscape(parameterToString(r.b2xIdentityUserFlowId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"identityUserFlowAttributeAssignment-id"+"}", _neturl.PathEscape(parameterToString(r.identityUserFlowAttributeAssignmentId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIdentityB2xUserFlowsUserAttributeAssignmentsGetUserAttributeRequest struct {
	ctx _context.Context
	ApiService *IdentityB2xIdentityUserFlowApiService
	b2xIdentityUserFlowId string
	identityUserFlowAttributeAssignmentId string
	select_ *[]string
	expand *[]string
}

// Select properties to be returned
func (r ApiIdentityB2xUserFlowsUserAttributeAssignmentsGetUserAttributeRequest) Select_(select_ []string) ApiIdentityB2xUserFlowsUserAttributeAssignmentsGetUserAttributeRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiIdentityB2xUserFlowsUserAttributeAssignmentsGetUserAttributeRequest) Expand(expand []string) ApiIdentityB2xUserFlowsUserAttributeAssignmentsGetUserAttributeRequest {
	r.expand = &expand
	return r
}

func (r ApiIdentityB2xUserFlowsUserAttributeAssignmentsGetUserAttributeRequest) Execute() (MicrosoftGraphIdentityUserFlowAttribute, *_nethttp.Response, error) {
	return r.ApiService.IdentityB2xUserFlowsUserAttributeAssignmentsGetUserAttributeExecute(r)
}

/*
IdentityB2xUserFlowsUserAttributeAssignmentsGetUserAttribute Get userAttribute from identity

The user attribute that you want to add to your user flow.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param b2xIdentityUserFlowId key: id of b2xIdentityUserFlow
 @param identityUserFlowAttributeAssignmentId key: id of identityUserFlowAttributeAssignment
 @return ApiIdentityB2xUserFlowsUserAttributeAssignmentsGetUserAttributeRequest
*/
func (a *IdentityB2xIdentityUserFlowApiService) IdentityB2xUserFlowsUserAttributeAssignmentsGetUserAttribute(ctx _context.Context, b2xIdentityUserFlowId string, identityUserFlowAttributeAssignmentId string) ApiIdentityB2xUserFlowsUserAttributeAssignmentsGetUserAttributeRequest {
	return ApiIdentityB2xUserFlowsUserAttributeAssignmentsGetUserAttributeRequest{
		ApiService: a,
		ctx: ctx,
		b2xIdentityUserFlowId: b2xIdentityUserFlowId,
		identityUserFlowAttributeAssignmentId: identityUserFlowAttributeAssignmentId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphIdentityUserFlowAttribute
func (a *IdentityB2xIdentityUserFlowApiService) IdentityB2xUserFlowsUserAttributeAssignmentsGetUserAttributeExecute(r ApiIdentityB2xUserFlowsUserAttributeAssignmentsGetUserAttributeRequest) (MicrosoftGraphIdentityUserFlowAttribute, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphIdentityUserFlowAttribute
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IdentityB2xIdentityUserFlowApiService.IdentityB2xUserFlowsUserAttributeAssignmentsGetUserAttribute")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/identity/b2xUserFlows/{b2xIdentityUserFlow-id}/userAttributeAssignments/{identityUserFlowAttributeAssignment-id}/userAttribute"
	localVarPath = strings.Replace(localVarPath, "{"+"b2xIdentityUserFlow-id"+"}", _neturl.PathEscape(parameterToString(r.b2xIdentityUserFlowId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"identityUserFlowAttributeAssignment-id"+"}", _neturl.PathEscape(parameterToString(r.identityUserFlowAttributeAssignmentId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIdentityB2xUserFlowsUserAttributeAssignmentsUpdateRefUserAttributeRequest struct {
	ctx _context.Context
	ApiService *IdentityB2xIdentityUserFlowApiService
	b2xIdentityUserFlowId string
	identityUserFlowAttributeAssignmentId string
	requestBody *map[string]map[string]interface{}
}

// New navigation property ref values
func (r ApiIdentityB2xUserFlowsUserAttributeAssignmentsUpdateRefUserAttributeRequest) RequestBody(requestBody map[string]map[string]interface{}) ApiIdentityB2xUserFlowsUserAttributeAssignmentsUpdateRefUserAttributeRequest {
	r.requestBody = &requestBody
	return r
}

func (r ApiIdentityB2xUserFlowsUserAttributeAssignmentsUpdateRefUserAttributeRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.IdentityB2xUserFlowsUserAttributeAssignmentsUpdateRefUserAttributeExecute(r)
}

/*
IdentityB2xUserFlowsUserAttributeAssignmentsUpdateRefUserAttribute Update the ref of navigation property userAttribute in identity

The user attribute that you want to add to your user flow.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param b2xIdentityUserFlowId key: id of b2xIdentityUserFlow
 @param identityUserFlowAttributeAssignmentId key: id of identityUserFlowAttributeAssignment
 @return ApiIdentityB2xUserFlowsUserAttributeAssignmentsUpdateRefUserAttributeRequest
*/
func (a *IdentityB2xIdentityUserFlowApiService) IdentityB2xUserFlowsUserAttributeAssignmentsUpdateRefUserAttribute(ctx _context.Context, b2xIdentityUserFlowId string, identityUserFlowAttributeAssignmentId string) ApiIdentityB2xUserFlowsUserAttributeAssignmentsUpdateRefUserAttributeRequest {
	return ApiIdentityB2xUserFlowsUserAttributeAssignmentsUpdateRefUserAttributeRequest{
		ApiService: a,
		ctx: ctx,
		b2xIdentityUserFlowId: b2xIdentityUserFlowId,
		identityUserFlowAttributeAssignmentId: identityUserFlowAttributeAssignmentId,
	}
}

// Execute executes the request
func (a *IdentityB2xIdentityUserFlowApiService) IdentityB2xUserFlowsUserAttributeAssignmentsUpdateRefUserAttributeExecute(r ApiIdentityB2xUserFlowsUserAttributeAssignmentsUpdateRefUserAttributeRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPut
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IdentityB2xIdentityUserFlowApiService.IdentityB2xUserFlowsUserAttributeAssignmentsUpdateRefUserAttribute")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/identity/b2xUserFlows/{b2xIdentityUserFlow-id}/userAttributeAssignments/{identityUserFlowAttributeAssignment-id}/userAttribute/$ref"
	localVarPath = strings.Replace(localVarPath, "{"+"b2xIdentityUserFlow-id"+"}", _neturl.PathEscape(parameterToString(r.b2xIdentityUserFlowId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"identityUserFlowAttributeAssignment-id"+"}", _neturl.PathEscape(parameterToString(r.identityUserFlowAttributeAssignmentId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.requestBody == nil {
		return nil, reportError("requestBody is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.requestBody
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiIdentityCreateB2xUserFlowsRequest struct {
	ctx _context.Context
	ApiService *IdentityB2xIdentityUserFlowApiService
	microsoftGraphB2xIdentityUserFlow *MicrosoftGraphB2xIdentityUserFlow
}

// New navigation property
func (r ApiIdentityCreateB2xUserFlowsRequest) MicrosoftGraphB2xIdentityUserFlow(microsoftGraphB2xIdentityUserFlow MicrosoftGraphB2xIdentityUserFlow) ApiIdentityCreateB2xUserFlowsRequest {
	r.microsoftGraphB2xIdentityUserFlow = &microsoftGraphB2xIdentityUserFlow
	return r
}

func (r ApiIdentityCreateB2xUserFlowsRequest) Execute() (MicrosoftGraphB2xIdentityUserFlow, *_nethttp.Response, error) {
	return r.ApiService.IdentityCreateB2xUserFlowsExecute(r)
}

/*
IdentityCreateB2xUserFlows Create new navigation property to b2xUserFlows for identity

Represents entry point for B2X/self-service sign-up identity userflows.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiIdentityCreateB2xUserFlowsRequest
*/
func (a *IdentityB2xIdentityUserFlowApiService) IdentityCreateB2xUserFlows(ctx _context.Context) ApiIdentityCreateB2xUserFlowsRequest {
	return ApiIdentityCreateB2xUserFlowsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return MicrosoftGraphB2xIdentityUserFlow
func (a *IdentityB2xIdentityUserFlowApiService) IdentityCreateB2xUserFlowsExecute(r ApiIdentityCreateB2xUserFlowsRequest) (MicrosoftGraphB2xIdentityUserFlow, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphB2xIdentityUserFlow
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IdentityB2xIdentityUserFlowApiService.IdentityCreateB2xUserFlows")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/identity/b2xUserFlows"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphB2xIdentityUserFlow == nil {
		return localVarReturnValue, nil, reportError("microsoftGraphB2xIdentityUserFlow is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphB2xIdentityUserFlow
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIdentityDeleteB2xUserFlowsRequest struct {
	ctx _context.Context
	ApiService *IdentityB2xIdentityUserFlowApiService
	b2xIdentityUserFlowId string
	ifMatch *string
}

// ETag
func (r ApiIdentityDeleteB2xUserFlowsRequest) IfMatch(ifMatch string) ApiIdentityDeleteB2xUserFlowsRequest {
	r.ifMatch = &ifMatch
	return r
}

func (r ApiIdentityDeleteB2xUserFlowsRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.IdentityDeleteB2xUserFlowsExecute(r)
}

/*
IdentityDeleteB2xUserFlows Delete navigation property b2xUserFlows for identity

Represents entry point for B2X/self-service sign-up identity userflows.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param b2xIdentityUserFlowId key: id of b2xIdentityUserFlow
 @return ApiIdentityDeleteB2xUserFlowsRequest
*/
func (a *IdentityB2xIdentityUserFlowApiService) IdentityDeleteB2xUserFlows(ctx _context.Context, b2xIdentityUserFlowId string) ApiIdentityDeleteB2xUserFlowsRequest {
	return ApiIdentityDeleteB2xUserFlowsRequest{
		ApiService: a,
		ctx: ctx,
		b2xIdentityUserFlowId: b2xIdentityUserFlowId,
	}
}

// Execute executes the request
func (a *IdentityB2xIdentityUserFlowApiService) IdentityDeleteB2xUserFlowsExecute(r ApiIdentityDeleteB2xUserFlowsRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IdentityB2xIdentityUserFlowApiService.IdentityDeleteB2xUserFlows")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/identity/b2xUserFlows/{b2xIdentityUserFlow-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"b2xIdentityUserFlow-id"+"}", _neturl.PathEscape(parameterToString(r.b2xIdentityUserFlowId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ifMatch != nil {
		localVarHeaderParams["If-Match"] = parameterToString(*r.ifMatch, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiIdentityGetB2xUserFlowsRequest struct {
	ctx _context.Context
	ApiService *IdentityB2xIdentityUserFlowApiService
	b2xIdentityUserFlowId string
	select_ *[]string
	expand *[]string
}

// Select properties to be returned
func (r ApiIdentityGetB2xUserFlowsRequest) Select_(select_ []string) ApiIdentityGetB2xUserFlowsRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiIdentityGetB2xUserFlowsRequest) Expand(expand []string) ApiIdentityGetB2xUserFlowsRequest {
	r.expand = &expand
	return r
}

func (r ApiIdentityGetB2xUserFlowsRequest) Execute() (MicrosoftGraphB2xIdentityUserFlow, *_nethttp.Response, error) {
	return r.ApiService.IdentityGetB2xUserFlowsExecute(r)
}

/*
IdentityGetB2xUserFlows Get b2xUserFlows from identity

Represents entry point for B2X/self-service sign-up identity userflows.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param b2xIdentityUserFlowId key: id of b2xIdentityUserFlow
 @return ApiIdentityGetB2xUserFlowsRequest
*/
func (a *IdentityB2xIdentityUserFlowApiService) IdentityGetB2xUserFlows(ctx _context.Context, b2xIdentityUserFlowId string) ApiIdentityGetB2xUserFlowsRequest {
	return ApiIdentityGetB2xUserFlowsRequest{
		ApiService: a,
		ctx: ctx,
		b2xIdentityUserFlowId: b2xIdentityUserFlowId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphB2xIdentityUserFlow
func (a *IdentityB2xIdentityUserFlowApiService) IdentityGetB2xUserFlowsExecute(r ApiIdentityGetB2xUserFlowsRequest) (MicrosoftGraphB2xIdentityUserFlow, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphB2xIdentityUserFlow
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IdentityB2xIdentityUserFlowApiService.IdentityGetB2xUserFlows")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/identity/b2xUserFlows/{b2xIdentityUserFlow-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"b2xIdentityUserFlow-id"+"}", _neturl.PathEscape(parameterToString(r.b2xIdentityUserFlowId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIdentityListB2xUserFlowsRequest struct {
	ctx _context.Context
	ApiService *IdentityB2xIdentityUserFlowApiService
	top *int32
	skip *int32
	search *string
	filter *string
	count *bool
	orderby *[]string
	select_ *[]string
	expand *[]string
}

// Show only the first n items
func (r ApiIdentityListB2xUserFlowsRequest) Top(top int32) ApiIdentityListB2xUserFlowsRequest {
	r.top = &top
	return r
}
// Skip the first n items
func (r ApiIdentityListB2xUserFlowsRequest) Skip(skip int32) ApiIdentityListB2xUserFlowsRequest {
	r.skip = &skip
	return r
}
// Search items by search phrases
func (r ApiIdentityListB2xUserFlowsRequest) Search(search string) ApiIdentityListB2xUserFlowsRequest {
	r.search = &search
	return r
}
// Filter items by property values
func (r ApiIdentityListB2xUserFlowsRequest) Filter(filter string) ApiIdentityListB2xUserFlowsRequest {
	r.filter = &filter
	return r
}
// Include count of items
func (r ApiIdentityListB2xUserFlowsRequest) Count(count bool) ApiIdentityListB2xUserFlowsRequest {
	r.count = &count
	return r
}
// Order items by property values
func (r ApiIdentityListB2xUserFlowsRequest) Orderby(orderby []string) ApiIdentityListB2xUserFlowsRequest {
	r.orderby = &orderby
	return r
}
// Select properties to be returned
func (r ApiIdentityListB2xUserFlowsRequest) Select_(select_ []string) ApiIdentityListB2xUserFlowsRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiIdentityListB2xUserFlowsRequest) Expand(expand []string) ApiIdentityListB2xUserFlowsRequest {
	r.expand = &expand
	return r
}

func (r ApiIdentityListB2xUserFlowsRequest) Execute() (CollectionOfB2xIdentityUserFlow, *_nethttp.Response, error) {
	return r.ApiService.IdentityListB2xUserFlowsExecute(r)
}

/*
IdentityListB2xUserFlows Get b2xUserFlows from identity

Represents entry point for B2X/self-service sign-up identity userflows.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiIdentityListB2xUserFlowsRequest
*/
func (a *IdentityB2xIdentityUserFlowApiService) IdentityListB2xUserFlows(ctx _context.Context) ApiIdentityListB2xUserFlowsRequest {
	return ApiIdentityListB2xUserFlowsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CollectionOfB2xIdentityUserFlow
func (a *IdentityB2xIdentityUserFlowApiService) IdentityListB2xUserFlowsExecute(r ApiIdentityListB2xUserFlowsRequest) (CollectionOfB2xIdentityUserFlow, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  CollectionOfB2xIdentityUserFlow
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IdentityB2xIdentityUserFlowApiService.IdentityListB2xUserFlows")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/identity/b2xUserFlows"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.top != nil {
		localVarQueryParams.Add("$top", parameterToString(*r.top, ""))
	}
	if r.skip != nil {
		localVarQueryParams.Add("$skip", parameterToString(*r.skip, ""))
	}
	if r.search != nil {
		localVarQueryParams.Add("$search", parameterToString(*r.search, ""))
	}
	if r.filter != nil {
		localVarQueryParams.Add("$filter", parameterToString(*r.filter, ""))
	}
	if r.count != nil {
		localVarQueryParams.Add("$count", parameterToString(*r.count, ""))
	}
	if r.orderby != nil {
		localVarQueryParams.Add("$orderby", parameterToString(*r.orderby, "csv"))
	}
	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIdentityUpdateB2xUserFlowsRequest struct {
	ctx _context.Context
	ApiService *IdentityB2xIdentityUserFlowApiService
	b2xIdentityUserFlowId string
	microsoftGraphB2xIdentityUserFlow *MicrosoftGraphB2xIdentityUserFlow
}

// New navigation property values
func (r ApiIdentityUpdateB2xUserFlowsRequest) MicrosoftGraphB2xIdentityUserFlow(microsoftGraphB2xIdentityUserFlow MicrosoftGraphB2xIdentityUserFlow) ApiIdentityUpdateB2xUserFlowsRequest {
	r.microsoftGraphB2xIdentityUserFlow = &microsoftGraphB2xIdentityUserFlow
	return r
}

func (r ApiIdentityUpdateB2xUserFlowsRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.IdentityUpdateB2xUserFlowsExecute(r)
}

/*
IdentityUpdateB2xUserFlows Update the navigation property b2xUserFlows in identity

Represents entry point for B2X/self-service sign-up identity userflows.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param b2xIdentityUserFlowId key: id of b2xIdentityUserFlow
 @return ApiIdentityUpdateB2xUserFlowsRequest
*/
func (a *IdentityB2xIdentityUserFlowApiService) IdentityUpdateB2xUserFlows(ctx _context.Context, b2xIdentityUserFlowId string) ApiIdentityUpdateB2xUserFlowsRequest {
	return ApiIdentityUpdateB2xUserFlowsRequest{
		ApiService: a,
		ctx: ctx,
		b2xIdentityUserFlowId: b2xIdentityUserFlowId,
	}
}

// Execute executes the request
func (a *IdentityB2xIdentityUserFlowApiService) IdentityUpdateB2xUserFlowsExecute(r ApiIdentityUpdateB2xUserFlowsRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPatch
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IdentityB2xIdentityUserFlowApiService.IdentityUpdateB2xUserFlows")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/identity/b2xUserFlows/{b2xIdentityUserFlow-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"b2xIdentityUserFlow-id"+"}", _neturl.PathEscape(parameterToString(r.b2xIdentityUserFlowId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphB2xIdentityUserFlow == nil {
		return nil, reportError("microsoftGraphB2xIdentityUserFlow is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphB2xIdentityUserFlow
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}
