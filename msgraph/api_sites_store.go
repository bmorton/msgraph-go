/*
Partial Graph API

No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

API version: v1.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package openapi

import (
	"bytes"
	_context "context"
	_ioutil "io/ioutil"
	_nethttp "net/http"
	_neturl "net/url"
	"strings"
)

// Linger please
var (
	_ _context.Context
)

// SitesStoreApiService SitesStoreApi service
type SitesStoreApiService service

type ApiSitesCreateTermStoresRequest struct {
	ctx _context.Context
	ApiService *SitesStoreApiService
	siteId string
	microsoftGraphTermStoreStore *MicrosoftGraphTermStoreStore
}

// New navigation property
func (r ApiSitesCreateTermStoresRequest) MicrosoftGraphTermStoreStore(microsoftGraphTermStoreStore MicrosoftGraphTermStoreStore) ApiSitesCreateTermStoresRequest {
	r.microsoftGraphTermStoreStore = &microsoftGraphTermStoreStore
	return r
}

func (r ApiSitesCreateTermStoresRequest) Execute() (MicrosoftGraphTermStoreStore, *_nethttp.Response, error) {
	return r.ApiService.SitesCreateTermStoresExecute(r)
}

/*
SitesCreateTermStores Create new navigation property to termStores for sites

The collection of termStores under this site.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param siteId key: id of site
 @return ApiSitesCreateTermStoresRequest
*/
func (a *SitesStoreApiService) SitesCreateTermStores(ctx _context.Context, siteId string) ApiSitesCreateTermStoresRequest {
	return ApiSitesCreateTermStoresRequest{
		ApiService: a,
		ctx: ctx,
		siteId: siteId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphTermStoreStore
func (a *SitesStoreApiService) SitesCreateTermStoresExecute(r ApiSitesCreateTermStoresRequest) (MicrosoftGraphTermStoreStore, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphTermStoreStore
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SitesStoreApiService.SitesCreateTermStores")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sites/{site-id}/termStores"
	localVarPath = strings.Replace(localVarPath, "{"+"site-id"+"}", _neturl.PathEscape(parameterToString(r.siteId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphTermStoreStore == nil {
		return localVarReturnValue, nil, reportError("microsoftGraphTermStoreStore is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphTermStoreStore
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSitesDeleteTermStoreRequest struct {
	ctx _context.Context
	ApiService *SitesStoreApiService
	siteId string
	ifMatch *string
}

// ETag
func (r ApiSitesDeleteTermStoreRequest) IfMatch(ifMatch string) ApiSitesDeleteTermStoreRequest {
	r.ifMatch = &ifMatch
	return r
}

func (r ApiSitesDeleteTermStoreRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.SitesDeleteTermStoreExecute(r)
}

/*
SitesDeleteTermStore Delete navigation property termStore for sites

The default termStore under this site.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param siteId key: id of site
 @return ApiSitesDeleteTermStoreRequest
*/
func (a *SitesStoreApiService) SitesDeleteTermStore(ctx _context.Context, siteId string) ApiSitesDeleteTermStoreRequest {
	return ApiSitesDeleteTermStoreRequest{
		ApiService: a,
		ctx: ctx,
		siteId: siteId,
	}
}

// Execute executes the request
func (a *SitesStoreApiService) SitesDeleteTermStoreExecute(r ApiSitesDeleteTermStoreRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SitesStoreApiService.SitesDeleteTermStore")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sites/{site-id}/termStore"
	localVarPath = strings.Replace(localVarPath, "{"+"site-id"+"}", _neturl.PathEscape(parameterToString(r.siteId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ifMatch != nil {
		localVarHeaderParams["If-Match"] = parameterToString(*r.ifMatch, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiSitesDeleteTermStoresRequest struct {
	ctx _context.Context
	ApiService *SitesStoreApiService
	siteId string
	storeId string
	ifMatch *string
}

// ETag
func (r ApiSitesDeleteTermStoresRequest) IfMatch(ifMatch string) ApiSitesDeleteTermStoresRequest {
	r.ifMatch = &ifMatch
	return r
}

func (r ApiSitesDeleteTermStoresRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.SitesDeleteTermStoresExecute(r)
}

/*
SitesDeleteTermStores Delete navigation property termStores for sites

The collection of termStores under this site.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param siteId key: id of site
 @param storeId key: id of store
 @return ApiSitesDeleteTermStoresRequest
*/
func (a *SitesStoreApiService) SitesDeleteTermStores(ctx _context.Context, siteId string, storeId string) ApiSitesDeleteTermStoresRequest {
	return ApiSitesDeleteTermStoresRequest{
		ApiService: a,
		ctx: ctx,
		siteId: siteId,
		storeId: storeId,
	}
}

// Execute executes the request
func (a *SitesStoreApiService) SitesDeleteTermStoresExecute(r ApiSitesDeleteTermStoresRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SitesStoreApiService.SitesDeleteTermStores")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sites/{site-id}/termStores/{store-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"site-id"+"}", _neturl.PathEscape(parameterToString(r.siteId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"store-id"+"}", _neturl.PathEscape(parameterToString(r.storeId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ifMatch != nil {
		localVarHeaderParams["If-Match"] = parameterToString(*r.ifMatch, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiSitesGetTermStoreRequest struct {
	ctx _context.Context
	ApiService *SitesStoreApiService
	siteId string
	select_ *[]string
	expand *[]string
}

// Select properties to be returned
func (r ApiSitesGetTermStoreRequest) Select_(select_ []string) ApiSitesGetTermStoreRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiSitesGetTermStoreRequest) Expand(expand []string) ApiSitesGetTermStoreRequest {
	r.expand = &expand
	return r
}

func (r ApiSitesGetTermStoreRequest) Execute() (MicrosoftGraphTermStoreStore, *_nethttp.Response, error) {
	return r.ApiService.SitesGetTermStoreExecute(r)
}

/*
SitesGetTermStore Get termStore from sites

The default termStore under this site.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param siteId key: id of site
 @return ApiSitesGetTermStoreRequest
*/
func (a *SitesStoreApiService) SitesGetTermStore(ctx _context.Context, siteId string) ApiSitesGetTermStoreRequest {
	return ApiSitesGetTermStoreRequest{
		ApiService: a,
		ctx: ctx,
		siteId: siteId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphTermStoreStore
func (a *SitesStoreApiService) SitesGetTermStoreExecute(r ApiSitesGetTermStoreRequest) (MicrosoftGraphTermStoreStore, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphTermStoreStore
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SitesStoreApiService.SitesGetTermStore")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sites/{site-id}/termStore"
	localVarPath = strings.Replace(localVarPath, "{"+"site-id"+"}", _neturl.PathEscape(parameterToString(r.siteId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSitesGetTermStoresRequest struct {
	ctx _context.Context
	ApiService *SitesStoreApiService
	siteId string
	storeId string
	select_ *[]string
	expand *[]string
}

// Select properties to be returned
func (r ApiSitesGetTermStoresRequest) Select_(select_ []string) ApiSitesGetTermStoresRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiSitesGetTermStoresRequest) Expand(expand []string) ApiSitesGetTermStoresRequest {
	r.expand = &expand
	return r
}

func (r ApiSitesGetTermStoresRequest) Execute() (MicrosoftGraphTermStoreStore, *_nethttp.Response, error) {
	return r.ApiService.SitesGetTermStoresExecute(r)
}

/*
SitesGetTermStores Get termStores from sites

The collection of termStores under this site.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param siteId key: id of site
 @param storeId key: id of store
 @return ApiSitesGetTermStoresRequest
*/
func (a *SitesStoreApiService) SitesGetTermStores(ctx _context.Context, siteId string, storeId string) ApiSitesGetTermStoresRequest {
	return ApiSitesGetTermStoresRequest{
		ApiService: a,
		ctx: ctx,
		siteId: siteId,
		storeId: storeId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphTermStoreStore
func (a *SitesStoreApiService) SitesGetTermStoresExecute(r ApiSitesGetTermStoresRequest) (MicrosoftGraphTermStoreStore, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphTermStoreStore
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SitesStoreApiService.SitesGetTermStores")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sites/{site-id}/termStores/{store-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"site-id"+"}", _neturl.PathEscape(parameterToString(r.siteId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"store-id"+"}", _neturl.PathEscape(parameterToString(r.storeId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSitesListTermStoresRequest struct {
	ctx _context.Context
	ApiService *SitesStoreApiService
	siteId string
	top *int32
	skip *int32
	search *string
	filter *string
	count *bool
	orderby *[]string
	select_ *[]string
	expand *[]string
}

// Show only the first n items
func (r ApiSitesListTermStoresRequest) Top(top int32) ApiSitesListTermStoresRequest {
	r.top = &top
	return r
}
// Skip the first n items
func (r ApiSitesListTermStoresRequest) Skip(skip int32) ApiSitesListTermStoresRequest {
	r.skip = &skip
	return r
}
// Search items by search phrases
func (r ApiSitesListTermStoresRequest) Search(search string) ApiSitesListTermStoresRequest {
	r.search = &search
	return r
}
// Filter items by property values
func (r ApiSitesListTermStoresRequest) Filter(filter string) ApiSitesListTermStoresRequest {
	r.filter = &filter
	return r
}
// Include count of items
func (r ApiSitesListTermStoresRequest) Count(count bool) ApiSitesListTermStoresRequest {
	r.count = &count
	return r
}
// Order items by property values
func (r ApiSitesListTermStoresRequest) Orderby(orderby []string) ApiSitesListTermStoresRequest {
	r.orderby = &orderby
	return r
}
// Select properties to be returned
func (r ApiSitesListTermStoresRequest) Select_(select_ []string) ApiSitesListTermStoresRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiSitesListTermStoresRequest) Expand(expand []string) ApiSitesListTermStoresRequest {
	r.expand = &expand
	return r
}

func (r ApiSitesListTermStoresRequest) Execute() (CollectionOfStore, *_nethttp.Response, error) {
	return r.ApiService.SitesListTermStoresExecute(r)
}

/*
SitesListTermStores Get termStores from sites

The collection of termStores under this site.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param siteId key: id of site
 @return ApiSitesListTermStoresRequest
*/
func (a *SitesStoreApiService) SitesListTermStores(ctx _context.Context, siteId string) ApiSitesListTermStoresRequest {
	return ApiSitesListTermStoresRequest{
		ApiService: a,
		ctx: ctx,
		siteId: siteId,
	}
}

// Execute executes the request
//  @return CollectionOfStore
func (a *SitesStoreApiService) SitesListTermStoresExecute(r ApiSitesListTermStoresRequest) (CollectionOfStore, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  CollectionOfStore
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SitesStoreApiService.SitesListTermStores")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sites/{site-id}/termStores"
	localVarPath = strings.Replace(localVarPath, "{"+"site-id"+"}", _neturl.PathEscape(parameterToString(r.siteId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.top != nil {
		localVarQueryParams.Add("$top", parameterToString(*r.top, ""))
	}
	if r.skip != nil {
		localVarQueryParams.Add("$skip", parameterToString(*r.skip, ""))
	}
	if r.search != nil {
		localVarQueryParams.Add("$search", parameterToString(*r.search, ""))
	}
	if r.filter != nil {
		localVarQueryParams.Add("$filter", parameterToString(*r.filter, ""))
	}
	if r.count != nil {
		localVarQueryParams.Add("$count", parameterToString(*r.count, ""))
	}
	if r.orderby != nil {
		localVarQueryParams.Add("$orderby", parameterToString(*r.orderby, "csv"))
	}
	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSitesTermStoreCreateGroupsRequest struct {
	ctx _context.Context
	ApiService *SitesStoreApiService
	siteId string
	microsoftGraphTermStoreGroup *MicrosoftGraphTermStoreGroup
}

// New navigation property
func (r ApiSitesTermStoreCreateGroupsRequest) MicrosoftGraphTermStoreGroup(microsoftGraphTermStoreGroup MicrosoftGraphTermStoreGroup) ApiSitesTermStoreCreateGroupsRequest {
	r.microsoftGraphTermStoreGroup = &microsoftGraphTermStoreGroup
	return r
}

func (r ApiSitesTermStoreCreateGroupsRequest) Execute() (MicrosoftGraphTermStoreGroup, *_nethttp.Response, error) {
	return r.ApiService.SitesTermStoreCreateGroupsExecute(r)
}

/*
SitesTermStoreCreateGroups Create new navigation property to groups for sites

Collection of all groups available in the term store.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param siteId key: id of site
 @return ApiSitesTermStoreCreateGroupsRequest
*/
func (a *SitesStoreApiService) SitesTermStoreCreateGroups(ctx _context.Context, siteId string) ApiSitesTermStoreCreateGroupsRequest {
	return ApiSitesTermStoreCreateGroupsRequest{
		ApiService: a,
		ctx: ctx,
		siteId: siteId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphTermStoreGroup
func (a *SitesStoreApiService) SitesTermStoreCreateGroupsExecute(r ApiSitesTermStoreCreateGroupsRequest) (MicrosoftGraphTermStoreGroup, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphTermStoreGroup
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SitesStoreApiService.SitesTermStoreCreateGroups")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sites/{site-id}/termStore/groups"
	localVarPath = strings.Replace(localVarPath, "{"+"site-id"+"}", _neturl.PathEscape(parameterToString(r.siteId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphTermStoreGroup == nil {
		return localVarReturnValue, nil, reportError("microsoftGraphTermStoreGroup is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphTermStoreGroup
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSitesTermStoreCreateSetsRequest struct {
	ctx _context.Context
	ApiService *SitesStoreApiService
	siteId string
	microsoftGraphTermStoreSet *MicrosoftGraphTermStoreSet
}

// New navigation property
func (r ApiSitesTermStoreCreateSetsRequest) MicrosoftGraphTermStoreSet(microsoftGraphTermStoreSet MicrosoftGraphTermStoreSet) ApiSitesTermStoreCreateSetsRequest {
	r.microsoftGraphTermStoreSet = &microsoftGraphTermStoreSet
	return r
}

func (r ApiSitesTermStoreCreateSetsRequest) Execute() (MicrosoftGraphTermStoreSet, *_nethttp.Response, error) {
	return r.ApiService.SitesTermStoreCreateSetsExecute(r)
}

/*
SitesTermStoreCreateSets Create new navigation property to sets for sites

Collection of all sets available in the term store.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param siteId key: id of site
 @return ApiSitesTermStoreCreateSetsRequest
*/
func (a *SitesStoreApiService) SitesTermStoreCreateSets(ctx _context.Context, siteId string) ApiSitesTermStoreCreateSetsRequest {
	return ApiSitesTermStoreCreateSetsRequest{
		ApiService: a,
		ctx: ctx,
		siteId: siteId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphTermStoreSet
func (a *SitesStoreApiService) SitesTermStoreCreateSetsExecute(r ApiSitesTermStoreCreateSetsRequest) (MicrosoftGraphTermStoreSet, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphTermStoreSet
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SitesStoreApiService.SitesTermStoreCreateSets")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sites/{site-id}/termStore/sets"
	localVarPath = strings.Replace(localVarPath, "{"+"site-id"+"}", _neturl.PathEscape(parameterToString(r.siteId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphTermStoreSet == nil {
		return localVarReturnValue, nil, reportError("microsoftGraphTermStoreSet is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphTermStoreSet
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSitesTermStoreDeleteGroupsRequest struct {
	ctx _context.Context
	ApiService *SitesStoreApiService
	siteId string
	groupId string
	ifMatch *string
}

// ETag
func (r ApiSitesTermStoreDeleteGroupsRequest) IfMatch(ifMatch string) ApiSitesTermStoreDeleteGroupsRequest {
	r.ifMatch = &ifMatch
	return r
}

func (r ApiSitesTermStoreDeleteGroupsRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.SitesTermStoreDeleteGroupsExecute(r)
}

/*
SitesTermStoreDeleteGroups Delete navigation property groups for sites

Collection of all groups available in the term store.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param siteId key: id of site
 @param groupId key: id of group
 @return ApiSitesTermStoreDeleteGroupsRequest
*/
func (a *SitesStoreApiService) SitesTermStoreDeleteGroups(ctx _context.Context, siteId string, groupId string) ApiSitesTermStoreDeleteGroupsRequest {
	return ApiSitesTermStoreDeleteGroupsRequest{
		ApiService: a,
		ctx: ctx,
		siteId: siteId,
		groupId: groupId,
	}
}

// Execute executes the request
func (a *SitesStoreApiService) SitesTermStoreDeleteGroupsExecute(r ApiSitesTermStoreDeleteGroupsRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SitesStoreApiService.SitesTermStoreDeleteGroups")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sites/{site-id}/termStore/groups/{group-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"site-id"+"}", _neturl.PathEscape(parameterToString(r.siteId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ifMatch != nil {
		localVarHeaderParams["If-Match"] = parameterToString(*r.ifMatch, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiSitesTermStoreDeleteSetsRequest struct {
	ctx _context.Context
	ApiService *SitesStoreApiService
	siteId string
	setId string
	ifMatch *string
}

// ETag
func (r ApiSitesTermStoreDeleteSetsRequest) IfMatch(ifMatch string) ApiSitesTermStoreDeleteSetsRequest {
	r.ifMatch = &ifMatch
	return r
}

func (r ApiSitesTermStoreDeleteSetsRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.SitesTermStoreDeleteSetsExecute(r)
}

/*
SitesTermStoreDeleteSets Delete navigation property sets for sites

Collection of all sets available in the term store.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param siteId key: id of site
 @param setId key: id of set
 @return ApiSitesTermStoreDeleteSetsRequest
*/
func (a *SitesStoreApiService) SitesTermStoreDeleteSets(ctx _context.Context, siteId string, setId string) ApiSitesTermStoreDeleteSetsRequest {
	return ApiSitesTermStoreDeleteSetsRequest{
		ApiService: a,
		ctx: ctx,
		siteId: siteId,
		setId: setId,
	}
}

// Execute executes the request
func (a *SitesStoreApiService) SitesTermStoreDeleteSetsExecute(r ApiSitesTermStoreDeleteSetsRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SitesStoreApiService.SitesTermStoreDeleteSets")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sites/{site-id}/termStore/sets/{set-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"site-id"+"}", _neturl.PathEscape(parameterToString(r.siteId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"set-id"+"}", _neturl.PathEscape(parameterToString(r.setId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ifMatch != nil {
		localVarHeaderParams["If-Match"] = parameterToString(*r.ifMatch, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiSitesTermStoreGetGroupsRequest struct {
	ctx _context.Context
	ApiService *SitesStoreApiService
	siteId string
	groupId string
	select_ *[]string
	expand *[]string
}

// Select properties to be returned
func (r ApiSitesTermStoreGetGroupsRequest) Select_(select_ []string) ApiSitesTermStoreGetGroupsRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiSitesTermStoreGetGroupsRequest) Expand(expand []string) ApiSitesTermStoreGetGroupsRequest {
	r.expand = &expand
	return r
}

func (r ApiSitesTermStoreGetGroupsRequest) Execute() (MicrosoftGraphTermStoreGroup, *_nethttp.Response, error) {
	return r.ApiService.SitesTermStoreGetGroupsExecute(r)
}

/*
SitesTermStoreGetGroups Get groups from sites

Collection of all groups available in the term store.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param siteId key: id of site
 @param groupId key: id of group
 @return ApiSitesTermStoreGetGroupsRequest
*/
func (a *SitesStoreApiService) SitesTermStoreGetGroups(ctx _context.Context, siteId string, groupId string) ApiSitesTermStoreGetGroupsRequest {
	return ApiSitesTermStoreGetGroupsRequest{
		ApiService: a,
		ctx: ctx,
		siteId: siteId,
		groupId: groupId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphTermStoreGroup
func (a *SitesStoreApiService) SitesTermStoreGetGroupsExecute(r ApiSitesTermStoreGetGroupsRequest) (MicrosoftGraphTermStoreGroup, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphTermStoreGroup
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SitesStoreApiService.SitesTermStoreGetGroups")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sites/{site-id}/termStore/groups/{group-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"site-id"+"}", _neturl.PathEscape(parameterToString(r.siteId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSitesTermStoreGetSetsRequest struct {
	ctx _context.Context
	ApiService *SitesStoreApiService
	siteId string
	setId string
	select_ *[]string
	expand *[]string
}

// Select properties to be returned
func (r ApiSitesTermStoreGetSetsRequest) Select_(select_ []string) ApiSitesTermStoreGetSetsRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiSitesTermStoreGetSetsRequest) Expand(expand []string) ApiSitesTermStoreGetSetsRequest {
	r.expand = &expand
	return r
}

func (r ApiSitesTermStoreGetSetsRequest) Execute() (MicrosoftGraphTermStoreSet, *_nethttp.Response, error) {
	return r.ApiService.SitesTermStoreGetSetsExecute(r)
}

/*
SitesTermStoreGetSets Get sets from sites

Collection of all sets available in the term store.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param siteId key: id of site
 @param setId key: id of set
 @return ApiSitesTermStoreGetSetsRequest
*/
func (a *SitesStoreApiService) SitesTermStoreGetSets(ctx _context.Context, siteId string, setId string) ApiSitesTermStoreGetSetsRequest {
	return ApiSitesTermStoreGetSetsRequest{
		ApiService: a,
		ctx: ctx,
		siteId: siteId,
		setId: setId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphTermStoreSet
func (a *SitesStoreApiService) SitesTermStoreGetSetsExecute(r ApiSitesTermStoreGetSetsRequest) (MicrosoftGraphTermStoreSet, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphTermStoreSet
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SitesStoreApiService.SitesTermStoreGetSets")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sites/{site-id}/termStore/sets/{set-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"site-id"+"}", _neturl.PathEscape(parameterToString(r.siteId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"set-id"+"}", _neturl.PathEscape(parameterToString(r.setId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSitesTermStoreGroupsCreateSetsRequest struct {
	ctx _context.Context
	ApiService *SitesStoreApiService
	siteId string
	groupId string
	microsoftGraphTermStoreSet *MicrosoftGraphTermStoreSet
}

// New navigation property
func (r ApiSitesTermStoreGroupsCreateSetsRequest) MicrosoftGraphTermStoreSet(microsoftGraphTermStoreSet MicrosoftGraphTermStoreSet) ApiSitesTermStoreGroupsCreateSetsRequest {
	r.microsoftGraphTermStoreSet = &microsoftGraphTermStoreSet
	return r
}

func (r ApiSitesTermStoreGroupsCreateSetsRequest) Execute() (MicrosoftGraphTermStoreSet, *_nethttp.Response, error) {
	return r.ApiService.SitesTermStoreGroupsCreateSetsExecute(r)
}

/*
SitesTermStoreGroupsCreateSets Create new navigation property to sets for sites

All sets under the group in a term [store].

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param siteId key: id of site
 @param groupId key: id of group
 @return ApiSitesTermStoreGroupsCreateSetsRequest
*/
func (a *SitesStoreApiService) SitesTermStoreGroupsCreateSets(ctx _context.Context, siteId string, groupId string) ApiSitesTermStoreGroupsCreateSetsRequest {
	return ApiSitesTermStoreGroupsCreateSetsRequest{
		ApiService: a,
		ctx: ctx,
		siteId: siteId,
		groupId: groupId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphTermStoreSet
func (a *SitesStoreApiService) SitesTermStoreGroupsCreateSetsExecute(r ApiSitesTermStoreGroupsCreateSetsRequest) (MicrosoftGraphTermStoreSet, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphTermStoreSet
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SitesStoreApiService.SitesTermStoreGroupsCreateSets")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sites/{site-id}/termStore/groups/{group-id}/sets"
	localVarPath = strings.Replace(localVarPath, "{"+"site-id"+"}", _neturl.PathEscape(parameterToString(r.siteId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphTermStoreSet == nil {
		return localVarReturnValue, nil, reportError("microsoftGraphTermStoreSet is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphTermStoreSet
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSitesTermStoreGroupsDeleteSetsRequest struct {
	ctx _context.Context
	ApiService *SitesStoreApiService
	siteId string
	groupId string
	setId string
	ifMatch *string
}

// ETag
func (r ApiSitesTermStoreGroupsDeleteSetsRequest) IfMatch(ifMatch string) ApiSitesTermStoreGroupsDeleteSetsRequest {
	r.ifMatch = &ifMatch
	return r
}

func (r ApiSitesTermStoreGroupsDeleteSetsRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.SitesTermStoreGroupsDeleteSetsExecute(r)
}

/*
SitesTermStoreGroupsDeleteSets Delete navigation property sets for sites

All sets under the group in a term [store].

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param siteId key: id of site
 @param groupId key: id of group
 @param setId key: id of set
 @return ApiSitesTermStoreGroupsDeleteSetsRequest
*/
func (a *SitesStoreApiService) SitesTermStoreGroupsDeleteSets(ctx _context.Context, siteId string, groupId string, setId string) ApiSitesTermStoreGroupsDeleteSetsRequest {
	return ApiSitesTermStoreGroupsDeleteSetsRequest{
		ApiService: a,
		ctx: ctx,
		siteId: siteId,
		groupId: groupId,
		setId: setId,
	}
}

// Execute executes the request
func (a *SitesStoreApiService) SitesTermStoreGroupsDeleteSetsExecute(r ApiSitesTermStoreGroupsDeleteSetsRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SitesStoreApiService.SitesTermStoreGroupsDeleteSets")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sites/{site-id}/termStore/groups/{group-id}/sets/{set-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"site-id"+"}", _neturl.PathEscape(parameterToString(r.siteId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"set-id"+"}", _neturl.PathEscape(parameterToString(r.setId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ifMatch != nil {
		localVarHeaderParams["If-Match"] = parameterToString(*r.ifMatch, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiSitesTermStoreGroupsGetSetsRequest struct {
	ctx _context.Context
	ApiService *SitesStoreApiService
	siteId string
	groupId string
	setId string
	select_ *[]string
	expand *[]string
}

// Select properties to be returned
func (r ApiSitesTermStoreGroupsGetSetsRequest) Select_(select_ []string) ApiSitesTermStoreGroupsGetSetsRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiSitesTermStoreGroupsGetSetsRequest) Expand(expand []string) ApiSitesTermStoreGroupsGetSetsRequest {
	r.expand = &expand
	return r
}

func (r ApiSitesTermStoreGroupsGetSetsRequest) Execute() (MicrosoftGraphTermStoreSet, *_nethttp.Response, error) {
	return r.ApiService.SitesTermStoreGroupsGetSetsExecute(r)
}

/*
SitesTermStoreGroupsGetSets Get sets from sites

All sets under the group in a term [store].

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param siteId key: id of site
 @param groupId key: id of group
 @param setId key: id of set
 @return ApiSitesTermStoreGroupsGetSetsRequest
*/
func (a *SitesStoreApiService) SitesTermStoreGroupsGetSets(ctx _context.Context, siteId string, groupId string, setId string) ApiSitesTermStoreGroupsGetSetsRequest {
	return ApiSitesTermStoreGroupsGetSetsRequest{
		ApiService: a,
		ctx: ctx,
		siteId: siteId,
		groupId: groupId,
		setId: setId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphTermStoreSet
func (a *SitesStoreApiService) SitesTermStoreGroupsGetSetsExecute(r ApiSitesTermStoreGroupsGetSetsRequest) (MicrosoftGraphTermStoreSet, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphTermStoreSet
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SitesStoreApiService.SitesTermStoreGroupsGetSets")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sites/{site-id}/termStore/groups/{group-id}/sets/{set-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"site-id"+"}", _neturl.PathEscape(parameterToString(r.siteId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"set-id"+"}", _neturl.PathEscape(parameterToString(r.setId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSitesTermStoreGroupsListSetsRequest struct {
	ctx _context.Context
	ApiService *SitesStoreApiService
	siteId string
	groupId string
	top *int32
	skip *int32
	search *string
	filter *string
	count *bool
	orderby *[]string
	select_ *[]string
	expand *[]string
}

// Show only the first n items
func (r ApiSitesTermStoreGroupsListSetsRequest) Top(top int32) ApiSitesTermStoreGroupsListSetsRequest {
	r.top = &top
	return r
}
// Skip the first n items
func (r ApiSitesTermStoreGroupsListSetsRequest) Skip(skip int32) ApiSitesTermStoreGroupsListSetsRequest {
	r.skip = &skip
	return r
}
// Search items by search phrases
func (r ApiSitesTermStoreGroupsListSetsRequest) Search(search string) ApiSitesTermStoreGroupsListSetsRequest {
	r.search = &search
	return r
}
// Filter items by property values
func (r ApiSitesTermStoreGroupsListSetsRequest) Filter(filter string) ApiSitesTermStoreGroupsListSetsRequest {
	r.filter = &filter
	return r
}
// Include count of items
func (r ApiSitesTermStoreGroupsListSetsRequest) Count(count bool) ApiSitesTermStoreGroupsListSetsRequest {
	r.count = &count
	return r
}
// Order items by property values
func (r ApiSitesTermStoreGroupsListSetsRequest) Orderby(orderby []string) ApiSitesTermStoreGroupsListSetsRequest {
	r.orderby = &orderby
	return r
}
// Select properties to be returned
func (r ApiSitesTermStoreGroupsListSetsRequest) Select_(select_ []string) ApiSitesTermStoreGroupsListSetsRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiSitesTermStoreGroupsListSetsRequest) Expand(expand []string) ApiSitesTermStoreGroupsListSetsRequest {
	r.expand = &expand
	return r
}

func (r ApiSitesTermStoreGroupsListSetsRequest) Execute() (CollectionOfSet, *_nethttp.Response, error) {
	return r.ApiService.SitesTermStoreGroupsListSetsExecute(r)
}

/*
SitesTermStoreGroupsListSets Get sets from sites

All sets under the group in a term [store].

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param siteId key: id of site
 @param groupId key: id of group
 @return ApiSitesTermStoreGroupsListSetsRequest
*/
func (a *SitesStoreApiService) SitesTermStoreGroupsListSets(ctx _context.Context, siteId string, groupId string) ApiSitesTermStoreGroupsListSetsRequest {
	return ApiSitesTermStoreGroupsListSetsRequest{
		ApiService: a,
		ctx: ctx,
		siteId: siteId,
		groupId: groupId,
	}
}

// Execute executes the request
//  @return CollectionOfSet
func (a *SitesStoreApiService) SitesTermStoreGroupsListSetsExecute(r ApiSitesTermStoreGroupsListSetsRequest) (CollectionOfSet, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  CollectionOfSet
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SitesStoreApiService.SitesTermStoreGroupsListSets")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sites/{site-id}/termStore/groups/{group-id}/sets"
	localVarPath = strings.Replace(localVarPath, "{"+"site-id"+"}", _neturl.PathEscape(parameterToString(r.siteId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.top != nil {
		localVarQueryParams.Add("$top", parameterToString(*r.top, ""))
	}
	if r.skip != nil {
		localVarQueryParams.Add("$skip", parameterToString(*r.skip, ""))
	}
	if r.search != nil {
		localVarQueryParams.Add("$search", parameterToString(*r.search, ""))
	}
	if r.filter != nil {
		localVarQueryParams.Add("$filter", parameterToString(*r.filter, ""))
	}
	if r.count != nil {
		localVarQueryParams.Add("$count", parameterToString(*r.count, ""))
	}
	if r.orderby != nil {
		localVarQueryParams.Add("$orderby", parameterToString(*r.orderby, "csv"))
	}
	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSitesTermStoreGroupsSetsChildrenCreateChildrenRequest struct {
	ctx _context.Context
	ApiService *SitesStoreApiService
	siteId string
	groupId string
	setId string
	termId string
	microsoftGraphTermStoreTerm *MicrosoftGraphTermStoreTerm
}

// New navigation property
func (r ApiSitesTermStoreGroupsSetsChildrenCreateChildrenRequest) MicrosoftGraphTermStoreTerm(microsoftGraphTermStoreTerm MicrosoftGraphTermStoreTerm) ApiSitesTermStoreGroupsSetsChildrenCreateChildrenRequest {
	r.microsoftGraphTermStoreTerm = &microsoftGraphTermStoreTerm
	return r
}

func (r ApiSitesTermStoreGroupsSetsChildrenCreateChildrenRequest) Execute() (MicrosoftGraphTermStoreTerm, *_nethttp.Response, error) {
	return r.ApiService.SitesTermStoreGroupsSetsChildrenCreateChildrenExecute(r)
}

/*
SitesTermStoreGroupsSetsChildrenCreateChildren Create new navigation property to children for sites

Children of current term.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param siteId key: id of site
 @param groupId key: id of group
 @param setId key: id of set
 @param termId key: id of term
 @return ApiSitesTermStoreGroupsSetsChildrenCreateChildrenRequest
*/
func (a *SitesStoreApiService) SitesTermStoreGroupsSetsChildrenCreateChildren(ctx _context.Context, siteId string, groupId string, setId string, termId string) ApiSitesTermStoreGroupsSetsChildrenCreateChildrenRequest {
	return ApiSitesTermStoreGroupsSetsChildrenCreateChildrenRequest{
		ApiService: a,
		ctx: ctx,
		siteId: siteId,
		groupId: groupId,
		setId: setId,
		termId: termId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphTermStoreTerm
func (a *SitesStoreApiService) SitesTermStoreGroupsSetsChildrenCreateChildrenExecute(r ApiSitesTermStoreGroupsSetsChildrenCreateChildrenRequest) (MicrosoftGraphTermStoreTerm, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphTermStoreTerm
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SitesStoreApiService.SitesTermStoreGroupsSetsChildrenCreateChildren")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sites/{site-id}/termStore/groups/{group-id}/sets/{set-id}/children/{term-id}/children"
	localVarPath = strings.Replace(localVarPath, "{"+"site-id"+"}", _neturl.PathEscape(parameterToString(r.siteId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"set-id"+"}", _neturl.PathEscape(parameterToString(r.setId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"term-id"+"}", _neturl.PathEscape(parameterToString(r.termId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphTermStoreTerm == nil {
		return localVarReturnValue, nil, reportError("microsoftGraphTermStoreTerm is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphTermStoreTerm
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSitesTermStoreGroupsSetsChildrenCreateRelationsRequest struct {
	ctx _context.Context
	ApiService *SitesStoreApiService
	siteId string
	groupId string
	setId string
	termId string
	microsoftGraphTermStoreRelation *MicrosoftGraphTermStoreRelation
}

// New navigation property
func (r ApiSitesTermStoreGroupsSetsChildrenCreateRelationsRequest) MicrosoftGraphTermStoreRelation(microsoftGraphTermStoreRelation MicrosoftGraphTermStoreRelation) ApiSitesTermStoreGroupsSetsChildrenCreateRelationsRequest {
	r.microsoftGraphTermStoreRelation = &microsoftGraphTermStoreRelation
	return r
}

func (r ApiSitesTermStoreGroupsSetsChildrenCreateRelationsRequest) Execute() (MicrosoftGraphTermStoreRelation, *_nethttp.Response, error) {
	return r.ApiService.SitesTermStoreGroupsSetsChildrenCreateRelationsExecute(r)
}

/*
SitesTermStoreGroupsSetsChildrenCreateRelations Create new navigation property to relations for sites

To indicate which terms are related to the current term as either pinned or reused.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param siteId key: id of site
 @param groupId key: id of group
 @param setId key: id of set
 @param termId key: id of term
 @return ApiSitesTermStoreGroupsSetsChildrenCreateRelationsRequest
*/
func (a *SitesStoreApiService) SitesTermStoreGroupsSetsChildrenCreateRelations(ctx _context.Context, siteId string, groupId string, setId string, termId string) ApiSitesTermStoreGroupsSetsChildrenCreateRelationsRequest {
	return ApiSitesTermStoreGroupsSetsChildrenCreateRelationsRequest{
		ApiService: a,
		ctx: ctx,
		siteId: siteId,
		groupId: groupId,
		setId: setId,
		termId: termId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphTermStoreRelation
func (a *SitesStoreApiService) SitesTermStoreGroupsSetsChildrenCreateRelationsExecute(r ApiSitesTermStoreGroupsSetsChildrenCreateRelationsRequest) (MicrosoftGraphTermStoreRelation, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphTermStoreRelation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SitesStoreApiService.SitesTermStoreGroupsSetsChildrenCreateRelations")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sites/{site-id}/termStore/groups/{group-id}/sets/{set-id}/children/{term-id}/relations"
	localVarPath = strings.Replace(localVarPath, "{"+"site-id"+"}", _neturl.PathEscape(parameterToString(r.siteId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"set-id"+"}", _neturl.PathEscape(parameterToString(r.setId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"term-id"+"}", _neturl.PathEscape(parameterToString(r.termId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphTermStoreRelation == nil {
		return localVarReturnValue, nil, reportError("microsoftGraphTermStoreRelation is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphTermStoreRelation
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSitesTermStoreGroupsSetsChildrenDeleteChildrenRequest struct {
	ctx _context.Context
	ApiService *SitesStoreApiService
	siteId string
	groupId string
	setId string
	termId string
	termId1 string
	ifMatch *string
}

// ETag
func (r ApiSitesTermStoreGroupsSetsChildrenDeleteChildrenRequest) IfMatch(ifMatch string) ApiSitesTermStoreGroupsSetsChildrenDeleteChildrenRequest {
	r.ifMatch = &ifMatch
	return r
}

func (r ApiSitesTermStoreGroupsSetsChildrenDeleteChildrenRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.SitesTermStoreGroupsSetsChildrenDeleteChildrenExecute(r)
}

/*
SitesTermStoreGroupsSetsChildrenDeleteChildren Delete navigation property children for sites

Children of current term.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param siteId key: id of site
 @param groupId key: id of group
 @param setId key: id of set
 @param termId key: id of term
 @param termId1 key: id of term
 @return ApiSitesTermStoreGroupsSetsChildrenDeleteChildrenRequest
*/
func (a *SitesStoreApiService) SitesTermStoreGroupsSetsChildrenDeleteChildren(ctx _context.Context, siteId string, groupId string, setId string, termId string, termId1 string) ApiSitesTermStoreGroupsSetsChildrenDeleteChildrenRequest {
	return ApiSitesTermStoreGroupsSetsChildrenDeleteChildrenRequest{
		ApiService: a,
		ctx: ctx,
		siteId: siteId,
		groupId: groupId,
		setId: setId,
		termId: termId,
		termId1: termId1,
	}
}

// Execute executes the request
func (a *SitesStoreApiService) SitesTermStoreGroupsSetsChildrenDeleteChildrenExecute(r ApiSitesTermStoreGroupsSetsChildrenDeleteChildrenRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SitesStoreApiService.SitesTermStoreGroupsSetsChildrenDeleteChildren")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sites/{site-id}/termStore/groups/{group-id}/sets/{set-id}/children/{term-id}/children/{term-id1}"
	localVarPath = strings.Replace(localVarPath, "{"+"site-id"+"}", _neturl.PathEscape(parameterToString(r.siteId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"set-id"+"}", _neturl.PathEscape(parameterToString(r.setId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"term-id"+"}", _neturl.PathEscape(parameterToString(r.termId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"term-id1"+"}", _neturl.PathEscape(parameterToString(r.termId1, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ifMatch != nil {
		localVarHeaderParams["If-Match"] = parameterToString(*r.ifMatch, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiSitesTermStoreGroupsSetsChildrenDeleteRefSetRequest struct {
	ctx _context.Context
	ApiService *SitesStoreApiService
	siteId string
	groupId string
	setId string
	termId string
	ifMatch *string
}

// ETag
func (r ApiSitesTermStoreGroupsSetsChildrenDeleteRefSetRequest) IfMatch(ifMatch string) ApiSitesTermStoreGroupsSetsChildrenDeleteRefSetRequest {
	r.ifMatch = &ifMatch
	return r
}

func (r ApiSitesTermStoreGroupsSetsChildrenDeleteRefSetRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.SitesTermStoreGroupsSetsChildrenDeleteRefSetExecute(r)
}

/*
SitesTermStoreGroupsSetsChildrenDeleteRefSet Delete ref of navigation property set for sites

The [set] in which the term is created.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param siteId key: id of site
 @param groupId key: id of group
 @param setId key: id of set
 @param termId key: id of term
 @return ApiSitesTermStoreGroupsSetsChildrenDeleteRefSetRequest
*/
func (a *SitesStoreApiService) SitesTermStoreGroupsSetsChildrenDeleteRefSet(ctx _context.Context, siteId string, groupId string, setId string, termId string) ApiSitesTermStoreGroupsSetsChildrenDeleteRefSetRequest {
	return ApiSitesTermStoreGroupsSetsChildrenDeleteRefSetRequest{
		ApiService: a,
		ctx: ctx,
		siteId: siteId,
		groupId: groupId,
		setId: setId,
		termId: termId,
	}
}

// Execute executes the request
func (a *SitesStoreApiService) SitesTermStoreGroupsSetsChildrenDeleteRefSetExecute(r ApiSitesTermStoreGroupsSetsChildrenDeleteRefSetRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SitesStoreApiService.SitesTermStoreGroupsSetsChildrenDeleteRefSet")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sites/{site-id}/termStore/groups/{group-id}/sets/{set-id}/children/{term-id}/set/$ref"
	localVarPath = strings.Replace(localVarPath, "{"+"site-id"+"}", _neturl.PathEscape(parameterToString(r.siteId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"set-id"+"}", _neturl.PathEscape(parameterToString(r.setId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"term-id"+"}", _neturl.PathEscape(parameterToString(r.termId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ifMatch != nil {
		localVarHeaderParams["If-Match"] = parameterToString(*r.ifMatch, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiSitesTermStoreGroupsSetsChildrenDeleteRelationsRequest struct {
	ctx _context.Context
	ApiService *SitesStoreApiService
	siteId string
	groupId string
	setId string
	termId string
	relationId string
	ifMatch *string
}

// ETag
func (r ApiSitesTermStoreGroupsSetsChildrenDeleteRelationsRequest) IfMatch(ifMatch string) ApiSitesTermStoreGroupsSetsChildrenDeleteRelationsRequest {
	r.ifMatch = &ifMatch
	return r
}

func (r ApiSitesTermStoreGroupsSetsChildrenDeleteRelationsRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.SitesTermStoreGroupsSetsChildrenDeleteRelationsExecute(r)
}

/*
SitesTermStoreGroupsSetsChildrenDeleteRelations Delete navigation property relations for sites

To indicate which terms are related to the current term as either pinned or reused.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param siteId key: id of site
 @param groupId key: id of group
 @param setId key: id of set
 @param termId key: id of term
 @param relationId key: id of relation
 @return ApiSitesTermStoreGroupsSetsChildrenDeleteRelationsRequest
*/
func (a *SitesStoreApiService) SitesTermStoreGroupsSetsChildrenDeleteRelations(ctx _context.Context, siteId string, groupId string, setId string, termId string, relationId string) ApiSitesTermStoreGroupsSetsChildrenDeleteRelationsRequest {
	return ApiSitesTermStoreGroupsSetsChildrenDeleteRelationsRequest{
		ApiService: a,
		ctx: ctx,
		siteId: siteId,
		groupId: groupId,
		setId: setId,
		termId: termId,
		relationId: relationId,
	}
}

// Execute executes the request
func (a *SitesStoreApiService) SitesTermStoreGroupsSetsChildrenDeleteRelationsExecute(r ApiSitesTermStoreGroupsSetsChildrenDeleteRelationsRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SitesStoreApiService.SitesTermStoreGroupsSetsChildrenDeleteRelations")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sites/{site-id}/termStore/groups/{group-id}/sets/{set-id}/children/{term-id}/relations/{relation-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"site-id"+"}", _neturl.PathEscape(parameterToString(r.siteId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"set-id"+"}", _neturl.PathEscape(parameterToString(r.setId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"term-id"+"}", _neturl.PathEscape(parameterToString(r.termId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"relation-id"+"}", _neturl.PathEscape(parameterToString(r.relationId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ifMatch != nil {
		localVarHeaderParams["If-Match"] = parameterToString(*r.ifMatch, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiSitesTermStoreGroupsSetsChildrenGetChildrenRequest struct {
	ctx _context.Context
	ApiService *SitesStoreApiService
	siteId string
	groupId string
	setId string
	termId string
	termId1 string
	select_ *[]string
	expand *[]string
}

// Select properties to be returned
func (r ApiSitesTermStoreGroupsSetsChildrenGetChildrenRequest) Select_(select_ []string) ApiSitesTermStoreGroupsSetsChildrenGetChildrenRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiSitesTermStoreGroupsSetsChildrenGetChildrenRequest) Expand(expand []string) ApiSitesTermStoreGroupsSetsChildrenGetChildrenRequest {
	r.expand = &expand
	return r
}

func (r ApiSitesTermStoreGroupsSetsChildrenGetChildrenRequest) Execute() (MicrosoftGraphTermStoreTerm, *_nethttp.Response, error) {
	return r.ApiService.SitesTermStoreGroupsSetsChildrenGetChildrenExecute(r)
}

/*
SitesTermStoreGroupsSetsChildrenGetChildren Get children from sites

Children of current term.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param siteId key: id of site
 @param groupId key: id of group
 @param setId key: id of set
 @param termId key: id of term
 @param termId1 key: id of term
 @return ApiSitesTermStoreGroupsSetsChildrenGetChildrenRequest
*/
func (a *SitesStoreApiService) SitesTermStoreGroupsSetsChildrenGetChildren(ctx _context.Context, siteId string, groupId string, setId string, termId string, termId1 string) ApiSitesTermStoreGroupsSetsChildrenGetChildrenRequest {
	return ApiSitesTermStoreGroupsSetsChildrenGetChildrenRequest{
		ApiService: a,
		ctx: ctx,
		siteId: siteId,
		groupId: groupId,
		setId: setId,
		termId: termId,
		termId1: termId1,
	}
}

// Execute executes the request
//  @return MicrosoftGraphTermStoreTerm
func (a *SitesStoreApiService) SitesTermStoreGroupsSetsChildrenGetChildrenExecute(r ApiSitesTermStoreGroupsSetsChildrenGetChildrenRequest) (MicrosoftGraphTermStoreTerm, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphTermStoreTerm
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SitesStoreApiService.SitesTermStoreGroupsSetsChildrenGetChildren")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sites/{site-id}/termStore/groups/{group-id}/sets/{set-id}/children/{term-id}/children/{term-id1}"
	localVarPath = strings.Replace(localVarPath, "{"+"site-id"+"}", _neturl.PathEscape(parameterToString(r.siteId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"set-id"+"}", _neturl.PathEscape(parameterToString(r.setId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"term-id"+"}", _neturl.PathEscape(parameterToString(r.termId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"term-id1"+"}", _neturl.PathEscape(parameterToString(r.termId1, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSitesTermStoreGroupsSetsChildrenGetRefSetRequest struct {
	ctx _context.Context
	ApiService *SitesStoreApiService
	siteId string
	groupId string
	setId string
	termId string
}


func (r ApiSitesTermStoreGroupsSetsChildrenGetRefSetRequest) Execute() (string, *_nethttp.Response, error) {
	return r.ApiService.SitesTermStoreGroupsSetsChildrenGetRefSetExecute(r)
}

/*
SitesTermStoreGroupsSetsChildrenGetRefSet Get ref of set from sites

The [set] in which the term is created.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param siteId key: id of site
 @param groupId key: id of group
 @param setId key: id of set
 @param termId key: id of term
 @return ApiSitesTermStoreGroupsSetsChildrenGetRefSetRequest
*/
func (a *SitesStoreApiService) SitesTermStoreGroupsSetsChildrenGetRefSet(ctx _context.Context, siteId string, groupId string, setId string, termId string) ApiSitesTermStoreGroupsSetsChildrenGetRefSetRequest {
	return ApiSitesTermStoreGroupsSetsChildrenGetRefSetRequest{
		ApiService: a,
		ctx: ctx,
		siteId: siteId,
		groupId: groupId,
		setId: setId,
		termId: termId,
	}
}

// Execute executes the request
//  @return string
func (a *SitesStoreApiService) SitesTermStoreGroupsSetsChildrenGetRefSetExecute(r ApiSitesTermStoreGroupsSetsChildrenGetRefSetRequest) (string, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  string
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SitesStoreApiService.SitesTermStoreGroupsSetsChildrenGetRefSet")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sites/{site-id}/termStore/groups/{group-id}/sets/{set-id}/children/{term-id}/set/$ref"
	localVarPath = strings.Replace(localVarPath, "{"+"site-id"+"}", _neturl.PathEscape(parameterToString(r.siteId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"set-id"+"}", _neturl.PathEscape(parameterToString(r.setId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"term-id"+"}", _neturl.PathEscape(parameterToString(r.termId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSitesTermStoreGroupsSetsChildrenGetRelationsRequest struct {
	ctx _context.Context
	ApiService *SitesStoreApiService
	siteId string
	groupId string
	setId string
	termId string
	relationId string
	select_ *[]string
	expand *[]string
}

// Select properties to be returned
func (r ApiSitesTermStoreGroupsSetsChildrenGetRelationsRequest) Select_(select_ []string) ApiSitesTermStoreGroupsSetsChildrenGetRelationsRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiSitesTermStoreGroupsSetsChildrenGetRelationsRequest) Expand(expand []string) ApiSitesTermStoreGroupsSetsChildrenGetRelationsRequest {
	r.expand = &expand
	return r
}

func (r ApiSitesTermStoreGroupsSetsChildrenGetRelationsRequest) Execute() (MicrosoftGraphTermStoreRelation, *_nethttp.Response, error) {
	return r.ApiService.SitesTermStoreGroupsSetsChildrenGetRelationsExecute(r)
}

/*
SitesTermStoreGroupsSetsChildrenGetRelations Get relations from sites

To indicate which terms are related to the current term as either pinned or reused.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param siteId key: id of site
 @param groupId key: id of group
 @param setId key: id of set
 @param termId key: id of term
 @param relationId key: id of relation
 @return ApiSitesTermStoreGroupsSetsChildrenGetRelationsRequest
*/
func (a *SitesStoreApiService) SitesTermStoreGroupsSetsChildrenGetRelations(ctx _context.Context, siteId string, groupId string, setId string, termId string, relationId string) ApiSitesTermStoreGroupsSetsChildrenGetRelationsRequest {
	return ApiSitesTermStoreGroupsSetsChildrenGetRelationsRequest{
		ApiService: a,
		ctx: ctx,
		siteId: siteId,
		groupId: groupId,
		setId: setId,
		termId: termId,
		relationId: relationId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphTermStoreRelation
func (a *SitesStoreApiService) SitesTermStoreGroupsSetsChildrenGetRelationsExecute(r ApiSitesTermStoreGroupsSetsChildrenGetRelationsRequest) (MicrosoftGraphTermStoreRelation, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphTermStoreRelation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SitesStoreApiService.SitesTermStoreGroupsSetsChildrenGetRelations")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sites/{site-id}/termStore/groups/{group-id}/sets/{set-id}/children/{term-id}/relations/{relation-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"site-id"+"}", _neturl.PathEscape(parameterToString(r.siteId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"set-id"+"}", _neturl.PathEscape(parameterToString(r.setId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"term-id"+"}", _neturl.PathEscape(parameterToString(r.termId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"relation-id"+"}", _neturl.PathEscape(parameterToString(r.relationId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSitesTermStoreGroupsSetsChildrenGetSetRequest struct {
	ctx _context.Context
	ApiService *SitesStoreApiService
	siteId string
	groupId string
	setId string
	termId string
	select_ *[]string
	expand *[]string
}

// Select properties to be returned
func (r ApiSitesTermStoreGroupsSetsChildrenGetSetRequest) Select_(select_ []string) ApiSitesTermStoreGroupsSetsChildrenGetSetRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiSitesTermStoreGroupsSetsChildrenGetSetRequest) Expand(expand []string) ApiSitesTermStoreGroupsSetsChildrenGetSetRequest {
	r.expand = &expand
	return r
}

func (r ApiSitesTermStoreGroupsSetsChildrenGetSetRequest) Execute() (MicrosoftGraphTermStoreSet, *_nethttp.Response, error) {
	return r.ApiService.SitesTermStoreGroupsSetsChildrenGetSetExecute(r)
}

/*
SitesTermStoreGroupsSetsChildrenGetSet Get set from sites

The [set] in which the term is created.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param siteId key: id of site
 @param groupId key: id of group
 @param setId key: id of set
 @param termId key: id of term
 @return ApiSitesTermStoreGroupsSetsChildrenGetSetRequest
*/
func (a *SitesStoreApiService) SitesTermStoreGroupsSetsChildrenGetSet(ctx _context.Context, siteId string, groupId string, setId string, termId string) ApiSitesTermStoreGroupsSetsChildrenGetSetRequest {
	return ApiSitesTermStoreGroupsSetsChildrenGetSetRequest{
		ApiService: a,
		ctx: ctx,
		siteId: siteId,
		groupId: groupId,
		setId: setId,
		termId: termId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphTermStoreSet
func (a *SitesStoreApiService) SitesTermStoreGroupsSetsChildrenGetSetExecute(r ApiSitesTermStoreGroupsSetsChildrenGetSetRequest) (MicrosoftGraphTermStoreSet, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphTermStoreSet
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SitesStoreApiService.SitesTermStoreGroupsSetsChildrenGetSet")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sites/{site-id}/termStore/groups/{group-id}/sets/{set-id}/children/{term-id}/set"
	localVarPath = strings.Replace(localVarPath, "{"+"site-id"+"}", _neturl.PathEscape(parameterToString(r.siteId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"set-id"+"}", _neturl.PathEscape(parameterToString(r.setId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"term-id"+"}", _neturl.PathEscape(parameterToString(r.termId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSitesTermStoreGroupsSetsChildrenListChildrenRequest struct {
	ctx _context.Context
	ApiService *SitesStoreApiService
	siteId string
	groupId string
	setId string
	termId string
	top *int32
	skip *int32
	search *string
	filter *string
	count *bool
	orderby *[]string
	select_ *[]string
	expand *[]string
}

// Show only the first n items
func (r ApiSitesTermStoreGroupsSetsChildrenListChildrenRequest) Top(top int32) ApiSitesTermStoreGroupsSetsChildrenListChildrenRequest {
	r.top = &top
	return r
}
// Skip the first n items
func (r ApiSitesTermStoreGroupsSetsChildrenListChildrenRequest) Skip(skip int32) ApiSitesTermStoreGroupsSetsChildrenListChildrenRequest {
	r.skip = &skip
	return r
}
// Search items by search phrases
func (r ApiSitesTermStoreGroupsSetsChildrenListChildrenRequest) Search(search string) ApiSitesTermStoreGroupsSetsChildrenListChildrenRequest {
	r.search = &search
	return r
}
// Filter items by property values
func (r ApiSitesTermStoreGroupsSetsChildrenListChildrenRequest) Filter(filter string) ApiSitesTermStoreGroupsSetsChildrenListChildrenRequest {
	r.filter = &filter
	return r
}
// Include count of items
func (r ApiSitesTermStoreGroupsSetsChildrenListChildrenRequest) Count(count bool) ApiSitesTermStoreGroupsSetsChildrenListChildrenRequest {
	r.count = &count
	return r
}
// Order items by property values
func (r ApiSitesTermStoreGroupsSetsChildrenListChildrenRequest) Orderby(orderby []string) ApiSitesTermStoreGroupsSetsChildrenListChildrenRequest {
	r.orderby = &orderby
	return r
}
// Select properties to be returned
func (r ApiSitesTermStoreGroupsSetsChildrenListChildrenRequest) Select_(select_ []string) ApiSitesTermStoreGroupsSetsChildrenListChildrenRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiSitesTermStoreGroupsSetsChildrenListChildrenRequest) Expand(expand []string) ApiSitesTermStoreGroupsSetsChildrenListChildrenRequest {
	r.expand = &expand
	return r
}

func (r ApiSitesTermStoreGroupsSetsChildrenListChildrenRequest) Execute() (CollectionOfTerm, *_nethttp.Response, error) {
	return r.ApiService.SitesTermStoreGroupsSetsChildrenListChildrenExecute(r)
}

/*
SitesTermStoreGroupsSetsChildrenListChildren Get children from sites

Children of current term.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param siteId key: id of site
 @param groupId key: id of group
 @param setId key: id of set
 @param termId key: id of term
 @return ApiSitesTermStoreGroupsSetsChildrenListChildrenRequest
*/
func (a *SitesStoreApiService) SitesTermStoreGroupsSetsChildrenListChildren(ctx _context.Context, siteId string, groupId string, setId string, termId string) ApiSitesTermStoreGroupsSetsChildrenListChildrenRequest {
	return ApiSitesTermStoreGroupsSetsChildrenListChildrenRequest{
		ApiService: a,
		ctx: ctx,
		siteId: siteId,
		groupId: groupId,
		setId: setId,
		termId: termId,
	}
}

// Execute executes the request
//  @return CollectionOfTerm
func (a *SitesStoreApiService) SitesTermStoreGroupsSetsChildrenListChildrenExecute(r ApiSitesTermStoreGroupsSetsChildrenListChildrenRequest) (CollectionOfTerm, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  CollectionOfTerm
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SitesStoreApiService.SitesTermStoreGroupsSetsChildrenListChildren")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sites/{site-id}/termStore/groups/{group-id}/sets/{set-id}/children/{term-id}/children"
	localVarPath = strings.Replace(localVarPath, "{"+"site-id"+"}", _neturl.PathEscape(parameterToString(r.siteId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"set-id"+"}", _neturl.PathEscape(parameterToString(r.setId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"term-id"+"}", _neturl.PathEscape(parameterToString(r.termId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.top != nil {
		localVarQueryParams.Add("$top", parameterToString(*r.top, ""))
	}
	if r.skip != nil {
		localVarQueryParams.Add("$skip", parameterToString(*r.skip, ""))
	}
	if r.search != nil {
		localVarQueryParams.Add("$search", parameterToString(*r.search, ""))
	}
	if r.filter != nil {
		localVarQueryParams.Add("$filter", parameterToString(*r.filter, ""))
	}
	if r.count != nil {
		localVarQueryParams.Add("$count", parameterToString(*r.count, ""))
	}
	if r.orderby != nil {
		localVarQueryParams.Add("$orderby", parameterToString(*r.orderby, "csv"))
	}
	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSitesTermStoreGroupsSetsChildrenListRelationsRequest struct {
	ctx _context.Context
	ApiService *SitesStoreApiService
	siteId string
	groupId string
	setId string
	termId string
	top *int32
	skip *int32
	search *string
	filter *string
	count *bool
	orderby *[]string
	select_ *[]string
	expand *[]string
}

// Show only the first n items
func (r ApiSitesTermStoreGroupsSetsChildrenListRelationsRequest) Top(top int32) ApiSitesTermStoreGroupsSetsChildrenListRelationsRequest {
	r.top = &top
	return r
}
// Skip the first n items
func (r ApiSitesTermStoreGroupsSetsChildrenListRelationsRequest) Skip(skip int32) ApiSitesTermStoreGroupsSetsChildrenListRelationsRequest {
	r.skip = &skip
	return r
}
// Search items by search phrases
func (r ApiSitesTermStoreGroupsSetsChildrenListRelationsRequest) Search(search string) ApiSitesTermStoreGroupsSetsChildrenListRelationsRequest {
	r.search = &search
	return r
}
// Filter items by property values
func (r ApiSitesTermStoreGroupsSetsChildrenListRelationsRequest) Filter(filter string) ApiSitesTermStoreGroupsSetsChildrenListRelationsRequest {
	r.filter = &filter
	return r
}
// Include count of items
func (r ApiSitesTermStoreGroupsSetsChildrenListRelationsRequest) Count(count bool) ApiSitesTermStoreGroupsSetsChildrenListRelationsRequest {
	r.count = &count
	return r
}
// Order items by property values
func (r ApiSitesTermStoreGroupsSetsChildrenListRelationsRequest) Orderby(orderby []string) ApiSitesTermStoreGroupsSetsChildrenListRelationsRequest {
	r.orderby = &orderby
	return r
}
// Select properties to be returned
func (r ApiSitesTermStoreGroupsSetsChildrenListRelationsRequest) Select_(select_ []string) ApiSitesTermStoreGroupsSetsChildrenListRelationsRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiSitesTermStoreGroupsSetsChildrenListRelationsRequest) Expand(expand []string) ApiSitesTermStoreGroupsSetsChildrenListRelationsRequest {
	r.expand = &expand
	return r
}

func (r ApiSitesTermStoreGroupsSetsChildrenListRelationsRequest) Execute() (CollectionOfRelation, *_nethttp.Response, error) {
	return r.ApiService.SitesTermStoreGroupsSetsChildrenListRelationsExecute(r)
}

/*
SitesTermStoreGroupsSetsChildrenListRelations Get relations from sites

To indicate which terms are related to the current term as either pinned or reused.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param siteId key: id of site
 @param groupId key: id of group
 @param setId key: id of set
 @param termId key: id of term
 @return ApiSitesTermStoreGroupsSetsChildrenListRelationsRequest
*/
func (a *SitesStoreApiService) SitesTermStoreGroupsSetsChildrenListRelations(ctx _context.Context, siteId string, groupId string, setId string, termId string) ApiSitesTermStoreGroupsSetsChildrenListRelationsRequest {
	return ApiSitesTermStoreGroupsSetsChildrenListRelationsRequest{
		ApiService: a,
		ctx: ctx,
		siteId: siteId,
		groupId: groupId,
		setId: setId,
		termId: termId,
	}
}

// Execute executes the request
//  @return CollectionOfRelation
func (a *SitesStoreApiService) SitesTermStoreGroupsSetsChildrenListRelationsExecute(r ApiSitesTermStoreGroupsSetsChildrenListRelationsRequest) (CollectionOfRelation, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  CollectionOfRelation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SitesStoreApiService.SitesTermStoreGroupsSetsChildrenListRelations")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sites/{site-id}/termStore/groups/{group-id}/sets/{set-id}/children/{term-id}/relations"
	localVarPath = strings.Replace(localVarPath, "{"+"site-id"+"}", _neturl.PathEscape(parameterToString(r.siteId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"set-id"+"}", _neturl.PathEscape(parameterToString(r.setId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"term-id"+"}", _neturl.PathEscape(parameterToString(r.termId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.top != nil {
		localVarQueryParams.Add("$top", parameterToString(*r.top, ""))
	}
	if r.skip != nil {
		localVarQueryParams.Add("$skip", parameterToString(*r.skip, ""))
	}
	if r.search != nil {
		localVarQueryParams.Add("$search", parameterToString(*r.search, ""))
	}
	if r.filter != nil {
		localVarQueryParams.Add("$filter", parameterToString(*r.filter, ""))
	}
	if r.count != nil {
		localVarQueryParams.Add("$count", parameterToString(*r.count, ""))
	}
	if r.orderby != nil {
		localVarQueryParams.Add("$orderby", parameterToString(*r.orderby, "csv"))
	}
	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSitesTermStoreGroupsSetsChildrenRelationsDeleteRefFromTermRequest struct {
	ctx _context.Context
	ApiService *SitesStoreApiService
	siteId string
	groupId string
	setId string
	termId string
	relationId string
	ifMatch *string
}

// ETag
func (r ApiSitesTermStoreGroupsSetsChildrenRelationsDeleteRefFromTermRequest) IfMatch(ifMatch string) ApiSitesTermStoreGroupsSetsChildrenRelationsDeleteRefFromTermRequest {
	r.ifMatch = &ifMatch
	return r
}

func (r ApiSitesTermStoreGroupsSetsChildrenRelationsDeleteRefFromTermRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.SitesTermStoreGroupsSetsChildrenRelationsDeleteRefFromTermExecute(r)
}

/*
SitesTermStoreGroupsSetsChildrenRelationsDeleteRefFromTerm Delete ref of navigation property fromTerm for sites

The from [term] of the relation. The term from which the relationship is defined. A null value would indicate the relation is directly with the [set].

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param siteId key: id of site
 @param groupId key: id of group
 @param setId key: id of set
 @param termId key: id of term
 @param relationId key: id of relation
 @return ApiSitesTermStoreGroupsSetsChildrenRelationsDeleteRefFromTermRequest
*/
func (a *SitesStoreApiService) SitesTermStoreGroupsSetsChildrenRelationsDeleteRefFromTerm(ctx _context.Context, siteId string, groupId string, setId string, termId string, relationId string) ApiSitesTermStoreGroupsSetsChildrenRelationsDeleteRefFromTermRequest {
	return ApiSitesTermStoreGroupsSetsChildrenRelationsDeleteRefFromTermRequest{
		ApiService: a,
		ctx: ctx,
		siteId: siteId,
		groupId: groupId,
		setId: setId,
		termId: termId,
		relationId: relationId,
	}
}

// Execute executes the request
func (a *SitesStoreApiService) SitesTermStoreGroupsSetsChildrenRelationsDeleteRefFromTermExecute(r ApiSitesTermStoreGroupsSetsChildrenRelationsDeleteRefFromTermRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SitesStoreApiService.SitesTermStoreGroupsSetsChildrenRelationsDeleteRefFromTerm")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sites/{site-id}/termStore/groups/{group-id}/sets/{set-id}/children/{term-id}/relations/{relation-id}/fromTerm/$ref"
	localVarPath = strings.Replace(localVarPath, "{"+"site-id"+"}", _neturl.PathEscape(parameterToString(r.siteId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"set-id"+"}", _neturl.PathEscape(parameterToString(r.setId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"term-id"+"}", _neturl.PathEscape(parameterToString(r.termId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"relation-id"+"}", _neturl.PathEscape(parameterToString(r.relationId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ifMatch != nil {
		localVarHeaderParams["If-Match"] = parameterToString(*r.ifMatch, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiSitesTermStoreGroupsSetsChildrenRelationsDeleteRefSetRequest struct {
	ctx _context.Context
	ApiService *SitesStoreApiService
	siteId string
	groupId string
	setId string
	termId string
	relationId string
	ifMatch *string
}

// ETag
func (r ApiSitesTermStoreGroupsSetsChildrenRelationsDeleteRefSetRequest) IfMatch(ifMatch string) ApiSitesTermStoreGroupsSetsChildrenRelationsDeleteRefSetRequest {
	r.ifMatch = &ifMatch
	return r
}

func (r ApiSitesTermStoreGroupsSetsChildrenRelationsDeleteRefSetRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.SitesTermStoreGroupsSetsChildrenRelationsDeleteRefSetExecute(r)
}

/*
SitesTermStoreGroupsSetsChildrenRelationsDeleteRefSet Delete ref of navigation property set for sites

The [set] in which the relation is relevant.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param siteId key: id of site
 @param groupId key: id of group
 @param setId key: id of set
 @param termId key: id of term
 @param relationId key: id of relation
 @return ApiSitesTermStoreGroupsSetsChildrenRelationsDeleteRefSetRequest
*/
func (a *SitesStoreApiService) SitesTermStoreGroupsSetsChildrenRelationsDeleteRefSet(ctx _context.Context, siteId string, groupId string, setId string, termId string, relationId string) ApiSitesTermStoreGroupsSetsChildrenRelationsDeleteRefSetRequest {
	return ApiSitesTermStoreGroupsSetsChildrenRelationsDeleteRefSetRequest{
		ApiService: a,
		ctx: ctx,
		siteId: siteId,
		groupId: groupId,
		setId: setId,
		termId: termId,
		relationId: relationId,
	}
}

// Execute executes the request
func (a *SitesStoreApiService) SitesTermStoreGroupsSetsChildrenRelationsDeleteRefSetExecute(r ApiSitesTermStoreGroupsSetsChildrenRelationsDeleteRefSetRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SitesStoreApiService.SitesTermStoreGroupsSetsChildrenRelationsDeleteRefSet")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sites/{site-id}/termStore/groups/{group-id}/sets/{set-id}/children/{term-id}/relations/{relation-id}/set/$ref"
	localVarPath = strings.Replace(localVarPath, "{"+"site-id"+"}", _neturl.PathEscape(parameterToString(r.siteId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"set-id"+"}", _neturl.PathEscape(parameterToString(r.setId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"term-id"+"}", _neturl.PathEscape(parameterToString(r.termId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"relation-id"+"}", _neturl.PathEscape(parameterToString(r.relationId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ifMatch != nil {
		localVarHeaderParams["If-Match"] = parameterToString(*r.ifMatch, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiSitesTermStoreGroupsSetsChildrenRelationsDeleteRefToTermRequest struct {
	ctx _context.Context
	ApiService *SitesStoreApiService
	siteId string
	groupId string
	setId string
	termId string
	relationId string
	ifMatch *string
}

// ETag
func (r ApiSitesTermStoreGroupsSetsChildrenRelationsDeleteRefToTermRequest) IfMatch(ifMatch string) ApiSitesTermStoreGroupsSetsChildrenRelationsDeleteRefToTermRequest {
	r.ifMatch = &ifMatch
	return r
}

func (r ApiSitesTermStoreGroupsSetsChildrenRelationsDeleteRefToTermRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.SitesTermStoreGroupsSetsChildrenRelationsDeleteRefToTermExecute(r)
}

/*
SitesTermStoreGroupsSetsChildrenRelationsDeleteRefToTerm Delete ref of navigation property toTerm for sites

The to [term] of the relation. The term to which the relationship is defined.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param siteId key: id of site
 @param groupId key: id of group
 @param setId key: id of set
 @param termId key: id of term
 @param relationId key: id of relation
 @return ApiSitesTermStoreGroupsSetsChildrenRelationsDeleteRefToTermRequest
*/
func (a *SitesStoreApiService) SitesTermStoreGroupsSetsChildrenRelationsDeleteRefToTerm(ctx _context.Context, siteId string, groupId string, setId string, termId string, relationId string) ApiSitesTermStoreGroupsSetsChildrenRelationsDeleteRefToTermRequest {
	return ApiSitesTermStoreGroupsSetsChildrenRelationsDeleteRefToTermRequest{
		ApiService: a,
		ctx: ctx,
		siteId: siteId,
		groupId: groupId,
		setId: setId,
		termId: termId,
		relationId: relationId,
	}
}

// Execute executes the request
func (a *SitesStoreApiService) SitesTermStoreGroupsSetsChildrenRelationsDeleteRefToTermExecute(r ApiSitesTermStoreGroupsSetsChildrenRelationsDeleteRefToTermRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SitesStoreApiService.SitesTermStoreGroupsSetsChildrenRelationsDeleteRefToTerm")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sites/{site-id}/termStore/groups/{group-id}/sets/{set-id}/children/{term-id}/relations/{relation-id}/toTerm/$ref"
	localVarPath = strings.Replace(localVarPath, "{"+"site-id"+"}", _neturl.PathEscape(parameterToString(r.siteId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"set-id"+"}", _neturl.PathEscape(parameterToString(r.setId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"term-id"+"}", _neturl.PathEscape(parameterToString(r.termId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"relation-id"+"}", _neturl.PathEscape(parameterToString(r.relationId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ifMatch != nil {
		localVarHeaderParams["If-Match"] = parameterToString(*r.ifMatch, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiSitesTermStoreGroupsSetsChildrenRelationsGetFromTermRequest struct {
	ctx _context.Context
	ApiService *SitesStoreApiService
	siteId string
	groupId string
	setId string
	termId string
	relationId string
	select_ *[]string
	expand *[]string
}

// Select properties to be returned
func (r ApiSitesTermStoreGroupsSetsChildrenRelationsGetFromTermRequest) Select_(select_ []string) ApiSitesTermStoreGroupsSetsChildrenRelationsGetFromTermRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiSitesTermStoreGroupsSetsChildrenRelationsGetFromTermRequest) Expand(expand []string) ApiSitesTermStoreGroupsSetsChildrenRelationsGetFromTermRequest {
	r.expand = &expand
	return r
}

func (r ApiSitesTermStoreGroupsSetsChildrenRelationsGetFromTermRequest) Execute() (MicrosoftGraphTermStoreTerm, *_nethttp.Response, error) {
	return r.ApiService.SitesTermStoreGroupsSetsChildrenRelationsGetFromTermExecute(r)
}

/*
SitesTermStoreGroupsSetsChildrenRelationsGetFromTerm Get fromTerm from sites

The from [term] of the relation. The term from which the relationship is defined. A null value would indicate the relation is directly with the [set].

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param siteId key: id of site
 @param groupId key: id of group
 @param setId key: id of set
 @param termId key: id of term
 @param relationId key: id of relation
 @return ApiSitesTermStoreGroupsSetsChildrenRelationsGetFromTermRequest
*/
func (a *SitesStoreApiService) SitesTermStoreGroupsSetsChildrenRelationsGetFromTerm(ctx _context.Context, siteId string, groupId string, setId string, termId string, relationId string) ApiSitesTermStoreGroupsSetsChildrenRelationsGetFromTermRequest {
	return ApiSitesTermStoreGroupsSetsChildrenRelationsGetFromTermRequest{
		ApiService: a,
		ctx: ctx,
		siteId: siteId,
		groupId: groupId,
		setId: setId,
		termId: termId,
		relationId: relationId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphTermStoreTerm
func (a *SitesStoreApiService) SitesTermStoreGroupsSetsChildrenRelationsGetFromTermExecute(r ApiSitesTermStoreGroupsSetsChildrenRelationsGetFromTermRequest) (MicrosoftGraphTermStoreTerm, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphTermStoreTerm
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SitesStoreApiService.SitesTermStoreGroupsSetsChildrenRelationsGetFromTerm")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sites/{site-id}/termStore/groups/{group-id}/sets/{set-id}/children/{term-id}/relations/{relation-id}/fromTerm"
	localVarPath = strings.Replace(localVarPath, "{"+"site-id"+"}", _neturl.PathEscape(parameterToString(r.siteId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"set-id"+"}", _neturl.PathEscape(parameterToString(r.setId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"term-id"+"}", _neturl.PathEscape(parameterToString(r.termId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"relation-id"+"}", _neturl.PathEscape(parameterToString(r.relationId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSitesTermStoreGroupsSetsChildrenRelationsGetRefFromTermRequest struct {
	ctx _context.Context
	ApiService *SitesStoreApiService
	siteId string
	groupId string
	setId string
	termId string
	relationId string
}


func (r ApiSitesTermStoreGroupsSetsChildrenRelationsGetRefFromTermRequest) Execute() (string, *_nethttp.Response, error) {
	return r.ApiService.SitesTermStoreGroupsSetsChildrenRelationsGetRefFromTermExecute(r)
}

/*
SitesTermStoreGroupsSetsChildrenRelationsGetRefFromTerm Get ref of fromTerm from sites

The from [term] of the relation. The term from which the relationship is defined. A null value would indicate the relation is directly with the [set].

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param siteId key: id of site
 @param groupId key: id of group
 @param setId key: id of set
 @param termId key: id of term
 @param relationId key: id of relation
 @return ApiSitesTermStoreGroupsSetsChildrenRelationsGetRefFromTermRequest
*/
func (a *SitesStoreApiService) SitesTermStoreGroupsSetsChildrenRelationsGetRefFromTerm(ctx _context.Context, siteId string, groupId string, setId string, termId string, relationId string) ApiSitesTermStoreGroupsSetsChildrenRelationsGetRefFromTermRequest {
	return ApiSitesTermStoreGroupsSetsChildrenRelationsGetRefFromTermRequest{
		ApiService: a,
		ctx: ctx,
		siteId: siteId,
		groupId: groupId,
		setId: setId,
		termId: termId,
		relationId: relationId,
	}
}

// Execute executes the request
//  @return string
func (a *SitesStoreApiService) SitesTermStoreGroupsSetsChildrenRelationsGetRefFromTermExecute(r ApiSitesTermStoreGroupsSetsChildrenRelationsGetRefFromTermRequest) (string, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  string
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SitesStoreApiService.SitesTermStoreGroupsSetsChildrenRelationsGetRefFromTerm")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sites/{site-id}/termStore/groups/{group-id}/sets/{set-id}/children/{term-id}/relations/{relation-id}/fromTerm/$ref"
	localVarPath = strings.Replace(localVarPath, "{"+"site-id"+"}", _neturl.PathEscape(parameterToString(r.siteId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"set-id"+"}", _neturl.PathEscape(parameterToString(r.setId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"term-id"+"}", _neturl.PathEscape(parameterToString(r.termId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"relation-id"+"}", _neturl.PathEscape(parameterToString(r.relationId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSitesTermStoreGroupsSetsChildrenRelationsGetRefSetRequest struct {
	ctx _context.Context
	ApiService *SitesStoreApiService
	siteId string
	groupId string
	setId string
	termId string
	relationId string
}


func (r ApiSitesTermStoreGroupsSetsChildrenRelationsGetRefSetRequest) Execute() (string, *_nethttp.Response, error) {
	return r.ApiService.SitesTermStoreGroupsSetsChildrenRelationsGetRefSetExecute(r)
}

/*
SitesTermStoreGroupsSetsChildrenRelationsGetRefSet Get ref of set from sites

The [set] in which the relation is relevant.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param siteId key: id of site
 @param groupId key: id of group
 @param setId key: id of set
 @param termId key: id of term
 @param relationId key: id of relation
 @return ApiSitesTermStoreGroupsSetsChildrenRelationsGetRefSetRequest
*/
func (a *SitesStoreApiService) SitesTermStoreGroupsSetsChildrenRelationsGetRefSet(ctx _context.Context, siteId string, groupId string, setId string, termId string, relationId string) ApiSitesTermStoreGroupsSetsChildrenRelationsGetRefSetRequest {
	return ApiSitesTermStoreGroupsSetsChildrenRelationsGetRefSetRequest{
		ApiService: a,
		ctx: ctx,
		siteId: siteId,
		groupId: groupId,
		setId: setId,
		termId: termId,
		relationId: relationId,
	}
}

// Execute executes the request
//  @return string
func (a *SitesStoreApiService) SitesTermStoreGroupsSetsChildrenRelationsGetRefSetExecute(r ApiSitesTermStoreGroupsSetsChildrenRelationsGetRefSetRequest) (string, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  string
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SitesStoreApiService.SitesTermStoreGroupsSetsChildrenRelationsGetRefSet")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sites/{site-id}/termStore/groups/{group-id}/sets/{set-id}/children/{term-id}/relations/{relation-id}/set/$ref"
	localVarPath = strings.Replace(localVarPath, "{"+"site-id"+"}", _neturl.PathEscape(parameterToString(r.siteId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"set-id"+"}", _neturl.PathEscape(parameterToString(r.setId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"term-id"+"}", _neturl.PathEscape(parameterToString(r.termId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"relation-id"+"}", _neturl.PathEscape(parameterToString(r.relationId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSitesTermStoreGroupsSetsChildrenRelationsGetRefToTermRequest struct {
	ctx _context.Context
	ApiService *SitesStoreApiService
	siteId string
	groupId string
	setId string
	termId string
	relationId string
}


func (r ApiSitesTermStoreGroupsSetsChildrenRelationsGetRefToTermRequest) Execute() (string, *_nethttp.Response, error) {
	return r.ApiService.SitesTermStoreGroupsSetsChildrenRelationsGetRefToTermExecute(r)
}

/*
SitesTermStoreGroupsSetsChildrenRelationsGetRefToTerm Get ref of toTerm from sites

The to [term] of the relation. The term to which the relationship is defined.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param siteId key: id of site
 @param groupId key: id of group
 @param setId key: id of set
 @param termId key: id of term
 @param relationId key: id of relation
 @return ApiSitesTermStoreGroupsSetsChildrenRelationsGetRefToTermRequest
*/
func (a *SitesStoreApiService) SitesTermStoreGroupsSetsChildrenRelationsGetRefToTerm(ctx _context.Context, siteId string, groupId string, setId string, termId string, relationId string) ApiSitesTermStoreGroupsSetsChildrenRelationsGetRefToTermRequest {
	return ApiSitesTermStoreGroupsSetsChildrenRelationsGetRefToTermRequest{
		ApiService: a,
		ctx: ctx,
		siteId: siteId,
		groupId: groupId,
		setId: setId,
		termId: termId,
		relationId: relationId,
	}
}

// Execute executes the request
//  @return string
func (a *SitesStoreApiService) SitesTermStoreGroupsSetsChildrenRelationsGetRefToTermExecute(r ApiSitesTermStoreGroupsSetsChildrenRelationsGetRefToTermRequest) (string, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  string
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SitesStoreApiService.SitesTermStoreGroupsSetsChildrenRelationsGetRefToTerm")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sites/{site-id}/termStore/groups/{group-id}/sets/{set-id}/children/{term-id}/relations/{relation-id}/toTerm/$ref"
	localVarPath = strings.Replace(localVarPath, "{"+"site-id"+"}", _neturl.PathEscape(parameterToString(r.siteId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"set-id"+"}", _neturl.PathEscape(parameterToString(r.setId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"term-id"+"}", _neturl.PathEscape(parameterToString(r.termId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"relation-id"+"}", _neturl.PathEscape(parameterToString(r.relationId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSitesTermStoreGroupsSetsChildrenRelationsGetSetRequest struct {
	ctx _context.Context
	ApiService *SitesStoreApiService
	siteId string
	groupId string
	setId string
	termId string
	relationId string
	select_ *[]string
	expand *[]string
}

// Select properties to be returned
func (r ApiSitesTermStoreGroupsSetsChildrenRelationsGetSetRequest) Select_(select_ []string) ApiSitesTermStoreGroupsSetsChildrenRelationsGetSetRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiSitesTermStoreGroupsSetsChildrenRelationsGetSetRequest) Expand(expand []string) ApiSitesTermStoreGroupsSetsChildrenRelationsGetSetRequest {
	r.expand = &expand
	return r
}

func (r ApiSitesTermStoreGroupsSetsChildrenRelationsGetSetRequest) Execute() (MicrosoftGraphTermStoreSet, *_nethttp.Response, error) {
	return r.ApiService.SitesTermStoreGroupsSetsChildrenRelationsGetSetExecute(r)
}

/*
SitesTermStoreGroupsSetsChildrenRelationsGetSet Get set from sites

The [set] in which the relation is relevant.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param siteId key: id of site
 @param groupId key: id of group
 @param setId key: id of set
 @param termId key: id of term
 @param relationId key: id of relation
 @return ApiSitesTermStoreGroupsSetsChildrenRelationsGetSetRequest
*/
func (a *SitesStoreApiService) SitesTermStoreGroupsSetsChildrenRelationsGetSet(ctx _context.Context, siteId string, groupId string, setId string, termId string, relationId string) ApiSitesTermStoreGroupsSetsChildrenRelationsGetSetRequest {
	return ApiSitesTermStoreGroupsSetsChildrenRelationsGetSetRequest{
		ApiService: a,
		ctx: ctx,
		siteId: siteId,
		groupId: groupId,
		setId: setId,
		termId: termId,
		relationId: relationId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphTermStoreSet
func (a *SitesStoreApiService) SitesTermStoreGroupsSetsChildrenRelationsGetSetExecute(r ApiSitesTermStoreGroupsSetsChildrenRelationsGetSetRequest) (MicrosoftGraphTermStoreSet, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphTermStoreSet
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SitesStoreApiService.SitesTermStoreGroupsSetsChildrenRelationsGetSet")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sites/{site-id}/termStore/groups/{group-id}/sets/{set-id}/children/{term-id}/relations/{relation-id}/set"
	localVarPath = strings.Replace(localVarPath, "{"+"site-id"+"}", _neturl.PathEscape(parameterToString(r.siteId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"set-id"+"}", _neturl.PathEscape(parameterToString(r.setId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"term-id"+"}", _neturl.PathEscape(parameterToString(r.termId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"relation-id"+"}", _neturl.PathEscape(parameterToString(r.relationId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSitesTermStoreGroupsSetsChildrenRelationsGetToTermRequest struct {
	ctx _context.Context
	ApiService *SitesStoreApiService
	siteId string
	groupId string
	setId string
	termId string
	relationId string
	select_ *[]string
	expand *[]string
}

// Select properties to be returned
func (r ApiSitesTermStoreGroupsSetsChildrenRelationsGetToTermRequest) Select_(select_ []string) ApiSitesTermStoreGroupsSetsChildrenRelationsGetToTermRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiSitesTermStoreGroupsSetsChildrenRelationsGetToTermRequest) Expand(expand []string) ApiSitesTermStoreGroupsSetsChildrenRelationsGetToTermRequest {
	r.expand = &expand
	return r
}

func (r ApiSitesTermStoreGroupsSetsChildrenRelationsGetToTermRequest) Execute() (MicrosoftGraphTermStoreTerm, *_nethttp.Response, error) {
	return r.ApiService.SitesTermStoreGroupsSetsChildrenRelationsGetToTermExecute(r)
}

/*
SitesTermStoreGroupsSetsChildrenRelationsGetToTerm Get toTerm from sites

The to [term] of the relation. The term to which the relationship is defined.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param siteId key: id of site
 @param groupId key: id of group
 @param setId key: id of set
 @param termId key: id of term
 @param relationId key: id of relation
 @return ApiSitesTermStoreGroupsSetsChildrenRelationsGetToTermRequest
*/
func (a *SitesStoreApiService) SitesTermStoreGroupsSetsChildrenRelationsGetToTerm(ctx _context.Context, siteId string, groupId string, setId string, termId string, relationId string) ApiSitesTermStoreGroupsSetsChildrenRelationsGetToTermRequest {
	return ApiSitesTermStoreGroupsSetsChildrenRelationsGetToTermRequest{
		ApiService: a,
		ctx: ctx,
		siteId: siteId,
		groupId: groupId,
		setId: setId,
		termId: termId,
		relationId: relationId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphTermStoreTerm
func (a *SitesStoreApiService) SitesTermStoreGroupsSetsChildrenRelationsGetToTermExecute(r ApiSitesTermStoreGroupsSetsChildrenRelationsGetToTermRequest) (MicrosoftGraphTermStoreTerm, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphTermStoreTerm
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SitesStoreApiService.SitesTermStoreGroupsSetsChildrenRelationsGetToTerm")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sites/{site-id}/termStore/groups/{group-id}/sets/{set-id}/children/{term-id}/relations/{relation-id}/toTerm"
	localVarPath = strings.Replace(localVarPath, "{"+"site-id"+"}", _neturl.PathEscape(parameterToString(r.siteId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"set-id"+"}", _neturl.PathEscape(parameterToString(r.setId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"term-id"+"}", _neturl.PathEscape(parameterToString(r.termId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"relation-id"+"}", _neturl.PathEscape(parameterToString(r.relationId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSitesTermStoreGroupsSetsChildrenRelationsUpdateRefFromTermRequest struct {
	ctx _context.Context
	ApiService *SitesStoreApiService
	siteId string
	groupId string
	setId string
	termId string
	relationId string
	requestBody *map[string]map[string]interface{}
}

// New navigation property ref values
func (r ApiSitesTermStoreGroupsSetsChildrenRelationsUpdateRefFromTermRequest) RequestBody(requestBody map[string]map[string]interface{}) ApiSitesTermStoreGroupsSetsChildrenRelationsUpdateRefFromTermRequest {
	r.requestBody = &requestBody
	return r
}

func (r ApiSitesTermStoreGroupsSetsChildrenRelationsUpdateRefFromTermRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.SitesTermStoreGroupsSetsChildrenRelationsUpdateRefFromTermExecute(r)
}

/*
SitesTermStoreGroupsSetsChildrenRelationsUpdateRefFromTerm Update the ref of navigation property fromTerm in sites

The from [term] of the relation. The term from which the relationship is defined. A null value would indicate the relation is directly with the [set].

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param siteId key: id of site
 @param groupId key: id of group
 @param setId key: id of set
 @param termId key: id of term
 @param relationId key: id of relation
 @return ApiSitesTermStoreGroupsSetsChildrenRelationsUpdateRefFromTermRequest
*/
func (a *SitesStoreApiService) SitesTermStoreGroupsSetsChildrenRelationsUpdateRefFromTerm(ctx _context.Context, siteId string, groupId string, setId string, termId string, relationId string) ApiSitesTermStoreGroupsSetsChildrenRelationsUpdateRefFromTermRequest {
	return ApiSitesTermStoreGroupsSetsChildrenRelationsUpdateRefFromTermRequest{
		ApiService: a,
		ctx: ctx,
		siteId: siteId,
		groupId: groupId,
		setId: setId,
		termId: termId,
		relationId: relationId,
	}
}

// Execute executes the request
func (a *SitesStoreApiService) SitesTermStoreGroupsSetsChildrenRelationsUpdateRefFromTermExecute(r ApiSitesTermStoreGroupsSetsChildrenRelationsUpdateRefFromTermRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPut
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SitesStoreApiService.SitesTermStoreGroupsSetsChildrenRelationsUpdateRefFromTerm")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sites/{site-id}/termStore/groups/{group-id}/sets/{set-id}/children/{term-id}/relations/{relation-id}/fromTerm/$ref"
	localVarPath = strings.Replace(localVarPath, "{"+"site-id"+"}", _neturl.PathEscape(parameterToString(r.siteId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"set-id"+"}", _neturl.PathEscape(parameterToString(r.setId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"term-id"+"}", _neturl.PathEscape(parameterToString(r.termId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"relation-id"+"}", _neturl.PathEscape(parameterToString(r.relationId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.requestBody == nil {
		return nil, reportError("requestBody is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.requestBody
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiSitesTermStoreGroupsSetsChildrenRelationsUpdateRefSetRequest struct {
	ctx _context.Context
	ApiService *SitesStoreApiService
	siteId string
	groupId string
	setId string
	termId string
	relationId string
	requestBody *map[string]map[string]interface{}
}

// New navigation property ref values
func (r ApiSitesTermStoreGroupsSetsChildrenRelationsUpdateRefSetRequest) RequestBody(requestBody map[string]map[string]interface{}) ApiSitesTermStoreGroupsSetsChildrenRelationsUpdateRefSetRequest {
	r.requestBody = &requestBody
	return r
}

func (r ApiSitesTermStoreGroupsSetsChildrenRelationsUpdateRefSetRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.SitesTermStoreGroupsSetsChildrenRelationsUpdateRefSetExecute(r)
}

/*
SitesTermStoreGroupsSetsChildrenRelationsUpdateRefSet Update the ref of navigation property set in sites

The [set] in which the relation is relevant.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param siteId key: id of site
 @param groupId key: id of group
 @param setId key: id of set
 @param termId key: id of term
 @param relationId key: id of relation
 @return ApiSitesTermStoreGroupsSetsChildrenRelationsUpdateRefSetRequest
*/
func (a *SitesStoreApiService) SitesTermStoreGroupsSetsChildrenRelationsUpdateRefSet(ctx _context.Context, siteId string, groupId string, setId string, termId string, relationId string) ApiSitesTermStoreGroupsSetsChildrenRelationsUpdateRefSetRequest {
	return ApiSitesTermStoreGroupsSetsChildrenRelationsUpdateRefSetRequest{
		ApiService: a,
		ctx: ctx,
		siteId: siteId,
		groupId: groupId,
		setId: setId,
		termId: termId,
		relationId: relationId,
	}
}

// Execute executes the request
func (a *SitesStoreApiService) SitesTermStoreGroupsSetsChildrenRelationsUpdateRefSetExecute(r ApiSitesTermStoreGroupsSetsChildrenRelationsUpdateRefSetRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPut
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SitesStoreApiService.SitesTermStoreGroupsSetsChildrenRelationsUpdateRefSet")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sites/{site-id}/termStore/groups/{group-id}/sets/{set-id}/children/{term-id}/relations/{relation-id}/set/$ref"
	localVarPath = strings.Replace(localVarPath, "{"+"site-id"+"}", _neturl.PathEscape(parameterToString(r.siteId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"set-id"+"}", _neturl.PathEscape(parameterToString(r.setId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"term-id"+"}", _neturl.PathEscape(parameterToString(r.termId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"relation-id"+"}", _neturl.PathEscape(parameterToString(r.relationId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.requestBody == nil {
		return nil, reportError("requestBody is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.requestBody
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiSitesTermStoreGroupsSetsChildrenRelationsUpdateRefToTermRequest struct {
	ctx _context.Context
	ApiService *SitesStoreApiService
	siteId string
	groupId string
	setId string
	termId string
	relationId string
	requestBody *map[string]map[string]interface{}
}

// New navigation property ref values
func (r ApiSitesTermStoreGroupsSetsChildrenRelationsUpdateRefToTermRequest) RequestBody(requestBody map[string]map[string]interface{}) ApiSitesTermStoreGroupsSetsChildrenRelationsUpdateRefToTermRequest {
	r.requestBody = &requestBody
	return r
}

func (r ApiSitesTermStoreGroupsSetsChildrenRelationsUpdateRefToTermRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.SitesTermStoreGroupsSetsChildrenRelationsUpdateRefToTermExecute(r)
}

/*
SitesTermStoreGroupsSetsChildrenRelationsUpdateRefToTerm Update the ref of navigation property toTerm in sites

The to [term] of the relation. The term to which the relationship is defined.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param siteId key: id of site
 @param groupId key: id of group
 @param setId key: id of set
 @param termId key: id of term
 @param relationId key: id of relation
 @return ApiSitesTermStoreGroupsSetsChildrenRelationsUpdateRefToTermRequest
*/
func (a *SitesStoreApiService) SitesTermStoreGroupsSetsChildrenRelationsUpdateRefToTerm(ctx _context.Context, siteId string, groupId string, setId string, termId string, relationId string) ApiSitesTermStoreGroupsSetsChildrenRelationsUpdateRefToTermRequest {
	return ApiSitesTermStoreGroupsSetsChildrenRelationsUpdateRefToTermRequest{
		ApiService: a,
		ctx: ctx,
		siteId: siteId,
		groupId: groupId,
		setId: setId,
		termId: termId,
		relationId: relationId,
	}
}

// Execute executes the request
func (a *SitesStoreApiService) SitesTermStoreGroupsSetsChildrenRelationsUpdateRefToTermExecute(r ApiSitesTermStoreGroupsSetsChildrenRelationsUpdateRefToTermRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPut
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SitesStoreApiService.SitesTermStoreGroupsSetsChildrenRelationsUpdateRefToTerm")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sites/{site-id}/termStore/groups/{group-id}/sets/{set-id}/children/{term-id}/relations/{relation-id}/toTerm/$ref"
	localVarPath = strings.Replace(localVarPath, "{"+"site-id"+"}", _neturl.PathEscape(parameterToString(r.siteId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"set-id"+"}", _neturl.PathEscape(parameterToString(r.setId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"term-id"+"}", _neturl.PathEscape(parameterToString(r.termId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"relation-id"+"}", _neturl.PathEscape(parameterToString(r.relationId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.requestBody == nil {
		return nil, reportError("requestBody is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.requestBody
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiSitesTermStoreGroupsSetsChildrenUpdateChildrenRequest struct {
	ctx _context.Context
	ApiService *SitesStoreApiService
	siteId string
	groupId string
	setId string
	termId string
	termId1 string
	microsoftGraphTermStoreTerm *MicrosoftGraphTermStoreTerm
}

// New navigation property values
func (r ApiSitesTermStoreGroupsSetsChildrenUpdateChildrenRequest) MicrosoftGraphTermStoreTerm(microsoftGraphTermStoreTerm MicrosoftGraphTermStoreTerm) ApiSitesTermStoreGroupsSetsChildrenUpdateChildrenRequest {
	r.microsoftGraphTermStoreTerm = &microsoftGraphTermStoreTerm
	return r
}

func (r ApiSitesTermStoreGroupsSetsChildrenUpdateChildrenRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.SitesTermStoreGroupsSetsChildrenUpdateChildrenExecute(r)
}

/*
SitesTermStoreGroupsSetsChildrenUpdateChildren Update the navigation property children in sites

Children of current term.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param siteId key: id of site
 @param groupId key: id of group
 @param setId key: id of set
 @param termId key: id of term
 @param termId1 key: id of term
 @return ApiSitesTermStoreGroupsSetsChildrenUpdateChildrenRequest
*/
func (a *SitesStoreApiService) SitesTermStoreGroupsSetsChildrenUpdateChildren(ctx _context.Context, siteId string, groupId string, setId string, termId string, termId1 string) ApiSitesTermStoreGroupsSetsChildrenUpdateChildrenRequest {
	return ApiSitesTermStoreGroupsSetsChildrenUpdateChildrenRequest{
		ApiService: a,
		ctx: ctx,
		siteId: siteId,
		groupId: groupId,
		setId: setId,
		termId: termId,
		termId1: termId1,
	}
}

// Execute executes the request
func (a *SitesStoreApiService) SitesTermStoreGroupsSetsChildrenUpdateChildrenExecute(r ApiSitesTermStoreGroupsSetsChildrenUpdateChildrenRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPatch
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SitesStoreApiService.SitesTermStoreGroupsSetsChildrenUpdateChildren")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sites/{site-id}/termStore/groups/{group-id}/sets/{set-id}/children/{term-id}/children/{term-id1}"
	localVarPath = strings.Replace(localVarPath, "{"+"site-id"+"}", _neturl.PathEscape(parameterToString(r.siteId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"set-id"+"}", _neturl.PathEscape(parameterToString(r.setId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"term-id"+"}", _neturl.PathEscape(parameterToString(r.termId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"term-id1"+"}", _neturl.PathEscape(parameterToString(r.termId1, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphTermStoreTerm == nil {
		return nil, reportError("microsoftGraphTermStoreTerm is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphTermStoreTerm
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiSitesTermStoreGroupsSetsChildrenUpdateRefSetRequest struct {
	ctx _context.Context
	ApiService *SitesStoreApiService
	siteId string
	groupId string
	setId string
	termId string
	requestBody *map[string]map[string]interface{}
}

// New navigation property ref values
func (r ApiSitesTermStoreGroupsSetsChildrenUpdateRefSetRequest) RequestBody(requestBody map[string]map[string]interface{}) ApiSitesTermStoreGroupsSetsChildrenUpdateRefSetRequest {
	r.requestBody = &requestBody
	return r
}

func (r ApiSitesTermStoreGroupsSetsChildrenUpdateRefSetRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.SitesTermStoreGroupsSetsChildrenUpdateRefSetExecute(r)
}

/*
SitesTermStoreGroupsSetsChildrenUpdateRefSet Update the ref of navigation property set in sites

The [set] in which the term is created.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param siteId key: id of site
 @param groupId key: id of group
 @param setId key: id of set
 @param termId key: id of term
 @return ApiSitesTermStoreGroupsSetsChildrenUpdateRefSetRequest
*/
func (a *SitesStoreApiService) SitesTermStoreGroupsSetsChildrenUpdateRefSet(ctx _context.Context, siteId string, groupId string, setId string, termId string) ApiSitesTermStoreGroupsSetsChildrenUpdateRefSetRequest {
	return ApiSitesTermStoreGroupsSetsChildrenUpdateRefSetRequest{
		ApiService: a,
		ctx: ctx,
		siteId: siteId,
		groupId: groupId,
		setId: setId,
		termId: termId,
	}
}

// Execute executes the request
func (a *SitesStoreApiService) SitesTermStoreGroupsSetsChildrenUpdateRefSetExecute(r ApiSitesTermStoreGroupsSetsChildrenUpdateRefSetRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPut
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SitesStoreApiService.SitesTermStoreGroupsSetsChildrenUpdateRefSet")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sites/{site-id}/termStore/groups/{group-id}/sets/{set-id}/children/{term-id}/set/$ref"
	localVarPath = strings.Replace(localVarPath, "{"+"site-id"+"}", _neturl.PathEscape(parameterToString(r.siteId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"set-id"+"}", _neturl.PathEscape(parameterToString(r.setId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"term-id"+"}", _neturl.PathEscape(parameterToString(r.termId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.requestBody == nil {
		return nil, reportError("requestBody is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.requestBody
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiSitesTermStoreGroupsSetsChildrenUpdateRelationsRequest struct {
	ctx _context.Context
	ApiService *SitesStoreApiService
	siteId string
	groupId string
	setId string
	termId string
	relationId string
	microsoftGraphTermStoreRelation *MicrosoftGraphTermStoreRelation
}

// New navigation property values
func (r ApiSitesTermStoreGroupsSetsChildrenUpdateRelationsRequest) MicrosoftGraphTermStoreRelation(microsoftGraphTermStoreRelation MicrosoftGraphTermStoreRelation) ApiSitesTermStoreGroupsSetsChildrenUpdateRelationsRequest {
	r.microsoftGraphTermStoreRelation = &microsoftGraphTermStoreRelation
	return r
}

func (r ApiSitesTermStoreGroupsSetsChildrenUpdateRelationsRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.SitesTermStoreGroupsSetsChildrenUpdateRelationsExecute(r)
}

/*
SitesTermStoreGroupsSetsChildrenUpdateRelations Update the navigation property relations in sites

To indicate which terms are related to the current term as either pinned or reused.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param siteId key: id of site
 @param groupId key: id of group
 @param setId key: id of set
 @param termId key: id of term
 @param relationId key: id of relation
 @return ApiSitesTermStoreGroupsSetsChildrenUpdateRelationsRequest
*/
func (a *SitesStoreApiService) SitesTermStoreGroupsSetsChildrenUpdateRelations(ctx _context.Context, siteId string, groupId string, setId string, termId string, relationId string) ApiSitesTermStoreGroupsSetsChildrenUpdateRelationsRequest {
	return ApiSitesTermStoreGroupsSetsChildrenUpdateRelationsRequest{
		ApiService: a,
		ctx: ctx,
		siteId: siteId,
		groupId: groupId,
		setId: setId,
		termId: termId,
		relationId: relationId,
	}
}

// Execute executes the request
func (a *SitesStoreApiService) SitesTermStoreGroupsSetsChildrenUpdateRelationsExecute(r ApiSitesTermStoreGroupsSetsChildrenUpdateRelationsRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPatch
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SitesStoreApiService.SitesTermStoreGroupsSetsChildrenUpdateRelations")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sites/{site-id}/termStore/groups/{group-id}/sets/{set-id}/children/{term-id}/relations/{relation-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"site-id"+"}", _neturl.PathEscape(parameterToString(r.siteId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"set-id"+"}", _neturl.PathEscape(parameterToString(r.setId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"term-id"+"}", _neturl.PathEscape(parameterToString(r.termId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"relation-id"+"}", _neturl.PathEscape(parameterToString(r.relationId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphTermStoreRelation == nil {
		return nil, reportError("microsoftGraphTermStoreRelation is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphTermStoreRelation
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiSitesTermStoreGroupsSetsCreateChildrenRequest struct {
	ctx _context.Context
	ApiService *SitesStoreApiService
	siteId string
	groupId string
	setId string
	microsoftGraphTermStoreTerm *MicrosoftGraphTermStoreTerm
}

// New navigation property
func (r ApiSitesTermStoreGroupsSetsCreateChildrenRequest) MicrosoftGraphTermStoreTerm(microsoftGraphTermStoreTerm MicrosoftGraphTermStoreTerm) ApiSitesTermStoreGroupsSetsCreateChildrenRequest {
	r.microsoftGraphTermStoreTerm = &microsoftGraphTermStoreTerm
	return r
}

func (r ApiSitesTermStoreGroupsSetsCreateChildrenRequest) Execute() (MicrosoftGraphTermStoreTerm, *_nethttp.Response, error) {
	return r.ApiService.SitesTermStoreGroupsSetsCreateChildrenExecute(r)
}

/*
SitesTermStoreGroupsSetsCreateChildren Create new navigation property to children for sites

Children terms of set in term [store].

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param siteId key: id of site
 @param groupId key: id of group
 @param setId key: id of set
 @return ApiSitesTermStoreGroupsSetsCreateChildrenRequest
*/
func (a *SitesStoreApiService) SitesTermStoreGroupsSetsCreateChildren(ctx _context.Context, siteId string, groupId string, setId string) ApiSitesTermStoreGroupsSetsCreateChildrenRequest {
	return ApiSitesTermStoreGroupsSetsCreateChildrenRequest{
		ApiService: a,
		ctx: ctx,
		siteId: siteId,
		groupId: groupId,
		setId: setId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphTermStoreTerm
func (a *SitesStoreApiService) SitesTermStoreGroupsSetsCreateChildrenExecute(r ApiSitesTermStoreGroupsSetsCreateChildrenRequest) (MicrosoftGraphTermStoreTerm, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphTermStoreTerm
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SitesStoreApiService.SitesTermStoreGroupsSetsCreateChildren")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sites/{site-id}/termStore/groups/{group-id}/sets/{set-id}/children"
	localVarPath = strings.Replace(localVarPath, "{"+"site-id"+"}", _neturl.PathEscape(parameterToString(r.siteId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"set-id"+"}", _neturl.PathEscape(parameterToString(r.setId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphTermStoreTerm == nil {
		return localVarReturnValue, nil, reportError("microsoftGraphTermStoreTerm is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphTermStoreTerm
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSitesTermStoreGroupsSetsCreateRelationsRequest struct {
	ctx _context.Context
	ApiService *SitesStoreApiService
	siteId string
	groupId string
	setId string
	microsoftGraphTermStoreRelation *MicrosoftGraphTermStoreRelation
}

// New navigation property
func (r ApiSitesTermStoreGroupsSetsCreateRelationsRequest) MicrosoftGraphTermStoreRelation(microsoftGraphTermStoreRelation MicrosoftGraphTermStoreRelation) ApiSitesTermStoreGroupsSetsCreateRelationsRequest {
	r.microsoftGraphTermStoreRelation = &microsoftGraphTermStoreRelation
	return r
}

func (r ApiSitesTermStoreGroupsSetsCreateRelationsRequest) Execute() (MicrosoftGraphTermStoreRelation, *_nethttp.Response, error) {
	return r.ApiService.SitesTermStoreGroupsSetsCreateRelationsExecute(r)
}

/*
SitesTermStoreGroupsSetsCreateRelations Create new navigation property to relations for sites

Indicates which terms have been pinned or reused directly under the set.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param siteId key: id of site
 @param groupId key: id of group
 @param setId key: id of set
 @return ApiSitesTermStoreGroupsSetsCreateRelationsRequest
*/
func (a *SitesStoreApiService) SitesTermStoreGroupsSetsCreateRelations(ctx _context.Context, siteId string, groupId string, setId string) ApiSitesTermStoreGroupsSetsCreateRelationsRequest {
	return ApiSitesTermStoreGroupsSetsCreateRelationsRequest{
		ApiService: a,
		ctx: ctx,
		siteId: siteId,
		groupId: groupId,
		setId: setId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphTermStoreRelation
func (a *SitesStoreApiService) SitesTermStoreGroupsSetsCreateRelationsExecute(r ApiSitesTermStoreGroupsSetsCreateRelationsRequest) (MicrosoftGraphTermStoreRelation, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphTermStoreRelation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SitesStoreApiService.SitesTermStoreGroupsSetsCreateRelations")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sites/{site-id}/termStore/groups/{group-id}/sets/{set-id}/relations"
	localVarPath = strings.Replace(localVarPath, "{"+"site-id"+"}", _neturl.PathEscape(parameterToString(r.siteId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"set-id"+"}", _neturl.PathEscape(parameterToString(r.setId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphTermStoreRelation == nil {
		return localVarReturnValue, nil, reportError("microsoftGraphTermStoreRelation is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphTermStoreRelation
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSitesTermStoreGroupsSetsCreateTermsRequest struct {
	ctx _context.Context
	ApiService *SitesStoreApiService
	siteId string
	groupId string
	setId string
	microsoftGraphTermStoreTerm *MicrosoftGraphTermStoreTerm
}

// New navigation property
func (r ApiSitesTermStoreGroupsSetsCreateTermsRequest) MicrosoftGraphTermStoreTerm(microsoftGraphTermStoreTerm MicrosoftGraphTermStoreTerm) ApiSitesTermStoreGroupsSetsCreateTermsRequest {
	r.microsoftGraphTermStoreTerm = &microsoftGraphTermStoreTerm
	return r
}

func (r ApiSitesTermStoreGroupsSetsCreateTermsRequest) Execute() (MicrosoftGraphTermStoreTerm, *_nethttp.Response, error) {
	return r.ApiService.SitesTermStoreGroupsSetsCreateTermsExecute(r)
}

/*
SitesTermStoreGroupsSetsCreateTerms Create new navigation property to terms for sites

All the terms under the set.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param siteId key: id of site
 @param groupId key: id of group
 @param setId key: id of set
 @return ApiSitesTermStoreGroupsSetsCreateTermsRequest
*/
func (a *SitesStoreApiService) SitesTermStoreGroupsSetsCreateTerms(ctx _context.Context, siteId string, groupId string, setId string) ApiSitesTermStoreGroupsSetsCreateTermsRequest {
	return ApiSitesTermStoreGroupsSetsCreateTermsRequest{
		ApiService: a,
		ctx: ctx,
		siteId: siteId,
		groupId: groupId,
		setId: setId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphTermStoreTerm
func (a *SitesStoreApiService) SitesTermStoreGroupsSetsCreateTermsExecute(r ApiSitesTermStoreGroupsSetsCreateTermsRequest) (MicrosoftGraphTermStoreTerm, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphTermStoreTerm
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SitesStoreApiService.SitesTermStoreGroupsSetsCreateTerms")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sites/{site-id}/termStore/groups/{group-id}/sets/{set-id}/terms"
	localVarPath = strings.Replace(localVarPath, "{"+"site-id"+"}", _neturl.PathEscape(parameterToString(r.siteId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"set-id"+"}", _neturl.PathEscape(parameterToString(r.setId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphTermStoreTerm == nil {
		return localVarReturnValue, nil, reportError("microsoftGraphTermStoreTerm is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphTermStoreTerm
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSitesTermStoreGroupsSetsDeleteChildrenRequest struct {
	ctx _context.Context
	ApiService *SitesStoreApiService
	siteId string
	groupId string
	setId string
	termId string
	ifMatch *string
}

// ETag
func (r ApiSitesTermStoreGroupsSetsDeleteChildrenRequest) IfMatch(ifMatch string) ApiSitesTermStoreGroupsSetsDeleteChildrenRequest {
	r.ifMatch = &ifMatch
	return r
}

func (r ApiSitesTermStoreGroupsSetsDeleteChildrenRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.SitesTermStoreGroupsSetsDeleteChildrenExecute(r)
}

/*
SitesTermStoreGroupsSetsDeleteChildren Delete navigation property children for sites

Children terms of set in term [store].

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param siteId key: id of site
 @param groupId key: id of group
 @param setId key: id of set
 @param termId key: id of term
 @return ApiSitesTermStoreGroupsSetsDeleteChildrenRequest
*/
func (a *SitesStoreApiService) SitesTermStoreGroupsSetsDeleteChildren(ctx _context.Context, siteId string, groupId string, setId string, termId string) ApiSitesTermStoreGroupsSetsDeleteChildrenRequest {
	return ApiSitesTermStoreGroupsSetsDeleteChildrenRequest{
		ApiService: a,
		ctx: ctx,
		siteId: siteId,
		groupId: groupId,
		setId: setId,
		termId: termId,
	}
}

// Execute executes the request
func (a *SitesStoreApiService) SitesTermStoreGroupsSetsDeleteChildrenExecute(r ApiSitesTermStoreGroupsSetsDeleteChildrenRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SitesStoreApiService.SitesTermStoreGroupsSetsDeleteChildren")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sites/{site-id}/termStore/groups/{group-id}/sets/{set-id}/children/{term-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"site-id"+"}", _neturl.PathEscape(parameterToString(r.siteId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"set-id"+"}", _neturl.PathEscape(parameterToString(r.setId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"term-id"+"}", _neturl.PathEscape(parameterToString(r.termId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ifMatch != nil {
		localVarHeaderParams["If-Match"] = parameterToString(*r.ifMatch, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiSitesTermStoreGroupsSetsDeleteParentGroupRequest struct {
	ctx _context.Context
	ApiService *SitesStoreApiService
	siteId string
	groupId string
	setId string
	ifMatch *string
}

// ETag
func (r ApiSitesTermStoreGroupsSetsDeleteParentGroupRequest) IfMatch(ifMatch string) ApiSitesTermStoreGroupsSetsDeleteParentGroupRequest {
	r.ifMatch = &ifMatch
	return r
}

func (r ApiSitesTermStoreGroupsSetsDeleteParentGroupRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.SitesTermStoreGroupsSetsDeleteParentGroupExecute(r)
}

/*
SitesTermStoreGroupsSetsDeleteParentGroup Delete navigation property parentGroup for sites

The parent [group] that contains the set.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param siteId key: id of site
 @param groupId key: id of group
 @param setId key: id of set
 @return ApiSitesTermStoreGroupsSetsDeleteParentGroupRequest
*/
func (a *SitesStoreApiService) SitesTermStoreGroupsSetsDeleteParentGroup(ctx _context.Context, siteId string, groupId string, setId string) ApiSitesTermStoreGroupsSetsDeleteParentGroupRequest {
	return ApiSitesTermStoreGroupsSetsDeleteParentGroupRequest{
		ApiService: a,
		ctx: ctx,
		siteId: siteId,
		groupId: groupId,
		setId: setId,
	}
}

// Execute executes the request
func (a *SitesStoreApiService) SitesTermStoreGroupsSetsDeleteParentGroupExecute(r ApiSitesTermStoreGroupsSetsDeleteParentGroupRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SitesStoreApiService.SitesTermStoreGroupsSetsDeleteParentGroup")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sites/{site-id}/termStore/groups/{group-id}/sets/{set-id}/parentGroup"
	localVarPath = strings.Replace(localVarPath, "{"+"site-id"+"}", _neturl.PathEscape(parameterToString(r.siteId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"set-id"+"}", _neturl.PathEscape(parameterToString(r.setId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ifMatch != nil {
		localVarHeaderParams["If-Match"] = parameterToString(*r.ifMatch, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiSitesTermStoreGroupsSetsDeleteRelationsRequest struct {
	ctx _context.Context
	ApiService *SitesStoreApiService
	siteId string
	groupId string
	setId string
	relationId string
	ifMatch *string
}

// ETag
func (r ApiSitesTermStoreGroupsSetsDeleteRelationsRequest) IfMatch(ifMatch string) ApiSitesTermStoreGroupsSetsDeleteRelationsRequest {
	r.ifMatch = &ifMatch
	return r
}

func (r ApiSitesTermStoreGroupsSetsDeleteRelationsRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.SitesTermStoreGroupsSetsDeleteRelationsExecute(r)
}

/*
SitesTermStoreGroupsSetsDeleteRelations Delete navigation property relations for sites

Indicates which terms have been pinned or reused directly under the set.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param siteId key: id of site
 @param groupId key: id of group
 @param setId key: id of set
 @param relationId key: id of relation
 @return ApiSitesTermStoreGroupsSetsDeleteRelationsRequest
*/
func (a *SitesStoreApiService) SitesTermStoreGroupsSetsDeleteRelations(ctx _context.Context, siteId string, groupId string, setId string, relationId string) ApiSitesTermStoreGroupsSetsDeleteRelationsRequest {
	return ApiSitesTermStoreGroupsSetsDeleteRelationsRequest{
		ApiService: a,
		ctx: ctx,
		siteId: siteId,
		groupId: groupId,
		setId: setId,
		relationId: relationId,
	}
}

// Execute executes the request
func (a *SitesStoreApiService) SitesTermStoreGroupsSetsDeleteRelationsExecute(r ApiSitesTermStoreGroupsSetsDeleteRelationsRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SitesStoreApiService.SitesTermStoreGroupsSetsDeleteRelations")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sites/{site-id}/termStore/groups/{group-id}/sets/{set-id}/relations/{relation-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"site-id"+"}", _neturl.PathEscape(parameterToString(r.siteId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"set-id"+"}", _neturl.PathEscape(parameterToString(r.setId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"relation-id"+"}", _neturl.PathEscape(parameterToString(r.relationId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ifMatch != nil {
		localVarHeaderParams["If-Match"] = parameterToString(*r.ifMatch, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiSitesTermStoreGroupsSetsDeleteTermsRequest struct {
	ctx _context.Context
	ApiService *SitesStoreApiService
	siteId string
	groupId string
	setId string
	termId string
	ifMatch *string
}

// ETag
func (r ApiSitesTermStoreGroupsSetsDeleteTermsRequest) IfMatch(ifMatch string) ApiSitesTermStoreGroupsSetsDeleteTermsRequest {
	r.ifMatch = &ifMatch
	return r
}

func (r ApiSitesTermStoreGroupsSetsDeleteTermsRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.SitesTermStoreGroupsSetsDeleteTermsExecute(r)
}

/*
SitesTermStoreGroupsSetsDeleteTerms Delete navigation property terms for sites

All the terms under the set.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param siteId key: id of site
 @param groupId key: id of group
 @param setId key: id of set
 @param termId key: id of term
 @return ApiSitesTermStoreGroupsSetsDeleteTermsRequest
*/
func (a *SitesStoreApiService) SitesTermStoreGroupsSetsDeleteTerms(ctx _context.Context, siteId string, groupId string, setId string, termId string) ApiSitesTermStoreGroupsSetsDeleteTermsRequest {
	return ApiSitesTermStoreGroupsSetsDeleteTermsRequest{
		ApiService: a,
		ctx: ctx,
		siteId: siteId,
		groupId: groupId,
		setId: setId,
		termId: termId,
	}
}

// Execute executes the request
func (a *SitesStoreApiService) SitesTermStoreGroupsSetsDeleteTermsExecute(r ApiSitesTermStoreGroupsSetsDeleteTermsRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SitesStoreApiService.SitesTermStoreGroupsSetsDeleteTerms")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sites/{site-id}/termStore/groups/{group-id}/sets/{set-id}/terms/{term-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"site-id"+"}", _neturl.PathEscape(parameterToString(r.siteId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"set-id"+"}", _neturl.PathEscape(parameterToString(r.setId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"term-id"+"}", _neturl.PathEscape(parameterToString(r.termId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ifMatch != nil {
		localVarHeaderParams["If-Match"] = parameterToString(*r.ifMatch, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiSitesTermStoreGroupsSetsGetChildrenRequest struct {
	ctx _context.Context
	ApiService *SitesStoreApiService
	siteId string
	groupId string
	setId string
	termId string
	select_ *[]string
	expand *[]string
}

// Select properties to be returned
func (r ApiSitesTermStoreGroupsSetsGetChildrenRequest) Select_(select_ []string) ApiSitesTermStoreGroupsSetsGetChildrenRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiSitesTermStoreGroupsSetsGetChildrenRequest) Expand(expand []string) ApiSitesTermStoreGroupsSetsGetChildrenRequest {
	r.expand = &expand
	return r
}

func (r ApiSitesTermStoreGroupsSetsGetChildrenRequest) Execute() (MicrosoftGraphTermStoreTerm, *_nethttp.Response, error) {
	return r.ApiService.SitesTermStoreGroupsSetsGetChildrenExecute(r)
}

/*
SitesTermStoreGroupsSetsGetChildren Get children from sites

Children terms of set in term [store].

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param siteId key: id of site
 @param groupId key: id of group
 @param setId key: id of set
 @param termId key: id of term
 @return ApiSitesTermStoreGroupsSetsGetChildrenRequest
*/
func (a *SitesStoreApiService) SitesTermStoreGroupsSetsGetChildren(ctx _context.Context, siteId string, groupId string, setId string, termId string) ApiSitesTermStoreGroupsSetsGetChildrenRequest {
	return ApiSitesTermStoreGroupsSetsGetChildrenRequest{
		ApiService: a,
		ctx: ctx,
		siteId: siteId,
		groupId: groupId,
		setId: setId,
		termId: termId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphTermStoreTerm
func (a *SitesStoreApiService) SitesTermStoreGroupsSetsGetChildrenExecute(r ApiSitesTermStoreGroupsSetsGetChildrenRequest) (MicrosoftGraphTermStoreTerm, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphTermStoreTerm
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SitesStoreApiService.SitesTermStoreGroupsSetsGetChildren")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sites/{site-id}/termStore/groups/{group-id}/sets/{set-id}/children/{term-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"site-id"+"}", _neturl.PathEscape(parameterToString(r.siteId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"set-id"+"}", _neturl.PathEscape(parameterToString(r.setId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"term-id"+"}", _neturl.PathEscape(parameterToString(r.termId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSitesTermStoreGroupsSetsGetParentGroupRequest struct {
	ctx _context.Context
	ApiService *SitesStoreApiService
	siteId string
	groupId string
	setId string
	select_ *[]string
	expand *[]string
}

// Select properties to be returned
func (r ApiSitesTermStoreGroupsSetsGetParentGroupRequest) Select_(select_ []string) ApiSitesTermStoreGroupsSetsGetParentGroupRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiSitesTermStoreGroupsSetsGetParentGroupRequest) Expand(expand []string) ApiSitesTermStoreGroupsSetsGetParentGroupRequest {
	r.expand = &expand
	return r
}

func (r ApiSitesTermStoreGroupsSetsGetParentGroupRequest) Execute() (MicrosoftGraphTermStoreGroup, *_nethttp.Response, error) {
	return r.ApiService.SitesTermStoreGroupsSetsGetParentGroupExecute(r)
}

/*
SitesTermStoreGroupsSetsGetParentGroup Get parentGroup from sites

The parent [group] that contains the set.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param siteId key: id of site
 @param groupId key: id of group
 @param setId key: id of set
 @return ApiSitesTermStoreGroupsSetsGetParentGroupRequest
*/
func (a *SitesStoreApiService) SitesTermStoreGroupsSetsGetParentGroup(ctx _context.Context, siteId string, groupId string, setId string) ApiSitesTermStoreGroupsSetsGetParentGroupRequest {
	return ApiSitesTermStoreGroupsSetsGetParentGroupRequest{
		ApiService: a,
		ctx: ctx,
		siteId: siteId,
		groupId: groupId,
		setId: setId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphTermStoreGroup
func (a *SitesStoreApiService) SitesTermStoreGroupsSetsGetParentGroupExecute(r ApiSitesTermStoreGroupsSetsGetParentGroupRequest) (MicrosoftGraphTermStoreGroup, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphTermStoreGroup
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SitesStoreApiService.SitesTermStoreGroupsSetsGetParentGroup")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sites/{site-id}/termStore/groups/{group-id}/sets/{set-id}/parentGroup"
	localVarPath = strings.Replace(localVarPath, "{"+"site-id"+"}", _neturl.PathEscape(parameterToString(r.siteId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"set-id"+"}", _neturl.PathEscape(parameterToString(r.setId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSitesTermStoreGroupsSetsGetRelationsRequest struct {
	ctx _context.Context
	ApiService *SitesStoreApiService
	siteId string
	groupId string
	setId string
	relationId string
	select_ *[]string
	expand *[]string
}

// Select properties to be returned
func (r ApiSitesTermStoreGroupsSetsGetRelationsRequest) Select_(select_ []string) ApiSitesTermStoreGroupsSetsGetRelationsRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiSitesTermStoreGroupsSetsGetRelationsRequest) Expand(expand []string) ApiSitesTermStoreGroupsSetsGetRelationsRequest {
	r.expand = &expand
	return r
}

func (r ApiSitesTermStoreGroupsSetsGetRelationsRequest) Execute() (MicrosoftGraphTermStoreRelation, *_nethttp.Response, error) {
	return r.ApiService.SitesTermStoreGroupsSetsGetRelationsExecute(r)
}

/*
SitesTermStoreGroupsSetsGetRelations Get relations from sites

Indicates which terms have been pinned or reused directly under the set.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param siteId key: id of site
 @param groupId key: id of group
 @param setId key: id of set
 @param relationId key: id of relation
 @return ApiSitesTermStoreGroupsSetsGetRelationsRequest
*/
func (a *SitesStoreApiService) SitesTermStoreGroupsSetsGetRelations(ctx _context.Context, siteId string, groupId string, setId string, relationId string) ApiSitesTermStoreGroupsSetsGetRelationsRequest {
	return ApiSitesTermStoreGroupsSetsGetRelationsRequest{
		ApiService: a,
		ctx: ctx,
		siteId: siteId,
		groupId: groupId,
		setId: setId,
		relationId: relationId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphTermStoreRelation
func (a *SitesStoreApiService) SitesTermStoreGroupsSetsGetRelationsExecute(r ApiSitesTermStoreGroupsSetsGetRelationsRequest) (MicrosoftGraphTermStoreRelation, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphTermStoreRelation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SitesStoreApiService.SitesTermStoreGroupsSetsGetRelations")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sites/{site-id}/termStore/groups/{group-id}/sets/{set-id}/relations/{relation-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"site-id"+"}", _neturl.PathEscape(parameterToString(r.siteId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"set-id"+"}", _neturl.PathEscape(parameterToString(r.setId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"relation-id"+"}", _neturl.PathEscape(parameterToString(r.relationId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSitesTermStoreGroupsSetsGetTermsRequest struct {
	ctx _context.Context
	ApiService *SitesStoreApiService
	siteId string
	groupId string
	setId string
	termId string
	select_ *[]string
	expand *[]string
}

// Select properties to be returned
func (r ApiSitesTermStoreGroupsSetsGetTermsRequest) Select_(select_ []string) ApiSitesTermStoreGroupsSetsGetTermsRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiSitesTermStoreGroupsSetsGetTermsRequest) Expand(expand []string) ApiSitesTermStoreGroupsSetsGetTermsRequest {
	r.expand = &expand
	return r
}

func (r ApiSitesTermStoreGroupsSetsGetTermsRequest) Execute() (MicrosoftGraphTermStoreTerm, *_nethttp.Response, error) {
	return r.ApiService.SitesTermStoreGroupsSetsGetTermsExecute(r)
}

/*
SitesTermStoreGroupsSetsGetTerms Get terms from sites

All the terms under the set.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param siteId key: id of site
 @param groupId key: id of group
 @param setId key: id of set
 @param termId key: id of term
 @return ApiSitesTermStoreGroupsSetsGetTermsRequest
*/
func (a *SitesStoreApiService) SitesTermStoreGroupsSetsGetTerms(ctx _context.Context, siteId string, groupId string, setId string, termId string) ApiSitesTermStoreGroupsSetsGetTermsRequest {
	return ApiSitesTermStoreGroupsSetsGetTermsRequest{
		ApiService: a,
		ctx: ctx,
		siteId: siteId,
		groupId: groupId,
		setId: setId,
		termId: termId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphTermStoreTerm
func (a *SitesStoreApiService) SitesTermStoreGroupsSetsGetTermsExecute(r ApiSitesTermStoreGroupsSetsGetTermsRequest) (MicrosoftGraphTermStoreTerm, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphTermStoreTerm
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SitesStoreApiService.SitesTermStoreGroupsSetsGetTerms")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sites/{site-id}/termStore/groups/{group-id}/sets/{set-id}/terms/{term-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"site-id"+"}", _neturl.PathEscape(parameterToString(r.siteId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"set-id"+"}", _neturl.PathEscape(parameterToString(r.setId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"term-id"+"}", _neturl.PathEscape(parameterToString(r.termId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSitesTermStoreGroupsSetsListChildrenRequest struct {
	ctx _context.Context
	ApiService *SitesStoreApiService
	siteId string
	groupId string
	setId string
	top *int32
	skip *int32
	search *string
	filter *string
	count *bool
	orderby *[]string
	select_ *[]string
	expand *[]string
}

// Show only the first n items
func (r ApiSitesTermStoreGroupsSetsListChildrenRequest) Top(top int32) ApiSitesTermStoreGroupsSetsListChildrenRequest {
	r.top = &top
	return r
}
// Skip the first n items
func (r ApiSitesTermStoreGroupsSetsListChildrenRequest) Skip(skip int32) ApiSitesTermStoreGroupsSetsListChildrenRequest {
	r.skip = &skip
	return r
}
// Search items by search phrases
func (r ApiSitesTermStoreGroupsSetsListChildrenRequest) Search(search string) ApiSitesTermStoreGroupsSetsListChildrenRequest {
	r.search = &search
	return r
}
// Filter items by property values
func (r ApiSitesTermStoreGroupsSetsListChildrenRequest) Filter(filter string) ApiSitesTermStoreGroupsSetsListChildrenRequest {
	r.filter = &filter
	return r
}
// Include count of items
func (r ApiSitesTermStoreGroupsSetsListChildrenRequest) Count(count bool) ApiSitesTermStoreGroupsSetsListChildrenRequest {
	r.count = &count
	return r
}
// Order items by property values
func (r ApiSitesTermStoreGroupsSetsListChildrenRequest) Orderby(orderby []string) ApiSitesTermStoreGroupsSetsListChildrenRequest {
	r.orderby = &orderby
	return r
}
// Select properties to be returned
func (r ApiSitesTermStoreGroupsSetsListChildrenRequest) Select_(select_ []string) ApiSitesTermStoreGroupsSetsListChildrenRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiSitesTermStoreGroupsSetsListChildrenRequest) Expand(expand []string) ApiSitesTermStoreGroupsSetsListChildrenRequest {
	r.expand = &expand
	return r
}

func (r ApiSitesTermStoreGroupsSetsListChildrenRequest) Execute() (CollectionOfTerm, *_nethttp.Response, error) {
	return r.ApiService.SitesTermStoreGroupsSetsListChildrenExecute(r)
}

/*
SitesTermStoreGroupsSetsListChildren Get children from sites

Children terms of set in term [store].

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param siteId key: id of site
 @param groupId key: id of group
 @param setId key: id of set
 @return ApiSitesTermStoreGroupsSetsListChildrenRequest
*/
func (a *SitesStoreApiService) SitesTermStoreGroupsSetsListChildren(ctx _context.Context, siteId string, groupId string, setId string) ApiSitesTermStoreGroupsSetsListChildrenRequest {
	return ApiSitesTermStoreGroupsSetsListChildrenRequest{
		ApiService: a,
		ctx: ctx,
		siteId: siteId,
		groupId: groupId,
		setId: setId,
	}
}

// Execute executes the request
//  @return CollectionOfTerm
func (a *SitesStoreApiService) SitesTermStoreGroupsSetsListChildrenExecute(r ApiSitesTermStoreGroupsSetsListChildrenRequest) (CollectionOfTerm, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  CollectionOfTerm
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SitesStoreApiService.SitesTermStoreGroupsSetsListChildren")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sites/{site-id}/termStore/groups/{group-id}/sets/{set-id}/children"
	localVarPath = strings.Replace(localVarPath, "{"+"site-id"+"}", _neturl.PathEscape(parameterToString(r.siteId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"set-id"+"}", _neturl.PathEscape(parameterToString(r.setId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.top != nil {
		localVarQueryParams.Add("$top", parameterToString(*r.top, ""))
	}
	if r.skip != nil {
		localVarQueryParams.Add("$skip", parameterToString(*r.skip, ""))
	}
	if r.search != nil {
		localVarQueryParams.Add("$search", parameterToString(*r.search, ""))
	}
	if r.filter != nil {
		localVarQueryParams.Add("$filter", parameterToString(*r.filter, ""))
	}
	if r.count != nil {
		localVarQueryParams.Add("$count", parameterToString(*r.count, ""))
	}
	if r.orderby != nil {
		localVarQueryParams.Add("$orderby", parameterToString(*r.orderby, "csv"))
	}
	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSitesTermStoreGroupsSetsListRelationsRequest struct {
	ctx _context.Context
	ApiService *SitesStoreApiService
	siteId string
	groupId string
	setId string
	top *int32
	skip *int32
	search *string
	filter *string
	count *bool
	orderby *[]string
	select_ *[]string
	expand *[]string
}

// Show only the first n items
func (r ApiSitesTermStoreGroupsSetsListRelationsRequest) Top(top int32) ApiSitesTermStoreGroupsSetsListRelationsRequest {
	r.top = &top
	return r
}
// Skip the first n items
func (r ApiSitesTermStoreGroupsSetsListRelationsRequest) Skip(skip int32) ApiSitesTermStoreGroupsSetsListRelationsRequest {
	r.skip = &skip
	return r
}
// Search items by search phrases
func (r ApiSitesTermStoreGroupsSetsListRelationsRequest) Search(search string) ApiSitesTermStoreGroupsSetsListRelationsRequest {
	r.search = &search
	return r
}
// Filter items by property values
func (r ApiSitesTermStoreGroupsSetsListRelationsRequest) Filter(filter string) ApiSitesTermStoreGroupsSetsListRelationsRequest {
	r.filter = &filter
	return r
}
// Include count of items
func (r ApiSitesTermStoreGroupsSetsListRelationsRequest) Count(count bool) ApiSitesTermStoreGroupsSetsListRelationsRequest {
	r.count = &count
	return r
}
// Order items by property values
func (r ApiSitesTermStoreGroupsSetsListRelationsRequest) Orderby(orderby []string) ApiSitesTermStoreGroupsSetsListRelationsRequest {
	r.orderby = &orderby
	return r
}
// Select properties to be returned
func (r ApiSitesTermStoreGroupsSetsListRelationsRequest) Select_(select_ []string) ApiSitesTermStoreGroupsSetsListRelationsRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiSitesTermStoreGroupsSetsListRelationsRequest) Expand(expand []string) ApiSitesTermStoreGroupsSetsListRelationsRequest {
	r.expand = &expand
	return r
}

func (r ApiSitesTermStoreGroupsSetsListRelationsRequest) Execute() (CollectionOfRelation, *_nethttp.Response, error) {
	return r.ApiService.SitesTermStoreGroupsSetsListRelationsExecute(r)
}

/*
SitesTermStoreGroupsSetsListRelations Get relations from sites

Indicates which terms have been pinned or reused directly under the set.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param siteId key: id of site
 @param groupId key: id of group
 @param setId key: id of set
 @return ApiSitesTermStoreGroupsSetsListRelationsRequest
*/
func (a *SitesStoreApiService) SitesTermStoreGroupsSetsListRelations(ctx _context.Context, siteId string, groupId string, setId string) ApiSitesTermStoreGroupsSetsListRelationsRequest {
	return ApiSitesTermStoreGroupsSetsListRelationsRequest{
		ApiService: a,
		ctx: ctx,
		siteId: siteId,
		groupId: groupId,
		setId: setId,
	}
}

// Execute executes the request
//  @return CollectionOfRelation
func (a *SitesStoreApiService) SitesTermStoreGroupsSetsListRelationsExecute(r ApiSitesTermStoreGroupsSetsListRelationsRequest) (CollectionOfRelation, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  CollectionOfRelation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SitesStoreApiService.SitesTermStoreGroupsSetsListRelations")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sites/{site-id}/termStore/groups/{group-id}/sets/{set-id}/relations"
	localVarPath = strings.Replace(localVarPath, "{"+"site-id"+"}", _neturl.PathEscape(parameterToString(r.siteId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"set-id"+"}", _neturl.PathEscape(parameterToString(r.setId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.top != nil {
		localVarQueryParams.Add("$top", parameterToString(*r.top, ""))
	}
	if r.skip != nil {
		localVarQueryParams.Add("$skip", parameterToString(*r.skip, ""))
	}
	if r.search != nil {
		localVarQueryParams.Add("$search", parameterToString(*r.search, ""))
	}
	if r.filter != nil {
		localVarQueryParams.Add("$filter", parameterToString(*r.filter, ""))
	}
	if r.count != nil {
		localVarQueryParams.Add("$count", parameterToString(*r.count, ""))
	}
	if r.orderby != nil {
		localVarQueryParams.Add("$orderby", parameterToString(*r.orderby, "csv"))
	}
	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSitesTermStoreGroupsSetsListTermsRequest struct {
	ctx _context.Context
	ApiService *SitesStoreApiService
	siteId string
	groupId string
	setId string
	top *int32
	skip *int32
	search *string
	filter *string
	count *bool
	orderby *[]string
	select_ *[]string
	expand *[]string
}

// Show only the first n items
func (r ApiSitesTermStoreGroupsSetsListTermsRequest) Top(top int32) ApiSitesTermStoreGroupsSetsListTermsRequest {
	r.top = &top
	return r
}
// Skip the first n items
func (r ApiSitesTermStoreGroupsSetsListTermsRequest) Skip(skip int32) ApiSitesTermStoreGroupsSetsListTermsRequest {
	r.skip = &skip
	return r
}
// Search items by search phrases
func (r ApiSitesTermStoreGroupsSetsListTermsRequest) Search(search string) ApiSitesTermStoreGroupsSetsListTermsRequest {
	r.search = &search
	return r
}
// Filter items by property values
func (r ApiSitesTermStoreGroupsSetsListTermsRequest) Filter(filter string) ApiSitesTermStoreGroupsSetsListTermsRequest {
	r.filter = &filter
	return r
}
// Include count of items
func (r ApiSitesTermStoreGroupsSetsListTermsRequest) Count(count bool) ApiSitesTermStoreGroupsSetsListTermsRequest {
	r.count = &count
	return r
}
// Order items by property values
func (r ApiSitesTermStoreGroupsSetsListTermsRequest) Orderby(orderby []string) ApiSitesTermStoreGroupsSetsListTermsRequest {
	r.orderby = &orderby
	return r
}
// Select properties to be returned
func (r ApiSitesTermStoreGroupsSetsListTermsRequest) Select_(select_ []string) ApiSitesTermStoreGroupsSetsListTermsRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiSitesTermStoreGroupsSetsListTermsRequest) Expand(expand []string) ApiSitesTermStoreGroupsSetsListTermsRequest {
	r.expand = &expand
	return r
}

func (r ApiSitesTermStoreGroupsSetsListTermsRequest) Execute() (CollectionOfTerm, *_nethttp.Response, error) {
	return r.ApiService.SitesTermStoreGroupsSetsListTermsExecute(r)
}

/*
SitesTermStoreGroupsSetsListTerms Get terms from sites

All the terms under the set.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param siteId key: id of site
 @param groupId key: id of group
 @param setId key: id of set
 @return ApiSitesTermStoreGroupsSetsListTermsRequest
*/
func (a *SitesStoreApiService) SitesTermStoreGroupsSetsListTerms(ctx _context.Context, siteId string, groupId string, setId string) ApiSitesTermStoreGroupsSetsListTermsRequest {
	return ApiSitesTermStoreGroupsSetsListTermsRequest{
		ApiService: a,
		ctx: ctx,
		siteId: siteId,
		groupId: groupId,
		setId: setId,
	}
}

// Execute executes the request
//  @return CollectionOfTerm
func (a *SitesStoreApiService) SitesTermStoreGroupsSetsListTermsExecute(r ApiSitesTermStoreGroupsSetsListTermsRequest) (CollectionOfTerm, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  CollectionOfTerm
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SitesStoreApiService.SitesTermStoreGroupsSetsListTerms")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sites/{site-id}/termStore/groups/{group-id}/sets/{set-id}/terms"
	localVarPath = strings.Replace(localVarPath, "{"+"site-id"+"}", _neturl.PathEscape(parameterToString(r.siteId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"set-id"+"}", _neturl.PathEscape(parameterToString(r.setId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.top != nil {
		localVarQueryParams.Add("$top", parameterToString(*r.top, ""))
	}
	if r.skip != nil {
		localVarQueryParams.Add("$skip", parameterToString(*r.skip, ""))
	}
	if r.search != nil {
		localVarQueryParams.Add("$search", parameterToString(*r.search, ""))
	}
	if r.filter != nil {
		localVarQueryParams.Add("$filter", parameterToString(*r.filter, ""))
	}
	if r.count != nil {
		localVarQueryParams.Add("$count", parameterToString(*r.count, ""))
	}
	if r.orderby != nil {
		localVarQueryParams.Add("$orderby", parameterToString(*r.orderby, "csv"))
	}
	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSitesTermStoreGroupsSetsRelationsDeleteRefFromTermRequest struct {
	ctx _context.Context
	ApiService *SitesStoreApiService
	siteId string
	groupId string
	setId string
	relationId string
	ifMatch *string
}

// ETag
func (r ApiSitesTermStoreGroupsSetsRelationsDeleteRefFromTermRequest) IfMatch(ifMatch string) ApiSitesTermStoreGroupsSetsRelationsDeleteRefFromTermRequest {
	r.ifMatch = &ifMatch
	return r
}

func (r ApiSitesTermStoreGroupsSetsRelationsDeleteRefFromTermRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.SitesTermStoreGroupsSetsRelationsDeleteRefFromTermExecute(r)
}

/*
SitesTermStoreGroupsSetsRelationsDeleteRefFromTerm Delete ref of navigation property fromTerm for sites

The from [term] of the relation. The term from which the relationship is defined. A null value would indicate the relation is directly with the [set].

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param siteId key: id of site
 @param groupId key: id of group
 @param setId key: id of set
 @param relationId key: id of relation
 @return ApiSitesTermStoreGroupsSetsRelationsDeleteRefFromTermRequest
*/
func (a *SitesStoreApiService) SitesTermStoreGroupsSetsRelationsDeleteRefFromTerm(ctx _context.Context, siteId string, groupId string, setId string, relationId string) ApiSitesTermStoreGroupsSetsRelationsDeleteRefFromTermRequest {
	return ApiSitesTermStoreGroupsSetsRelationsDeleteRefFromTermRequest{
		ApiService: a,
		ctx: ctx,
		siteId: siteId,
		groupId: groupId,
		setId: setId,
		relationId: relationId,
	}
}

// Execute executes the request
func (a *SitesStoreApiService) SitesTermStoreGroupsSetsRelationsDeleteRefFromTermExecute(r ApiSitesTermStoreGroupsSetsRelationsDeleteRefFromTermRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SitesStoreApiService.SitesTermStoreGroupsSetsRelationsDeleteRefFromTerm")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sites/{site-id}/termStore/groups/{group-id}/sets/{set-id}/relations/{relation-id}/fromTerm/$ref"
	localVarPath = strings.Replace(localVarPath, "{"+"site-id"+"}", _neturl.PathEscape(parameterToString(r.siteId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"set-id"+"}", _neturl.PathEscape(parameterToString(r.setId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"relation-id"+"}", _neturl.PathEscape(parameterToString(r.relationId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ifMatch != nil {
		localVarHeaderParams["If-Match"] = parameterToString(*r.ifMatch, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiSitesTermStoreGroupsSetsRelationsDeleteRefSetRequest struct {
	ctx _context.Context
	ApiService *SitesStoreApiService
	siteId string
	groupId string
	setId string
	relationId string
	ifMatch *string
}

// ETag
func (r ApiSitesTermStoreGroupsSetsRelationsDeleteRefSetRequest) IfMatch(ifMatch string) ApiSitesTermStoreGroupsSetsRelationsDeleteRefSetRequest {
	r.ifMatch = &ifMatch
	return r
}

func (r ApiSitesTermStoreGroupsSetsRelationsDeleteRefSetRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.SitesTermStoreGroupsSetsRelationsDeleteRefSetExecute(r)
}

/*
SitesTermStoreGroupsSetsRelationsDeleteRefSet Delete ref of navigation property set for sites

The [set] in which the relation is relevant.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param siteId key: id of site
 @param groupId key: id of group
 @param setId key: id of set
 @param relationId key: id of relation
 @return ApiSitesTermStoreGroupsSetsRelationsDeleteRefSetRequest
*/
func (a *SitesStoreApiService) SitesTermStoreGroupsSetsRelationsDeleteRefSet(ctx _context.Context, siteId string, groupId string, setId string, relationId string) ApiSitesTermStoreGroupsSetsRelationsDeleteRefSetRequest {
	return ApiSitesTermStoreGroupsSetsRelationsDeleteRefSetRequest{
		ApiService: a,
		ctx: ctx,
		siteId: siteId,
		groupId: groupId,
		setId: setId,
		relationId: relationId,
	}
}

// Execute executes the request
func (a *SitesStoreApiService) SitesTermStoreGroupsSetsRelationsDeleteRefSetExecute(r ApiSitesTermStoreGroupsSetsRelationsDeleteRefSetRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SitesStoreApiService.SitesTermStoreGroupsSetsRelationsDeleteRefSet")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sites/{site-id}/termStore/groups/{group-id}/sets/{set-id}/relations/{relation-id}/set/$ref"
	localVarPath = strings.Replace(localVarPath, "{"+"site-id"+"}", _neturl.PathEscape(parameterToString(r.siteId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"set-id"+"}", _neturl.PathEscape(parameterToString(r.setId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"relation-id"+"}", _neturl.PathEscape(parameterToString(r.relationId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ifMatch != nil {
		localVarHeaderParams["If-Match"] = parameterToString(*r.ifMatch, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiSitesTermStoreGroupsSetsRelationsDeleteRefToTermRequest struct {
	ctx _context.Context
	ApiService *SitesStoreApiService
	siteId string
	groupId string
	setId string
	relationId string
	ifMatch *string
}

// ETag
func (r ApiSitesTermStoreGroupsSetsRelationsDeleteRefToTermRequest) IfMatch(ifMatch string) ApiSitesTermStoreGroupsSetsRelationsDeleteRefToTermRequest {
	r.ifMatch = &ifMatch
	return r
}

func (r ApiSitesTermStoreGroupsSetsRelationsDeleteRefToTermRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.SitesTermStoreGroupsSetsRelationsDeleteRefToTermExecute(r)
}

/*
SitesTermStoreGroupsSetsRelationsDeleteRefToTerm Delete ref of navigation property toTerm for sites

The to [term] of the relation. The term to which the relationship is defined.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param siteId key: id of site
 @param groupId key: id of group
 @param setId key: id of set
 @param relationId key: id of relation
 @return ApiSitesTermStoreGroupsSetsRelationsDeleteRefToTermRequest
*/
func (a *SitesStoreApiService) SitesTermStoreGroupsSetsRelationsDeleteRefToTerm(ctx _context.Context, siteId string, groupId string, setId string, relationId string) ApiSitesTermStoreGroupsSetsRelationsDeleteRefToTermRequest {
	return ApiSitesTermStoreGroupsSetsRelationsDeleteRefToTermRequest{
		ApiService: a,
		ctx: ctx,
		siteId: siteId,
		groupId: groupId,
		setId: setId,
		relationId: relationId,
	}
}

// Execute executes the request
func (a *SitesStoreApiService) SitesTermStoreGroupsSetsRelationsDeleteRefToTermExecute(r ApiSitesTermStoreGroupsSetsRelationsDeleteRefToTermRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SitesStoreApiService.SitesTermStoreGroupsSetsRelationsDeleteRefToTerm")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sites/{site-id}/termStore/groups/{group-id}/sets/{set-id}/relations/{relation-id}/toTerm/$ref"
	localVarPath = strings.Replace(localVarPath, "{"+"site-id"+"}", _neturl.PathEscape(parameterToString(r.siteId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"set-id"+"}", _neturl.PathEscape(parameterToString(r.setId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"relation-id"+"}", _neturl.PathEscape(parameterToString(r.relationId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ifMatch != nil {
		localVarHeaderParams["If-Match"] = parameterToString(*r.ifMatch, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiSitesTermStoreGroupsSetsRelationsGetFromTermRequest struct {
	ctx _context.Context
	ApiService *SitesStoreApiService
	siteId string
	groupId string
	setId string
	relationId string
	select_ *[]string
	expand *[]string
}

// Select properties to be returned
func (r ApiSitesTermStoreGroupsSetsRelationsGetFromTermRequest) Select_(select_ []string) ApiSitesTermStoreGroupsSetsRelationsGetFromTermRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiSitesTermStoreGroupsSetsRelationsGetFromTermRequest) Expand(expand []string) ApiSitesTermStoreGroupsSetsRelationsGetFromTermRequest {
	r.expand = &expand
	return r
}

func (r ApiSitesTermStoreGroupsSetsRelationsGetFromTermRequest) Execute() (MicrosoftGraphTermStoreTerm, *_nethttp.Response, error) {
	return r.ApiService.SitesTermStoreGroupsSetsRelationsGetFromTermExecute(r)
}

/*
SitesTermStoreGroupsSetsRelationsGetFromTerm Get fromTerm from sites

The from [term] of the relation. The term from which the relationship is defined. A null value would indicate the relation is directly with the [set].

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param siteId key: id of site
 @param groupId key: id of group
 @param setId key: id of set
 @param relationId key: id of relation
 @return ApiSitesTermStoreGroupsSetsRelationsGetFromTermRequest
*/
func (a *SitesStoreApiService) SitesTermStoreGroupsSetsRelationsGetFromTerm(ctx _context.Context, siteId string, groupId string, setId string, relationId string) ApiSitesTermStoreGroupsSetsRelationsGetFromTermRequest {
	return ApiSitesTermStoreGroupsSetsRelationsGetFromTermRequest{
		ApiService: a,
		ctx: ctx,
		siteId: siteId,
		groupId: groupId,
		setId: setId,
		relationId: relationId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphTermStoreTerm
func (a *SitesStoreApiService) SitesTermStoreGroupsSetsRelationsGetFromTermExecute(r ApiSitesTermStoreGroupsSetsRelationsGetFromTermRequest) (MicrosoftGraphTermStoreTerm, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphTermStoreTerm
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SitesStoreApiService.SitesTermStoreGroupsSetsRelationsGetFromTerm")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sites/{site-id}/termStore/groups/{group-id}/sets/{set-id}/relations/{relation-id}/fromTerm"
	localVarPath = strings.Replace(localVarPath, "{"+"site-id"+"}", _neturl.PathEscape(parameterToString(r.siteId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"set-id"+"}", _neturl.PathEscape(parameterToString(r.setId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"relation-id"+"}", _neturl.PathEscape(parameterToString(r.relationId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSitesTermStoreGroupsSetsRelationsGetRefFromTermRequest struct {
	ctx _context.Context
	ApiService *SitesStoreApiService
	siteId string
	groupId string
	setId string
	relationId string
}


func (r ApiSitesTermStoreGroupsSetsRelationsGetRefFromTermRequest) Execute() (string, *_nethttp.Response, error) {
	return r.ApiService.SitesTermStoreGroupsSetsRelationsGetRefFromTermExecute(r)
}

/*
SitesTermStoreGroupsSetsRelationsGetRefFromTerm Get ref of fromTerm from sites

The from [term] of the relation. The term from which the relationship is defined. A null value would indicate the relation is directly with the [set].

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param siteId key: id of site
 @param groupId key: id of group
 @param setId key: id of set
 @param relationId key: id of relation
 @return ApiSitesTermStoreGroupsSetsRelationsGetRefFromTermRequest
*/
func (a *SitesStoreApiService) SitesTermStoreGroupsSetsRelationsGetRefFromTerm(ctx _context.Context, siteId string, groupId string, setId string, relationId string) ApiSitesTermStoreGroupsSetsRelationsGetRefFromTermRequest {
	return ApiSitesTermStoreGroupsSetsRelationsGetRefFromTermRequest{
		ApiService: a,
		ctx: ctx,
		siteId: siteId,
		groupId: groupId,
		setId: setId,
		relationId: relationId,
	}
}

// Execute executes the request
//  @return string
func (a *SitesStoreApiService) SitesTermStoreGroupsSetsRelationsGetRefFromTermExecute(r ApiSitesTermStoreGroupsSetsRelationsGetRefFromTermRequest) (string, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  string
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SitesStoreApiService.SitesTermStoreGroupsSetsRelationsGetRefFromTerm")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sites/{site-id}/termStore/groups/{group-id}/sets/{set-id}/relations/{relation-id}/fromTerm/$ref"
	localVarPath = strings.Replace(localVarPath, "{"+"site-id"+"}", _neturl.PathEscape(parameterToString(r.siteId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"set-id"+"}", _neturl.PathEscape(parameterToString(r.setId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"relation-id"+"}", _neturl.PathEscape(parameterToString(r.relationId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSitesTermStoreGroupsSetsRelationsGetRefSetRequest struct {
	ctx _context.Context
	ApiService *SitesStoreApiService
	siteId string
	groupId string
	setId string
	relationId string
}


func (r ApiSitesTermStoreGroupsSetsRelationsGetRefSetRequest) Execute() (string, *_nethttp.Response, error) {
	return r.ApiService.SitesTermStoreGroupsSetsRelationsGetRefSetExecute(r)
}

/*
SitesTermStoreGroupsSetsRelationsGetRefSet Get ref of set from sites

The [set] in which the relation is relevant.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param siteId key: id of site
 @param groupId key: id of group
 @param setId key: id of set
 @param relationId key: id of relation
 @return ApiSitesTermStoreGroupsSetsRelationsGetRefSetRequest
*/
func (a *SitesStoreApiService) SitesTermStoreGroupsSetsRelationsGetRefSet(ctx _context.Context, siteId string, groupId string, setId string, relationId string) ApiSitesTermStoreGroupsSetsRelationsGetRefSetRequest {
	return ApiSitesTermStoreGroupsSetsRelationsGetRefSetRequest{
		ApiService: a,
		ctx: ctx,
		siteId: siteId,
		groupId: groupId,
		setId: setId,
		relationId: relationId,
	}
}

// Execute executes the request
//  @return string
func (a *SitesStoreApiService) SitesTermStoreGroupsSetsRelationsGetRefSetExecute(r ApiSitesTermStoreGroupsSetsRelationsGetRefSetRequest) (string, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  string
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SitesStoreApiService.SitesTermStoreGroupsSetsRelationsGetRefSet")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sites/{site-id}/termStore/groups/{group-id}/sets/{set-id}/relations/{relation-id}/set/$ref"
	localVarPath = strings.Replace(localVarPath, "{"+"site-id"+"}", _neturl.PathEscape(parameterToString(r.siteId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"set-id"+"}", _neturl.PathEscape(parameterToString(r.setId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"relation-id"+"}", _neturl.PathEscape(parameterToString(r.relationId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSitesTermStoreGroupsSetsRelationsGetRefToTermRequest struct {
	ctx _context.Context
	ApiService *SitesStoreApiService
	siteId string
	groupId string
	setId string
	relationId string
}


func (r ApiSitesTermStoreGroupsSetsRelationsGetRefToTermRequest) Execute() (string, *_nethttp.Response, error) {
	return r.ApiService.SitesTermStoreGroupsSetsRelationsGetRefToTermExecute(r)
}

/*
SitesTermStoreGroupsSetsRelationsGetRefToTerm Get ref of toTerm from sites

The to [term] of the relation. The term to which the relationship is defined.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param siteId key: id of site
 @param groupId key: id of group
 @param setId key: id of set
 @param relationId key: id of relation
 @return ApiSitesTermStoreGroupsSetsRelationsGetRefToTermRequest
*/
func (a *SitesStoreApiService) SitesTermStoreGroupsSetsRelationsGetRefToTerm(ctx _context.Context, siteId string, groupId string, setId string, relationId string) ApiSitesTermStoreGroupsSetsRelationsGetRefToTermRequest {
	return ApiSitesTermStoreGroupsSetsRelationsGetRefToTermRequest{
		ApiService: a,
		ctx: ctx,
		siteId: siteId,
		groupId: groupId,
		setId: setId,
		relationId: relationId,
	}
}

// Execute executes the request
//  @return string
func (a *SitesStoreApiService) SitesTermStoreGroupsSetsRelationsGetRefToTermExecute(r ApiSitesTermStoreGroupsSetsRelationsGetRefToTermRequest) (string, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  string
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SitesStoreApiService.SitesTermStoreGroupsSetsRelationsGetRefToTerm")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sites/{site-id}/termStore/groups/{group-id}/sets/{set-id}/relations/{relation-id}/toTerm/$ref"
	localVarPath = strings.Replace(localVarPath, "{"+"site-id"+"}", _neturl.PathEscape(parameterToString(r.siteId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"set-id"+"}", _neturl.PathEscape(parameterToString(r.setId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"relation-id"+"}", _neturl.PathEscape(parameterToString(r.relationId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSitesTermStoreGroupsSetsRelationsGetSetRequest struct {
	ctx _context.Context
	ApiService *SitesStoreApiService
	siteId string
	groupId string
	setId string
	relationId string
	select_ *[]string
	expand *[]string
}

// Select properties to be returned
func (r ApiSitesTermStoreGroupsSetsRelationsGetSetRequest) Select_(select_ []string) ApiSitesTermStoreGroupsSetsRelationsGetSetRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiSitesTermStoreGroupsSetsRelationsGetSetRequest) Expand(expand []string) ApiSitesTermStoreGroupsSetsRelationsGetSetRequest {
	r.expand = &expand
	return r
}

func (r ApiSitesTermStoreGroupsSetsRelationsGetSetRequest) Execute() (MicrosoftGraphTermStoreSet, *_nethttp.Response, error) {
	return r.ApiService.SitesTermStoreGroupsSetsRelationsGetSetExecute(r)
}

/*
SitesTermStoreGroupsSetsRelationsGetSet Get set from sites

The [set] in which the relation is relevant.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param siteId key: id of site
 @param groupId key: id of group
 @param setId key: id of set
 @param relationId key: id of relation
 @return ApiSitesTermStoreGroupsSetsRelationsGetSetRequest
*/
func (a *SitesStoreApiService) SitesTermStoreGroupsSetsRelationsGetSet(ctx _context.Context, siteId string, groupId string, setId string, relationId string) ApiSitesTermStoreGroupsSetsRelationsGetSetRequest {
	return ApiSitesTermStoreGroupsSetsRelationsGetSetRequest{
		ApiService: a,
		ctx: ctx,
		siteId: siteId,
		groupId: groupId,
		setId: setId,
		relationId: relationId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphTermStoreSet
func (a *SitesStoreApiService) SitesTermStoreGroupsSetsRelationsGetSetExecute(r ApiSitesTermStoreGroupsSetsRelationsGetSetRequest) (MicrosoftGraphTermStoreSet, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphTermStoreSet
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SitesStoreApiService.SitesTermStoreGroupsSetsRelationsGetSet")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sites/{site-id}/termStore/groups/{group-id}/sets/{set-id}/relations/{relation-id}/set"
	localVarPath = strings.Replace(localVarPath, "{"+"site-id"+"}", _neturl.PathEscape(parameterToString(r.siteId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"set-id"+"}", _neturl.PathEscape(parameterToString(r.setId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"relation-id"+"}", _neturl.PathEscape(parameterToString(r.relationId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSitesTermStoreGroupsSetsRelationsGetToTermRequest struct {
	ctx _context.Context
	ApiService *SitesStoreApiService
	siteId string
	groupId string
	setId string
	relationId string
	select_ *[]string
	expand *[]string
}

// Select properties to be returned
func (r ApiSitesTermStoreGroupsSetsRelationsGetToTermRequest) Select_(select_ []string) ApiSitesTermStoreGroupsSetsRelationsGetToTermRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiSitesTermStoreGroupsSetsRelationsGetToTermRequest) Expand(expand []string) ApiSitesTermStoreGroupsSetsRelationsGetToTermRequest {
	r.expand = &expand
	return r
}

func (r ApiSitesTermStoreGroupsSetsRelationsGetToTermRequest) Execute() (MicrosoftGraphTermStoreTerm, *_nethttp.Response, error) {
	return r.ApiService.SitesTermStoreGroupsSetsRelationsGetToTermExecute(r)
}

/*
SitesTermStoreGroupsSetsRelationsGetToTerm Get toTerm from sites

The to [term] of the relation. The term to which the relationship is defined.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param siteId key: id of site
 @param groupId key: id of group
 @param setId key: id of set
 @param relationId key: id of relation
 @return ApiSitesTermStoreGroupsSetsRelationsGetToTermRequest
*/
func (a *SitesStoreApiService) SitesTermStoreGroupsSetsRelationsGetToTerm(ctx _context.Context, siteId string, groupId string, setId string, relationId string) ApiSitesTermStoreGroupsSetsRelationsGetToTermRequest {
	return ApiSitesTermStoreGroupsSetsRelationsGetToTermRequest{
		ApiService: a,
		ctx: ctx,
		siteId: siteId,
		groupId: groupId,
		setId: setId,
		relationId: relationId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphTermStoreTerm
func (a *SitesStoreApiService) SitesTermStoreGroupsSetsRelationsGetToTermExecute(r ApiSitesTermStoreGroupsSetsRelationsGetToTermRequest) (MicrosoftGraphTermStoreTerm, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphTermStoreTerm
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SitesStoreApiService.SitesTermStoreGroupsSetsRelationsGetToTerm")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sites/{site-id}/termStore/groups/{group-id}/sets/{set-id}/relations/{relation-id}/toTerm"
	localVarPath = strings.Replace(localVarPath, "{"+"site-id"+"}", _neturl.PathEscape(parameterToString(r.siteId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"set-id"+"}", _neturl.PathEscape(parameterToString(r.setId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"relation-id"+"}", _neturl.PathEscape(parameterToString(r.relationId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSitesTermStoreGroupsSetsRelationsUpdateRefFromTermRequest struct {
	ctx _context.Context
	ApiService *SitesStoreApiService
	siteId string
	groupId string
	setId string
	relationId string
	requestBody *map[string]map[string]interface{}
}

// New navigation property ref values
func (r ApiSitesTermStoreGroupsSetsRelationsUpdateRefFromTermRequest) RequestBody(requestBody map[string]map[string]interface{}) ApiSitesTermStoreGroupsSetsRelationsUpdateRefFromTermRequest {
	r.requestBody = &requestBody
	return r
}

func (r ApiSitesTermStoreGroupsSetsRelationsUpdateRefFromTermRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.SitesTermStoreGroupsSetsRelationsUpdateRefFromTermExecute(r)
}

/*
SitesTermStoreGroupsSetsRelationsUpdateRefFromTerm Update the ref of navigation property fromTerm in sites

The from [term] of the relation. The term from which the relationship is defined. A null value would indicate the relation is directly with the [set].

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param siteId key: id of site
 @param groupId key: id of group
 @param setId key: id of set
 @param relationId key: id of relation
 @return ApiSitesTermStoreGroupsSetsRelationsUpdateRefFromTermRequest
*/
func (a *SitesStoreApiService) SitesTermStoreGroupsSetsRelationsUpdateRefFromTerm(ctx _context.Context, siteId string, groupId string, setId string, relationId string) ApiSitesTermStoreGroupsSetsRelationsUpdateRefFromTermRequest {
	return ApiSitesTermStoreGroupsSetsRelationsUpdateRefFromTermRequest{
		ApiService: a,
		ctx: ctx,
		siteId: siteId,
		groupId: groupId,
		setId: setId,
		relationId: relationId,
	}
}

// Execute executes the request
func (a *SitesStoreApiService) SitesTermStoreGroupsSetsRelationsUpdateRefFromTermExecute(r ApiSitesTermStoreGroupsSetsRelationsUpdateRefFromTermRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPut
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SitesStoreApiService.SitesTermStoreGroupsSetsRelationsUpdateRefFromTerm")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sites/{site-id}/termStore/groups/{group-id}/sets/{set-id}/relations/{relation-id}/fromTerm/$ref"
	localVarPath = strings.Replace(localVarPath, "{"+"site-id"+"}", _neturl.PathEscape(parameterToString(r.siteId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"set-id"+"}", _neturl.PathEscape(parameterToString(r.setId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"relation-id"+"}", _neturl.PathEscape(parameterToString(r.relationId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.requestBody == nil {
		return nil, reportError("requestBody is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.requestBody
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiSitesTermStoreGroupsSetsRelationsUpdateRefSetRequest struct {
	ctx _context.Context
	ApiService *SitesStoreApiService
	siteId string
	groupId string
	setId string
	relationId string
	requestBody *map[string]map[string]interface{}
}

// New navigation property ref values
func (r ApiSitesTermStoreGroupsSetsRelationsUpdateRefSetRequest) RequestBody(requestBody map[string]map[string]interface{}) ApiSitesTermStoreGroupsSetsRelationsUpdateRefSetRequest {
	r.requestBody = &requestBody
	return r
}

func (r ApiSitesTermStoreGroupsSetsRelationsUpdateRefSetRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.SitesTermStoreGroupsSetsRelationsUpdateRefSetExecute(r)
}

/*
SitesTermStoreGroupsSetsRelationsUpdateRefSet Update the ref of navigation property set in sites

The [set] in which the relation is relevant.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param siteId key: id of site
 @param groupId key: id of group
 @param setId key: id of set
 @param relationId key: id of relation
 @return ApiSitesTermStoreGroupsSetsRelationsUpdateRefSetRequest
*/
func (a *SitesStoreApiService) SitesTermStoreGroupsSetsRelationsUpdateRefSet(ctx _context.Context, siteId string, groupId string, setId string, relationId string) ApiSitesTermStoreGroupsSetsRelationsUpdateRefSetRequest {
	return ApiSitesTermStoreGroupsSetsRelationsUpdateRefSetRequest{
		ApiService: a,
		ctx: ctx,
		siteId: siteId,
		groupId: groupId,
		setId: setId,
		relationId: relationId,
	}
}

// Execute executes the request
func (a *SitesStoreApiService) SitesTermStoreGroupsSetsRelationsUpdateRefSetExecute(r ApiSitesTermStoreGroupsSetsRelationsUpdateRefSetRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPut
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SitesStoreApiService.SitesTermStoreGroupsSetsRelationsUpdateRefSet")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sites/{site-id}/termStore/groups/{group-id}/sets/{set-id}/relations/{relation-id}/set/$ref"
	localVarPath = strings.Replace(localVarPath, "{"+"site-id"+"}", _neturl.PathEscape(parameterToString(r.siteId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"set-id"+"}", _neturl.PathEscape(parameterToString(r.setId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"relation-id"+"}", _neturl.PathEscape(parameterToString(r.relationId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.requestBody == nil {
		return nil, reportError("requestBody is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.requestBody
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiSitesTermStoreGroupsSetsRelationsUpdateRefToTermRequest struct {
	ctx _context.Context
	ApiService *SitesStoreApiService
	siteId string
	groupId string
	setId string
	relationId string
	requestBody *map[string]map[string]interface{}
}

// New navigation property ref values
func (r ApiSitesTermStoreGroupsSetsRelationsUpdateRefToTermRequest) RequestBody(requestBody map[string]map[string]interface{}) ApiSitesTermStoreGroupsSetsRelationsUpdateRefToTermRequest {
	r.requestBody = &requestBody
	return r
}

func (r ApiSitesTermStoreGroupsSetsRelationsUpdateRefToTermRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.SitesTermStoreGroupsSetsRelationsUpdateRefToTermExecute(r)
}

/*
SitesTermStoreGroupsSetsRelationsUpdateRefToTerm Update the ref of navigation property toTerm in sites

The to [term] of the relation. The term to which the relationship is defined.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param siteId key: id of site
 @param groupId key: id of group
 @param setId key: id of set
 @param relationId key: id of relation
 @return ApiSitesTermStoreGroupsSetsRelationsUpdateRefToTermRequest
*/
func (a *SitesStoreApiService) SitesTermStoreGroupsSetsRelationsUpdateRefToTerm(ctx _context.Context, siteId string, groupId string, setId string, relationId string) ApiSitesTermStoreGroupsSetsRelationsUpdateRefToTermRequest {
	return ApiSitesTermStoreGroupsSetsRelationsUpdateRefToTermRequest{
		ApiService: a,
		ctx: ctx,
		siteId: siteId,
		groupId: groupId,
		setId: setId,
		relationId: relationId,
	}
}

// Execute executes the request
func (a *SitesStoreApiService) SitesTermStoreGroupsSetsRelationsUpdateRefToTermExecute(r ApiSitesTermStoreGroupsSetsRelationsUpdateRefToTermRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPut
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SitesStoreApiService.SitesTermStoreGroupsSetsRelationsUpdateRefToTerm")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sites/{site-id}/termStore/groups/{group-id}/sets/{set-id}/relations/{relation-id}/toTerm/$ref"
	localVarPath = strings.Replace(localVarPath, "{"+"site-id"+"}", _neturl.PathEscape(parameterToString(r.siteId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"set-id"+"}", _neturl.PathEscape(parameterToString(r.setId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"relation-id"+"}", _neturl.PathEscape(parameterToString(r.relationId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.requestBody == nil {
		return nil, reportError("requestBody is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.requestBody
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiSitesTermStoreGroupsSetsTermsCreateChildrenRequest struct {
	ctx _context.Context
	ApiService *SitesStoreApiService
	siteId string
	groupId string
	setId string
	termId string
	microsoftGraphTermStoreTerm *MicrosoftGraphTermStoreTerm
}

// New navigation property
func (r ApiSitesTermStoreGroupsSetsTermsCreateChildrenRequest) MicrosoftGraphTermStoreTerm(microsoftGraphTermStoreTerm MicrosoftGraphTermStoreTerm) ApiSitesTermStoreGroupsSetsTermsCreateChildrenRequest {
	r.microsoftGraphTermStoreTerm = &microsoftGraphTermStoreTerm
	return r
}

func (r ApiSitesTermStoreGroupsSetsTermsCreateChildrenRequest) Execute() (MicrosoftGraphTermStoreTerm, *_nethttp.Response, error) {
	return r.ApiService.SitesTermStoreGroupsSetsTermsCreateChildrenExecute(r)
}

/*
SitesTermStoreGroupsSetsTermsCreateChildren Create new navigation property to children for sites

Children of current term.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param siteId key: id of site
 @param groupId key: id of group
 @param setId key: id of set
 @param termId key: id of term
 @return ApiSitesTermStoreGroupsSetsTermsCreateChildrenRequest
*/
func (a *SitesStoreApiService) SitesTermStoreGroupsSetsTermsCreateChildren(ctx _context.Context, siteId string, groupId string, setId string, termId string) ApiSitesTermStoreGroupsSetsTermsCreateChildrenRequest {
	return ApiSitesTermStoreGroupsSetsTermsCreateChildrenRequest{
		ApiService: a,
		ctx: ctx,
		siteId: siteId,
		groupId: groupId,
		setId: setId,
		termId: termId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphTermStoreTerm
func (a *SitesStoreApiService) SitesTermStoreGroupsSetsTermsCreateChildrenExecute(r ApiSitesTermStoreGroupsSetsTermsCreateChildrenRequest) (MicrosoftGraphTermStoreTerm, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphTermStoreTerm
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SitesStoreApiService.SitesTermStoreGroupsSetsTermsCreateChildren")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sites/{site-id}/termStore/groups/{group-id}/sets/{set-id}/terms/{term-id}/children"
	localVarPath = strings.Replace(localVarPath, "{"+"site-id"+"}", _neturl.PathEscape(parameterToString(r.siteId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"set-id"+"}", _neturl.PathEscape(parameterToString(r.setId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"term-id"+"}", _neturl.PathEscape(parameterToString(r.termId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphTermStoreTerm == nil {
		return localVarReturnValue, nil, reportError("microsoftGraphTermStoreTerm is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphTermStoreTerm
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSitesTermStoreGroupsSetsTermsCreateRelationsRequest struct {
	ctx _context.Context
	ApiService *SitesStoreApiService
	siteId string
	groupId string
	setId string
	termId string
	microsoftGraphTermStoreRelation *MicrosoftGraphTermStoreRelation
}

// New navigation property
func (r ApiSitesTermStoreGroupsSetsTermsCreateRelationsRequest) MicrosoftGraphTermStoreRelation(microsoftGraphTermStoreRelation MicrosoftGraphTermStoreRelation) ApiSitesTermStoreGroupsSetsTermsCreateRelationsRequest {
	r.microsoftGraphTermStoreRelation = &microsoftGraphTermStoreRelation
	return r
}

func (r ApiSitesTermStoreGroupsSetsTermsCreateRelationsRequest) Execute() (MicrosoftGraphTermStoreRelation, *_nethttp.Response, error) {
	return r.ApiService.SitesTermStoreGroupsSetsTermsCreateRelationsExecute(r)
}

/*
SitesTermStoreGroupsSetsTermsCreateRelations Create new navigation property to relations for sites

To indicate which terms are related to the current term as either pinned or reused.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param siteId key: id of site
 @param groupId key: id of group
 @param setId key: id of set
 @param termId key: id of term
 @return ApiSitesTermStoreGroupsSetsTermsCreateRelationsRequest
*/
func (a *SitesStoreApiService) SitesTermStoreGroupsSetsTermsCreateRelations(ctx _context.Context, siteId string, groupId string, setId string, termId string) ApiSitesTermStoreGroupsSetsTermsCreateRelationsRequest {
	return ApiSitesTermStoreGroupsSetsTermsCreateRelationsRequest{
		ApiService: a,
		ctx: ctx,
		siteId: siteId,
		groupId: groupId,
		setId: setId,
		termId: termId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphTermStoreRelation
func (a *SitesStoreApiService) SitesTermStoreGroupsSetsTermsCreateRelationsExecute(r ApiSitesTermStoreGroupsSetsTermsCreateRelationsRequest) (MicrosoftGraphTermStoreRelation, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphTermStoreRelation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SitesStoreApiService.SitesTermStoreGroupsSetsTermsCreateRelations")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sites/{site-id}/termStore/groups/{group-id}/sets/{set-id}/terms/{term-id}/relations"
	localVarPath = strings.Replace(localVarPath, "{"+"site-id"+"}", _neturl.PathEscape(parameterToString(r.siteId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"set-id"+"}", _neturl.PathEscape(parameterToString(r.setId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"term-id"+"}", _neturl.PathEscape(parameterToString(r.termId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphTermStoreRelation == nil {
		return localVarReturnValue, nil, reportError("microsoftGraphTermStoreRelation is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphTermStoreRelation
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSitesTermStoreGroupsSetsTermsDeleteChildrenRequest struct {
	ctx _context.Context
	ApiService *SitesStoreApiService
	siteId string
	groupId string
	setId string
	termId string
	termId1 string
	ifMatch *string
}

// ETag
func (r ApiSitesTermStoreGroupsSetsTermsDeleteChildrenRequest) IfMatch(ifMatch string) ApiSitesTermStoreGroupsSetsTermsDeleteChildrenRequest {
	r.ifMatch = &ifMatch
	return r
}

func (r ApiSitesTermStoreGroupsSetsTermsDeleteChildrenRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.SitesTermStoreGroupsSetsTermsDeleteChildrenExecute(r)
}

/*
SitesTermStoreGroupsSetsTermsDeleteChildren Delete navigation property children for sites

Children of current term.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param siteId key: id of site
 @param groupId key: id of group
 @param setId key: id of set
 @param termId key: id of term
 @param termId1 key: id of term
 @return ApiSitesTermStoreGroupsSetsTermsDeleteChildrenRequest
*/
func (a *SitesStoreApiService) SitesTermStoreGroupsSetsTermsDeleteChildren(ctx _context.Context, siteId string, groupId string, setId string, termId string, termId1 string) ApiSitesTermStoreGroupsSetsTermsDeleteChildrenRequest {
	return ApiSitesTermStoreGroupsSetsTermsDeleteChildrenRequest{
		ApiService: a,
		ctx: ctx,
		siteId: siteId,
		groupId: groupId,
		setId: setId,
		termId: termId,
		termId1: termId1,
	}
}

// Execute executes the request
func (a *SitesStoreApiService) SitesTermStoreGroupsSetsTermsDeleteChildrenExecute(r ApiSitesTermStoreGroupsSetsTermsDeleteChildrenRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SitesStoreApiService.SitesTermStoreGroupsSetsTermsDeleteChildren")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sites/{site-id}/termStore/groups/{group-id}/sets/{set-id}/terms/{term-id}/children/{term-id1}"
	localVarPath = strings.Replace(localVarPath, "{"+"site-id"+"}", _neturl.PathEscape(parameterToString(r.siteId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"set-id"+"}", _neturl.PathEscape(parameterToString(r.setId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"term-id"+"}", _neturl.PathEscape(parameterToString(r.termId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"term-id1"+"}", _neturl.PathEscape(parameterToString(r.termId1, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ifMatch != nil {
		localVarHeaderParams["If-Match"] = parameterToString(*r.ifMatch, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiSitesTermStoreGroupsSetsTermsDeleteRefSetRequest struct {
	ctx _context.Context
	ApiService *SitesStoreApiService
	siteId string
	groupId string
	setId string
	termId string
	ifMatch *string
}

// ETag
func (r ApiSitesTermStoreGroupsSetsTermsDeleteRefSetRequest) IfMatch(ifMatch string) ApiSitesTermStoreGroupsSetsTermsDeleteRefSetRequest {
	r.ifMatch = &ifMatch
	return r
}

func (r ApiSitesTermStoreGroupsSetsTermsDeleteRefSetRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.SitesTermStoreGroupsSetsTermsDeleteRefSetExecute(r)
}

/*
SitesTermStoreGroupsSetsTermsDeleteRefSet Delete ref of navigation property set for sites

The [set] in which the term is created.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param siteId key: id of site
 @param groupId key: id of group
 @param setId key: id of set
 @param termId key: id of term
 @return ApiSitesTermStoreGroupsSetsTermsDeleteRefSetRequest
*/
func (a *SitesStoreApiService) SitesTermStoreGroupsSetsTermsDeleteRefSet(ctx _context.Context, siteId string, groupId string, setId string, termId string) ApiSitesTermStoreGroupsSetsTermsDeleteRefSetRequest {
	return ApiSitesTermStoreGroupsSetsTermsDeleteRefSetRequest{
		ApiService: a,
		ctx: ctx,
		siteId: siteId,
		groupId: groupId,
		setId: setId,
		termId: termId,
	}
}

// Execute executes the request
func (a *SitesStoreApiService) SitesTermStoreGroupsSetsTermsDeleteRefSetExecute(r ApiSitesTermStoreGroupsSetsTermsDeleteRefSetRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SitesStoreApiService.SitesTermStoreGroupsSetsTermsDeleteRefSet")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sites/{site-id}/termStore/groups/{group-id}/sets/{set-id}/terms/{term-id}/set/$ref"
	localVarPath = strings.Replace(localVarPath, "{"+"site-id"+"}", _neturl.PathEscape(parameterToString(r.siteId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"set-id"+"}", _neturl.PathEscape(parameterToString(r.setId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"term-id"+"}", _neturl.PathEscape(parameterToString(r.termId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ifMatch != nil {
		localVarHeaderParams["If-Match"] = parameterToString(*r.ifMatch, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiSitesTermStoreGroupsSetsTermsDeleteRelationsRequest struct {
	ctx _context.Context
	ApiService *SitesStoreApiService
	siteId string
	groupId string
	setId string
	termId string
	relationId string
	ifMatch *string
}

// ETag
func (r ApiSitesTermStoreGroupsSetsTermsDeleteRelationsRequest) IfMatch(ifMatch string) ApiSitesTermStoreGroupsSetsTermsDeleteRelationsRequest {
	r.ifMatch = &ifMatch
	return r
}

func (r ApiSitesTermStoreGroupsSetsTermsDeleteRelationsRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.SitesTermStoreGroupsSetsTermsDeleteRelationsExecute(r)
}

/*
SitesTermStoreGroupsSetsTermsDeleteRelations Delete navigation property relations for sites

To indicate which terms are related to the current term as either pinned or reused.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param siteId key: id of site
 @param groupId key: id of group
 @param setId key: id of set
 @param termId key: id of term
 @param relationId key: id of relation
 @return ApiSitesTermStoreGroupsSetsTermsDeleteRelationsRequest
*/
func (a *SitesStoreApiService) SitesTermStoreGroupsSetsTermsDeleteRelations(ctx _context.Context, siteId string, groupId string, setId string, termId string, relationId string) ApiSitesTermStoreGroupsSetsTermsDeleteRelationsRequest {
	return ApiSitesTermStoreGroupsSetsTermsDeleteRelationsRequest{
		ApiService: a,
		ctx: ctx,
		siteId: siteId,
		groupId: groupId,
		setId: setId,
		termId: termId,
		relationId: relationId,
	}
}

// Execute executes the request
func (a *SitesStoreApiService) SitesTermStoreGroupsSetsTermsDeleteRelationsExecute(r ApiSitesTermStoreGroupsSetsTermsDeleteRelationsRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SitesStoreApiService.SitesTermStoreGroupsSetsTermsDeleteRelations")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sites/{site-id}/termStore/groups/{group-id}/sets/{set-id}/terms/{term-id}/relations/{relation-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"site-id"+"}", _neturl.PathEscape(parameterToString(r.siteId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"set-id"+"}", _neturl.PathEscape(parameterToString(r.setId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"term-id"+"}", _neturl.PathEscape(parameterToString(r.termId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"relation-id"+"}", _neturl.PathEscape(parameterToString(r.relationId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ifMatch != nil {
		localVarHeaderParams["If-Match"] = parameterToString(*r.ifMatch, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiSitesTermStoreGroupsSetsTermsGetChildrenRequest struct {
	ctx _context.Context
	ApiService *SitesStoreApiService
	siteId string
	groupId string
	setId string
	termId string
	termId1 string
	select_ *[]string
	expand *[]string
}

// Select properties to be returned
func (r ApiSitesTermStoreGroupsSetsTermsGetChildrenRequest) Select_(select_ []string) ApiSitesTermStoreGroupsSetsTermsGetChildrenRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiSitesTermStoreGroupsSetsTermsGetChildrenRequest) Expand(expand []string) ApiSitesTermStoreGroupsSetsTermsGetChildrenRequest {
	r.expand = &expand
	return r
}

func (r ApiSitesTermStoreGroupsSetsTermsGetChildrenRequest) Execute() (MicrosoftGraphTermStoreTerm, *_nethttp.Response, error) {
	return r.ApiService.SitesTermStoreGroupsSetsTermsGetChildrenExecute(r)
}

/*
SitesTermStoreGroupsSetsTermsGetChildren Get children from sites

Children of current term.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param siteId key: id of site
 @param groupId key: id of group
 @param setId key: id of set
 @param termId key: id of term
 @param termId1 key: id of term
 @return ApiSitesTermStoreGroupsSetsTermsGetChildrenRequest
*/
func (a *SitesStoreApiService) SitesTermStoreGroupsSetsTermsGetChildren(ctx _context.Context, siteId string, groupId string, setId string, termId string, termId1 string) ApiSitesTermStoreGroupsSetsTermsGetChildrenRequest {
	return ApiSitesTermStoreGroupsSetsTermsGetChildrenRequest{
		ApiService: a,
		ctx: ctx,
		siteId: siteId,
		groupId: groupId,
		setId: setId,
		termId: termId,
		termId1: termId1,
	}
}

// Execute executes the request
//  @return MicrosoftGraphTermStoreTerm
func (a *SitesStoreApiService) SitesTermStoreGroupsSetsTermsGetChildrenExecute(r ApiSitesTermStoreGroupsSetsTermsGetChildrenRequest) (MicrosoftGraphTermStoreTerm, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphTermStoreTerm
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SitesStoreApiService.SitesTermStoreGroupsSetsTermsGetChildren")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sites/{site-id}/termStore/groups/{group-id}/sets/{set-id}/terms/{term-id}/children/{term-id1}"
	localVarPath = strings.Replace(localVarPath, "{"+"site-id"+"}", _neturl.PathEscape(parameterToString(r.siteId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"set-id"+"}", _neturl.PathEscape(parameterToString(r.setId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"term-id"+"}", _neturl.PathEscape(parameterToString(r.termId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"term-id1"+"}", _neturl.PathEscape(parameterToString(r.termId1, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSitesTermStoreGroupsSetsTermsGetRefSetRequest struct {
	ctx _context.Context
	ApiService *SitesStoreApiService
	siteId string
	groupId string
	setId string
	termId string
}


func (r ApiSitesTermStoreGroupsSetsTermsGetRefSetRequest) Execute() (string, *_nethttp.Response, error) {
	return r.ApiService.SitesTermStoreGroupsSetsTermsGetRefSetExecute(r)
}

/*
SitesTermStoreGroupsSetsTermsGetRefSet Get ref of set from sites

The [set] in which the term is created.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param siteId key: id of site
 @param groupId key: id of group
 @param setId key: id of set
 @param termId key: id of term
 @return ApiSitesTermStoreGroupsSetsTermsGetRefSetRequest
*/
func (a *SitesStoreApiService) SitesTermStoreGroupsSetsTermsGetRefSet(ctx _context.Context, siteId string, groupId string, setId string, termId string) ApiSitesTermStoreGroupsSetsTermsGetRefSetRequest {
	return ApiSitesTermStoreGroupsSetsTermsGetRefSetRequest{
		ApiService: a,
		ctx: ctx,
		siteId: siteId,
		groupId: groupId,
		setId: setId,
		termId: termId,
	}
}

// Execute executes the request
//  @return string
func (a *SitesStoreApiService) SitesTermStoreGroupsSetsTermsGetRefSetExecute(r ApiSitesTermStoreGroupsSetsTermsGetRefSetRequest) (string, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  string
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SitesStoreApiService.SitesTermStoreGroupsSetsTermsGetRefSet")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sites/{site-id}/termStore/groups/{group-id}/sets/{set-id}/terms/{term-id}/set/$ref"
	localVarPath = strings.Replace(localVarPath, "{"+"site-id"+"}", _neturl.PathEscape(parameterToString(r.siteId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"set-id"+"}", _neturl.PathEscape(parameterToString(r.setId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"term-id"+"}", _neturl.PathEscape(parameterToString(r.termId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSitesTermStoreGroupsSetsTermsGetRelationsRequest struct {
	ctx _context.Context
	ApiService *SitesStoreApiService
	siteId string
	groupId string
	setId string
	termId string
	relationId string
	select_ *[]string
	expand *[]string
}

// Select properties to be returned
func (r ApiSitesTermStoreGroupsSetsTermsGetRelationsRequest) Select_(select_ []string) ApiSitesTermStoreGroupsSetsTermsGetRelationsRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiSitesTermStoreGroupsSetsTermsGetRelationsRequest) Expand(expand []string) ApiSitesTermStoreGroupsSetsTermsGetRelationsRequest {
	r.expand = &expand
	return r
}

func (r ApiSitesTermStoreGroupsSetsTermsGetRelationsRequest) Execute() (MicrosoftGraphTermStoreRelation, *_nethttp.Response, error) {
	return r.ApiService.SitesTermStoreGroupsSetsTermsGetRelationsExecute(r)
}

/*
SitesTermStoreGroupsSetsTermsGetRelations Get relations from sites

To indicate which terms are related to the current term as either pinned or reused.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param siteId key: id of site
 @param groupId key: id of group
 @param setId key: id of set
 @param termId key: id of term
 @param relationId key: id of relation
 @return ApiSitesTermStoreGroupsSetsTermsGetRelationsRequest
*/
func (a *SitesStoreApiService) SitesTermStoreGroupsSetsTermsGetRelations(ctx _context.Context, siteId string, groupId string, setId string, termId string, relationId string) ApiSitesTermStoreGroupsSetsTermsGetRelationsRequest {
	return ApiSitesTermStoreGroupsSetsTermsGetRelationsRequest{
		ApiService: a,
		ctx: ctx,
		siteId: siteId,
		groupId: groupId,
		setId: setId,
		termId: termId,
		relationId: relationId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphTermStoreRelation
func (a *SitesStoreApiService) SitesTermStoreGroupsSetsTermsGetRelationsExecute(r ApiSitesTermStoreGroupsSetsTermsGetRelationsRequest) (MicrosoftGraphTermStoreRelation, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphTermStoreRelation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SitesStoreApiService.SitesTermStoreGroupsSetsTermsGetRelations")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sites/{site-id}/termStore/groups/{group-id}/sets/{set-id}/terms/{term-id}/relations/{relation-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"site-id"+"}", _neturl.PathEscape(parameterToString(r.siteId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"set-id"+"}", _neturl.PathEscape(parameterToString(r.setId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"term-id"+"}", _neturl.PathEscape(parameterToString(r.termId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"relation-id"+"}", _neturl.PathEscape(parameterToString(r.relationId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSitesTermStoreGroupsSetsTermsGetSetRequest struct {
	ctx _context.Context
	ApiService *SitesStoreApiService
	siteId string
	groupId string
	setId string
	termId string
	select_ *[]string
	expand *[]string
}

// Select properties to be returned
func (r ApiSitesTermStoreGroupsSetsTermsGetSetRequest) Select_(select_ []string) ApiSitesTermStoreGroupsSetsTermsGetSetRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiSitesTermStoreGroupsSetsTermsGetSetRequest) Expand(expand []string) ApiSitesTermStoreGroupsSetsTermsGetSetRequest {
	r.expand = &expand
	return r
}

func (r ApiSitesTermStoreGroupsSetsTermsGetSetRequest) Execute() (MicrosoftGraphTermStoreSet, *_nethttp.Response, error) {
	return r.ApiService.SitesTermStoreGroupsSetsTermsGetSetExecute(r)
}

/*
SitesTermStoreGroupsSetsTermsGetSet Get set from sites

The [set] in which the term is created.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param siteId key: id of site
 @param groupId key: id of group
 @param setId key: id of set
 @param termId key: id of term
 @return ApiSitesTermStoreGroupsSetsTermsGetSetRequest
*/
func (a *SitesStoreApiService) SitesTermStoreGroupsSetsTermsGetSet(ctx _context.Context, siteId string, groupId string, setId string, termId string) ApiSitesTermStoreGroupsSetsTermsGetSetRequest {
	return ApiSitesTermStoreGroupsSetsTermsGetSetRequest{
		ApiService: a,
		ctx: ctx,
		siteId: siteId,
		groupId: groupId,
		setId: setId,
		termId: termId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphTermStoreSet
func (a *SitesStoreApiService) SitesTermStoreGroupsSetsTermsGetSetExecute(r ApiSitesTermStoreGroupsSetsTermsGetSetRequest) (MicrosoftGraphTermStoreSet, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphTermStoreSet
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SitesStoreApiService.SitesTermStoreGroupsSetsTermsGetSet")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sites/{site-id}/termStore/groups/{group-id}/sets/{set-id}/terms/{term-id}/set"
	localVarPath = strings.Replace(localVarPath, "{"+"site-id"+"}", _neturl.PathEscape(parameterToString(r.siteId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"set-id"+"}", _neturl.PathEscape(parameterToString(r.setId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"term-id"+"}", _neturl.PathEscape(parameterToString(r.termId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSitesTermStoreGroupsSetsTermsListChildrenRequest struct {
	ctx _context.Context
	ApiService *SitesStoreApiService
	siteId string
	groupId string
	setId string
	termId string
	top *int32
	skip *int32
	search *string
	filter *string
	count *bool
	orderby *[]string
	select_ *[]string
	expand *[]string
}

// Show only the first n items
func (r ApiSitesTermStoreGroupsSetsTermsListChildrenRequest) Top(top int32) ApiSitesTermStoreGroupsSetsTermsListChildrenRequest {
	r.top = &top
	return r
}
// Skip the first n items
func (r ApiSitesTermStoreGroupsSetsTermsListChildrenRequest) Skip(skip int32) ApiSitesTermStoreGroupsSetsTermsListChildrenRequest {
	r.skip = &skip
	return r
}
// Search items by search phrases
func (r ApiSitesTermStoreGroupsSetsTermsListChildrenRequest) Search(search string) ApiSitesTermStoreGroupsSetsTermsListChildrenRequest {
	r.search = &search
	return r
}
// Filter items by property values
func (r ApiSitesTermStoreGroupsSetsTermsListChildrenRequest) Filter(filter string) ApiSitesTermStoreGroupsSetsTermsListChildrenRequest {
	r.filter = &filter
	return r
}
// Include count of items
func (r ApiSitesTermStoreGroupsSetsTermsListChildrenRequest) Count(count bool) ApiSitesTermStoreGroupsSetsTermsListChildrenRequest {
	r.count = &count
	return r
}
// Order items by property values
func (r ApiSitesTermStoreGroupsSetsTermsListChildrenRequest) Orderby(orderby []string) ApiSitesTermStoreGroupsSetsTermsListChildrenRequest {
	r.orderby = &orderby
	return r
}
// Select properties to be returned
func (r ApiSitesTermStoreGroupsSetsTermsListChildrenRequest) Select_(select_ []string) ApiSitesTermStoreGroupsSetsTermsListChildrenRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiSitesTermStoreGroupsSetsTermsListChildrenRequest) Expand(expand []string) ApiSitesTermStoreGroupsSetsTermsListChildrenRequest {
	r.expand = &expand
	return r
}

func (r ApiSitesTermStoreGroupsSetsTermsListChildrenRequest) Execute() (CollectionOfTerm, *_nethttp.Response, error) {
	return r.ApiService.SitesTermStoreGroupsSetsTermsListChildrenExecute(r)
}

/*
SitesTermStoreGroupsSetsTermsListChildren Get children from sites

Children of current term.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param siteId key: id of site
 @param groupId key: id of group
 @param setId key: id of set
 @param termId key: id of term
 @return ApiSitesTermStoreGroupsSetsTermsListChildrenRequest
*/
func (a *SitesStoreApiService) SitesTermStoreGroupsSetsTermsListChildren(ctx _context.Context, siteId string, groupId string, setId string, termId string) ApiSitesTermStoreGroupsSetsTermsListChildrenRequest {
	return ApiSitesTermStoreGroupsSetsTermsListChildrenRequest{
		ApiService: a,
		ctx: ctx,
		siteId: siteId,
		groupId: groupId,
		setId: setId,
		termId: termId,
	}
}

// Execute executes the request
//  @return CollectionOfTerm
func (a *SitesStoreApiService) SitesTermStoreGroupsSetsTermsListChildrenExecute(r ApiSitesTermStoreGroupsSetsTermsListChildrenRequest) (CollectionOfTerm, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  CollectionOfTerm
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SitesStoreApiService.SitesTermStoreGroupsSetsTermsListChildren")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sites/{site-id}/termStore/groups/{group-id}/sets/{set-id}/terms/{term-id}/children"
	localVarPath = strings.Replace(localVarPath, "{"+"site-id"+"}", _neturl.PathEscape(parameterToString(r.siteId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"set-id"+"}", _neturl.PathEscape(parameterToString(r.setId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"term-id"+"}", _neturl.PathEscape(parameterToString(r.termId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.top != nil {
		localVarQueryParams.Add("$top", parameterToString(*r.top, ""))
	}
	if r.skip != nil {
		localVarQueryParams.Add("$skip", parameterToString(*r.skip, ""))
	}
	if r.search != nil {
		localVarQueryParams.Add("$search", parameterToString(*r.search, ""))
	}
	if r.filter != nil {
		localVarQueryParams.Add("$filter", parameterToString(*r.filter, ""))
	}
	if r.count != nil {
		localVarQueryParams.Add("$count", parameterToString(*r.count, ""))
	}
	if r.orderby != nil {
		localVarQueryParams.Add("$orderby", parameterToString(*r.orderby, "csv"))
	}
	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSitesTermStoreGroupsSetsTermsListRelationsRequest struct {
	ctx _context.Context
	ApiService *SitesStoreApiService
	siteId string
	groupId string
	setId string
	termId string
	top *int32
	skip *int32
	search *string
	filter *string
	count *bool
	orderby *[]string
	select_ *[]string
	expand *[]string
}

// Show only the first n items
func (r ApiSitesTermStoreGroupsSetsTermsListRelationsRequest) Top(top int32) ApiSitesTermStoreGroupsSetsTermsListRelationsRequest {
	r.top = &top
	return r
}
// Skip the first n items
func (r ApiSitesTermStoreGroupsSetsTermsListRelationsRequest) Skip(skip int32) ApiSitesTermStoreGroupsSetsTermsListRelationsRequest {
	r.skip = &skip
	return r
}
// Search items by search phrases
func (r ApiSitesTermStoreGroupsSetsTermsListRelationsRequest) Search(search string) ApiSitesTermStoreGroupsSetsTermsListRelationsRequest {
	r.search = &search
	return r
}
// Filter items by property values
func (r ApiSitesTermStoreGroupsSetsTermsListRelationsRequest) Filter(filter string) ApiSitesTermStoreGroupsSetsTermsListRelationsRequest {
	r.filter = &filter
	return r
}
// Include count of items
func (r ApiSitesTermStoreGroupsSetsTermsListRelationsRequest) Count(count bool) ApiSitesTermStoreGroupsSetsTermsListRelationsRequest {
	r.count = &count
	return r
}
// Order items by property values
func (r ApiSitesTermStoreGroupsSetsTermsListRelationsRequest) Orderby(orderby []string) ApiSitesTermStoreGroupsSetsTermsListRelationsRequest {
	r.orderby = &orderby
	return r
}
// Select properties to be returned
func (r ApiSitesTermStoreGroupsSetsTermsListRelationsRequest) Select_(select_ []string) ApiSitesTermStoreGroupsSetsTermsListRelationsRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiSitesTermStoreGroupsSetsTermsListRelationsRequest) Expand(expand []string) ApiSitesTermStoreGroupsSetsTermsListRelationsRequest {
	r.expand = &expand
	return r
}

func (r ApiSitesTermStoreGroupsSetsTermsListRelationsRequest) Execute() (CollectionOfRelation, *_nethttp.Response, error) {
	return r.ApiService.SitesTermStoreGroupsSetsTermsListRelationsExecute(r)
}

/*
SitesTermStoreGroupsSetsTermsListRelations Get relations from sites

To indicate which terms are related to the current term as either pinned or reused.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param siteId key: id of site
 @param groupId key: id of group
 @param setId key: id of set
 @param termId key: id of term
 @return ApiSitesTermStoreGroupsSetsTermsListRelationsRequest
*/
func (a *SitesStoreApiService) SitesTermStoreGroupsSetsTermsListRelations(ctx _context.Context, siteId string, groupId string, setId string, termId string) ApiSitesTermStoreGroupsSetsTermsListRelationsRequest {
	return ApiSitesTermStoreGroupsSetsTermsListRelationsRequest{
		ApiService: a,
		ctx: ctx,
		siteId: siteId,
		groupId: groupId,
		setId: setId,
		termId: termId,
	}
}

// Execute executes the request
//  @return CollectionOfRelation
func (a *SitesStoreApiService) SitesTermStoreGroupsSetsTermsListRelationsExecute(r ApiSitesTermStoreGroupsSetsTermsListRelationsRequest) (CollectionOfRelation, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  CollectionOfRelation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SitesStoreApiService.SitesTermStoreGroupsSetsTermsListRelations")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sites/{site-id}/termStore/groups/{group-id}/sets/{set-id}/terms/{term-id}/relations"
	localVarPath = strings.Replace(localVarPath, "{"+"site-id"+"}", _neturl.PathEscape(parameterToString(r.siteId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"set-id"+"}", _neturl.PathEscape(parameterToString(r.setId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"term-id"+"}", _neturl.PathEscape(parameterToString(r.termId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.top != nil {
		localVarQueryParams.Add("$top", parameterToString(*r.top, ""))
	}
	if r.skip != nil {
		localVarQueryParams.Add("$skip", parameterToString(*r.skip, ""))
	}
	if r.search != nil {
		localVarQueryParams.Add("$search", parameterToString(*r.search, ""))
	}
	if r.filter != nil {
		localVarQueryParams.Add("$filter", parameterToString(*r.filter, ""))
	}
	if r.count != nil {
		localVarQueryParams.Add("$count", parameterToString(*r.count, ""))
	}
	if r.orderby != nil {
		localVarQueryParams.Add("$orderby", parameterToString(*r.orderby, "csv"))
	}
	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSitesTermStoreGroupsSetsTermsRelationsDeleteRefFromTermRequest struct {
	ctx _context.Context
	ApiService *SitesStoreApiService
	siteId string
	groupId string
	setId string
	termId string
	relationId string
	ifMatch *string
}

// ETag
func (r ApiSitesTermStoreGroupsSetsTermsRelationsDeleteRefFromTermRequest) IfMatch(ifMatch string) ApiSitesTermStoreGroupsSetsTermsRelationsDeleteRefFromTermRequest {
	r.ifMatch = &ifMatch
	return r
}

func (r ApiSitesTermStoreGroupsSetsTermsRelationsDeleteRefFromTermRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.SitesTermStoreGroupsSetsTermsRelationsDeleteRefFromTermExecute(r)
}

/*
SitesTermStoreGroupsSetsTermsRelationsDeleteRefFromTerm Delete ref of navigation property fromTerm for sites

The from [term] of the relation. The term from which the relationship is defined. A null value would indicate the relation is directly with the [set].

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param siteId key: id of site
 @param groupId key: id of group
 @param setId key: id of set
 @param termId key: id of term
 @param relationId key: id of relation
 @return ApiSitesTermStoreGroupsSetsTermsRelationsDeleteRefFromTermRequest
*/
func (a *SitesStoreApiService) SitesTermStoreGroupsSetsTermsRelationsDeleteRefFromTerm(ctx _context.Context, siteId string, groupId string, setId string, termId string, relationId string) ApiSitesTermStoreGroupsSetsTermsRelationsDeleteRefFromTermRequest {
	return ApiSitesTermStoreGroupsSetsTermsRelationsDeleteRefFromTermRequest{
		ApiService: a,
		ctx: ctx,
		siteId: siteId,
		groupId: groupId,
		setId: setId,
		termId: termId,
		relationId: relationId,
	}
}

// Execute executes the request
func (a *SitesStoreApiService) SitesTermStoreGroupsSetsTermsRelationsDeleteRefFromTermExecute(r ApiSitesTermStoreGroupsSetsTermsRelationsDeleteRefFromTermRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SitesStoreApiService.SitesTermStoreGroupsSetsTermsRelationsDeleteRefFromTerm")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sites/{site-id}/termStore/groups/{group-id}/sets/{set-id}/terms/{term-id}/relations/{relation-id}/fromTerm/$ref"
	localVarPath = strings.Replace(localVarPath, "{"+"site-id"+"}", _neturl.PathEscape(parameterToString(r.siteId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"set-id"+"}", _neturl.PathEscape(parameterToString(r.setId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"term-id"+"}", _neturl.PathEscape(parameterToString(r.termId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"relation-id"+"}", _neturl.PathEscape(parameterToString(r.relationId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ifMatch != nil {
		localVarHeaderParams["If-Match"] = parameterToString(*r.ifMatch, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiSitesTermStoreGroupsSetsTermsRelationsDeleteRefSetRequest struct {
	ctx _context.Context
	ApiService *SitesStoreApiService
	siteId string
	groupId string
	setId string
	termId string
	relationId string
	ifMatch *string
}

// ETag
func (r ApiSitesTermStoreGroupsSetsTermsRelationsDeleteRefSetRequest) IfMatch(ifMatch string) ApiSitesTermStoreGroupsSetsTermsRelationsDeleteRefSetRequest {
	r.ifMatch = &ifMatch
	return r
}

func (r ApiSitesTermStoreGroupsSetsTermsRelationsDeleteRefSetRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.SitesTermStoreGroupsSetsTermsRelationsDeleteRefSetExecute(r)
}

/*
SitesTermStoreGroupsSetsTermsRelationsDeleteRefSet Delete ref of navigation property set for sites

The [set] in which the relation is relevant.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param siteId key: id of site
 @param groupId key: id of group
 @param setId key: id of set
 @param termId key: id of term
 @param relationId key: id of relation
 @return ApiSitesTermStoreGroupsSetsTermsRelationsDeleteRefSetRequest
*/
func (a *SitesStoreApiService) SitesTermStoreGroupsSetsTermsRelationsDeleteRefSet(ctx _context.Context, siteId string, groupId string, setId string, termId string, relationId string) ApiSitesTermStoreGroupsSetsTermsRelationsDeleteRefSetRequest {
	return ApiSitesTermStoreGroupsSetsTermsRelationsDeleteRefSetRequest{
		ApiService: a,
		ctx: ctx,
		siteId: siteId,
		groupId: groupId,
		setId: setId,
		termId: termId,
		relationId: relationId,
	}
}

// Execute executes the request
func (a *SitesStoreApiService) SitesTermStoreGroupsSetsTermsRelationsDeleteRefSetExecute(r ApiSitesTermStoreGroupsSetsTermsRelationsDeleteRefSetRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SitesStoreApiService.SitesTermStoreGroupsSetsTermsRelationsDeleteRefSet")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sites/{site-id}/termStore/groups/{group-id}/sets/{set-id}/terms/{term-id}/relations/{relation-id}/set/$ref"
	localVarPath = strings.Replace(localVarPath, "{"+"site-id"+"}", _neturl.PathEscape(parameterToString(r.siteId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"set-id"+"}", _neturl.PathEscape(parameterToString(r.setId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"term-id"+"}", _neturl.PathEscape(parameterToString(r.termId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"relation-id"+"}", _neturl.PathEscape(parameterToString(r.relationId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ifMatch != nil {
		localVarHeaderParams["If-Match"] = parameterToString(*r.ifMatch, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiSitesTermStoreGroupsSetsTermsRelationsDeleteRefToTermRequest struct {
	ctx _context.Context
	ApiService *SitesStoreApiService
	siteId string
	groupId string
	setId string
	termId string
	relationId string
	ifMatch *string
}

// ETag
func (r ApiSitesTermStoreGroupsSetsTermsRelationsDeleteRefToTermRequest) IfMatch(ifMatch string) ApiSitesTermStoreGroupsSetsTermsRelationsDeleteRefToTermRequest {
	r.ifMatch = &ifMatch
	return r
}

func (r ApiSitesTermStoreGroupsSetsTermsRelationsDeleteRefToTermRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.SitesTermStoreGroupsSetsTermsRelationsDeleteRefToTermExecute(r)
}

/*
SitesTermStoreGroupsSetsTermsRelationsDeleteRefToTerm Delete ref of navigation property toTerm for sites

The to [term] of the relation. The term to which the relationship is defined.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param siteId key: id of site
 @param groupId key: id of group
 @param setId key: id of set
 @param termId key: id of term
 @param relationId key: id of relation
 @return ApiSitesTermStoreGroupsSetsTermsRelationsDeleteRefToTermRequest
*/
func (a *SitesStoreApiService) SitesTermStoreGroupsSetsTermsRelationsDeleteRefToTerm(ctx _context.Context, siteId string, groupId string, setId string, termId string, relationId string) ApiSitesTermStoreGroupsSetsTermsRelationsDeleteRefToTermRequest {
	return ApiSitesTermStoreGroupsSetsTermsRelationsDeleteRefToTermRequest{
		ApiService: a,
		ctx: ctx,
		siteId: siteId,
		groupId: groupId,
		setId: setId,
		termId: termId,
		relationId: relationId,
	}
}

// Execute executes the request
func (a *SitesStoreApiService) SitesTermStoreGroupsSetsTermsRelationsDeleteRefToTermExecute(r ApiSitesTermStoreGroupsSetsTermsRelationsDeleteRefToTermRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SitesStoreApiService.SitesTermStoreGroupsSetsTermsRelationsDeleteRefToTerm")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sites/{site-id}/termStore/groups/{group-id}/sets/{set-id}/terms/{term-id}/relations/{relation-id}/toTerm/$ref"
	localVarPath = strings.Replace(localVarPath, "{"+"site-id"+"}", _neturl.PathEscape(parameterToString(r.siteId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"set-id"+"}", _neturl.PathEscape(parameterToString(r.setId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"term-id"+"}", _neturl.PathEscape(parameterToString(r.termId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"relation-id"+"}", _neturl.PathEscape(parameterToString(r.relationId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ifMatch != nil {
		localVarHeaderParams["If-Match"] = parameterToString(*r.ifMatch, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiSitesTermStoreGroupsSetsTermsRelationsGetFromTermRequest struct {
	ctx _context.Context
	ApiService *SitesStoreApiService
	siteId string
	groupId string
	setId string
	termId string
	relationId string
	select_ *[]string
	expand *[]string
}

// Select properties to be returned
func (r ApiSitesTermStoreGroupsSetsTermsRelationsGetFromTermRequest) Select_(select_ []string) ApiSitesTermStoreGroupsSetsTermsRelationsGetFromTermRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiSitesTermStoreGroupsSetsTermsRelationsGetFromTermRequest) Expand(expand []string) ApiSitesTermStoreGroupsSetsTermsRelationsGetFromTermRequest {
	r.expand = &expand
	return r
}

func (r ApiSitesTermStoreGroupsSetsTermsRelationsGetFromTermRequest) Execute() (MicrosoftGraphTermStoreTerm, *_nethttp.Response, error) {
	return r.ApiService.SitesTermStoreGroupsSetsTermsRelationsGetFromTermExecute(r)
}

/*
SitesTermStoreGroupsSetsTermsRelationsGetFromTerm Get fromTerm from sites

The from [term] of the relation. The term from which the relationship is defined. A null value would indicate the relation is directly with the [set].

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param siteId key: id of site
 @param groupId key: id of group
 @param setId key: id of set
 @param termId key: id of term
 @param relationId key: id of relation
 @return ApiSitesTermStoreGroupsSetsTermsRelationsGetFromTermRequest
*/
func (a *SitesStoreApiService) SitesTermStoreGroupsSetsTermsRelationsGetFromTerm(ctx _context.Context, siteId string, groupId string, setId string, termId string, relationId string) ApiSitesTermStoreGroupsSetsTermsRelationsGetFromTermRequest {
	return ApiSitesTermStoreGroupsSetsTermsRelationsGetFromTermRequest{
		ApiService: a,
		ctx: ctx,
		siteId: siteId,
		groupId: groupId,
		setId: setId,
		termId: termId,
		relationId: relationId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphTermStoreTerm
func (a *SitesStoreApiService) SitesTermStoreGroupsSetsTermsRelationsGetFromTermExecute(r ApiSitesTermStoreGroupsSetsTermsRelationsGetFromTermRequest) (MicrosoftGraphTermStoreTerm, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphTermStoreTerm
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SitesStoreApiService.SitesTermStoreGroupsSetsTermsRelationsGetFromTerm")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sites/{site-id}/termStore/groups/{group-id}/sets/{set-id}/terms/{term-id}/relations/{relation-id}/fromTerm"
	localVarPath = strings.Replace(localVarPath, "{"+"site-id"+"}", _neturl.PathEscape(parameterToString(r.siteId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"set-id"+"}", _neturl.PathEscape(parameterToString(r.setId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"term-id"+"}", _neturl.PathEscape(parameterToString(r.termId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"relation-id"+"}", _neturl.PathEscape(parameterToString(r.relationId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSitesTermStoreGroupsSetsTermsRelationsGetRefFromTermRequest struct {
	ctx _context.Context
	ApiService *SitesStoreApiService
	siteId string
	groupId string
	setId string
	termId string
	relationId string
}


func (r ApiSitesTermStoreGroupsSetsTermsRelationsGetRefFromTermRequest) Execute() (string, *_nethttp.Response, error) {
	return r.ApiService.SitesTermStoreGroupsSetsTermsRelationsGetRefFromTermExecute(r)
}

/*
SitesTermStoreGroupsSetsTermsRelationsGetRefFromTerm Get ref of fromTerm from sites

The from [term] of the relation. The term from which the relationship is defined. A null value would indicate the relation is directly with the [set].

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param siteId key: id of site
 @param groupId key: id of group
 @param setId key: id of set
 @param termId key: id of term
 @param relationId key: id of relation
 @return ApiSitesTermStoreGroupsSetsTermsRelationsGetRefFromTermRequest
*/
func (a *SitesStoreApiService) SitesTermStoreGroupsSetsTermsRelationsGetRefFromTerm(ctx _context.Context, siteId string, groupId string, setId string, termId string, relationId string) ApiSitesTermStoreGroupsSetsTermsRelationsGetRefFromTermRequest {
	return ApiSitesTermStoreGroupsSetsTermsRelationsGetRefFromTermRequest{
		ApiService: a,
		ctx: ctx,
		siteId: siteId,
		groupId: groupId,
		setId: setId,
		termId: termId,
		relationId: relationId,
	}
}

// Execute executes the request
//  @return string
func (a *SitesStoreApiService) SitesTermStoreGroupsSetsTermsRelationsGetRefFromTermExecute(r ApiSitesTermStoreGroupsSetsTermsRelationsGetRefFromTermRequest) (string, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  string
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SitesStoreApiService.SitesTermStoreGroupsSetsTermsRelationsGetRefFromTerm")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sites/{site-id}/termStore/groups/{group-id}/sets/{set-id}/terms/{term-id}/relations/{relation-id}/fromTerm/$ref"
	localVarPath = strings.Replace(localVarPath, "{"+"site-id"+"}", _neturl.PathEscape(parameterToString(r.siteId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"set-id"+"}", _neturl.PathEscape(parameterToString(r.setId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"term-id"+"}", _neturl.PathEscape(parameterToString(r.termId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"relation-id"+"}", _neturl.PathEscape(parameterToString(r.relationId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSitesTermStoreGroupsSetsTermsRelationsGetRefSetRequest struct {
	ctx _context.Context
	ApiService *SitesStoreApiService
	siteId string
	groupId string
	setId string
	termId string
	relationId string
}


func (r ApiSitesTermStoreGroupsSetsTermsRelationsGetRefSetRequest) Execute() (string, *_nethttp.Response, error) {
	return r.ApiService.SitesTermStoreGroupsSetsTermsRelationsGetRefSetExecute(r)
}

/*
SitesTermStoreGroupsSetsTermsRelationsGetRefSet Get ref of set from sites

The [set] in which the relation is relevant.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param siteId key: id of site
 @param groupId key: id of group
 @param setId key: id of set
 @param termId key: id of term
 @param relationId key: id of relation
 @return ApiSitesTermStoreGroupsSetsTermsRelationsGetRefSetRequest
*/
func (a *SitesStoreApiService) SitesTermStoreGroupsSetsTermsRelationsGetRefSet(ctx _context.Context, siteId string, groupId string, setId string, termId string, relationId string) ApiSitesTermStoreGroupsSetsTermsRelationsGetRefSetRequest {
	return ApiSitesTermStoreGroupsSetsTermsRelationsGetRefSetRequest{
		ApiService: a,
		ctx: ctx,
		siteId: siteId,
		groupId: groupId,
		setId: setId,
		termId: termId,
		relationId: relationId,
	}
}

// Execute executes the request
//  @return string
func (a *SitesStoreApiService) SitesTermStoreGroupsSetsTermsRelationsGetRefSetExecute(r ApiSitesTermStoreGroupsSetsTermsRelationsGetRefSetRequest) (string, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  string
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SitesStoreApiService.SitesTermStoreGroupsSetsTermsRelationsGetRefSet")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sites/{site-id}/termStore/groups/{group-id}/sets/{set-id}/terms/{term-id}/relations/{relation-id}/set/$ref"
	localVarPath = strings.Replace(localVarPath, "{"+"site-id"+"}", _neturl.PathEscape(parameterToString(r.siteId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"set-id"+"}", _neturl.PathEscape(parameterToString(r.setId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"term-id"+"}", _neturl.PathEscape(parameterToString(r.termId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"relation-id"+"}", _neturl.PathEscape(parameterToString(r.relationId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSitesTermStoreGroupsSetsTermsRelationsGetRefToTermRequest struct {
	ctx _context.Context
	ApiService *SitesStoreApiService
	siteId string
	groupId string
	setId string
	termId string
	relationId string
}


func (r ApiSitesTermStoreGroupsSetsTermsRelationsGetRefToTermRequest) Execute() (string, *_nethttp.Response, error) {
	return r.ApiService.SitesTermStoreGroupsSetsTermsRelationsGetRefToTermExecute(r)
}

/*
SitesTermStoreGroupsSetsTermsRelationsGetRefToTerm Get ref of toTerm from sites

The to [term] of the relation. The term to which the relationship is defined.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param siteId key: id of site
 @param groupId key: id of group
 @param setId key: id of set
 @param termId key: id of term
 @param relationId key: id of relation
 @return ApiSitesTermStoreGroupsSetsTermsRelationsGetRefToTermRequest
*/
func (a *SitesStoreApiService) SitesTermStoreGroupsSetsTermsRelationsGetRefToTerm(ctx _context.Context, siteId string, groupId string, setId string, termId string, relationId string) ApiSitesTermStoreGroupsSetsTermsRelationsGetRefToTermRequest {
	return ApiSitesTermStoreGroupsSetsTermsRelationsGetRefToTermRequest{
		ApiService: a,
		ctx: ctx,
		siteId: siteId,
		groupId: groupId,
		setId: setId,
		termId: termId,
		relationId: relationId,
	}
}

// Execute executes the request
//  @return string
func (a *SitesStoreApiService) SitesTermStoreGroupsSetsTermsRelationsGetRefToTermExecute(r ApiSitesTermStoreGroupsSetsTermsRelationsGetRefToTermRequest) (string, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  string
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SitesStoreApiService.SitesTermStoreGroupsSetsTermsRelationsGetRefToTerm")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sites/{site-id}/termStore/groups/{group-id}/sets/{set-id}/terms/{term-id}/relations/{relation-id}/toTerm/$ref"
	localVarPath = strings.Replace(localVarPath, "{"+"site-id"+"}", _neturl.PathEscape(parameterToString(r.siteId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"set-id"+"}", _neturl.PathEscape(parameterToString(r.setId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"term-id"+"}", _neturl.PathEscape(parameterToString(r.termId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"relation-id"+"}", _neturl.PathEscape(parameterToString(r.relationId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSitesTermStoreGroupsSetsTermsRelationsGetSetRequest struct {
	ctx _context.Context
	ApiService *SitesStoreApiService
	siteId string
	groupId string
	setId string
	termId string
	relationId string
	select_ *[]string
	expand *[]string
}

// Select properties to be returned
func (r ApiSitesTermStoreGroupsSetsTermsRelationsGetSetRequest) Select_(select_ []string) ApiSitesTermStoreGroupsSetsTermsRelationsGetSetRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiSitesTermStoreGroupsSetsTermsRelationsGetSetRequest) Expand(expand []string) ApiSitesTermStoreGroupsSetsTermsRelationsGetSetRequest {
	r.expand = &expand
	return r
}

func (r ApiSitesTermStoreGroupsSetsTermsRelationsGetSetRequest) Execute() (MicrosoftGraphTermStoreSet, *_nethttp.Response, error) {
	return r.ApiService.SitesTermStoreGroupsSetsTermsRelationsGetSetExecute(r)
}

/*
SitesTermStoreGroupsSetsTermsRelationsGetSet Get set from sites

The [set] in which the relation is relevant.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param siteId key: id of site
 @param groupId key: id of group
 @param setId key: id of set
 @param termId key: id of term
 @param relationId key: id of relation
 @return ApiSitesTermStoreGroupsSetsTermsRelationsGetSetRequest
*/
func (a *SitesStoreApiService) SitesTermStoreGroupsSetsTermsRelationsGetSet(ctx _context.Context, siteId string, groupId string, setId string, termId string, relationId string) ApiSitesTermStoreGroupsSetsTermsRelationsGetSetRequest {
	return ApiSitesTermStoreGroupsSetsTermsRelationsGetSetRequest{
		ApiService: a,
		ctx: ctx,
		siteId: siteId,
		groupId: groupId,
		setId: setId,
		termId: termId,
		relationId: relationId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphTermStoreSet
func (a *SitesStoreApiService) SitesTermStoreGroupsSetsTermsRelationsGetSetExecute(r ApiSitesTermStoreGroupsSetsTermsRelationsGetSetRequest) (MicrosoftGraphTermStoreSet, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphTermStoreSet
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SitesStoreApiService.SitesTermStoreGroupsSetsTermsRelationsGetSet")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sites/{site-id}/termStore/groups/{group-id}/sets/{set-id}/terms/{term-id}/relations/{relation-id}/set"
	localVarPath = strings.Replace(localVarPath, "{"+"site-id"+"}", _neturl.PathEscape(parameterToString(r.siteId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"set-id"+"}", _neturl.PathEscape(parameterToString(r.setId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"term-id"+"}", _neturl.PathEscape(parameterToString(r.termId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"relation-id"+"}", _neturl.PathEscape(parameterToString(r.relationId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSitesTermStoreGroupsSetsTermsRelationsGetToTermRequest struct {
	ctx _context.Context
	ApiService *SitesStoreApiService
	siteId string
	groupId string
	setId string
	termId string
	relationId string
	select_ *[]string
	expand *[]string
}

// Select properties to be returned
func (r ApiSitesTermStoreGroupsSetsTermsRelationsGetToTermRequest) Select_(select_ []string) ApiSitesTermStoreGroupsSetsTermsRelationsGetToTermRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiSitesTermStoreGroupsSetsTermsRelationsGetToTermRequest) Expand(expand []string) ApiSitesTermStoreGroupsSetsTermsRelationsGetToTermRequest {
	r.expand = &expand
	return r
}

func (r ApiSitesTermStoreGroupsSetsTermsRelationsGetToTermRequest) Execute() (MicrosoftGraphTermStoreTerm, *_nethttp.Response, error) {
	return r.ApiService.SitesTermStoreGroupsSetsTermsRelationsGetToTermExecute(r)
}

/*
SitesTermStoreGroupsSetsTermsRelationsGetToTerm Get toTerm from sites

The to [term] of the relation. The term to which the relationship is defined.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param siteId key: id of site
 @param groupId key: id of group
 @param setId key: id of set
 @param termId key: id of term
 @param relationId key: id of relation
 @return ApiSitesTermStoreGroupsSetsTermsRelationsGetToTermRequest
*/
func (a *SitesStoreApiService) SitesTermStoreGroupsSetsTermsRelationsGetToTerm(ctx _context.Context, siteId string, groupId string, setId string, termId string, relationId string) ApiSitesTermStoreGroupsSetsTermsRelationsGetToTermRequest {
	return ApiSitesTermStoreGroupsSetsTermsRelationsGetToTermRequest{
		ApiService: a,
		ctx: ctx,
		siteId: siteId,
		groupId: groupId,
		setId: setId,
		termId: termId,
		relationId: relationId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphTermStoreTerm
func (a *SitesStoreApiService) SitesTermStoreGroupsSetsTermsRelationsGetToTermExecute(r ApiSitesTermStoreGroupsSetsTermsRelationsGetToTermRequest) (MicrosoftGraphTermStoreTerm, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphTermStoreTerm
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SitesStoreApiService.SitesTermStoreGroupsSetsTermsRelationsGetToTerm")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sites/{site-id}/termStore/groups/{group-id}/sets/{set-id}/terms/{term-id}/relations/{relation-id}/toTerm"
	localVarPath = strings.Replace(localVarPath, "{"+"site-id"+"}", _neturl.PathEscape(parameterToString(r.siteId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"set-id"+"}", _neturl.PathEscape(parameterToString(r.setId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"term-id"+"}", _neturl.PathEscape(parameterToString(r.termId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"relation-id"+"}", _neturl.PathEscape(parameterToString(r.relationId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSitesTermStoreGroupsSetsTermsRelationsUpdateRefFromTermRequest struct {
	ctx _context.Context
	ApiService *SitesStoreApiService
	siteId string
	groupId string
	setId string
	termId string
	relationId string
	requestBody *map[string]map[string]interface{}
}

// New navigation property ref values
func (r ApiSitesTermStoreGroupsSetsTermsRelationsUpdateRefFromTermRequest) RequestBody(requestBody map[string]map[string]interface{}) ApiSitesTermStoreGroupsSetsTermsRelationsUpdateRefFromTermRequest {
	r.requestBody = &requestBody
	return r
}

func (r ApiSitesTermStoreGroupsSetsTermsRelationsUpdateRefFromTermRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.SitesTermStoreGroupsSetsTermsRelationsUpdateRefFromTermExecute(r)
}

/*
SitesTermStoreGroupsSetsTermsRelationsUpdateRefFromTerm Update the ref of navigation property fromTerm in sites

The from [term] of the relation. The term from which the relationship is defined. A null value would indicate the relation is directly with the [set].

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param siteId key: id of site
 @param groupId key: id of group
 @param setId key: id of set
 @param termId key: id of term
 @param relationId key: id of relation
 @return ApiSitesTermStoreGroupsSetsTermsRelationsUpdateRefFromTermRequest
*/
func (a *SitesStoreApiService) SitesTermStoreGroupsSetsTermsRelationsUpdateRefFromTerm(ctx _context.Context, siteId string, groupId string, setId string, termId string, relationId string) ApiSitesTermStoreGroupsSetsTermsRelationsUpdateRefFromTermRequest {
	return ApiSitesTermStoreGroupsSetsTermsRelationsUpdateRefFromTermRequest{
		ApiService: a,
		ctx: ctx,
		siteId: siteId,
		groupId: groupId,
		setId: setId,
		termId: termId,
		relationId: relationId,
	}
}

// Execute executes the request
func (a *SitesStoreApiService) SitesTermStoreGroupsSetsTermsRelationsUpdateRefFromTermExecute(r ApiSitesTermStoreGroupsSetsTermsRelationsUpdateRefFromTermRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPut
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SitesStoreApiService.SitesTermStoreGroupsSetsTermsRelationsUpdateRefFromTerm")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sites/{site-id}/termStore/groups/{group-id}/sets/{set-id}/terms/{term-id}/relations/{relation-id}/fromTerm/$ref"
	localVarPath = strings.Replace(localVarPath, "{"+"site-id"+"}", _neturl.PathEscape(parameterToString(r.siteId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"set-id"+"}", _neturl.PathEscape(parameterToString(r.setId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"term-id"+"}", _neturl.PathEscape(parameterToString(r.termId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"relation-id"+"}", _neturl.PathEscape(parameterToString(r.relationId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.requestBody == nil {
		return nil, reportError("requestBody is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.requestBody
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiSitesTermStoreGroupsSetsTermsRelationsUpdateRefSetRequest struct {
	ctx _context.Context
	ApiService *SitesStoreApiService
	siteId string
	groupId string
	setId string
	termId string
	relationId string
	requestBody *map[string]map[string]interface{}
}

// New navigation property ref values
func (r ApiSitesTermStoreGroupsSetsTermsRelationsUpdateRefSetRequest) RequestBody(requestBody map[string]map[string]interface{}) ApiSitesTermStoreGroupsSetsTermsRelationsUpdateRefSetRequest {
	r.requestBody = &requestBody
	return r
}

func (r ApiSitesTermStoreGroupsSetsTermsRelationsUpdateRefSetRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.SitesTermStoreGroupsSetsTermsRelationsUpdateRefSetExecute(r)
}

/*
SitesTermStoreGroupsSetsTermsRelationsUpdateRefSet Update the ref of navigation property set in sites

The [set] in which the relation is relevant.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param siteId key: id of site
 @param groupId key: id of group
 @param setId key: id of set
 @param termId key: id of term
 @param relationId key: id of relation
 @return ApiSitesTermStoreGroupsSetsTermsRelationsUpdateRefSetRequest
*/
func (a *SitesStoreApiService) SitesTermStoreGroupsSetsTermsRelationsUpdateRefSet(ctx _context.Context, siteId string, groupId string, setId string, termId string, relationId string) ApiSitesTermStoreGroupsSetsTermsRelationsUpdateRefSetRequest {
	return ApiSitesTermStoreGroupsSetsTermsRelationsUpdateRefSetRequest{
		ApiService: a,
		ctx: ctx,
		siteId: siteId,
		groupId: groupId,
		setId: setId,
		termId: termId,
		relationId: relationId,
	}
}

// Execute executes the request
func (a *SitesStoreApiService) SitesTermStoreGroupsSetsTermsRelationsUpdateRefSetExecute(r ApiSitesTermStoreGroupsSetsTermsRelationsUpdateRefSetRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPut
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SitesStoreApiService.SitesTermStoreGroupsSetsTermsRelationsUpdateRefSet")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sites/{site-id}/termStore/groups/{group-id}/sets/{set-id}/terms/{term-id}/relations/{relation-id}/set/$ref"
	localVarPath = strings.Replace(localVarPath, "{"+"site-id"+"}", _neturl.PathEscape(parameterToString(r.siteId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"set-id"+"}", _neturl.PathEscape(parameterToString(r.setId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"term-id"+"}", _neturl.PathEscape(parameterToString(r.termId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"relation-id"+"}", _neturl.PathEscape(parameterToString(r.relationId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.requestBody == nil {
		return nil, reportError("requestBody is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.requestBody
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiSitesTermStoreGroupsSetsTermsRelationsUpdateRefToTermRequest struct {
	ctx _context.Context
	ApiService *SitesStoreApiService
	siteId string
	groupId string
	setId string
	termId string
	relationId string
	requestBody *map[string]map[string]interface{}
}

// New navigation property ref values
func (r ApiSitesTermStoreGroupsSetsTermsRelationsUpdateRefToTermRequest) RequestBody(requestBody map[string]map[string]interface{}) ApiSitesTermStoreGroupsSetsTermsRelationsUpdateRefToTermRequest {
	r.requestBody = &requestBody
	return r
}

func (r ApiSitesTermStoreGroupsSetsTermsRelationsUpdateRefToTermRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.SitesTermStoreGroupsSetsTermsRelationsUpdateRefToTermExecute(r)
}

/*
SitesTermStoreGroupsSetsTermsRelationsUpdateRefToTerm Update the ref of navigation property toTerm in sites

The to [term] of the relation. The term to which the relationship is defined.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param siteId key: id of site
 @param groupId key: id of group
 @param setId key: id of set
 @param termId key: id of term
 @param relationId key: id of relation
 @return ApiSitesTermStoreGroupsSetsTermsRelationsUpdateRefToTermRequest
*/
func (a *SitesStoreApiService) SitesTermStoreGroupsSetsTermsRelationsUpdateRefToTerm(ctx _context.Context, siteId string, groupId string, setId string, termId string, relationId string) ApiSitesTermStoreGroupsSetsTermsRelationsUpdateRefToTermRequest {
	return ApiSitesTermStoreGroupsSetsTermsRelationsUpdateRefToTermRequest{
		ApiService: a,
		ctx: ctx,
		siteId: siteId,
		groupId: groupId,
		setId: setId,
		termId: termId,
		relationId: relationId,
	}
}

// Execute executes the request
func (a *SitesStoreApiService) SitesTermStoreGroupsSetsTermsRelationsUpdateRefToTermExecute(r ApiSitesTermStoreGroupsSetsTermsRelationsUpdateRefToTermRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPut
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SitesStoreApiService.SitesTermStoreGroupsSetsTermsRelationsUpdateRefToTerm")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sites/{site-id}/termStore/groups/{group-id}/sets/{set-id}/terms/{term-id}/relations/{relation-id}/toTerm/$ref"
	localVarPath = strings.Replace(localVarPath, "{"+"site-id"+"}", _neturl.PathEscape(parameterToString(r.siteId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"set-id"+"}", _neturl.PathEscape(parameterToString(r.setId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"term-id"+"}", _neturl.PathEscape(parameterToString(r.termId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"relation-id"+"}", _neturl.PathEscape(parameterToString(r.relationId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.requestBody == nil {
		return nil, reportError("requestBody is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.requestBody
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiSitesTermStoreGroupsSetsTermsUpdateChildrenRequest struct {
	ctx _context.Context
	ApiService *SitesStoreApiService
	siteId string
	groupId string
	setId string
	termId string
	termId1 string
	microsoftGraphTermStoreTerm *MicrosoftGraphTermStoreTerm
}

// New navigation property values
func (r ApiSitesTermStoreGroupsSetsTermsUpdateChildrenRequest) MicrosoftGraphTermStoreTerm(microsoftGraphTermStoreTerm MicrosoftGraphTermStoreTerm) ApiSitesTermStoreGroupsSetsTermsUpdateChildrenRequest {
	r.microsoftGraphTermStoreTerm = &microsoftGraphTermStoreTerm
	return r
}

func (r ApiSitesTermStoreGroupsSetsTermsUpdateChildrenRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.SitesTermStoreGroupsSetsTermsUpdateChildrenExecute(r)
}

/*
SitesTermStoreGroupsSetsTermsUpdateChildren Update the navigation property children in sites

Children of current term.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param siteId key: id of site
 @param groupId key: id of group
 @param setId key: id of set
 @param termId key: id of term
 @param termId1 key: id of term
 @return ApiSitesTermStoreGroupsSetsTermsUpdateChildrenRequest
*/
func (a *SitesStoreApiService) SitesTermStoreGroupsSetsTermsUpdateChildren(ctx _context.Context, siteId string, groupId string, setId string, termId string, termId1 string) ApiSitesTermStoreGroupsSetsTermsUpdateChildrenRequest {
	return ApiSitesTermStoreGroupsSetsTermsUpdateChildrenRequest{
		ApiService: a,
		ctx: ctx,
		siteId: siteId,
		groupId: groupId,
		setId: setId,
		termId: termId,
		termId1: termId1,
	}
}

// Execute executes the request
func (a *SitesStoreApiService) SitesTermStoreGroupsSetsTermsUpdateChildrenExecute(r ApiSitesTermStoreGroupsSetsTermsUpdateChildrenRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPatch
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SitesStoreApiService.SitesTermStoreGroupsSetsTermsUpdateChildren")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sites/{site-id}/termStore/groups/{group-id}/sets/{set-id}/terms/{term-id}/children/{term-id1}"
	localVarPath = strings.Replace(localVarPath, "{"+"site-id"+"}", _neturl.PathEscape(parameterToString(r.siteId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"set-id"+"}", _neturl.PathEscape(parameterToString(r.setId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"term-id"+"}", _neturl.PathEscape(parameterToString(r.termId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"term-id1"+"}", _neturl.PathEscape(parameterToString(r.termId1, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphTermStoreTerm == nil {
		return nil, reportError("microsoftGraphTermStoreTerm is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphTermStoreTerm
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiSitesTermStoreGroupsSetsTermsUpdateRefSetRequest struct {
	ctx _context.Context
	ApiService *SitesStoreApiService
	siteId string
	groupId string
	setId string
	termId string
	requestBody *map[string]map[string]interface{}
}

// New navigation property ref values
func (r ApiSitesTermStoreGroupsSetsTermsUpdateRefSetRequest) RequestBody(requestBody map[string]map[string]interface{}) ApiSitesTermStoreGroupsSetsTermsUpdateRefSetRequest {
	r.requestBody = &requestBody
	return r
}

func (r ApiSitesTermStoreGroupsSetsTermsUpdateRefSetRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.SitesTermStoreGroupsSetsTermsUpdateRefSetExecute(r)
}

/*
SitesTermStoreGroupsSetsTermsUpdateRefSet Update the ref of navigation property set in sites

The [set] in which the term is created.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param siteId key: id of site
 @param groupId key: id of group
 @param setId key: id of set
 @param termId key: id of term
 @return ApiSitesTermStoreGroupsSetsTermsUpdateRefSetRequest
*/
func (a *SitesStoreApiService) SitesTermStoreGroupsSetsTermsUpdateRefSet(ctx _context.Context, siteId string, groupId string, setId string, termId string) ApiSitesTermStoreGroupsSetsTermsUpdateRefSetRequest {
	return ApiSitesTermStoreGroupsSetsTermsUpdateRefSetRequest{
		ApiService: a,
		ctx: ctx,
		siteId: siteId,
		groupId: groupId,
		setId: setId,
		termId: termId,
	}
}

// Execute executes the request
func (a *SitesStoreApiService) SitesTermStoreGroupsSetsTermsUpdateRefSetExecute(r ApiSitesTermStoreGroupsSetsTermsUpdateRefSetRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPut
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SitesStoreApiService.SitesTermStoreGroupsSetsTermsUpdateRefSet")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sites/{site-id}/termStore/groups/{group-id}/sets/{set-id}/terms/{term-id}/set/$ref"
	localVarPath = strings.Replace(localVarPath, "{"+"site-id"+"}", _neturl.PathEscape(parameterToString(r.siteId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"set-id"+"}", _neturl.PathEscape(parameterToString(r.setId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"term-id"+"}", _neturl.PathEscape(parameterToString(r.termId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.requestBody == nil {
		return nil, reportError("requestBody is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.requestBody
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiSitesTermStoreGroupsSetsTermsUpdateRelationsRequest struct {
	ctx _context.Context
	ApiService *SitesStoreApiService
	siteId string
	groupId string
	setId string
	termId string
	relationId string
	microsoftGraphTermStoreRelation *MicrosoftGraphTermStoreRelation
}

// New navigation property values
func (r ApiSitesTermStoreGroupsSetsTermsUpdateRelationsRequest) MicrosoftGraphTermStoreRelation(microsoftGraphTermStoreRelation MicrosoftGraphTermStoreRelation) ApiSitesTermStoreGroupsSetsTermsUpdateRelationsRequest {
	r.microsoftGraphTermStoreRelation = &microsoftGraphTermStoreRelation
	return r
}

func (r ApiSitesTermStoreGroupsSetsTermsUpdateRelationsRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.SitesTermStoreGroupsSetsTermsUpdateRelationsExecute(r)
}

/*
SitesTermStoreGroupsSetsTermsUpdateRelations Update the navigation property relations in sites

To indicate which terms are related to the current term as either pinned or reused.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param siteId key: id of site
 @param groupId key: id of group
 @param setId key: id of set
 @param termId key: id of term
 @param relationId key: id of relation
 @return ApiSitesTermStoreGroupsSetsTermsUpdateRelationsRequest
*/
func (a *SitesStoreApiService) SitesTermStoreGroupsSetsTermsUpdateRelations(ctx _context.Context, siteId string, groupId string, setId string, termId string, relationId string) ApiSitesTermStoreGroupsSetsTermsUpdateRelationsRequest {
	return ApiSitesTermStoreGroupsSetsTermsUpdateRelationsRequest{
		ApiService: a,
		ctx: ctx,
		siteId: siteId,
		groupId: groupId,
		setId: setId,
		termId: termId,
		relationId: relationId,
	}
}

// Execute executes the request
func (a *SitesStoreApiService) SitesTermStoreGroupsSetsTermsUpdateRelationsExecute(r ApiSitesTermStoreGroupsSetsTermsUpdateRelationsRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPatch
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SitesStoreApiService.SitesTermStoreGroupsSetsTermsUpdateRelations")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sites/{site-id}/termStore/groups/{group-id}/sets/{set-id}/terms/{term-id}/relations/{relation-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"site-id"+"}", _neturl.PathEscape(parameterToString(r.siteId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"set-id"+"}", _neturl.PathEscape(parameterToString(r.setId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"term-id"+"}", _neturl.PathEscape(parameterToString(r.termId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"relation-id"+"}", _neturl.PathEscape(parameterToString(r.relationId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphTermStoreRelation == nil {
		return nil, reportError("microsoftGraphTermStoreRelation is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphTermStoreRelation
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiSitesTermStoreGroupsSetsUpdateChildrenRequest struct {
	ctx _context.Context
	ApiService *SitesStoreApiService
	siteId string
	groupId string
	setId string
	termId string
	microsoftGraphTermStoreTerm *MicrosoftGraphTermStoreTerm
}

// New navigation property values
func (r ApiSitesTermStoreGroupsSetsUpdateChildrenRequest) MicrosoftGraphTermStoreTerm(microsoftGraphTermStoreTerm MicrosoftGraphTermStoreTerm) ApiSitesTermStoreGroupsSetsUpdateChildrenRequest {
	r.microsoftGraphTermStoreTerm = &microsoftGraphTermStoreTerm
	return r
}

func (r ApiSitesTermStoreGroupsSetsUpdateChildrenRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.SitesTermStoreGroupsSetsUpdateChildrenExecute(r)
}

/*
SitesTermStoreGroupsSetsUpdateChildren Update the navigation property children in sites

Children terms of set in term [store].

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param siteId key: id of site
 @param groupId key: id of group
 @param setId key: id of set
 @param termId key: id of term
 @return ApiSitesTermStoreGroupsSetsUpdateChildrenRequest
*/
func (a *SitesStoreApiService) SitesTermStoreGroupsSetsUpdateChildren(ctx _context.Context, siteId string, groupId string, setId string, termId string) ApiSitesTermStoreGroupsSetsUpdateChildrenRequest {
	return ApiSitesTermStoreGroupsSetsUpdateChildrenRequest{
		ApiService: a,
		ctx: ctx,
		siteId: siteId,
		groupId: groupId,
		setId: setId,
		termId: termId,
	}
}

// Execute executes the request
func (a *SitesStoreApiService) SitesTermStoreGroupsSetsUpdateChildrenExecute(r ApiSitesTermStoreGroupsSetsUpdateChildrenRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPatch
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SitesStoreApiService.SitesTermStoreGroupsSetsUpdateChildren")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sites/{site-id}/termStore/groups/{group-id}/sets/{set-id}/children/{term-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"site-id"+"}", _neturl.PathEscape(parameterToString(r.siteId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"set-id"+"}", _neturl.PathEscape(parameterToString(r.setId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"term-id"+"}", _neturl.PathEscape(parameterToString(r.termId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphTermStoreTerm == nil {
		return nil, reportError("microsoftGraphTermStoreTerm is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphTermStoreTerm
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiSitesTermStoreGroupsSetsUpdateParentGroupRequest struct {
	ctx _context.Context
	ApiService *SitesStoreApiService
	siteId string
	groupId string
	setId string
	microsoftGraphTermStoreGroup *MicrosoftGraphTermStoreGroup
}

// New navigation property values
func (r ApiSitesTermStoreGroupsSetsUpdateParentGroupRequest) MicrosoftGraphTermStoreGroup(microsoftGraphTermStoreGroup MicrosoftGraphTermStoreGroup) ApiSitesTermStoreGroupsSetsUpdateParentGroupRequest {
	r.microsoftGraphTermStoreGroup = &microsoftGraphTermStoreGroup
	return r
}

func (r ApiSitesTermStoreGroupsSetsUpdateParentGroupRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.SitesTermStoreGroupsSetsUpdateParentGroupExecute(r)
}

/*
SitesTermStoreGroupsSetsUpdateParentGroup Update the navigation property parentGroup in sites

The parent [group] that contains the set.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param siteId key: id of site
 @param groupId key: id of group
 @param setId key: id of set
 @return ApiSitesTermStoreGroupsSetsUpdateParentGroupRequest
*/
func (a *SitesStoreApiService) SitesTermStoreGroupsSetsUpdateParentGroup(ctx _context.Context, siteId string, groupId string, setId string) ApiSitesTermStoreGroupsSetsUpdateParentGroupRequest {
	return ApiSitesTermStoreGroupsSetsUpdateParentGroupRequest{
		ApiService: a,
		ctx: ctx,
		siteId: siteId,
		groupId: groupId,
		setId: setId,
	}
}

// Execute executes the request
func (a *SitesStoreApiService) SitesTermStoreGroupsSetsUpdateParentGroupExecute(r ApiSitesTermStoreGroupsSetsUpdateParentGroupRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPatch
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SitesStoreApiService.SitesTermStoreGroupsSetsUpdateParentGroup")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sites/{site-id}/termStore/groups/{group-id}/sets/{set-id}/parentGroup"
	localVarPath = strings.Replace(localVarPath, "{"+"site-id"+"}", _neturl.PathEscape(parameterToString(r.siteId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"set-id"+"}", _neturl.PathEscape(parameterToString(r.setId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphTermStoreGroup == nil {
		return nil, reportError("microsoftGraphTermStoreGroup is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphTermStoreGroup
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiSitesTermStoreGroupsSetsUpdateRelationsRequest struct {
	ctx _context.Context
	ApiService *SitesStoreApiService
	siteId string
	groupId string
	setId string
	relationId string
	microsoftGraphTermStoreRelation *MicrosoftGraphTermStoreRelation
}

// New navigation property values
func (r ApiSitesTermStoreGroupsSetsUpdateRelationsRequest) MicrosoftGraphTermStoreRelation(microsoftGraphTermStoreRelation MicrosoftGraphTermStoreRelation) ApiSitesTermStoreGroupsSetsUpdateRelationsRequest {
	r.microsoftGraphTermStoreRelation = &microsoftGraphTermStoreRelation
	return r
}

func (r ApiSitesTermStoreGroupsSetsUpdateRelationsRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.SitesTermStoreGroupsSetsUpdateRelationsExecute(r)
}

/*
SitesTermStoreGroupsSetsUpdateRelations Update the navigation property relations in sites

Indicates which terms have been pinned or reused directly under the set.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param siteId key: id of site
 @param groupId key: id of group
 @param setId key: id of set
 @param relationId key: id of relation
 @return ApiSitesTermStoreGroupsSetsUpdateRelationsRequest
*/
func (a *SitesStoreApiService) SitesTermStoreGroupsSetsUpdateRelations(ctx _context.Context, siteId string, groupId string, setId string, relationId string) ApiSitesTermStoreGroupsSetsUpdateRelationsRequest {
	return ApiSitesTermStoreGroupsSetsUpdateRelationsRequest{
		ApiService: a,
		ctx: ctx,
		siteId: siteId,
		groupId: groupId,
		setId: setId,
		relationId: relationId,
	}
}

// Execute executes the request
func (a *SitesStoreApiService) SitesTermStoreGroupsSetsUpdateRelationsExecute(r ApiSitesTermStoreGroupsSetsUpdateRelationsRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPatch
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SitesStoreApiService.SitesTermStoreGroupsSetsUpdateRelations")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sites/{site-id}/termStore/groups/{group-id}/sets/{set-id}/relations/{relation-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"site-id"+"}", _neturl.PathEscape(parameterToString(r.siteId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"set-id"+"}", _neturl.PathEscape(parameterToString(r.setId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"relation-id"+"}", _neturl.PathEscape(parameterToString(r.relationId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphTermStoreRelation == nil {
		return nil, reportError("microsoftGraphTermStoreRelation is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphTermStoreRelation
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiSitesTermStoreGroupsSetsUpdateTermsRequest struct {
	ctx _context.Context
	ApiService *SitesStoreApiService
	siteId string
	groupId string
	setId string
	termId string
	microsoftGraphTermStoreTerm *MicrosoftGraphTermStoreTerm
}

// New navigation property values
func (r ApiSitesTermStoreGroupsSetsUpdateTermsRequest) MicrosoftGraphTermStoreTerm(microsoftGraphTermStoreTerm MicrosoftGraphTermStoreTerm) ApiSitesTermStoreGroupsSetsUpdateTermsRequest {
	r.microsoftGraphTermStoreTerm = &microsoftGraphTermStoreTerm
	return r
}

func (r ApiSitesTermStoreGroupsSetsUpdateTermsRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.SitesTermStoreGroupsSetsUpdateTermsExecute(r)
}

/*
SitesTermStoreGroupsSetsUpdateTerms Update the navigation property terms in sites

All the terms under the set.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param siteId key: id of site
 @param groupId key: id of group
 @param setId key: id of set
 @param termId key: id of term
 @return ApiSitesTermStoreGroupsSetsUpdateTermsRequest
*/
func (a *SitesStoreApiService) SitesTermStoreGroupsSetsUpdateTerms(ctx _context.Context, siteId string, groupId string, setId string, termId string) ApiSitesTermStoreGroupsSetsUpdateTermsRequest {
	return ApiSitesTermStoreGroupsSetsUpdateTermsRequest{
		ApiService: a,
		ctx: ctx,
		siteId: siteId,
		groupId: groupId,
		setId: setId,
		termId: termId,
	}
}

// Execute executes the request
func (a *SitesStoreApiService) SitesTermStoreGroupsSetsUpdateTermsExecute(r ApiSitesTermStoreGroupsSetsUpdateTermsRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPatch
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SitesStoreApiService.SitesTermStoreGroupsSetsUpdateTerms")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sites/{site-id}/termStore/groups/{group-id}/sets/{set-id}/terms/{term-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"site-id"+"}", _neturl.PathEscape(parameterToString(r.siteId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"set-id"+"}", _neturl.PathEscape(parameterToString(r.setId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"term-id"+"}", _neturl.PathEscape(parameterToString(r.termId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphTermStoreTerm == nil {
		return nil, reportError("microsoftGraphTermStoreTerm is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphTermStoreTerm
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiSitesTermStoreGroupsUpdateSetsRequest struct {
	ctx _context.Context
	ApiService *SitesStoreApiService
	siteId string
	groupId string
	setId string
	microsoftGraphTermStoreSet *MicrosoftGraphTermStoreSet
}

// New navigation property values
func (r ApiSitesTermStoreGroupsUpdateSetsRequest) MicrosoftGraphTermStoreSet(microsoftGraphTermStoreSet MicrosoftGraphTermStoreSet) ApiSitesTermStoreGroupsUpdateSetsRequest {
	r.microsoftGraphTermStoreSet = &microsoftGraphTermStoreSet
	return r
}

func (r ApiSitesTermStoreGroupsUpdateSetsRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.SitesTermStoreGroupsUpdateSetsExecute(r)
}

/*
SitesTermStoreGroupsUpdateSets Update the navigation property sets in sites

All sets under the group in a term [store].

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param siteId key: id of site
 @param groupId key: id of group
 @param setId key: id of set
 @return ApiSitesTermStoreGroupsUpdateSetsRequest
*/
func (a *SitesStoreApiService) SitesTermStoreGroupsUpdateSets(ctx _context.Context, siteId string, groupId string, setId string) ApiSitesTermStoreGroupsUpdateSetsRequest {
	return ApiSitesTermStoreGroupsUpdateSetsRequest{
		ApiService: a,
		ctx: ctx,
		siteId: siteId,
		groupId: groupId,
		setId: setId,
	}
}

// Execute executes the request
func (a *SitesStoreApiService) SitesTermStoreGroupsUpdateSetsExecute(r ApiSitesTermStoreGroupsUpdateSetsRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPatch
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SitesStoreApiService.SitesTermStoreGroupsUpdateSets")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sites/{site-id}/termStore/groups/{group-id}/sets/{set-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"site-id"+"}", _neturl.PathEscape(parameterToString(r.siteId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"set-id"+"}", _neturl.PathEscape(parameterToString(r.setId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphTermStoreSet == nil {
		return nil, reportError("microsoftGraphTermStoreSet is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphTermStoreSet
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiSitesTermStoreListGroupsRequest struct {
	ctx _context.Context
	ApiService *SitesStoreApiService
	siteId string
	top *int32
	skip *int32
	search *string
	filter *string
	count *bool
	orderby *[]string
	select_ *[]string
	expand *[]string
}

// Show only the first n items
func (r ApiSitesTermStoreListGroupsRequest) Top(top int32) ApiSitesTermStoreListGroupsRequest {
	r.top = &top
	return r
}
// Skip the first n items
func (r ApiSitesTermStoreListGroupsRequest) Skip(skip int32) ApiSitesTermStoreListGroupsRequest {
	r.skip = &skip
	return r
}
// Search items by search phrases
func (r ApiSitesTermStoreListGroupsRequest) Search(search string) ApiSitesTermStoreListGroupsRequest {
	r.search = &search
	return r
}
// Filter items by property values
func (r ApiSitesTermStoreListGroupsRequest) Filter(filter string) ApiSitesTermStoreListGroupsRequest {
	r.filter = &filter
	return r
}
// Include count of items
func (r ApiSitesTermStoreListGroupsRequest) Count(count bool) ApiSitesTermStoreListGroupsRequest {
	r.count = &count
	return r
}
// Order items by property values
func (r ApiSitesTermStoreListGroupsRequest) Orderby(orderby []string) ApiSitesTermStoreListGroupsRequest {
	r.orderby = &orderby
	return r
}
// Select properties to be returned
func (r ApiSitesTermStoreListGroupsRequest) Select_(select_ []string) ApiSitesTermStoreListGroupsRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiSitesTermStoreListGroupsRequest) Expand(expand []string) ApiSitesTermStoreListGroupsRequest {
	r.expand = &expand
	return r
}

func (r ApiSitesTermStoreListGroupsRequest) Execute() (CollectionOfGroup1, *_nethttp.Response, error) {
	return r.ApiService.SitesTermStoreListGroupsExecute(r)
}

/*
SitesTermStoreListGroups Get groups from sites

Collection of all groups available in the term store.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param siteId key: id of site
 @return ApiSitesTermStoreListGroupsRequest
*/
func (a *SitesStoreApiService) SitesTermStoreListGroups(ctx _context.Context, siteId string) ApiSitesTermStoreListGroupsRequest {
	return ApiSitesTermStoreListGroupsRequest{
		ApiService: a,
		ctx: ctx,
		siteId: siteId,
	}
}

// Execute executes the request
//  @return CollectionOfGroup1
func (a *SitesStoreApiService) SitesTermStoreListGroupsExecute(r ApiSitesTermStoreListGroupsRequest) (CollectionOfGroup1, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  CollectionOfGroup1
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SitesStoreApiService.SitesTermStoreListGroups")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sites/{site-id}/termStore/groups"
	localVarPath = strings.Replace(localVarPath, "{"+"site-id"+"}", _neturl.PathEscape(parameterToString(r.siteId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.top != nil {
		localVarQueryParams.Add("$top", parameterToString(*r.top, ""))
	}
	if r.skip != nil {
		localVarQueryParams.Add("$skip", parameterToString(*r.skip, ""))
	}
	if r.search != nil {
		localVarQueryParams.Add("$search", parameterToString(*r.search, ""))
	}
	if r.filter != nil {
		localVarQueryParams.Add("$filter", parameterToString(*r.filter, ""))
	}
	if r.count != nil {
		localVarQueryParams.Add("$count", parameterToString(*r.count, ""))
	}
	if r.orderby != nil {
		localVarQueryParams.Add("$orderby", parameterToString(*r.orderby, "csv"))
	}
	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSitesTermStoreListSetsRequest struct {
	ctx _context.Context
	ApiService *SitesStoreApiService
	siteId string
	top *int32
	skip *int32
	search *string
	filter *string
	count *bool
	orderby *[]string
	select_ *[]string
	expand *[]string
}

// Show only the first n items
func (r ApiSitesTermStoreListSetsRequest) Top(top int32) ApiSitesTermStoreListSetsRequest {
	r.top = &top
	return r
}
// Skip the first n items
func (r ApiSitesTermStoreListSetsRequest) Skip(skip int32) ApiSitesTermStoreListSetsRequest {
	r.skip = &skip
	return r
}
// Search items by search phrases
func (r ApiSitesTermStoreListSetsRequest) Search(search string) ApiSitesTermStoreListSetsRequest {
	r.search = &search
	return r
}
// Filter items by property values
func (r ApiSitesTermStoreListSetsRequest) Filter(filter string) ApiSitesTermStoreListSetsRequest {
	r.filter = &filter
	return r
}
// Include count of items
func (r ApiSitesTermStoreListSetsRequest) Count(count bool) ApiSitesTermStoreListSetsRequest {
	r.count = &count
	return r
}
// Order items by property values
func (r ApiSitesTermStoreListSetsRequest) Orderby(orderby []string) ApiSitesTermStoreListSetsRequest {
	r.orderby = &orderby
	return r
}
// Select properties to be returned
func (r ApiSitesTermStoreListSetsRequest) Select_(select_ []string) ApiSitesTermStoreListSetsRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiSitesTermStoreListSetsRequest) Expand(expand []string) ApiSitesTermStoreListSetsRequest {
	r.expand = &expand
	return r
}

func (r ApiSitesTermStoreListSetsRequest) Execute() (CollectionOfSet, *_nethttp.Response, error) {
	return r.ApiService.SitesTermStoreListSetsExecute(r)
}

/*
SitesTermStoreListSets Get sets from sites

Collection of all sets available in the term store.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param siteId key: id of site
 @return ApiSitesTermStoreListSetsRequest
*/
func (a *SitesStoreApiService) SitesTermStoreListSets(ctx _context.Context, siteId string) ApiSitesTermStoreListSetsRequest {
	return ApiSitesTermStoreListSetsRequest{
		ApiService: a,
		ctx: ctx,
		siteId: siteId,
	}
}

// Execute executes the request
//  @return CollectionOfSet
func (a *SitesStoreApiService) SitesTermStoreListSetsExecute(r ApiSitesTermStoreListSetsRequest) (CollectionOfSet, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  CollectionOfSet
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SitesStoreApiService.SitesTermStoreListSets")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sites/{site-id}/termStore/sets"
	localVarPath = strings.Replace(localVarPath, "{"+"site-id"+"}", _neturl.PathEscape(parameterToString(r.siteId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.top != nil {
		localVarQueryParams.Add("$top", parameterToString(*r.top, ""))
	}
	if r.skip != nil {
		localVarQueryParams.Add("$skip", parameterToString(*r.skip, ""))
	}
	if r.search != nil {
		localVarQueryParams.Add("$search", parameterToString(*r.search, ""))
	}
	if r.filter != nil {
		localVarQueryParams.Add("$filter", parameterToString(*r.filter, ""))
	}
	if r.count != nil {
		localVarQueryParams.Add("$count", parameterToString(*r.count, ""))
	}
	if r.orderby != nil {
		localVarQueryParams.Add("$orderby", parameterToString(*r.orderby, "csv"))
	}
	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSitesTermStoreSetsChildrenCreateChildrenRequest struct {
	ctx _context.Context
	ApiService *SitesStoreApiService
	siteId string
	setId string
	termId string
	microsoftGraphTermStoreTerm *MicrosoftGraphTermStoreTerm
}

// New navigation property
func (r ApiSitesTermStoreSetsChildrenCreateChildrenRequest) MicrosoftGraphTermStoreTerm(microsoftGraphTermStoreTerm MicrosoftGraphTermStoreTerm) ApiSitesTermStoreSetsChildrenCreateChildrenRequest {
	r.microsoftGraphTermStoreTerm = &microsoftGraphTermStoreTerm
	return r
}

func (r ApiSitesTermStoreSetsChildrenCreateChildrenRequest) Execute() (MicrosoftGraphTermStoreTerm, *_nethttp.Response, error) {
	return r.ApiService.SitesTermStoreSetsChildrenCreateChildrenExecute(r)
}

/*
SitesTermStoreSetsChildrenCreateChildren Create new navigation property to children for sites

Children of current term.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param siteId key: id of site
 @param setId key: id of set
 @param termId key: id of term
 @return ApiSitesTermStoreSetsChildrenCreateChildrenRequest
*/
func (a *SitesStoreApiService) SitesTermStoreSetsChildrenCreateChildren(ctx _context.Context, siteId string, setId string, termId string) ApiSitesTermStoreSetsChildrenCreateChildrenRequest {
	return ApiSitesTermStoreSetsChildrenCreateChildrenRequest{
		ApiService: a,
		ctx: ctx,
		siteId: siteId,
		setId: setId,
		termId: termId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphTermStoreTerm
func (a *SitesStoreApiService) SitesTermStoreSetsChildrenCreateChildrenExecute(r ApiSitesTermStoreSetsChildrenCreateChildrenRequest) (MicrosoftGraphTermStoreTerm, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphTermStoreTerm
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SitesStoreApiService.SitesTermStoreSetsChildrenCreateChildren")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sites/{site-id}/termStore/sets/{set-id}/children/{term-id}/children"
	localVarPath = strings.Replace(localVarPath, "{"+"site-id"+"}", _neturl.PathEscape(parameterToString(r.siteId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"set-id"+"}", _neturl.PathEscape(parameterToString(r.setId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"term-id"+"}", _neturl.PathEscape(parameterToString(r.termId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphTermStoreTerm == nil {
		return localVarReturnValue, nil, reportError("microsoftGraphTermStoreTerm is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphTermStoreTerm
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSitesTermStoreSetsChildrenCreateRelationsRequest struct {
	ctx _context.Context
	ApiService *SitesStoreApiService
	siteId string
	setId string
	termId string
	microsoftGraphTermStoreRelation *MicrosoftGraphTermStoreRelation
}

// New navigation property
func (r ApiSitesTermStoreSetsChildrenCreateRelationsRequest) MicrosoftGraphTermStoreRelation(microsoftGraphTermStoreRelation MicrosoftGraphTermStoreRelation) ApiSitesTermStoreSetsChildrenCreateRelationsRequest {
	r.microsoftGraphTermStoreRelation = &microsoftGraphTermStoreRelation
	return r
}

func (r ApiSitesTermStoreSetsChildrenCreateRelationsRequest) Execute() (MicrosoftGraphTermStoreRelation, *_nethttp.Response, error) {
	return r.ApiService.SitesTermStoreSetsChildrenCreateRelationsExecute(r)
}

/*
SitesTermStoreSetsChildrenCreateRelations Create new navigation property to relations for sites

To indicate which terms are related to the current term as either pinned or reused.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param siteId key: id of site
 @param setId key: id of set
 @param termId key: id of term
 @return ApiSitesTermStoreSetsChildrenCreateRelationsRequest
*/
func (a *SitesStoreApiService) SitesTermStoreSetsChildrenCreateRelations(ctx _context.Context, siteId string, setId string, termId string) ApiSitesTermStoreSetsChildrenCreateRelationsRequest {
	return ApiSitesTermStoreSetsChildrenCreateRelationsRequest{
		ApiService: a,
		ctx: ctx,
		siteId: siteId,
		setId: setId,
		termId: termId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphTermStoreRelation
func (a *SitesStoreApiService) SitesTermStoreSetsChildrenCreateRelationsExecute(r ApiSitesTermStoreSetsChildrenCreateRelationsRequest) (MicrosoftGraphTermStoreRelation, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphTermStoreRelation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SitesStoreApiService.SitesTermStoreSetsChildrenCreateRelations")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sites/{site-id}/termStore/sets/{set-id}/children/{term-id}/relations"
	localVarPath = strings.Replace(localVarPath, "{"+"site-id"+"}", _neturl.PathEscape(parameterToString(r.siteId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"set-id"+"}", _neturl.PathEscape(parameterToString(r.setId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"term-id"+"}", _neturl.PathEscape(parameterToString(r.termId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphTermStoreRelation == nil {
		return localVarReturnValue, nil, reportError("microsoftGraphTermStoreRelation is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphTermStoreRelation
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSitesTermStoreSetsChildrenDeleteChildrenRequest struct {
	ctx _context.Context
	ApiService *SitesStoreApiService
	siteId string
	setId string
	termId string
	termId1 string
	ifMatch *string
}

// ETag
func (r ApiSitesTermStoreSetsChildrenDeleteChildrenRequest) IfMatch(ifMatch string) ApiSitesTermStoreSetsChildrenDeleteChildrenRequest {
	r.ifMatch = &ifMatch
	return r
}

func (r ApiSitesTermStoreSetsChildrenDeleteChildrenRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.SitesTermStoreSetsChildrenDeleteChildrenExecute(r)
}

/*
SitesTermStoreSetsChildrenDeleteChildren Delete navigation property children for sites

Children of current term.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param siteId key: id of site
 @param setId key: id of set
 @param termId key: id of term
 @param termId1 key: id of term
 @return ApiSitesTermStoreSetsChildrenDeleteChildrenRequest
*/
func (a *SitesStoreApiService) SitesTermStoreSetsChildrenDeleteChildren(ctx _context.Context, siteId string, setId string, termId string, termId1 string) ApiSitesTermStoreSetsChildrenDeleteChildrenRequest {
	return ApiSitesTermStoreSetsChildrenDeleteChildrenRequest{
		ApiService: a,
		ctx: ctx,
		siteId: siteId,
		setId: setId,
		termId: termId,
		termId1: termId1,
	}
}

// Execute executes the request
func (a *SitesStoreApiService) SitesTermStoreSetsChildrenDeleteChildrenExecute(r ApiSitesTermStoreSetsChildrenDeleteChildrenRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SitesStoreApiService.SitesTermStoreSetsChildrenDeleteChildren")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sites/{site-id}/termStore/sets/{set-id}/children/{term-id}/children/{term-id1}"
	localVarPath = strings.Replace(localVarPath, "{"+"site-id"+"}", _neturl.PathEscape(parameterToString(r.siteId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"set-id"+"}", _neturl.PathEscape(parameterToString(r.setId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"term-id"+"}", _neturl.PathEscape(parameterToString(r.termId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"term-id1"+"}", _neturl.PathEscape(parameterToString(r.termId1, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ifMatch != nil {
		localVarHeaderParams["If-Match"] = parameterToString(*r.ifMatch, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiSitesTermStoreSetsChildrenDeleteRefSetRequest struct {
	ctx _context.Context
	ApiService *SitesStoreApiService
	siteId string
	setId string
	termId string
	ifMatch *string
}

// ETag
func (r ApiSitesTermStoreSetsChildrenDeleteRefSetRequest) IfMatch(ifMatch string) ApiSitesTermStoreSetsChildrenDeleteRefSetRequest {
	r.ifMatch = &ifMatch
	return r
}

func (r ApiSitesTermStoreSetsChildrenDeleteRefSetRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.SitesTermStoreSetsChildrenDeleteRefSetExecute(r)
}

/*
SitesTermStoreSetsChildrenDeleteRefSet Delete ref of navigation property set for sites

The [set] in which the term is created.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param siteId key: id of site
 @param setId key: id of set
 @param termId key: id of term
 @return ApiSitesTermStoreSetsChildrenDeleteRefSetRequest
*/
func (a *SitesStoreApiService) SitesTermStoreSetsChildrenDeleteRefSet(ctx _context.Context, siteId string, setId string, termId string) ApiSitesTermStoreSetsChildrenDeleteRefSetRequest {
	return ApiSitesTermStoreSetsChildrenDeleteRefSetRequest{
		ApiService: a,
		ctx: ctx,
		siteId: siteId,
		setId: setId,
		termId: termId,
	}
}

// Execute executes the request
func (a *SitesStoreApiService) SitesTermStoreSetsChildrenDeleteRefSetExecute(r ApiSitesTermStoreSetsChildrenDeleteRefSetRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SitesStoreApiService.SitesTermStoreSetsChildrenDeleteRefSet")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sites/{site-id}/termStore/sets/{set-id}/children/{term-id}/set/$ref"
	localVarPath = strings.Replace(localVarPath, "{"+"site-id"+"}", _neturl.PathEscape(parameterToString(r.siteId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"set-id"+"}", _neturl.PathEscape(parameterToString(r.setId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"term-id"+"}", _neturl.PathEscape(parameterToString(r.termId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ifMatch != nil {
		localVarHeaderParams["If-Match"] = parameterToString(*r.ifMatch, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiSitesTermStoreSetsChildrenDeleteRelationsRequest struct {
	ctx _context.Context
	ApiService *SitesStoreApiService
	siteId string
	setId string
	termId string
	relationId string
	ifMatch *string
}

// ETag
func (r ApiSitesTermStoreSetsChildrenDeleteRelationsRequest) IfMatch(ifMatch string) ApiSitesTermStoreSetsChildrenDeleteRelationsRequest {
	r.ifMatch = &ifMatch
	return r
}

func (r ApiSitesTermStoreSetsChildrenDeleteRelationsRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.SitesTermStoreSetsChildrenDeleteRelationsExecute(r)
}

/*
SitesTermStoreSetsChildrenDeleteRelations Delete navigation property relations for sites

To indicate which terms are related to the current term as either pinned or reused.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param siteId key: id of site
 @param setId key: id of set
 @param termId key: id of term
 @param relationId key: id of relation
 @return ApiSitesTermStoreSetsChildrenDeleteRelationsRequest
*/
func (a *SitesStoreApiService) SitesTermStoreSetsChildrenDeleteRelations(ctx _context.Context, siteId string, setId string, termId string, relationId string) ApiSitesTermStoreSetsChildrenDeleteRelationsRequest {
	return ApiSitesTermStoreSetsChildrenDeleteRelationsRequest{
		ApiService: a,
		ctx: ctx,
		siteId: siteId,
		setId: setId,
		termId: termId,
		relationId: relationId,
	}
}

// Execute executes the request
func (a *SitesStoreApiService) SitesTermStoreSetsChildrenDeleteRelationsExecute(r ApiSitesTermStoreSetsChildrenDeleteRelationsRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SitesStoreApiService.SitesTermStoreSetsChildrenDeleteRelations")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sites/{site-id}/termStore/sets/{set-id}/children/{term-id}/relations/{relation-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"site-id"+"}", _neturl.PathEscape(parameterToString(r.siteId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"set-id"+"}", _neturl.PathEscape(parameterToString(r.setId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"term-id"+"}", _neturl.PathEscape(parameterToString(r.termId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"relation-id"+"}", _neturl.PathEscape(parameterToString(r.relationId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ifMatch != nil {
		localVarHeaderParams["If-Match"] = parameterToString(*r.ifMatch, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiSitesTermStoreSetsChildrenGetChildrenRequest struct {
	ctx _context.Context
	ApiService *SitesStoreApiService
	siteId string
	setId string
	termId string
	termId1 string
	select_ *[]string
	expand *[]string
}

// Select properties to be returned
func (r ApiSitesTermStoreSetsChildrenGetChildrenRequest) Select_(select_ []string) ApiSitesTermStoreSetsChildrenGetChildrenRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiSitesTermStoreSetsChildrenGetChildrenRequest) Expand(expand []string) ApiSitesTermStoreSetsChildrenGetChildrenRequest {
	r.expand = &expand
	return r
}

func (r ApiSitesTermStoreSetsChildrenGetChildrenRequest) Execute() (MicrosoftGraphTermStoreTerm, *_nethttp.Response, error) {
	return r.ApiService.SitesTermStoreSetsChildrenGetChildrenExecute(r)
}

/*
SitesTermStoreSetsChildrenGetChildren Get children from sites

Children of current term.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param siteId key: id of site
 @param setId key: id of set
 @param termId key: id of term
 @param termId1 key: id of term
 @return ApiSitesTermStoreSetsChildrenGetChildrenRequest
*/
func (a *SitesStoreApiService) SitesTermStoreSetsChildrenGetChildren(ctx _context.Context, siteId string, setId string, termId string, termId1 string) ApiSitesTermStoreSetsChildrenGetChildrenRequest {
	return ApiSitesTermStoreSetsChildrenGetChildrenRequest{
		ApiService: a,
		ctx: ctx,
		siteId: siteId,
		setId: setId,
		termId: termId,
		termId1: termId1,
	}
}

// Execute executes the request
//  @return MicrosoftGraphTermStoreTerm
func (a *SitesStoreApiService) SitesTermStoreSetsChildrenGetChildrenExecute(r ApiSitesTermStoreSetsChildrenGetChildrenRequest) (MicrosoftGraphTermStoreTerm, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphTermStoreTerm
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SitesStoreApiService.SitesTermStoreSetsChildrenGetChildren")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sites/{site-id}/termStore/sets/{set-id}/children/{term-id}/children/{term-id1}"
	localVarPath = strings.Replace(localVarPath, "{"+"site-id"+"}", _neturl.PathEscape(parameterToString(r.siteId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"set-id"+"}", _neturl.PathEscape(parameterToString(r.setId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"term-id"+"}", _neturl.PathEscape(parameterToString(r.termId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"term-id1"+"}", _neturl.PathEscape(parameterToString(r.termId1, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSitesTermStoreSetsChildrenGetRefSetRequest struct {
	ctx _context.Context
	ApiService *SitesStoreApiService
	siteId string
	setId string
	termId string
}


func (r ApiSitesTermStoreSetsChildrenGetRefSetRequest) Execute() (string, *_nethttp.Response, error) {
	return r.ApiService.SitesTermStoreSetsChildrenGetRefSetExecute(r)
}

/*
SitesTermStoreSetsChildrenGetRefSet Get ref of set from sites

The [set] in which the term is created.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param siteId key: id of site
 @param setId key: id of set
 @param termId key: id of term
 @return ApiSitesTermStoreSetsChildrenGetRefSetRequest
*/
func (a *SitesStoreApiService) SitesTermStoreSetsChildrenGetRefSet(ctx _context.Context, siteId string, setId string, termId string) ApiSitesTermStoreSetsChildrenGetRefSetRequest {
	return ApiSitesTermStoreSetsChildrenGetRefSetRequest{
		ApiService: a,
		ctx: ctx,
		siteId: siteId,
		setId: setId,
		termId: termId,
	}
}

// Execute executes the request
//  @return string
func (a *SitesStoreApiService) SitesTermStoreSetsChildrenGetRefSetExecute(r ApiSitesTermStoreSetsChildrenGetRefSetRequest) (string, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  string
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SitesStoreApiService.SitesTermStoreSetsChildrenGetRefSet")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sites/{site-id}/termStore/sets/{set-id}/children/{term-id}/set/$ref"
	localVarPath = strings.Replace(localVarPath, "{"+"site-id"+"}", _neturl.PathEscape(parameterToString(r.siteId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"set-id"+"}", _neturl.PathEscape(parameterToString(r.setId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"term-id"+"}", _neturl.PathEscape(parameterToString(r.termId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSitesTermStoreSetsChildrenGetRelationsRequest struct {
	ctx _context.Context
	ApiService *SitesStoreApiService
	siteId string
	setId string
	termId string
	relationId string
	select_ *[]string
	expand *[]string
}

// Select properties to be returned
func (r ApiSitesTermStoreSetsChildrenGetRelationsRequest) Select_(select_ []string) ApiSitesTermStoreSetsChildrenGetRelationsRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiSitesTermStoreSetsChildrenGetRelationsRequest) Expand(expand []string) ApiSitesTermStoreSetsChildrenGetRelationsRequest {
	r.expand = &expand
	return r
}

func (r ApiSitesTermStoreSetsChildrenGetRelationsRequest) Execute() (MicrosoftGraphTermStoreRelation, *_nethttp.Response, error) {
	return r.ApiService.SitesTermStoreSetsChildrenGetRelationsExecute(r)
}

/*
SitesTermStoreSetsChildrenGetRelations Get relations from sites

To indicate which terms are related to the current term as either pinned or reused.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param siteId key: id of site
 @param setId key: id of set
 @param termId key: id of term
 @param relationId key: id of relation
 @return ApiSitesTermStoreSetsChildrenGetRelationsRequest
*/
func (a *SitesStoreApiService) SitesTermStoreSetsChildrenGetRelations(ctx _context.Context, siteId string, setId string, termId string, relationId string) ApiSitesTermStoreSetsChildrenGetRelationsRequest {
	return ApiSitesTermStoreSetsChildrenGetRelationsRequest{
		ApiService: a,
		ctx: ctx,
		siteId: siteId,
		setId: setId,
		termId: termId,
		relationId: relationId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphTermStoreRelation
func (a *SitesStoreApiService) SitesTermStoreSetsChildrenGetRelationsExecute(r ApiSitesTermStoreSetsChildrenGetRelationsRequest) (MicrosoftGraphTermStoreRelation, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphTermStoreRelation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SitesStoreApiService.SitesTermStoreSetsChildrenGetRelations")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sites/{site-id}/termStore/sets/{set-id}/children/{term-id}/relations/{relation-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"site-id"+"}", _neturl.PathEscape(parameterToString(r.siteId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"set-id"+"}", _neturl.PathEscape(parameterToString(r.setId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"term-id"+"}", _neturl.PathEscape(parameterToString(r.termId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"relation-id"+"}", _neturl.PathEscape(parameterToString(r.relationId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSitesTermStoreSetsChildrenGetSetRequest struct {
	ctx _context.Context
	ApiService *SitesStoreApiService
	siteId string
	setId string
	termId string
	select_ *[]string
	expand *[]string
}

// Select properties to be returned
func (r ApiSitesTermStoreSetsChildrenGetSetRequest) Select_(select_ []string) ApiSitesTermStoreSetsChildrenGetSetRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiSitesTermStoreSetsChildrenGetSetRequest) Expand(expand []string) ApiSitesTermStoreSetsChildrenGetSetRequest {
	r.expand = &expand
	return r
}

func (r ApiSitesTermStoreSetsChildrenGetSetRequest) Execute() (MicrosoftGraphTermStoreSet, *_nethttp.Response, error) {
	return r.ApiService.SitesTermStoreSetsChildrenGetSetExecute(r)
}

/*
SitesTermStoreSetsChildrenGetSet Get set from sites

The [set] in which the term is created.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param siteId key: id of site
 @param setId key: id of set
 @param termId key: id of term
 @return ApiSitesTermStoreSetsChildrenGetSetRequest
*/
func (a *SitesStoreApiService) SitesTermStoreSetsChildrenGetSet(ctx _context.Context, siteId string, setId string, termId string) ApiSitesTermStoreSetsChildrenGetSetRequest {
	return ApiSitesTermStoreSetsChildrenGetSetRequest{
		ApiService: a,
		ctx: ctx,
		siteId: siteId,
		setId: setId,
		termId: termId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphTermStoreSet
func (a *SitesStoreApiService) SitesTermStoreSetsChildrenGetSetExecute(r ApiSitesTermStoreSetsChildrenGetSetRequest) (MicrosoftGraphTermStoreSet, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphTermStoreSet
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SitesStoreApiService.SitesTermStoreSetsChildrenGetSet")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sites/{site-id}/termStore/sets/{set-id}/children/{term-id}/set"
	localVarPath = strings.Replace(localVarPath, "{"+"site-id"+"}", _neturl.PathEscape(parameterToString(r.siteId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"set-id"+"}", _neturl.PathEscape(parameterToString(r.setId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"term-id"+"}", _neturl.PathEscape(parameterToString(r.termId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSitesTermStoreSetsChildrenListChildrenRequest struct {
	ctx _context.Context
	ApiService *SitesStoreApiService
	siteId string
	setId string
	termId string
	top *int32
	skip *int32
	search *string
	filter *string
	count *bool
	orderby *[]string
	select_ *[]string
	expand *[]string
}

// Show only the first n items
func (r ApiSitesTermStoreSetsChildrenListChildrenRequest) Top(top int32) ApiSitesTermStoreSetsChildrenListChildrenRequest {
	r.top = &top
	return r
}
// Skip the first n items
func (r ApiSitesTermStoreSetsChildrenListChildrenRequest) Skip(skip int32) ApiSitesTermStoreSetsChildrenListChildrenRequest {
	r.skip = &skip
	return r
}
// Search items by search phrases
func (r ApiSitesTermStoreSetsChildrenListChildrenRequest) Search(search string) ApiSitesTermStoreSetsChildrenListChildrenRequest {
	r.search = &search
	return r
}
// Filter items by property values
func (r ApiSitesTermStoreSetsChildrenListChildrenRequest) Filter(filter string) ApiSitesTermStoreSetsChildrenListChildrenRequest {
	r.filter = &filter
	return r
}
// Include count of items
func (r ApiSitesTermStoreSetsChildrenListChildrenRequest) Count(count bool) ApiSitesTermStoreSetsChildrenListChildrenRequest {
	r.count = &count
	return r
}
// Order items by property values
func (r ApiSitesTermStoreSetsChildrenListChildrenRequest) Orderby(orderby []string) ApiSitesTermStoreSetsChildrenListChildrenRequest {
	r.orderby = &orderby
	return r
}
// Select properties to be returned
func (r ApiSitesTermStoreSetsChildrenListChildrenRequest) Select_(select_ []string) ApiSitesTermStoreSetsChildrenListChildrenRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiSitesTermStoreSetsChildrenListChildrenRequest) Expand(expand []string) ApiSitesTermStoreSetsChildrenListChildrenRequest {
	r.expand = &expand
	return r
}

func (r ApiSitesTermStoreSetsChildrenListChildrenRequest) Execute() (CollectionOfTerm, *_nethttp.Response, error) {
	return r.ApiService.SitesTermStoreSetsChildrenListChildrenExecute(r)
}

/*
SitesTermStoreSetsChildrenListChildren Get children from sites

Children of current term.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param siteId key: id of site
 @param setId key: id of set
 @param termId key: id of term
 @return ApiSitesTermStoreSetsChildrenListChildrenRequest
*/
func (a *SitesStoreApiService) SitesTermStoreSetsChildrenListChildren(ctx _context.Context, siteId string, setId string, termId string) ApiSitesTermStoreSetsChildrenListChildrenRequest {
	return ApiSitesTermStoreSetsChildrenListChildrenRequest{
		ApiService: a,
		ctx: ctx,
		siteId: siteId,
		setId: setId,
		termId: termId,
	}
}

// Execute executes the request
//  @return CollectionOfTerm
func (a *SitesStoreApiService) SitesTermStoreSetsChildrenListChildrenExecute(r ApiSitesTermStoreSetsChildrenListChildrenRequest) (CollectionOfTerm, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  CollectionOfTerm
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SitesStoreApiService.SitesTermStoreSetsChildrenListChildren")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sites/{site-id}/termStore/sets/{set-id}/children/{term-id}/children"
	localVarPath = strings.Replace(localVarPath, "{"+"site-id"+"}", _neturl.PathEscape(parameterToString(r.siteId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"set-id"+"}", _neturl.PathEscape(parameterToString(r.setId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"term-id"+"}", _neturl.PathEscape(parameterToString(r.termId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.top != nil {
		localVarQueryParams.Add("$top", parameterToString(*r.top, ""))
	}
	if r.skip != nil {
		localVarQueryParams.Add("$skip", parameterToString(*r.skip, ""))
	}
	if r.search != nil {
		localVarQueryParams.Add("$search", parameterToString(*r.search, ""))
	}
	if r.filter != nil {
		localVarQueryParams.Add("$filter", parameterToString(*r.filter, ""))
	}
	if r.count != nil {
		localVarQueryParams.Add("$count", parameterToString(*r.count, ""))
	}
	if r.orderby != nil {
		localVarQueryParams.Add("$orderby", parameterToString(*r.orderby, "csv"))
	}
	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSitesTermStoreSetsChildrenListRelationsRequest struct {
	ctx _context.Context
	ApiService *SitesStoreApiService
	siteId string
	setId string
	termId string
	top *int32
	skip *int32
	search *string
	filter *string
	count *bool
	orderby *[]string
	select_ *[]string
	expand *[]string
}

// Show only the first n items
func (r ApiSitesTermStoreSetsChildrenListRelationsRequest) Top(top int32) ApiSitesTermStoreSetsChildrenListRelationsRequest {
	r.top = &top
	return r
}
// Skip the first n items
func (r ApiSitesTermStoreSetsChildrenListRelationsRequest) Skip(skip int32) ApiSitesTermStoreSetsChildrenListRelationsRequest {
	r.skip = &skip
	return r
}
// Search items by search phrases
func (r ApiSitesTermStoreSetsChildrenListRelationsRequest) Search(search string) ApiSitesTermStoreSetsChildrenListRelationsRequest {
	r.search = &search
	return r
}
// Filter items by property values
func (r ApiSitesTermStoreSetsChildrenListRelationsRequest) Filter(filter string) ApiSitesTermStoreSetsChildrenListRelationsRequest {
	r.filter = &filter
	return r
}
// Include count of items
func (r ApiSitesTermStoreSetsChildrenListRelationsRequest) Count(count bool) ApiSitesTermStoreSetsChildrenListRelationsRequest {
	r.count = &count
	return r
}
// Order items by property values
func (r ApiSitesTermStoreSetsChildrenListRelationsRequest) Orderby(orderby []string) ApiSitesTermStoreSetsChildrenListRelationsRequest {
	r.orderby = &orderby
	return r
}
// Select properties to be returned
func (r ApiSitesTermStoreSetsChildrenListRelationsRequest) Select_(select_ []string) ApiSitesTermStoreSetsChildrenListRelationsRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiSitesTermStoreSetsChildrenListRelationsRequest) Expand(expand []string) ApiSitesTermStoreSetsChildrenListRelationsRequest {
	r.expand = &expand
	return r
}

func (r ApiSitesTermStoreSetsChildrenListRelationsRequest) Execute() (CollectionOfRelation, *_nethttp.Response, error) {
	return r.ApiService.SitesTermStoreSetsChildrenListRelationsExecute(r)
}

/*
SitesTermStoreSetsChildrenListRelations Get relations from sites

To indicate which terms are related to the current term as either pinned or reused.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param siteId key: id of site
 @param setId key: id of set
 @param termId key: id of term
 @return ApiSitesTermStoreSetsChildrenListRelationsRequest
*/
func (a *SitesStoreApiService) SitesTermStoreSetsChildrenListRelations(ctx _context.Context, siteId string, setId string, termId string) ApiSitesTermStoreSetsChildrenListRelationsRequest {
	return ApiSitesTermStoreSetsChildrenListRelationsRequest{
		ApiService: a,
		ctx: ctx,
		siteId: siteId,
		setId: setId,
		termId: termId,
	}
}

// Execute executes the request
//  @return CollectionOfRelation
func (a *SitesStoreApiService) SitesTermStoreSetsChildrenListRelationsExecute(r ApiSitesTermStoreSetsChildrenListRelationsRequest) (CollectionOfRelation, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  CollectionOfRelation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SitesStoreApiService.SitesTermStoreSetsChildrenListRelations")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sites/{site-id}/termStore/sets/{set-id}/children/{term-id}/relations"
	localVarPath = strings.Replace(localVarPath, "{"+"site-id"+"}", _neturl.PathEscape(parameterToString(r.siteId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"set-id"+"}", _neturl.PathEscape(parameterToString(r.setId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"term-id"+"}", _neturl.PathEscape(parameterToString(r.termId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.top != nil {
		localVarQueryParams.Add("$top", parameterToString(*r.top, ""))
	}
	if r.skip != nil {
		localVarQueryParams.Add("$skip", parameterToString(*r.skip, ""))
	}
	if r.search != nil {
		localVarQueryParams.Add("$search", parameterToString(*r.search, ""))
	}
	if r.filter != nil {
		localVarQueryParams.Add("$filter", parameterToString(*r.filter, ""))
	}
	if r.count != nil {
		localVarQueryParams.Add("$count", parameterToString(*r.count, ""))
	}
	if r.orderby != nil {
		localVarQueryParams.Add("$orderby", parameterToString(*r.orderby, "csv"))
	}
	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSitesTermStoreSetsChildrenRelationsDeleteRefFromTermRequest struct {
	ctx _context.Context
	ApiService *SitesStoreApiService
	siteId string
	setId string
	termId string
	relationId string
	ifMatch *string
}

// ETag
func (r ApiSitesTermStoreSetsChildrenRelationsDeleteRefFromTermRequest) IfMatch(ifMatch string) ApiSitesTermStoreSetsChildrenRelationsDeleteRefFromTermRequest {
	r.ifMatch = &ifMatch
	return r
}

func (r ApiSitesTermStoreSetsChildrenRelationsDeleteRefFromTermRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.SitesTermStoreSetsChildrenRelationsDeleteRefFromTermExecute(r)
}

/*
SitesTermStoreSetsChildrenRelationsDeleteRefFromTerm Delete ref of navigation property fromTerm for sites

The from [term] of the relation. The term from which the relationship is defined. A null value would indicate the relation is directly with the [set].

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param siteId key: id of site
 @param setId key: id of set
 @param termId key: id of term
 @param relationId key: id of relation
 @return ApiSitesTermStoreSetsChildrenRelationsDeleteRefFromTermRequest
*/
func (a *SitesStoreApiService) SitesTermStoreSetsChildrenRelationsDeleteRefFromTerm(ctx _context.Context, siteId string, setId string, termId string, relationId string) ApiSitesTermStoreSetsChildrenRelationsDeleteRefFromTermRequest {
	return ApiSitesTermStoreSetsChildrenRelationsDeleteRefFromTermRequest{
		ApiService: a,
		ctx: ctx,
		siteId: siteId,
		setId: setId,
		termId: termId,
		relationId: relationId,
	}
}

// Execute executes the request
func (a *SitesStoreApiService) SitesTermStoreSetsChildrenRelationsDeleteRefFromTermExecute(r ApiSitesTermStoreSetsChildrenRelationsDeleteRefFromTermRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SitesStoreApiService.SitesTermStoreSetsChildrenRelationsDeleteRefFromTerm")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sites/{site-id}/termStore/sets/{set-id}/children/{term-id}/relations/{relation-id}/fromTerm/$ref"
	localVarPath = strings.Replace(localVarPath, "{"+"site-id"+"}", _neturl.PathEscape(parameterToString(r.siteId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"set-id"+"}", _neturl.PathEscape(parameterToString(r.setId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"term-id"+"}", _neturl.PathEscape(parameterToString(r.termId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"relation-id"+"}", _neturl.PathEscape(parameterToString(r.relationId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ifMatch != nil {
		localVarHeaderParams["If-Match"] = parameterToString(*r.ifMatch, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiSitesTermStoreSetsChildrenRelationsDeleteRefSetRequest struct {
	ctx _context.Context
	ApiService *SitesStoreApiService
	siteId string
	setId string
	termId string
	relationId string
	ifMatch *string
}

// ETag
func (r ApiSitesTermStoreSetsChildrenRelationsDeleteRefSetRequest) IfMatch(ifMatch string) ApiSitesTermStoreSetsChildrenRelationsDeleteRefSetRequest {
	r.ifMatch = &ifMatch
	return r
}

func (r ApiSitesTermStoreSetsChildrenRelationsDeleteRefSetRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.SitesTermStoreSetsChildrenRelationsDeleteRefSetExecute(r)
}

/*
SitesTermStoreSetsChildrenRelationsDeleteRefSet Delete ref of navigation property set for sites

The [set] in which the relation is relevant.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param siteId key: id of site
 @param setId key: id of set
 @param termId key: id of term
 @param relationId key: id of relation
 @return ApiSitesTermStoreSetsChildrenRelationsDeleteRefSetRequest
*/
func (a *SitesStoreApiService) SitesTermStoreSetsChildrenRelationsDeleteRefSet(ctx _context.Context, siteId string, setId string, termId string, relationId string) ApiSitesTermStoreSetsChildrenRelationsDeleteRefSetRequest {
	return ApiSitesTermStoreSetsChildrenRelationsDeleteRefSetRequest{
		ApiService: a,
		ctx: ctx,
		siteId: siteId,
		setId: setId,
		termId: termId,
		relationId: relationId,
	}
}

// Execute executes the request
func (a *SitesStoreApiService) SitesTermStoreSetsChildrenRelationsDeleteRefSetExecute(r ApiSitesTermStoreSetsChildrenRelationsDeleteRefSetRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SitesStoreApiService.SitesTermStoreSetsChildrenRelationsDeleteRefSet")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sites/{site-id}/termStore/sets/{set-id}/children/{term-id}/relations/{relation-id}/set/$ref"
	localVarPath = strings.Replace(localVarPath, "{"+"site-id"+"}", _neturl.PathEscape(parameterToString(r.siteId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"set-id"+"}", _neturl.PathEscape(parameterToString(r.setId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"term-id"+"}", _neturl.PathEscape(parameterToString(r.termId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"relation-id"+"}", _neturl.PathEscape(parameterToString(r.relationId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ifMatch != nil {
		localVarHeaderParams["If-Match"] = parameterToString(*r.ifMatch, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiSitesTermStoreSetsChildrenRelationsDeleteRefToTermRequest struct {
	ctx _context.Context
	ApiService *SitesStoreApiService
	siteId string
	setId string
	termId string
	relationId string
	ifMatch *string
}

// ETag
func (r ApiSitesTermStoreSetsChildrenRelationsDeleteRefToTermRequest) IfMatch(ifMatch string) ApiSitesTermStoreSetsChildrenRelationsDeleteRefToTermRequest {
	r.ifMatch = &ifMatch
	return r
}

func (r ApiSitesTermStoreSetsChildrenRelationsDeleteRefToTermRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.SitesTermStoreSetsChildrenRelationsDeleteRefToTermExecute(r)
}

/*
SitesTermStoreSetsChildrenRelationsDeleteRefToTerm Delete ref of navigation property toTerm for sites

The to [term] of the relation. The term to which the relationship is defined.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param siteId key: id of site
 @param setId key: id of set
 @param termId key: id of term
 @param relationId key: id of relation
 @return ApiSitesTermStoreSetsChildrenRelationsDeleteRefToTermRequest
*/
func (a *SitesStoreApiService) SitesTermStoreSetsChildrenRelationsDeleteRefToTerm(ctx _context.Context, siteId string, setId string, termId string, relationId string) ApiSitesTermStoreSetsChildrenRelationsDeleteRefToTermRequest {
	return ApiSitesTermStoreSetsChildrenRelationsDeleteRefToTermRequest{
		ApiService: a,
		ctx: ctx,
		siteId: siteId,
		setId: setId,
		termId: termId,
		relationId: relationId,
	}
}

// Execute executes the request
func (a *SitesStoreApiService) SitesTermStoreSetsChildrenRelationsDeleteRefToTermExecute(r ApiSitesTermStoreSetsChildrenRelationsDeleteRefToTermRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SitesStoreApiService.SitesTermStoreSetsChildrenRelationsDeleteRefToTerm")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sites/{site-id}/termStore/sets/{set-id}/children/{term-id}/relations/{relation-id}/toTerm/$ref"
	localVarPath = strings.Replace(localVarPath, "{"+"site-id"+"}", _neturl.PathEscape(parameterToString(r.siteId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"set-id"+"}", _neturl.PathEscape(parameterToString(r.setId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"term-id"+"}", _neturl.PathEscape(parameterToString(r.termId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"relation-id"+"}", _neturl.PathEscape(parameterToString(r.relationId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ifMatch != nil {
		localVarHeaderParams["If-Match"] = parameterToString(*r.ifMatch, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiSitesTermStoreSetsChildrenRelationsGetFromTermRequest struct {
	ctx _context.Context
	ApiService *SitesStoreApiService
	siteId string
	setId string
	termId string
	relationId string
	select_ *[]string
	expand *[]string
}

// Select properties to be returned
func (r ApiSitesTermStoreSetsChildrenRelationsGetFromTermRequest) Select_(select_ []string) ApiSitesTermStoreSetsChildrenRelationsGetFromTermRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiSitesTermStoreSetsChildrenRelationsGetFromTermRequest) Expand(expand []string) ApiSitesTermStoreSetsChildrenRelationsGetFromTermRequest {
	r.expand = &expand
	return r
}

func (r ApiSitesTermStoreSetsChildrenRelationsGetFromTermRequest) Execute() (MicrosoftGraphTermStoreTerm, *_nethttp.Response, error) {
	return r.ApiService.SitesTermStoreSetsChildrenRelationsGetFromTermExecute(r)
}

/*
SitesTermStoreSetsChildrenRelationsGetFromTerm Get fromTerm from sites

The from [term] of the relation. The term from which the relationship is defined. A null value would indicate the relation is directly with the [set].

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param siteId key: id of site
 @param setId key: id of set
 @param termId key: id of term
 @param relationId key: id of relation
 @return ApiSitesTermStoreSetsChildrenRelationsGetFromTermRequest
*/
func (a *SitesStoreApiService) SitesTermStoreSetsChildrenRelationsGetFromTerm(ctx _context.Context, siteId string, setId string, termId string, relationId string) ApiSitesTermStoreSetsChildrenRelationsGetFromTermRequest {
	return ApiSitesTermStoreSetsChildrenRelationsGetFromTermRequest{
		ApiService: a,
		ctx: ctx,
		siteId: siteId,
		setId: setId,
		termId: termId,
		relationId: relationId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphTermStoreTerm
func (a *SitesStoreApiService) SitesTermStoreSetsChildrenRelationsGetFromTermExecute(r ApiSitesTermStoreSetsChildrenRelationsGetFromTermRequest) (MicrosoftGraphTermStoreTerm, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphTermStoreTerm
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SitesStoreApiService.SitesTermStoreSetsChildrenRelationsGetFromTerm")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sites/{site-id}/termStore/sets/{set-id}/children/{term-id}/relations/{relation-id}/fromTerm"
	localVarPath = strings.Replace(localVarPath, "{"+"site-id"+"}", _neturl.PathEscape(parameterToString(r.siteId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"set-id"+"}", _neturl.PathEscape(parameterToString(r.setId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"term-id"+"}", _neturl.PathEscape(parameterToString(r.termId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"relation-id"+"}", _neturl.PathEscape(parameterToString(r.relationId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSitesTermStoreSetsChildrenRelationsGetRefFromTermRequest struct {
	ctx _context.Context
	ApiService *SitesStoreApiService
	siteId string
	setId string
	termId string
	relationId string
}


func (r ApiSitesTermStoreSetsChildrenRelationsGetRefFromTermRequest) Execute() (string, *_nethttp.Response, error) {
	return r.ApiService.SitesTermStoreSetsChildrenRelationsGetRefFromTermExecute(r)
}

/*
SitesTermStoreSetsChildrenRelationsGetRefFromTerm Get ref of fromTerm from sites

The from [term] of the relation. The term from which the relationship is defined. A null value would indicate the relation is directly with the [set].

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param siteId key: id of site
 @param setId key: id of set
 @param termId key: id of term
 @param relationId key: id of relation
 @return ApiSitesTermStoreSetsChildrenRelationsGetRefFromTermRequest
*/
func (a *SitesStoreApiService) SitesTermStoreSetsChildrenRelationsGetRefFromTerm(ctx _context.Context, siteId string, setId string, termId string, relationId string) ApiSitesTermStoreSetsChildrenRelationsGetRefFromTermRequest {
	return ApiSitesTermStoreSetsChildrenRelationsGetRefFromTermRequest{
		ApiService: a,
		ctx: ctx,
		siteId: siteId,
		setId: setId,
		termId: termId,
		relationId: relationId,
	}
}

// Execute executes the request
//  @return string
func (a *SitesStoreApiService) SitesTermStoreSetsChildrenRelationsGetRefFromTermExecute(r ApiSitesTermStoreSetsChildrenRelationsGetRefFromTermRequest) (string, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  string
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SitesStoreApiService.SitesTermStoreSetsChildrenRelationsGetRefFromTerm")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sites/{site-id}/termStore/sets/{set-id}/children/{term-id}/relations/{relation-id}/fromTerm/$ref"
	localVarPath = strings.Replace(localVarPath, "{"+"site-id"+"}", _neturl.PathEscape(parameterToString(r.siteId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"set-id"+"}", _neturl.PathEscape(parameterToString(r.setId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"term-id"+"}", _neturl.PathEscape(parameterToString(r.termId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"relation-id"+"}", _neturl.PathEscape(parameterToString(r.relationId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSitesTermStoreSetsChildrenRelationsGetRefSetRequest struct {
	ctx _context.Context
	ApiService *SitesStoreApiService
	siteId string
	setId string
	termId string
	relationId string
}


func (r ApiSitesTermStoreSetsChildrenRelationsGetRefSetRequest) Execute() (string, *_nethttp.Response, error) {
	return r.ApiService.SitesTermStoreSetsChildrenRelationsGetRefSetExecute(r)
}

/*
SitesTermStoreSetsChildrenRelationsGetRefSet Get ref of set from sites

The [set] in which the relation is relevant.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param siteId key: id of site
 @param setId key: id of set
 @param termId key: id of term
 @param relationId key: id of relation
 @return ApiSitesTermStoreSetsChildrenRelationsGetRefSetRequest
*/
func (a *SitesStoreApiService) SitesTermStoreSetsChildrenRelationsGetRefSet(ctx _context.Context, siteId string, setId string, termId string, relationId string) ApiSitesTermStoreSetsChildrenRelationsGetRefSetRequest {
	return ApiSitesTermStoreSetsChildrenRelationsGetRefSetRequest{
		ApiService: a,
		ctx: ctx,
		siteId: siteId,
		setId: setId,
		termId: termId,
		relationId: relationId,
	}
}

// Execute executes the request
//  @return string
func (a *SitesStoreApiService) SitesTermStoreSetsChildrenRelationsGetRefSetExecute(r ApiSitesTermStoreSetsChildrenRelationsGetRefSetRequest) (string, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  string
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SitesStoreApiService.SitesTermStoreSetsChildrenRelationsGetRefSet")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sites/{site-id}/termStore/sets/{set-id}/children/{term-id}/relations/{relation-id}/set/$ref"
	localVarPath = strings.Replace(localVarPath, "{"+"site-id"+"}", _neturl.PathEscape(parameterToString(r.siteId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"set-id"+"}", _neturl.PathEscape(parameterToString(r.setId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"term-id"+"}", _neturl.PathEscape(parameterToString(r.termId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"relation-id"+"}", _neturl.PathEscape(parameterToString(r.relationId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSitesTermStoreSetsChildrenRelationsGetRefToTermRequest struct {
	ctx _context.Context
	ApiService *SitesStoreApiService
	siteId string
	setId string
	termId string
	relationId string
}


func (r ApiSitesTermStoreSetsChildrenRelationsGetRefToTermRequest) Execute() (string, *_nethttp.Response, error) {
	return r.ApiService.SitesTermStoreSetsChildrenRelationsGetRefToTermExecute(r)
}

/*
SitesTermStoreSetsChildrenRelationsGetRefToTerm Get ref of toTerm from sites

The to [term] of the relation. The term to which the relationship is defined.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param siteId key: id of site
 @param setId key: id of set
 @param termId key: id of term
 @param relationId key: id of relation
 @return ApiSitesTermStoreSetsChildrenRelationsGetRefToTermRequest
*/
func (a *SitesStoreApiService) SitesTermStoreSetsChildrenRelationsGetRefToTerm(ctx _context.Context, siteId string, setId string, termId string, relationId string) ApiSitesTermStoreSetsChildrenRelationsGetRefToTermRequest {
	return ApiSitesTermStoreSetsChildrenRelationsGetRefToTermRequest{
		ApiService: a,
		ctx: ctx,
		siteId: siteId,
		setId: setId,
		termId: termId,
		relationId: relationId,
	}
}

// Execute executes the request
//  @return string
func (a *SitesStoreApiService) SitesTermStoreSetsChildrenRelationsGetRefToTermExecute(r ApiSitesTermStoreSetsChildrenRelationsGetRefToTermRequest) (string, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  string
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SitesStoreApiService.SitesTermStoreSetsChildrenRelationsGetRefToTerm")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sites/{site-id}/termStore/sets/{set-id}/children/{term-id}/relations/{relation-id}/toTerm/$ref"
	localVarPath = strings.Replace(localVarPath, "{"+"site-id"+"}", _neturl.PathEscape(parameterToString(r.siteId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"set-id"+"}", _neturl.PathEscape(parameterToString(r.setId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"term-id"+"}", _neturl.PathEscape(parameterToString(r.termId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"relation-id"+"}", _neturl.PathEscape(parameterToString(r.relationId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSitesTermStoreSetsChildrenRelationsGetSetRequest struct {
	ctx _context.Context
	ApiService *SitesStoreApiService
	siteId string
	setId string
	termId string
	relationId string
	select_ *[]string
	expand *[]string
}

// Select properties to be returned
func (r ApiSitesTermStoreSetsChildrenRelationsGetSetRequest) Select_(select_ []string) ApiSitesTermStoreSetsChildrenRelationsGetSetRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiSitesTermStoreSetsChildrenRelationsGetSetRequest) Expand(expand []string) ApiSitesTermStoreSetsChildrenRelationsGetSetRequest {
	r.expand = &expand
	return r
}

func (r ApiSitesTermStoreSetsChildrenRelationsGetSetRequest) Execute() (MicrosoftGraphTermStoreSet, *_nethttp.Response, error) {
	return r.ApiService.SitesTermStoreSetsChildrenRelationsGetSetExecute(r)
}

/*
SitesTermStoreSetsChildrenRelationsGetSet Get set from sites

The [set] in which the relation is relevant.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param siteId key: id of site
 @param setId key: id of set
 @param termId key: id of term
 @param relationId key: id of relation
 @return ApiSitesTermStoreSetsChildrenRelationsGetSetRequest
*/
func (a *SitesStoreApiService) SitesTermStoreSetsChildrenRelationsGetSet(ctx _context.Context, siteId string, setId string, termId string, relationId string) ApiSitesTermStoreSetsChildrenRelationsGetSetRequest {
	return ApiSitesTermStoreSetsChildrenRelationsGetSetRequest{
		ApiService: a,
		ctx: ctx,
		siteId: siteId,
		setId: setId,
		termId: termId,
		relationId: relationId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphTermStoreSet
func (a *SitesStoreApiService) SitesTermStoreSetsChildrenRelationsGetSetExecute(r ApiSitesTermStoreSetsChildrenRelationsGetSetRequest) (MicrosoftGraphTermStoreSet, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphTermStoreSet
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SitesStoreApiService.SitesTermStoreSetsChildrenRelationsGetSet")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sites/{site-id}/termStore/sets/{set-id}/children/{term-id}/relations/{relation-id}/set"
	localVarPath = strings.Replace(localVarPath, "{"+"site-id"+"}", _neturl.PathEscape(parameterToString(r.siteId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"set-id"+"}", _neturl.PathEscape(parameterToString(r.setId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"term-id"+"}", _neturl.PathEscape(parameterToString(r.termId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"relation-id"+"}", _neturl.PathEscape(parameterToString(r.relationId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSitesTermStoreSetsChildrenRelationsGetToTermRequest struct {
	ctx _context.Context
	ApiService *SitesStoreApiService
	siteId string
	setId string
	termId string
	relationId string
	select_ *[]string
	expand *[]string
}

// Select properties to be returned
func (r ApiSitesTermStoreSetsChildrenRelationsGetToTermRequest) Select_(select_ []string) ApiSitesTermStoreSetsChildrenRelationsGetToTermRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiSitesTermStoreSetsChildrenRelationsGetToTermRequest) Expand(expand []string) ApiSitesTermStoreSetsChildrenRelationsGetToTermRequest {
	r.expand = &expand
	return r
}

func (r ApiSitesTermStoreSetsChildrenRelationsGetToTermRequest) Execute() (MicrosoftGraphTermStoreTerm, *_nethttp.Response, error) {
	return r.ApiService.SitesTermStoreSetsChildrenRelationsGetToTermExecute(r)
}

/*
SitesTermStoreSetsChildrenRelationsGetToTerm Get toTerm from sites

The to [term] of the relation. The term to which the relationship is defined.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param siteId key: id of site
 @param setId key: id of set
 @param termId key: id of term
 @param relationId key: id of relation
 @return ApiSitesTermStoreSetsChildrenRelationsGetToTermRequest
*/
func (a *SitesStoreApiService) SitesTermStoreSetsChildrenRelationsGetToTerm(ctx _context.Context, siteId string, setId string, termId string, relationId string) ApiSitesTermStoreSetsChildrenRelationsGetToTermRequest {
	return ApiSitesTermStoreSetsChildrenRelationsGetToTermRequest{
		ApiService: a,
		ctx: ctx,
		siteId: siteId,
		setId: setId,
		termId: termId,
		relationId: relationId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphTermStoreTerm
func (a *SitesStoreApiService) SitesTermStoreSetsChildrenRelationsGetToTermExecute(r ApiSitesTermStoreSetsChildrenRelationsGetToTermRequest) (MicrosoftGraphTermStoreTerm, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphTermStoreTerm
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SitesStoreApiService.SitesTermStoreSetsChildrenRelationsGetToTerm")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sites/{site-id}/termStore/sets/{set-id}/children/{term-id}/relations/{relation-id}/toTerm"
	localVarPath = strings.Replace(localVarPath, "{"+"site-id"+"}", _neturl.PathEscape(parameterToString(r.siteId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"set-id"+"}", _neturl.PathEscape(parameterToString(r.setId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"term-id"+"}", _neturl.PathEscape(parameterToString(r.termId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"relation-id"+"}", _neturl.PathEscape(parameterToString(r.relationId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSitesTermStoreSetsChildrenRelationsUpdateRefFromTermRequest struct {
	ctx _context.Context
	ApiService *SitesStoreApiService
	siteId string
	setId string
	termId string
	relationId string
	requestBody *map[string]map[string]interface{}
}

// New navigation property ref values
func (r ApiSitesTermStoreSetsChildrenRelationsUpdateRefFromTermRequest) RequestBody(requestBody map[string]map[string]interface{}) ApiSitesTermStoreSetsChildrenRelationsUpdateRefFromTermRequest {
	r.requestBody = &requestBody
	return r
}

func (r ApiSitesTermStoreSetsChildrenRelationsUpdateRefFromTermRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.SitesTermStoreSetsChildrenRelationsUpdateRefFromTermExecute(r)
}

/*
SitesTermStoreSetsChildrenRelationsUpdateRefFromTerm Update the ref of navigation property fromTerm in sites

The from [term] of the relation. The term from which the relationship is defined. A null value would indicate the relation is directly with the [set].

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param siteId key: id of site
 @param setId key: id of set
 @param termId key: id of term
 @param relationId key: id of relation
 @return ApiSitesTermStoreSetsChildrenRelationsUpdateRefFromTermRequest
*/
func (a *SitesStoreApiService) SitesTermStoreSetsChildrenRelationsUpdateRefFromTerm(ctx _context.Context, siteId string, setId string, termId string, relationId string) ApiSitesTermStoreSetsChildrenRelationsUpdateRefFromTermRequest {
	return ApiSitesTermStoreSetsChildrenRelationsUpdateRefFromTermRequest{
		ApiService: a,
		ctx: ctx,
		siteId: siteId,
		setId: setId,
		termId: termId,
		relationId: relationId,
	}
}

// Execute executes the request
func (a *SitesStoreApiService) SitesTermStoreSetsChildrenRelationsUpdateRefFromTermExecute(r ApiSitesTermStoreSetsChildrenRelationsUpdateRefFromTermRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPut
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SitesStoreApiService.SitesTermStoreSetsChildrenRelationsUpdateRefFromTerm")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sites/{site-id}/termStore/sets/{set-id}/children/{term-id}/relations/{relation-id}/fromTerm/$ref"
	localVarPath = strings.Replace(localVarPath, "{"+"site-id"+"}", _neturl.PathEscape(parameterToString(r.siteId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"set-id"+"}", _neturl.PathEscape(parameterToString(r.setId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"term-id"+"}", _neturl.PathEscape(parameterToString(r.termId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"relation-id"+"}", _neturl.PathEscape(parameterToString(r.relationId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.requestBody == nil {
		return nil, reportError("requestBody is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.requestBody
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiSitesTermStoreSetsChildrenRelationsUpdateRefSetRequest struct {
	ctx _context.Context
	ApiService *SitesStoreApiService
	siteId string
	setId string
	termId string
	relationId string
	requestBody *map[string]map[string]interface{}
}

// New navigation property ref values
func (r ApiSitesTermStoreSetsChildrenRelationsUpdateRefSetRequest) RequestBody(requestBody map[string]map[string]interface{}) ApiSitesTermStoreSetsChildrenRelationsUpdateRefSetRequest {
	r.requestBody = &requestBody
	return r
}

func (r ApiSitesTermStoreSetsChildrenRelationsUpdateRefSetRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.SitesTermStoreSetsChildrenRelationsUpdateRefSetExecute(r)
}

/*
SitesTermStoreSetsChildrenRelationsUpdateRefSet Update the ref of navigation property set in sites

The [set] in which the relation is relevant.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param siteId key: id of site
 @param setId key: id of set
 @param termId key: id of term
 @param relationId key: id of relation
 @return ApiSitesTermStoreSetsChildrenRelationsUpdateRefSetRequest
*/
func (a *SitesStoreApiService) SitesTermStoreSetsChildrenRelationsUpdateRefSet(ctx _context.Context, siteId string, setId string, termId string, relationId string) ApiSitesTermStoreSetsChildrenRelationsUpdateRefSetRequest {
	return ApiSitesTermStoreSetsChildrenRelationsUpdateRefSetRequest{
		ApiService: a,
		ctx: ctx,
		siteId: siteId,
		setId: setId,
		termId: termId,
		relationId: relationId,
	}
}

// Execute executes the request
func (a *SitesStoreApiService) SitesTermStoreSetsChildrenRelationsUpdateRefSetExecute(r ApiSitesTermStoreSetsChildrenRelationsUpdateRefSetRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPut
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SitesStoreApiService.SitesTermStoreSetsChildrenRelationsUpdateRefSet")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sites/{site-id}/termStore/sets/{set-id}/children/{term-id}/relations/{relation-id}/set/$ref"
	localVarPath = strings.Replace(localVarPath, "{"+"site-id"+"}", _neturl.PathEscape(parameterToString(r.siteId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"set-id"+"}", _neturl.PathEscape(parameterToString(r.setId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"term-id"+"}", _neturl.PathEscape(parameterToString(r.termId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"relation-id"+"}", _neturl.PathEscape(parameterToString(r.relationId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.requestBody == nil {
		return nil, reportError("requestBody is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.requestBody
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiSitesTermStoreSetsChildrenRelationsUpdateRefToTermRequest struct {
	ctx _context.Context
	ApiService *SitesStoreApiService
	siteId string
	setId string
	termId string
	relationId string
	requestBody *map[string]map[string]interface{}
}

// New navigation property ref values
func (r ApiSitesTermStoreSetsChildrenRelationsUpdateRefToTermRequest) RequestBody(requestBody map[string]map[string]interface{}) ApiSitesTermStoreSetsChildrenRelationsUpdateRefToTermRequest {
	r.requestBody = &requestBody
	return r
}

func (r ApiSitesTermStoreSetsChildrenRelationsUpdateRefToTermRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.SitesTermStoreSetsChildrenRelationsUpdateRefToTermExecute(r)
}

/*
SitesTermStoreSetsChildrenRelationsUpdateRefToTerm Update the ref of navigation property toTerm in sites

The to [term] of the relation. The term to which the relationship is defined.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param siteId key: id of site
 @param setId key: id of set
 @param termId key: id of term
 @param relationId key: id of relation
 @return ApiSitesTermStoreSetsChildrenRelationsUpdateRefToTermRequest
*/
func (a *SitesStoreApiService) SitesTermStoreSetsChildrenRelationsUpdateRefToTerm(ctx _context.Context, siteId string, setId string, termId string, relationId string) ApiSitesTermStoreSetsChildrenRelationsUpdateRefToTermRequest {
	return ApiSitesTermStoreSetsChildrenRelationsUpdateRefToTermRequest{
		ApiService: a,
		ctx: ctx,
		siteId: siteId,
		setId: setId,
		termId: termId,
		relationId: relationId,
	}
}

// Execute executes the request
func (a *SitesStoreApiService) SitesTermStoreSetsChildrenRelationsUpdateRefToTermExecute(r ApiSitesTermStoreSetsChildrenRelationsUpdateRefToTermRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPut
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SitesStoreApiService.SitesTermStoreSetsChildrenRelationsUpdateRefToTerm")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sites/{site-id}/termStore/sets/{set-id}/children/{term-id}/relations/{relation-id}/toTerm/$ref"
	localVarPath = strings.Replace(localVarPath, "{"+"site-id"+"}", _neturl.PathEscape(parameterToString(r.siteId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"set-id"+"}", _neturl.PathEscape(parameterToString(r.setId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"term-id"+"}", _neturl.PathEscape(parameterToString(r.termId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"relation-id"+"}", _neturl.PathEscape(parameterToString(r.relationId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.requestBody == nil {
		return nil, reportError("requestBody is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.requestBody
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiSitesTermStoreSetsChildrenUpdateChildrenRequest struct {
	ctx _context.Context
	ApiService *SitesStoreApiService
	siteId string
	setId string
	termId string
	termId1 string
	microsoftGraphTermStoreTerm *MicrosoftGraphTermStoreTerm
}

// New navigation property values
func (r ApiSitesTermStoreSetsChildrenUpdateChildrenRequest) MicrosoftGraphTermStoreTerm(microsoftGraphTermStoreTerm MicrosoftGraphTermStoreTerm) ApiSitesTermStoreSetsChildrenUpdateChildrenRequest {
	r.microsoftGraphTermStoreTerm = &microsoftGraphTermStoreTerm
	return r
}

func (r ApiSitesTermStoreSetsChildrenUpdateChildrenRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.SitesTermStoreSetsChildrenUpdateChildrenExecute(r)
}

/*
SitesTermStoreSetsChildrenUpdateChildren Update the navigation property children in sites

Children of current term.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param siteId key: id of site
 @param setId key: id of set
 @param termId key: id of term
 @param termId1 key: id of term
 @return ApiSitesTermStoreSetsChildrenUpdateChildrenRequest
*/
func (a *SitesStoreApiService) SitesTermStoreSetsChildrenUpdateChildren(ctx _context.Context, siteId string, setId string, termId string, termId1 string) ApiSitesTermStoreSetsChildrenUpdateChildrenRequest {
	return ApiSitesTermStoreSetsChildrenUpdateChildrenRequest{
		ApiService: a,
		ctx: ctx,
		siteId: siteId,
		setId: setId,
		termId: termId,
		termId1: termId1,
	}
}

// Execute executes the request
func (a *SitesStoreApiService) SitesTermStoreSetsChildrenUpdateChildrenExecute(r ApiSitesTermStoreSetsChildrenUpdateChildrenRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPatch
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SitesStoreApiService.SitesTermStoreSetsChildrenUpdateChildren")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sites/{site-id}/termStore/sets/{set-id}/children/{term-id}/children/{term-id1}"
	localVarPath = strings.Replace(localVarPath, "{"+"site-id"+"}", _neturl.PathEscape(parameterToString(r.siteId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"set-id"+"}", _neturl.PathEscape(parameterToString(r.setId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"term-id"+"}", _neturl.PathEscape(parameterToString(r.termId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"term-id1"+"}", _neturl.PathEscape(parameterToString(r.termId1, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphTermStoreTerm == nil {
		return nil, reportError("microsoftGraphTermStoreTerm is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphTermStoreTerm
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiSitesTermStoreSetsChildrenUpdateRefSetRequest struct {
	ctx _context.Context
	ApiService *SitesStoreApiService
	siteId string
	setId string
	termId string
	requestBody *map[string]map[string]interface{}
}

// New navigation property ref values
func (r ApiSitesTermStoreSetsChildrenUpdateRefSetRequest) RequestBody(requestBody map[string]map[string]interface{}) ApiSitesTermStoreSetsChildrenUpdateRefSetRequest {
	r.requestBody = &requestBody
	return r
}

func (r ApiSitesTermStoreSetsChildrenUpdateRefSetRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.SitesTermStoreSetsChildrenUpdateRefSetExecute(r)
}

/*
SitesTermStoreSetsChildrenUpdateRefSet Update the ref of navigation property set in sites

The [set] in which the term is created.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param siteId key: id of site
 @param setId key: id of set
 @param termId key: id of term
 @return ApiSitesTermStoreSetsChildrenUpdateRefSetRequest
*/
func (a *SitesStoreApiService) SitesTermStoreSetsChildrenUpdateRefSet(ctx _context.Context, siteId string, setId string, termId string) ApiSitesTermStoreSetsChildrenUpdateRefSetRequest {
	return ApiSitesTermStoreSetsChildrenUpdateRefSetRequest{
		ApiService: a,
		ctx: ctx,
		siteId: siteId,
		setId: setId,
		termId: termId,
	}
}

// Execute executes the request
func (a *SitesStoreApiService) SitesTermStoreSetsChildrenUpdateRefSetExecute(r ApiSitesTermStoreSetsChildrenUpdateRefSetRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPut
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SitesStoreApiService.SitesTermStoreSetsChildrenUpdateRefSet")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sites/{site-id}/termStore/sets/{set-id}/children/{term-id}/set/$ref"
	localVarPath = strings.Replace(localVarPath, "{"+"site-id"+"}", _neturl.PathEscape(parameterToString(r.siteId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"set-id"+"}", _neturl.PathEscape(parameterToString(r.setId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"term-id"+"}", _neturl.PathEscape(parameterToString(r.termId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.requestBody == nil {
		return nil, reportError("requestBody is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.requestBody
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiSitesTermStoreSetsChildrenUpdateRelationsRequest struct {
	ctx _context.Context
	ApiService *SitesStoreApiService
	siteId string
	setId string
	termId string
	relationId string
	microsoftGraphTermStoreRelation *MicrosoftGraphTermStoreRelation
}

// New navigation property values
func (r ApiSitesTermStoreSetsChildrenUpdateRelationsRequest) MicrosoftGraphTermStoreRelation(microsoftGraphTermStoreRelation MicrosoftGraphTermStoreRelation) ApiSitesTermStoreSetsChildrenUpdateRelationsRequest {
	r.microsoftGraphTermStoreRelation = &microsoftGraphTermStoreRelation
	return r
}

func (r ApiSitesTermStoreSetsChildrenUpdateRelationsRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.SitesTermStoreSetsChildrenUpdateRelationsExecute(r)
}

/*
SitesTermStoreSetsChildrenUpdateRelations Update the navigation property relations in sites

To indicate which terms are related to the current term as either pinned or reused.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param siteId key: id of site
 @param setId key: id of set
 @param termId key: id of term
 @param relationId key: id of relation
 @return ApiSitesTermStoreSetsChildrenUpdateRelationsRequest
*/
func (a *SitesStoreApiService) SitesTermStoreSetsChildrenUpdateRelations(ctx _context.Context, siteId string, setId string, termId string, relationId string) ApiSitesTermStoreSetsChildrenUpdateRelationsRequest {
	return ApiSitesTermStoreSetsChildrenUpdateRelationsRequest{
		ApiService: a,
		ctx: ctx,
		siteId: siteId,
		setId: setId,
		termId: termId,
		relationId: relationId,
	}
}

// Execute executes the request
func (a *SitesStoreApiService) SitesTermStoreSetsChildrenUpdateRelationsExecute(r ApiSitesTermStoreSetsChildrenUpdateRelationsRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPatch
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SitesStoreApiService.SitesTermStoreSetsChildrenUpdateRelations")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sites/{site-id}/termStore/sets/{set-id}/children/{term-id}/relations/{relation-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"site-id"+"}", _neturl.PathEscape(parameterToString(r.siteId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"set-id"+"}", _neturl.PathEscape(parameterToString(r.setId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"term-id"+"}", _neturl.PathEscape(parameterToString(r.termId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"relation-id"+"}", _neturl.PathEscape(parameterToString(r.relationId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphTermStoreRelation == nil {
		return nil, reportError("microsoftGraphTermStoreRelation is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphTermStoreRelation
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiSitesTermStoreSetsCreateChildrenRequest struct {
	ctx _context.Context
	ApiService *SitesStoreApiService
	siteId string
	setId string
	microsoftGraphTermStoreTerm *MicrosoftGraphTermStoreTerm
}

// New navigation property
func (r ApiSitesTermStoreSetsCreateChildrenRequest) MicrosoftGraphTermStoreTerm(microsoftGraphTermStoreTerm MicrosoftGraphTermStoreTerm) ApiSitesTermStoreSetsCreateChildrenRequest {
	r.microsoftGraphTermStoreTerm = &microsoftGraphTermStoreTerm
	return r
}

func (r ApiSitesTermStoreSetsCreateChildrenRequest) Execute() (MicrosoftGraphTermStoreTerm, *_nethttp.Response, error) {
	return r.ApiService.SitesTermStoreSetsCreateChildrenExecute(r)
}

/*
SitesTermStoreSetsCreateChildren Create new navigation property to children for sites

Children terms of set in term [store].

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param siteId key: id of site
 @param setId key: id of set
 @return ApiSitesTermStoreSetsCreateChildrenRequest
*/
func (a *SitesStoreApiService) SitesTermStoreSetsCreateChildren(ctx _context.Context, siteId string, setId string) ApiSitesTermStoreSetsCreateChildrenRequest {
	return ApiSitesTermStoreSetsCreateChildrenRequest{
		ApiService: a,
		ctx: ctx,
		siteId: siteId,
		setId: setId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphTermStoreTerm
func (a *SitesStoreApiService) SitesTermStoreSetsCreateChildrenExecute(r ApiSitesTermStoreSetsCreateChildrenRequest) (MicrosoftGraphTermStoreTerm, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphTermStoreTerm
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SitesStoreApiService.SitesTermStoreSetsCreateChildren")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sites/{site-id}/termStore/sets/{set-id}/children"
	localVarPath = strings.Replace(localVarPath, "{"+"site-id"+"}", _neturl.PathEscape(parameterToString(r.siteId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"set-id"+"}", _neturl.PathEscape(parameterToString(r.setId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphTermStoreTerm == nil {
		return localVarReturnValue, nil, reportError("microsoftGraphTermStoreTerm is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphTermStoreTerm
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSitesTermStoreSetsCreateRelationsRequest struct {
	ctx _context.Context
	ApiService *SitesStoreApiService
	siteId string
	setId string
	microsoftGraphTermStoreRelation *MicrosoftGraphTermStoreRelation
}

// New navigation property
func (r ApiSitesTermStoreSetsCreateRelationsRequest) MicrosoftGraphTermStoreRelation(microsoftGraphTermStoreRelation MicrosoftGraphTermStoreRelation) ApiSitesTermStoreSetsCreateRelationsRequest {
	r.microsoftGraphTermStoreRelation = &microsoftGraphTermStoreRelation
	return r
}

func (r ApiSitesTermStoreSetsCreateRelationsRequest) Execute() (MicrosoftGraphTermStoreRelation, *_nethttp.Response, error) {
	return r.ApiService.SitesTermStoreSetsCreateRelationsExecute(r)
}

/*
SitesTermStoreSetsCreateRelations Create new navigation property to relations for sites

Indicates which terms have been pinned or reused directly under the set.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param siteId key: id of site
 @param setId key: id of set
 @return ApiSitesTermStoreSetsCreateRelationsRequest
*/
func (a *SitesStoreApiService) SitesTermStoreSetsCreateRelations(ctx _context.Context, siteId string, setId string) ApiSitesTermStoreSetsCreateRelationsRequest {
	return ApiSitesTermStoreSetsCreateRelationsRequest{
		ApiService: a,
		ctx: ctx,
		siteId: siteId,
		setId: setId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphTermStoreRelation
func (a *SitesStoreApiService) SitesTermStoreSetsCreateRelationsExecute(r ApiSitesTermStoreSetsCreateRelationsRequest) (MicrosoftGraphTermStoreRelation, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphTermStoreRelation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SitesStoreApiService.SitesTermStoreSetsCreateRelations")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sites/{site-id}/termStore/sets/{set-id}/relations"
	localVarPath = strings.Replace(localVarPath, "{"+"site-id"+"}", _neturl.PathEscape(parameterToString(r.siteId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"set-id"+"}", _neturl.PathEscape(parameterToString(r.setId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphTermStoreRelation == nil {
		return localVarReturnValue, nil, reportError("microsoftGraphTermStoreRelation is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphTermStoreRelation
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSitesTermStoreSetsCreateTermsRequest struct {
	ctx _context.Context
	ApiService *SitesStoreApiService
	siteId string
	setId string
	microsoftGraphTermStoreTerm *MicrosoftGraphTermStoreTerm
}

// New navigation property
func (r ApiSitesTermStoreSetsCreateTermsRequest) MicrosoftGraphTermStoreTerm(microsoftGraphTermStoreTerm MicrosoftGraphTermStoreTerm) ApiSitesTermStoreSetsCreateTermsRequest {
	r.microsoftGraphTermStoreTerm = &microsoftGraphTermStoreTerm
	return r
}

func (r ApiSitesTermStoreSetsCreateTermsRequest) Execute() (MicrosoftGraphTermStoreTerm, *_nethttp.Response, error) {
	return r.ApiService.SitesTermStoreSetsCreateTermsExecute(r)
}

/*
SitesTermStoreSetsCreateTerms Create new navigation property to terms for sites

All the terms under the set.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param siteId key: id of site
 @param setId key: id of set
 @return ApiSitesTermStoreSetsCreateTermsRequest
*/
func (a *SitesStoreApiService) SitesTermStoreSetsCreateTerms(ctx _context.Context, siteId string, setId string) ApiSitesTermStoreSetsCreateTermsRequest {
	return ApiSitesTermStoreSetsCreateTermsRequest{
		ApiService: a,
		ctx: ctx,
		siteId: siteId,
		setId: setId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphTermStoreTerm
func (a *SitesStoreApiService) SitesTermStoreSetsCreateTermsExecute(r ApiSitesTermStoreSetsCreateTermsRequest) (MicrosoftGraphTermStoreTerm, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphTermStoreTerm
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SitesStoreApiService.SitesTermStoreSetsCreateTerms")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sites/{site-id}/termStore/sets/{set-id}/terms"
	localVarPath = strings.Replace(localVarPath, "{"+"site-id"+"}", _neturl.PathEscape(parameterToString(r.siteId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"set-id"+"}", _neturl.PathEscape(parameterToString(r.setId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphTermStoreTerm == nil {
		return localVarReturnValue, nil, reportError("microsoftGraphTermStoreTerm is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphTermStoreTerm
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSitesTermStoreSetsDeleteChildrenRequest struct {
	ctx _context.Context
	ApiService *SitesStoreApiService
	siteId string
	setId string
	termId string
	ifMatch *string
}

// ETag
func (r ApiSitesTermStoreSetsDeleteChildrenRequest) IfMatch(ifMatch string) ApiSitesTermStoreSetsDeleteChildrenRequest {
	r.ifMatch = &ifMatch
	return r
}

func (r ApiSitesTermStoreSetsDeleteChildrenRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.SitesTermStoreSetsDeleteChildrenExecute(r)
}

/*
SitesTermStoreSetsDeleteChildren Delete navigation property children for sites

Children terms of set in term [store].

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param siteId key: id of site
 @param setId key: id of set
 @param termId key: id of term
 @return ApiSitesTermStoreSetsDeleteChildrenRequest
*/
func (a *SitesStoreApiService) SitesTermStoreSetsDeleteChildren(ctx _context.Context, siteId string, setId string, termId string) ApiSitesTermStoreSetsDeleteChildrenRequest {
	return ApiSitesTermStoreSetsDeleteChildrenRequest{
		ApiService: a,
		ctx: ctx,
		siteId: siteId,
		setId: setId,
		termId: termId,
	}
}

// Execute executes the request
func (a *SitesStoreApiService) SitesTermStoreSetsDeleteChildrenExecute(r ApiSitesTermStoreSetsDeleteChildrenRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SitesStoreApiService.SitesTermStoreSetsDeleteChildren")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sites/{site-id}/termStore/sets/{set-id}/children/{term-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"site-id"+"}", _neturl.PathEscape(parameterToString(r.siteId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"set-id"+"}", _neturl.PathEscape(parameterToString(r.setId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"term-id"+"}", _neturl.PathEscape(parameterToString(r.termId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ifMatch != nil {
		localVarHeaderParams["If-Match"] = parameterToString(*r.ifMatch, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiSitesTermStoreSetsDeleteParentGroupRequest struct {
	ctx _context.Context
	ApiService *SitesStoreApiService
	siteId string
	setId string
	ifMatch *string
}

// ETag
func (r ApiSitesTermStoreSetsDeleteParentGroupRequest) IfMatch(ifMatch string) ApiSitesTermStoreSetsDeleteParentGroupRequest {
	r.ifMatch = &ifMatch
	return r
}

func (r ApiSitesTermStoreSetsDeleteParentGroupRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.SitesTermStoreSetsDeleteParentGroupExecute(r)
}

/*
SitesTermStoreSetsDeleteParentGroup Delete navigation property parentGroup for sites

The parent [group] that contains the set.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param siteId key: id of site
 @param setId key: id of set
 @return ApiSitesTermStoreSetsDeleteParentGroupRequest
*/
func (a *SitesStoreApiService) SitesTermStoreSetsDeleteParentGroup(ctx _context.Context, siteId string, setId string) ApiSitesTermStoreSetsDeleteParentGroupRequest {
	return ApiSitesTermStoreSetsDeleteParentGroupRequest{
		ApiService: a,
		ctx: ctx,
		siteId: siteId,
		setId: setId,
	}
}

// Execute executes the request
func (a *SitesStoreApiService) SitesTermStoreSetsDeleteParentGroupExecute(r ApiSitesTermStoreSetsDeleteParentGroupRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SitesStoreApiService.SitesTermStoreSetsDeleteParentGroup")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sites/{site-id}/termStore/sets/{set-id}/parentGroup"
	localVarPath = strings.Replace(localVarPath, "{"+"site-id"+"}", _neturl.PathEscape(parameterToString(r.siteId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"set-id"+"}", _neturl.PathEscape(parameterToString(r.setId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ifMatch != nil {
		localVarHeaderParams["If-Match"] = parameterToString(*r.ifMatch, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiSitesTermStoreSetsDeleteRelationsRequest struct {
	ctx _context.Context
	ApiService *SitesStoreApiService
	siteId string
	setId string
	relationId string
	ifMatch *string
}

// ETag
func (r ApiSitesTermStoreSetsDeleteRelationsRequest) IfMatch(ifMatch string) ApiSitesTermStoreSetsDeleteRelationsRequest {
	r.ifMatch = &ifMatch
	return r
}

func (r ApiSitesTermStoreSetsDeleteRelationsRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.SitesTermStoreSetsDeleteRelationsExecute(r)
}

/*
SitesTermStoreSetsDeleteRelations Delete navigation property relations for sites

Indicates which terms have been pinned or reused directly under the set.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param siteId key: id of site
 @param setId key: id of set
 @param relationId key: id of relation
 @return ApiSitesTermStoreSetsDeleteRelationsRequest
*/
func (a *SitesStoreApiService) SitesTermStoreSetsDeleteRelations(ctx _context.Context, siteId string, setId string, relationId string) ApiSitesTermStoreSetsDeleteRelationsRequest {
	return ApiSitesTermStoreSetsDeleteRelationsRequest{
		ApiService: a,
		ctx: ctx,
		siteId: siteId,
		setId: setId,
		relationId: relationId,
	}
}

// Execute executes the request
func (a *SitesStoreApiService) SitesTermStoreSetsDeleteRelationsExecute(r ApiSitesTermStoreSetsDeleteRelationsRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SitesStoreApiService.SitesTermStoreSetsDeleteRelations")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sites/{site-id}/termStore/sets/{set-id}/relations/{relation-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"site-id"+"}", _neturl.PathEscape(parameterToString(r.siteId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"set-id"+"}", _neturl.PathEscape(parameterToString(r.setId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"relation-id"+"}", _neturl.PathEscape(parameterToString(r.relationId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ifMatch != nil {
		localVarHeaderParams["If-Match"] = parameterToString(*r.ifMatch, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiSitesTermStoreSetsDeleteTermsRequest struct {
	ctx _context.Context
	ApiService *SitesStoreApiService
	siteId string
	setId string
	termId string
	ifMatch *string
}

// ETag
func (r ApiSitesTermStoreSetsDeleteTermsRequest) IfMatch(ifMatch string) ApiSitesTermStoreSetsDeleteTermsRequest {
	r.ifMatch = &ifMatch
	return r
}

func (r ApiSitesTermStoreSetsDeleteTermsRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.SitesTermStoreSetsDeleteTermsExecute(r)
}

/*
SitesTermStoreSetsDeleteTerms Delete navigation property terms for sites

All the terms under the set.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param siteId key: id of site
 @param setId key: id of set
 @param termId key: id of term
 @return ApiSitesTermStoreSetsDeleteTermsRequest
*/
func (a *SitesStoreApiService) SitesTermStoreSetsDeleteTerms(ctx _context.Context, siteId string, setId string, termId string) ApiSitesTermStoreSetsDeleteTermsRequest {
	return ApiSitesTermStoreSetsDeleteTermsRequest{
		ApiService: a,
		ctx: ctx,
		siteId: siteId,
		setId: setId,
		termId: termId,
	}
}

// Execute executes the request
func (a *SitesStoreApiService) SitesTermStoreSetsDeleteTermsExecute(r ApiSitesTermStoreSetsDeleteTermsRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SitesStoreApiService.SitesTermStoreSetsDeleteTerms")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sites/{site-id}/termStore/sets/{set-id}/terms/{term-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"site-id"+"}", _neturl.PathEscape(parameterToString(r.siteId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"set-id"+"}", _neturl.PathEscape(parameterToString(r.setId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"term-id"+"}", _neturl.PathEscape(parameterToString(r.termId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ifMatch != nil {
		localVarHeaderParams["If-Match"] = parameterToString(*r.ifMatch, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiSitesTermStoreSetsGetChildrenRequest struct {
	ctx _context.Context
	ApiService *SitesStoreApiService
	siteId string
	setId string
	termId string
	select_ *[]string
	expand *[]string
}

// Select properties to be returned
func (r ApiSitesTermStoreSetsGetChildrenRequest) Select_(select_ []string) ApiSitesTermStoreSetsGetChildrenRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiSitesTermStoreSetsGetChildrenRequest) Expand(expand []string) ApiSitesTermStoreSetsGetChildrenRequest {
	r.expand = &expand
	return r
}

func (r ApiSitesTermStoreSetsGetChildrenRequest) Execute() (MicrosoftGraphTermStoreTerm, *_nethttp.Response, error) {
	return r.ApiService.SitesTermStoreSetsGetChildrenExecute(r)
}

/*
SitesTermStoreSetsGetChildren Get children from sites

Children terms of set in term [store].

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param siteId key: id of site
 @param setId key: id of set
 @param termId key: id of term
 @return ApiSitesTermStoreSetsGetChildrenRequest
*/
func (a *SitesStoreApiService) SitesTermStoreSetsGetChildren(ctx _context.Context, siteId string, setId string, termId string) ApiSitesTermStoreSetsGetChildrenRequest {
	return ApiSitesTermStoreSetsGetChildrenRequest{
		ApiService: a,
		ctx: ctx,
		siteId: siteId,
		setId: setId,
		termId: termId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphTermStoreTerm
func (a *SitesStoreApiService) SitesTermStoreSetsGetChildrenExecute(r ApiSitesTermStoreSetsGetChildrenRequest) (MicrosoftGraphTermStoreTerm, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphTermStoreTerm
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SitesStoreApiService.SitesTermStoreSetsGetChildren")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sites/{site-id}/termStore/sets/{set-id}/children/{term-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"site-id"+"}", _neturl.PathEscape(parameterToString(r.siteId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"set-id"+"}", _neturl.PathEscape(parameterToString(r.setId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"term-id"+"}", _neturl.PathEscape(parameterToString(r.termId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSitesTermStoreSetsGetParentGroupRequest struct {
	ctx _context.Context
	ApiService *SitesStoreApiService
	siteId string
	setId string
	select_ *[]string
	expand *[]string
}

// Select properties to be returned
func (r ApiSitesTermStoreSetsGetParentGroupRequest) Select_(select_ []string) ApiSitesTermStoreSetsGetParentGroupRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiSitesTermStoreSetsGetParentGroupRequest) Expand(expand []string) ApiSitesTermStoreSetsGetParentGroupRequest {
	r.expand = &expand
	return r
}

func (r ApiSitesTermStoreSetsGetParentGroupRequest) Execute() (MicrosoftGraphTermStoreGroup, *_nethttp.Response, error) {
	return r.ApiService.SitesTermStoreSetsGetParentGroupExecute(r)
}

/*
SitesTermStoreSetsGetParentGroup Get parentGroup from sites

The parent [group] that contains the set.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param siteId key: id of site
 @param setId key: id of set
 @return ApiSitesTermStoreSetsGetParentGroupRequest
*/
func (a *SitesStoreApiService) SitesTermStoreSetsGetParentGroup(ctx _context.Context, siteId string, setId string) ApiSitesTermStoreSetsGetParentGroupRequest {
	return ApiSitesTermStoreSetsGetParentGroupRequest{
		ApiService: a,
		ctx: ctx,
		siteId: siteId,
		setId: setId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphTermStoreGroup
func (a *SitesStoreApiService) SitesTermStoreSetsGetParentGroupExecute(r ApiSitesTermStoreSetsGetParentGroupRequest) (MicrosoftGraphTermStoreGroup, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphTermStoreGroup
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SitesStoreApiService.SitesTermStoreSetsGetParentGroup")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sites/{site-id}/termStore/sets/{set-id}/parentGroup"
	localVarPath = strings.Replace(localVarPath, "{"+"site-id"+"}", _neturl.PathEscape(parameterToString(r.siteId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"set-id"+"}", _neturl.PathEscape(parameterToString(r.setId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSitesTermStoreSetsGetRelationsRequest struct {
	ctx _context.Context
	ApiService *SitesStoreApiService
	siteId string
	setId string
	relationId string
	select_ *[]string
	expand *[]string
}

// Select properties to be returned
func (r ApiSitesTermStoreSetsGetRelationsRequest) Select_(select_ []string) ApiSitesTermStoreSetsGetRelationsRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiSitesTermStoreSetsGetRelationsRequest) Expand(expand []string) ApiSitesTermStoreSetsGetRelationsRequest {
	r.expand = &expand
	return r
}

func (r ApiSitesTermStoreSetsGetRelationsRequest) Execute() (MicrosoftGraphTermStoreRelation, *_nethttp.Response, error) {
	return r.ApiService.SitesTermStoreSetsGetRelationsExecute(r)
}

/*
SitesTermStoreSetsGetRelations Get relations from sites

Indicates which terms have been pinned or reused directly under the set.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param siteId key: id of site
 @param setId key: id of set
 @param relationId key: id of relation
 @return ApiSitesTermStoreSetsGetRelationsRequest
*/
func (a *SitesStoreApiService) SitesTermStoreSetsGetRelations(ctx _context.Context, siteId string, setId string, relationId string) ApiSitesTermStoreSetsGetRelationsRequest {
	return ApiSitesTermStoreSetsGetRelationsRequest{
		ApiService: a,
		ctx: ctx,
		siteId: siteId,
		setId: setId,
		relationId: relationId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphTermStoreRelation
func (a *SitesStoreApiService) SitesTermStoreSetsGetRelationsExecute(r ApiSitesTermStoreSetsGetRelationsRequest) (MicrosoftGraphTermStoreRelation, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphTermStoreRelation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SitesStoreApiService.SitesTermStoreSetsGetRelations")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sites/{site-id}/termStore/sets/{set-id}/relations/{relation-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"site-id"+"}", _neturl.PathEscape(parameterToString(r.siteId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"set-id"+"}", _neturl.PathEscape(parameterToString(r.setId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"relation-id"+"}", _neturl.PathEscape(parameterToString(r.relationId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSitesTermStoreSetsGetTermsRequest struct {
	ctx _context.Context
	ApiService *SitesStoreApiService
	siteId string
	setId string
	termId string
	select_ *[]string
	expand *[]string
}

// Select properties to be returned
func (r ApiSitesTermStoreSetsGetTermsRequest) Select_(select_ []string) ApiSitesTermStoreSetsGetTermsRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiSitesTermStoreSetsGetTermsRequest) Expand(expand []string) ApiSitesTermStoreSetsGetTermsRequest {
	r.expand = &expand
	return r
}

func (r ApiSitesTermStoreSetsGetTermsRequest) Execute() (MicrosoftGraphTermStoreTerm, *_nethttp.Response, error) {
	return r.ApiService.SitesTermStoreSetsGetTermsExecute(r)
}

/*
SitesTermStoreSetsGetTerms Get terms from sites

All the terms under the set.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param siteId key: id of site
 @param setId key: id of set
 @param termId key: id of term
 @return ApiSitesTermStoreSetsGetTermsRequest
*/
func (a *SitesStoreApiService) SitesTermStoreSetsGetTerms(ctx _context.Context, siteId string, setId string, termId string) ApiSitesTermStoreSetsGetTermsRequest {
	return ApiSitesTermStoreSetsGetTermsRequest{
		ApiService: a,
		ctx: ctx,
		siteId: siteId,
		setId: setId,
		termId: termId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphTermStoreTerm
func (a *SitesStoreApiService) SitesTermStoreSetsGetTermsExecute(r ApiSitesTermStoreSetsGetTermsRequest) (MicrosoftGraphTermStoreTerm, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphTermStoreTerm
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SitesStoreApiService.SitesTermStoreSetsGetTerms")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sites/{site-id}/termStore/sets/{set-id}/terms/{term-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"site-id"+"}", _neturl.PathEscape(parameterToString(r.siteId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"set-id"+"}", _neturl.PathEscape(parameterToString(r.setId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"term-id"+"}", _neturl.PathEscape(parameterToString(r.termId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSitesTermStoreSetsListChildrenRequest struct {
	ctx _context.Context
	ApiService *SitesStoreApiService
	siteId string
	setId string
	top *int32
	skip *int32
	search *string
	filter *string
	count *bool
	orderby *[]string
	select_ *[]string
	expand *[]string
}

// Show only the first n items
func (r ApiSitesTermStoreSetsListChildrenRequest) Top(top int32) ApiSitesTermStoreSetsListChildrenRequest {
	r.top = &top
	return r
}
// Skip the first n items
func (r ApiSitesTermStoreSetsListChildrenRequest) Skip(skip int32) ApiSitesTermStoreSetsListChildrenRequest {
	r.skip = &skip
	return r
}
// Search items by search phrases
func (r ApiSitesTermStoreSetsListChildrenRequest) Search(search string) ApiSitesTermStoreSetsListChildrenRequest {
	r.search = &search
	return r
}
// Filter items by property values
func (r ApiSitesTermStoreSetsListChildrenRequest) Filter(filter string) ApiSitesTermStoreSetsListChildrenRequest {
	r.filter = &filter
	return r
}
// Include count of items
func (r ApiSitesTermStoreSetsListChildrenRequest) Count(count bool) ApiSitesTermStoreSetsListChildrenRequest {
	r.count = &count
	return r
}
// Order items by property values
func (r ApiSitesTermStoreSetsListChildrenRequest) Orderby(orderby []string) ApiSitesTermStoreSetsListChildrenRequest {
	r.orderby = &orderby
	return r
}
// Select properties to be returned
func (r ApiSitesTermStoreSetsListChildrenRequest) Select_(select_ []string) ApiSitesTermStoreSetsListChildrenRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiSitesTermStoreSetsListChildrenRequest) Expand(expand []string) ApiSitesTermStoreSetsListChildrenRequest {
	r.expand = &expand
	return r
}

func (r ApiSitesTermStoreSetsListChildrenRequest) Execute() (CollectionOfTerm, *_nethttp.Response, error) {
	return r.ApiService.SitesTermStoreSetsListChildrenExecute(r)
}

/*
SitesTermStoreSetsListChildren Get children from sites

Children terms of set in term [store].

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param siteId key: id of site
 @param setId key: id of set
 @return ApiSitesTermStoreSetsListChildrenRequest
*/
func (a *SitesStoreApiService) SitesTermStoreSetsListChildren(ctx _context.Context, siteId string, setId string) ApiSitesTermStoreSetsListChildrenRequest {
	return ApiSitesTermStoreSetsListChildrenRequest{
		ApiService: a,
		ctx: ctx,
		siteId: siteId,
		setId: setId,
	}
}

// Execute executes the request
//  @return CollectionOfTerm
func (a *SitesStoreApiService) SitesTermStoreSetsListChildrenExecute(r ApiSitesTermStoreSetsListChildrenRequest) (CollectionOfTerm, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  CollectionOfTerm
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SitesStoreApiService.SitesTermStoreSetsListChildren")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sites/{site-id}/termStore/sets/{set-id}/children"
	localVarPath = strings.Replace(localVarPath, "{"+"site-id"+"}", _neturl.PathEscape(parameterToString(r.siteId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"set-id"+"}", _neturl.PathEscape(parameterToString(r.setId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.top != nil {
		localVarQueryParams.Add("$top", parameterToString(*r.top, ""))
	}
	if r.skip != nil {
		localVarQueryParams.Add("$skip", parameterToString(*r.skip, ""))
	}
	if r.search != nil {
		localVarQueryParams.Add("$search", parameterToString(*r.search, ""))
	}
	if r.filter != nil {
		localVarQueryParams.Add("$filter", parameterToString(*r.filter, ""))
	}
	if r.count != nil {
		localVarQueryParams.Add("$count", parameterToString(*r.count, ""))
	}
	if r.orderby != nil {
		localVarQueryParams.Add("$orderby", parameterToString(*r.orderby, "csv"))
	}
	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSitesTermStoreSetsListRelationsRequest struct {
	ctx _context.Context
	ApiService *SitesStoreApiService
	siteId string
	setId string
	top *int32
	skip *int32
	search *string
	filter *string
	count *bool
	orderby *[]string
	select_ *[]string
	expand *[]string
}

// Show only the first n items
func (r ApiSitesTermStoreSetsListRelationsRequest) Top(top int32) ApiSitesTermStoreSetsListRelationsRequest {
	r.top = &top
	return r
}
// Skip the first n items
func (r ApiSitesTermStoreSetsListRelationsRequest) Skip(skip int32) ApiSitesTermStoreSetsListRelationsRequest {
	r.skip = &skip
	return r
}
// Search items by search phrases
func (r ApiSitesTermStoreSetsListRelationsRequest) Search(search string) ApiSitesTermStoreSetsListRelationsRequest {
	r.search = &search
	return r
}
// Filter items by property values
func (r ApiSitesTermStoreSetsListRelationsRequest) Filter(filter string) ApiSitesTermStoreSetsListRelationsRequest {
	r.filter = &filter
	return r
}
// Include count of items
func (r ApiSitesTermStoreSetsListRelationsRequest) Count(count bool) ApiSitesTermStoreSetsListRelationsRequest {
	r.count = &count
	return r
}
// Order items by property values
func (r ApiSitesTermStoreSetsListRelationsRequest) Orderby(orderby []string) ApiSitesTermStoreSetsListRelationsRequest {
	r.orderby = &orderby
	return r
}
// Select properties to be returned
func (r ApiSitesTermStoreSetsListRelationsRequest) Select_(select_ []string) ApiSitesTermStoreSetsListRelationsRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiSitesTermStoreSetsListRelationsRequest) Expand(expand []string) ApiSitesTermStoreSetsListRelationsRequest {
	r.expand = &expand
	return r
}

func (r ApiSitesTermStoreSetsListRelationsRequest) Execute() (CollectionOfRelation, *_nethttp.Response, error) {
	return r.ApiService.SitesTermStoreSetsListRelationsExecute(r)
}

/*
SitesTermStoreSetsListRelations Get relations from sites

Indicates which terms have been pinned or reused directly under the set.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param siteId key: id of site
 @param setId key: id of set
 @return ApiSitesTermStoreSetsListRelationsRequest
*/
func (a *SitesStoreApiService) SitesTermStoreSetsListRelations(ctx _context.Context, siteId string, setId string) ApiSitesTermStoreSetsListRelationsRequest {
	return ApiSitesTermStoreSetsListRelationsRequest{
		ApiService: a,
		ctx: ctx,
		siteId: siteId,
		setId: setId,
	}
}

// Execute executes the request
//  @return CollectionOfRelation
func (a *SitesStoreApiService) SitesTermStoreSetsListRelationsExecute(r ApiSitesTermStoreSetsListRelationsRequest) (CollectionOfRelation, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  CollectionOfRelation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SitesStoreApiService.SitesTermStoreSetsListRelations")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sites/{site-id}/termStore/sets/{set-id}/relations"
	localVarPath = strings.Replace(localVarPath, "{"+"site-id"+"}", _neturl.PathEscape(parameterToString(r.siteId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"set-id"+"}", _neturl.PathEscape(parameterToString(r.setId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.top != nil {
		localVarQueryParams.Add("$top", parameterToString(*r.top, ""))
	}
	if r.skip != nil {
		localVarQueryParams.Add("$skip", parameterToString(*r.skip, ""))
	}
	if r.search != nil {
		localVarQueryParams.Add("$search", parameterToString(*r.search, ""))
	}
	if r.filter != nil {
		localVarQueryParams.Add("$filter", parameterToString(*r.filter, ""))
	}
	if r.count != nil {
		localVarQueryParams.Add("$count", parameterToString(*r.count, ""))
	}
	if r.orderby != nil {
		localVarQueryParams.Add("$orderby", parameterToString(*r.orderby, "csv"))
	}
	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSitesTermStoreSetsListTermsRequest struct {
	ctx _context.Context
	ApiService *SitesStoreApiService
	siteId string
	setId string
	top *int32
	skip *int32
	search *string
	filter *string
	count *bool
	orderby *[]string
	select_ *[]string
	expand *[]string
}

// Show only the first n items
func (r ApiSitesTermStoreSetsListTermsRequest) Top(top int32) ApiSitesTermStoreSetsListTermsRequest {
	r.top = &top
	return r
}
// Skip the first n items
func (r ApiSitesTermStoreSetsListTermsRequest) Skip(skip int32) ApiSitesTermStoreSetsListTermsRequest {
	r.skip = &skip
	return r
}
// Search items by search phrases
func (r ApiSitesTermStoreSetsListTermsRequest) Search(search string) ApiSitesTermStoreSetsListTermsRequest {
	r.search = &search
	return r
}
// Filter items by property values
func (r ApiSitesTermStoreSetsListTermsRequest) Filter(filter string) ApiSitesTermStoreSetsListTermsRequest {
	r.filter = &filter
	return r
}
// Include count of items
func (r ApiSitesTermStoreSetsListTermsRequest) Count(count bool) ApiSitesTermStoreSetsListTermsRequest {
	r.count = &count
	return r
}
// Order items by property values
func (r ApiSitesTermStoreSetsListTermsRequest) Orderby(orderby []string) ApiSitesTermStoreSetsListTermsRequest {
	r.orderby = &orderby
	return r
}
// Select properties to be returned
func (r ApiSitesTermStoreSetsListTermsRequest) Select_(select_ []string) ApiSitesTermStoreSetsListTermsRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiSitesTermStoreSetsListTermsRequest) Expand(expand []string) ApiSitesTermStoreSetsListTermsRequest {
	r.expand = &expand
	return r
}

func (r ApiSitesTermStoreSetsListTermsRequest) Execute() (CollectionOfTerm, *_nethttp.Response, error) {
	return r.ApiService.SitesTermStoreSetsListTermsExecute(r)
}

/*
SitesTermStoreSetsListTerms Get terms from sites

All the terms under the set.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param siteId key: id of site
 @param setId key: id of set
 @return ApiSitesTermStoreSetsListTermsRequest
*/
func (a *SitesStoreApiService) SitesTermStoreSetsListTerms(ctx _context.Context, siteId string, setId string) ApiSitesTermStoreSetsListTermsRequest {
	return ApiSitesTermStoreSetsListTermsRequest{
		ApiService: a,
		ctx: ctx,
		siteId: siteId,
		setId: setId,
	}
}

// Execute executes the request
//  @return CollectionOfTerm
func (a *SitesStoreApiService) SitesTermStoreSetsListTermsExecute(r ApiSitesTermStoreSetsListTermsRequest) (CollectionOfTerm, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  CollectionOfTerm
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SitesStoreApiService.SitesTermStoreSetsListTerms")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sites/{site-id}/termStore/sets/{set-id}/terms"
	localVarPath = strings.Replace(localVarPath, "{"+"site-id"+"}", _neturl.PathEscape(parameterToString(r.siteId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"set-id"+"}", _neturl.PathEscape(parameterToString(r.setId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.top != nil {
		localVarQueryParams.Add("$top", parameterToString(*r.top, ""))
	}
	if r.skip != nil {
		localVarQueryParams.Add("$skip", parameterToString(*r.skip, ""))
	}
	if r.search != nil {
		localVarQueryParams.Add("$search", parameterToString(*r.search, ""))
	}
	if r.filter != nil {
		localVarQueryParams.Add("$filter", parameterToString(*r.filter, ""))
	}
	if r.count != nil {
		localVarQueryParams.Add("$count", parameterToString(*r.count, ""))
	}
	if r.orderby != nil {
		localVarQueryParams.Add("$orderby", parameterToString(*r.orderby, "csv"))
	}
	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSitesTermStoreSetsParentGroupCreateSetsRequest struct {
	ctx _context.Context
	ApiService *SitesStoreApiService
	siteId string
	setId string
	microsoftGraphTermStoreSet *MicrosoftGraphTermStoreSet
}

// New navigation property
func (r ApiSitesTermStoreSetsParentGroupCreateSetsRequest) MicrosoftGraphTermStoreSet(microsoftGraphTermStoreSet MicrosoftGraphTermStoreSet) ApiSitesTermStoreSetsParentGroupCreateSetsRequest {
	r.microsoftGraphTermStoreSet = &microsoftGraphTermStoreSet
	return r
}

func (r ApiSitesTermStoreSetsParentGroupCreateSetsRequest) Execute() (MicrosoftGraphTermStoreSet, *_nethttp.Response, error) {
	return r.ApiService.SitesTermStoreSetsParentGroupCreateSetsExecute(r)
}

/*
SitesTermStoreSetsParentGroupCreateSets Create new navigation property to sets for sites

All sets under the group in a term [store].

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param siteId key: id of site
 @param setId key: id of set
 @return ApiSitesTermStoreSetsParentGroupCreateSetsRequest
*/
func (a *SitesStoreApiService) SitesTermStoreSetsParentGroupCreateSets(ctx _context.Context, siteId string, setId string) ApiSitesTermStoreSetsParentGroupCreateSetsRequest {
	return ApiSitesTermStoreSetsParentGroupCreateSetsRequest{
		ApiService: a,
		ctx: ctx,
		siteId: siteId,
		setId: setId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphTermStoreSet
func (a *SitesStoreApiService) SitesTermStoreSetsParentGroupCreateSetsExecute(r ApiSitesTermStoreSetsParentGroupCreateSetsRequest) (MicrosoftGraphTermStoreSet, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphTermStoreSet
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SitesStoreApiService.SitesTermStoreSetsParentGroupCreateSets")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sites/{site-id}/termStore/sets/{set-id}/parentGroup/sets"
	localVarPath = strings.Replace(localVarPath, "{"+"site-id"+"}", _neturl.PathEscape(parameterToString(r.siteId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"set-id"+"}", _neturl.PathEscape(parameterToString(r.setId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphTermStoreSet == nil {
		return localVarReturnValue, nil, reportError("microsoftGraphTermStoreSet is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphTermStoreSet
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSitesTermStoreSetsParentGroupDeleteSetsRequest struct {
	ctx _context.Context
	ApiService *SitesStoreApiService
	siteId string
	setId string
	setId1 string
	ifMatch *string
}

// ETag
func (r ApiSitesTermStoreSetsParentGroupDeleteSetsRequest) IfMatch(ifMatch string) ApiSitesTermStoreSetsParentGroupDeleteSetsRequest {
	r.ifMatch = &ifMatch
	return r
}

func (r ApiSitesTermStoreSetsParentGroupDeleteSetsRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.SitesTermStoreSetsParentGroupDeleteSetsExecute(r)
}

/*
SitesTermStoreSetsParentGroupDeleteSets Delete navigation property sets for sites

All sets under the group in a term [store].

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param siteId key: id of site
 @param setId key: id of set
 @param setId1 key: id of set
 @return ApiSitesTermStoreSetsParentGroupDeleteSetsRequest
*/
func (a *SitesStoreApiService) SitesTermStoreSetsParentGroupDeleteSets(ctx _context.Context, siteId string, setId string, setId1 string) ApiSitesTermStoreSetsParentGroupDeleteSetsRequest {
	return ApiSitesTermStoreSetsParentGroupDeleteSetsRequest{
		ApiService: a,
		ctx: ctx,
		siteId: siteId,
		setId: setId,
		setId1: setId1,
	}
}

// Execute executes the request
func (a *SitesStoreApiService) SitesTermStoreSetsParentGroupDeleteSetsExecute(r ApiSitesTermStoreSetsParentGroupDeleteSetsRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SitesStoreApiService.SitesTermStoreSetsParentGroupDeleteSets")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sites/{site-id}/termStore/sets/{set-id}/parentGroup/sets/{set-id1}"
	localVarPath = strings.Replace(localVarPath, "{"+"site-id"+"}", _neturl.PathEscape(parameterToString(r.siteId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"set-id"+"}", _neturl.PathEscape(parameterToString(r.setId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"set-id1"+"}", _neturl.PathEscape(parameterToString(r.setId1, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ifMatch != nil {
		localVarHeaderParams["If-Match"] = parameterToString(*r.ifMatch, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiSitesTermStoreSetsParentGroupGetSetsRequest struct {
	ctx _context.Context
	ApiService *SitesStoreApiService
	siteId string
	setId string
	setId1 string
	select_ *[]string
	expand *[]string
}

// Select properties to be returned
func (r ApiSitesTermStoreSetsParentGroupGetSetsRequest) Select_(select_ []string) ApiSitesTermStoreSetsParentGroupGetSetsRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiSitesTermStoreSetsParentGroupGetSetsRequest) Expand(expand []string) ApiSitesTermStoreSetsParentGroupGetSetsRequest {
	r.expand = &expand
	return r
}

func (r ApiSitesTermStoreSetsParentGroupGetSetsRequest) Execute() (MicrosoftGraphTermStoreSet, *_nethttp.Response, error) {
	return r.ApiService.SitesTermStoreSetsParentGroupGetSetsExecute(r)
}

/*
SitesTermStoreSetsParentGroupGetSets Get sets from sites

All sets under the group in a term [store].

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param siteId key: id of site
 @param setId key: id of set
 @param setId1 key: id of set
 @return ApiSitesTermStoreSetsParentGroupGetSetsRequest
*/
func (a *SitesStoreApiService) SitesTermStoreSetsParentGroupGetSets(ctx _context.Context, siteId string, setId string, setId1 string) ApiSitesTermStoreSetsParentGroupGetSetsRequest {
	return ApiSitesTermStoreSetsParentGroupGetSetsRequest{
		ApiService: a,
		ctx: ctx,
		siteId: siteId,
		setId: setId,
		setId1: setId1,
	}
}

// Execute executes the request
//  @return MicrosoftGraphTermStoreSet
func (a *SitesStoreApiService) SitesTermStoreSetsParentGroupGetSetsExecute(r ApiSitesTermStoreSetsParentGroupGetSetsRequest) (MicrosoftGraphTermStoreSet, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphTermStoreSet
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SitesStoreApiService.SitesTermStoreSetsParentGroupGetSets")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sites/{site-id}/termStore/sets/{set-id}/parentGroup/sets/{set-id1}"
	localVarPath = strings.Replace(localVarPath, "{"+"site-id"+"}", _neturl.PathEscape(parameterToString(r.siteId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"set-id"+"}", _neturl.PathEscape(parameterToString(r.setId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"set-id1"+"}", _neturl.PathEscape(parameterToString(r.setId1, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSitesTermStoreSetsParentGroupListSetsRequest struct {
	ctx _context.Context
	ApiService *SitesStoreApiService
	siteId string
	setId string
	top *int32
	skip *int32
	search *string
	filter *string
	count *bool
	orderby *[]string
	select_ *[]string
	expand *[]string
}

// Show only the first n items
func (r ApiSitesTermStoreSetsParentGroupListSetsRequest) Top(top int32) ApiSitesTermStoreSetsParentGroupListSetsRequest {
	r.top = &top
	return r
}
// Skip the first n items
func (r ApiSitesTermStoreSetsParentGroupListSetsRequest) Skip(skip int32) ApiSitesTermStoreSetsParentGroupListSetsRequest {
	r.skip = &skip
	return r
}
// Search items by search phrases
func (r ApiSitesTermStoreSetsParentGroupListSetsRequest) Search(search string) ApiSitesTermStoreSetsParentGroupListSetsRequest {
	r.search = &search
	return r
}
// Filter items by property values
func (r ApiSitesTermStoreSetsParentGroupListSetsRequest) Filter(filter string) ApiSitesTermStoreSetsParentGroupListSetsRequest {
	r.filter = &filter
	return r
}
// Include count of items
func (r ApiSitesTermStoreSetsParentGroupListSetsRequest) Count(count bool) ApiSitesTermStoreSetsParentGroupListSetsRequest {
	r.count = &count
	return r
}
// Order items by property values
func (r ApiSitesTermStoreSetsParentGroupListSetsRequest) Orderby(orderby []string) ApiSitesTermStoreSetsParentGroupListSetsRequest {
	r.orderby = &orderby
	return r
}
// Select properties to be returned
func (r ApiSitesTermStoreSetsParentGroupListSetsRequest) Select_(select_ []string) ApiSitesTermStoreSetsParentGroupListSetsRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiSitesTermStoreSetsParentGroupListSetsRequest) Expand(expand []string) ApiSitesTermStoreSetsParentGroupListSetsRequest {
	r.expand = &expand
	return r
}

func (r ApiSitesTermStoreSetsParentGroupListSetsRequest) Execute() (CollectionOfSet, *_nethttp.Response, error) {
	return r.ApiService.SitesTermStoreSetsParentGroupListSetsExecute(r)
}

/*
SitesTermStoreSetsParentGroupListSets Get sets from sites

All sets under the group in a term [store].

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param siteId key: id of site
 @param setId key: id of set
 @return ApiSitesTermStoreSetsParentGroupListSetsRequest
*/
func (a *SitesStoreApiService) SitesTermStoreSetsParentGroupListSets(ctx _context.Context, siteId string, setId string) ApiSitesTermStoreSetsParentGroupListSetsRequest {
	return ApiSitesTermStoreSetsParentGroupListSetsRequest{
		ApiService: a,
		ctx: ctx,
		siteId: siteId,
		setId: setId,
	}
}

// Execute executes the request
//  @return CollectionOfSet
func (a *SitesStoreApiService) SitesTermStoreSetsParentGroupListSetsExecute(r ApiSitesTermStoreSetsParentGroupListSetsRequest) (CollectionOfSet, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  CollectionOfSet
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SitesStoreApiService.SitesTermStoreSetsParentGroupListSets")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sites/{site-id}/termStore/sets/{set-id}/parentGroup/sets"
	localVarPath = strings.Replace(localVarPath, "{"+"site-id"+"}", _neturl.PathEscape(parameterToString(r.siteId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"set-id"+"}", _neturl.PathEscape(parameterToString(r.setId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.top != nil {
		localVarQueryParams.Add("$top", parameterToString(*r.top, ""))
	}
	if r.skip != nil {
		localVarQueryParams.Add("$skip", parameterToString(*r.skip, ""))
	}
	if r.search != nil {
		localVarQueryParams.Add("$search", parameterToString(*r.search, ""))
	}
	if r.filter != nil {
		localVarQueryParams.Add("$filter", parameterToString(*r.filter, ""))
	}
	if r.count != nil {
		localVarQueryParams.Add("$count", parameterToString(*r.count, ""))
	}
	if r.orderby != nil {
		localVarQueryParams.Add("$orderby", parameterToString(*r.orderby, "csv"))
	}
	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSitesTermStoreSetsParentGroupUpdateSetsRequest struct {
	ctx _context.Context
	ApiService *SitesStoreApiService
	siteId string
	setId string
	setId1 string
	microsoftGraphTermStoreSet *MicrosoftGraphTermStoreSet
}

// New navigation property values
func (r ApiSitesTermStoreSetsParentGroupUpdateSetsRequest) MicrosoftGraphTermStoreSet(microsoftGraphTermStoreSet MicrosoftGraphTermStoreSet) ApiSitesTermStoreSetsParentGroupUpdateSetsRequest {
	r.microsoftGraphTermStoreSet = &microsoftGraphTermStoreSet
	return r
}

func (r ApiSitesTermStoreSetsParentGroupUpdateSetsRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.SitesTermStoreSetsParentGroupUpdateSetsExecute(r)
}

/*
SitesTermStoreSetsParentGroupUpdateSets Update the navigation property sets in sites

All sets under the group in a term [store].

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param siteId key: id of site
 @param setId key: id of set
 @param setId1 key: id of set
 @return ApiSitesTermStoreSetsParentGroupUpdateSetsRequest
*/
func (a *SitesStoreApiService) SitesTermStoreSetsParentGroupUpdateSets(ctx _context.Context, siteId string, setId string, setId1 string) ApiSitesTermStoreSetsParentGroupUpdateSetsRequest {
	return ApiSitesTermStoreSetsParentGroupUpdateSetsRequest{
		ApiService: a,
		ctx: ctx,
		siteId: siteId,
		setId: setId,
		setId1: setId1,
	}
}

// Execute executes the request
func (a *SitesStoreApiService) SitesTermStoreSetsParentGroupUpdateSetsExecute(r ApiSitesTermStoreSetsParentGroupUpdateSetsRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPatch
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SitesStoreApiService.SitesTermStoreSetsParentGroupUpdateSets")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sites/{site-id}/termStore/sets/{set-id}/parentGroup/sets/{set-id1}"
	localVarPath = strings.Replace(localVarPath, "{"+"site-id"+"}", _neturl.PathEscape(parameterToString(r.siteId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"set-id"+"}", _neturl.PathEscape(parameterToString(r.setId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"set-id1"+"}", _neturl.PathEscape(parameterToString(r.setId1, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphTermStoreSet == nil {
		return nil, reportError("microsoftGraphTermStoreSet is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphTermStoreSet
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiSitesTermStoreSetsRelationsDeleteRefFromTermRequest struct {
	ctx _context.Context
	ApiService *SitesStoreApiService
	siteId string
	setId string
	relationId string
	ifMatch *string
}

// ETag
func (r ApiSitesTermStoreSetsRelationsDeleteRefFromTermRequest) IfMatch(ifMatch string) ApiSitesTermStoreSetsRelationsDeleteRefFromTermRequest {
	r.ifMatch = &ifMatch
	return r
}

func (r ApiSitesTermStoreSetsRelationsDeleteRefFromTermRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.SitesTermStoreSetsRelationsDeleteRefFromTermExecute(r)
}

/*
SitesTermStoreSetsRelationsDeleteRefFromTerm Delete ref of navigation property fromTerm for sites

The from [term] of the relation. The term from which the relationship is defined. A null value would indicate the relation is directly with the [set].

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param siteId key: id of site
 @param setId key: id of set
 @param relationId key: id of relation
 @return ApiSitesTermStoreSetsRelationsDeleteRefFromTermRequest
*/
func (a *SitesStoreApiService) SitesTermStoreSetsRelationsDeleteRefFromTerm(ctx _context.Context, siteId string, setId string, relationId string) ApiSitesTermStoreSetsRelationsDeleteRefFromTermRequest {
	return ApiSitesTermStoreSetsRelationsDeleteRefFromTermRequest{
		ApiService: a,
		ctx: ctx,
		siteId: siteId,
		setId: setId,
		relationId: relationId,
	}
}

// Execute executes the request
func (a *SitesStoreApiService) SitesTermStoreSetsRelationsDeleteRefFromTermExecute(r ApiSitesTermStoreSetsRelationsDeleteRefFromTermRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SitesStoreApiService.SitesTermStoreSetsRelationsDeleteRefFromTerm")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sites/{site-id}/termStore/sets/{set-id}/relations/{relation-id}/fromTerm/$ref"
	localVarPath = strings.Replace(localVarPath, "{"+"site-id"+"}", _neturl.PathEscape(parameterToString(r.siteId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"set-id"+"}", _neturl.PathEscape(parameterToString(r.setId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"relation-id"+"}", _neturl.PathEscape(parameterToString(r.relationId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ifMatch != nil {
		localVarHeaderParams["If-Match"] = parameterToString(*r.ifMatch, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiSitesTermStoreSetsRelationsDeleteRefSetRequest struct {
	ctx _context.Context
	ApiService *SitesStoreApiService
	siteId string
	setId string
	relationId string
	ifMatch *string
}

// ETag
func (r ApiSitesTermStoreSetsRelationsDeleteRefSetRequest) IfMatch(ifMatch string) ApiSitesTermStoreSetsRelationsDeleteRefSetRequest {
	r.ifMatch = &ifMatch
	return r
}

func (r ApiSitesTermStoreSetsRelationsDeleteRefSetRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.SitesTermStoreSetsRelationsDeleteRefSetExecute(r)
}

/*
SitesTermStoreSetsRelationsDeleteRefSet Delete ref of navigation property set for sites

The [set] in which the relation is relevant.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param siteId key: id of site
 @param setId key: id of set
 @param relationId key: id of relation
 @return ApiSitesTermStoreSetsRelationsDeleteRefSetRequest
*/
func (a *SitesStoreApiService) SitesTermStoreSetsRelationsDeleteRefSet(ctx _context.Context, siteId string, setId string, relationId string) ApiSitesTermStoreSetsRelationsDeleteRefSetRequest {
	return ApiSitesTermStoreSetsRelationsDeleteRefSetRequest{
		ApiService: a,
		ctx: ctx,
		siteId: siteId,
		setId: setId,
		relationId: relationId,
	}
}

// Execute executes the request
func (a *SitesStoreApiService) SitesTermStoreSetsRelationsDeleteRefSetExecute(r ApiSitesTermStoreSetsRelationsDeleteRefSetRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SitesStoreApiService.SitesTermStoreSetsRelationsDeleteRefSet")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sites/{site-id}/termStore/sets/{set-id}/relations/{relation-id}/set/$ref"
	localVarPath = strings.Replace(localVarPath, "{"+"site-id"+"}", _neturl.PathEscape(parameterToString(r.siteId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"set-id"+"}", _neturl.PathEscape(parameterToString(r.setId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"relation-id"+"}", _neturl.PathEscape(parameterToString(r.relationId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ifMatch != nil {
		localVarHeaderParams["If-Match"] = parameterToString(*r.ifMatch, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiSitesTermStoreSetsRelationsDeleteRefToTermRequest struct {
	ctx _context.Context
	ApiService *SitesStoreApiService
	siteId string
	setId string
	relationId string
	ifMatch *string
}

// ETag
func (r ApiSitesTermStoreSetsRelationsDeleteRefToTermRequest) IfMatch(ifMatch string) ApiSitesTermStoreSetsRelationsDeleteRefToTermRequest {
	r.ifMatch = &ifMatch
	return r
}

func (r ApiSitesTermStoreSetsRelationsDeleteRefToTermRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.SitesTermStoreSetsRelationsDeleteRefToTermExecute(r)
}

/*
SitesTermStoreSetsRelationsDeleteRefToTerm Delete ref of navigation property toTerm for sites

The to [term] of the relation. The term to which the relationship is defined.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param siteId key: id of site
 @param setId key: id of set
 @param relationId key: id of relation
 @return ApiSitesTermStoreSetsRelationsDeleteRefToTermRequest
*/
func (a *SitesStoreApiService) SitesTermStoreSetsRelationsDeleteRefToTerm(ctx _context.Context, siteId string, setId string, relationId string) ApiSitesTermStoreSetsRelationsDeleteRefToTermRequest {
	return ApiSitesTermStoreSetsRelationsDeleteRefToTermRequest{
		ApiService: a,
		ctx: ctx,
		siteId: siteId,
		setId: setId,
		relationId: relationId,
	}
}

// Execute executes the request
func (a *SitesStoreApiService) SitesTermStoreSetsRelationsDeleteRefToTermExecute(r ApiSitesTermStoreSetsRelationsDeleteRefToTermRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SitesStoreApiService.SitesTermStoreSetsRelationsDeleteRefToTerm")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sites/{site-id}/termStore/sets/{set-id}/relations/{relation-id}/toTerm/$ref"
	localVarPath = strings.Replace(localVarPath, "{"+"site-id"+"}", _neturl.PathEscape(parameterToString(r.siteId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"set-id"+"}", _neturl.PathEscape(parameterToString(r.setId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"relation-id"+"}", _neturl.PathEscape(parameterToString(r.relationId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ifMatch != nil {
		localVarHeaderParams["If-Match"] = parameterToString(*r.ifMatch, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiSitesTermStoreSetsRelationsGetFromTermRequest struct {
	ctx _context.Context
	ApiService *SitesStoreApiService
	siteId string
	setId string
	relationId string
	select_ *[]string
	expand *[]string
}

// Select properties to be returned
func (r ApiSitesTermStoreSetsRelationsGetFromTermRequest) Select_(select_ []string) ApiSitesTermStoreSetsRelationsGetFromTermRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiSitesTermStoreSetsRelationsGetFromTermRequest) Expand(expand []string) ApiSitesTermStoreSetsRelationsGetFromTermRequest {
	r.expand = &expand
	return r
}

func (r ApiSitesTermStoreSetsRelationsGetFromTermRequest) Execute() (MicrosoftGraphTermStoreTerm, *_nethttp.Response, error) {
	return r.ApiService.SitesTermStoreSetsRelationsGetFromTermExecute(r)
}

/*
SitesTermStoreSetsRelationsGetFromTerm Get fromTerm from sites

The from [term] of the relation. The term from which the relationship is defined. A null value would indicate the relation is directly with the [set].

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param siteId key: id of site
 @param setId key: id of set
 @param relationId key: id of relation
 @return ApiSitesTermStoreSetsRelationsGetFromTermRequest
*/
func (a *SitesStoreApiService) SitesTermStoreSetsRelationsGetFromTerm(ctx _context.Context, siteId string, setId string, relationId string) ApiSitesTermStoreSetsRelationsGetFromTermRequest {
	return ApiSitesTermStoreSetsRelationsGetFromTermRequest{
		ApiService: a,
		ctx: ctx,
		siteId: siteId,
		setId: setId,
		relationId: relationId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphTermStoreTerm
func (a *SitesStoreApiService) SitesTermStoreSetsRelationsGetFromTermExecute(r ApiSitesTermStoreSetsRelationsGetFromTermRequest) (MicrosoftGraphTermStoreTerm, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphTermStoreTerm
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SitesStoreApiService.SitesTermStoreSetsRelationsGetFromTerm")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sites/{site-id}/termStore/sets/{set-id}/relations/{relation-id}/fromTerm"
	localVarPath = strings.Replace(localVarPath, "{"+"site-id"+"}", _neturl.PathEscape(parameterToString(r.siteId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"set-id"+"}", _neturl.PathEscape(parameterToString(r.setId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"relation-id"+"}", _neturl.PathEscape(parameterToString(r.relationId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSitesTermStoreSetsRelationsGetRefFromTermRequest struct {
	ctx _context.Context
	ApiService *SitesStoreApiService
	siteId string
	setId string
	relationId string
}


func (r ApiSitesTermStoreSetsRelationsGetRefFromTermRequest) Execute() (string, *_nethttp.Response, error) {
	return r.ApiService.SitesTermStoreSetsRelationsGetRefFromTermExecute(r)
}

/*
SitesTermStoreSetsRelationsGetRefFromTerm Get ref of fromTerm from sites

The from [term] of the relation. The term from which the relationship is defined. A null value would indicate the relation is directly with the [set].

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param siteId key: id of site
 @param setId key: id of set
 @param relationId key: id of relation
 @return ApiSitesTermStoreSetsRelationsGetRefFromTermRequest
*/
func (a *SitesStoreApiService) SitesTermStoreSetsRelationsGetRefFromTerm(ctx _context.Context, siteId string, setId string, relationId string) ApiSitesTermStoreSetsRelationsGetRefFromTermRequest {
	return ApiSitesTermStoreSetsRelationsGetRefFromTermRequest{
		ApiService: a,
		ctx: ctx,
		siteId: siteId,
		setId: setId,
		relationId: relationId,
	}
}

// Execute executes the request
//  @return string
func (a *SitesStoreApiService) SitesTermStoreSetsRelationsGetRefFromTermExecute(r ApiSitesTermStoreSetsRelationsGetRefFromTermRequest) (string, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  string
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SitesStoreApiService.SitesTermStoreSetsRelationsGetRefFromTerm")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sites/{site-id}/termStore/sets/{set-id}/relations/{relation-id}/fromTerm/$ref"
	localVarPath = strings.Replace(localVarPath, "{"+"site-id"+"}", _neturl.PathEscape(parameterToString(r.siteId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"set-id"+"}", _neturl.PathEscape(parameterToString(r.setId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"relation-id"+"}", _neturl.PathEscape(parameterToString(r.relationId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSitesTermStoreSetsRelationsGetRefSetRequest struct {
	ctx _context.Context
	ApiService *SitesStoreApiService
	siteId string
	setId string
	relationId string
}


func (r ApiSitesTermStoreSetsRelationsGetRefSetRequest) Execute() (string, *_nethttp.Response, error) {
	return r.ApiService.SitesTermStoreSetsRelationsGetRefSetExecute(r)
}

/*
SitesTermStoreSetsRelationsGetRefSet Get ref of set from sites

The [set] in which the relation is relevant.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param siteId key: id of site
 @param setId key: id of set
 @param relationId key: id of relation
 @return ApiSitesTermStoreSetsRelationsGetRefSetRequest
*/
func (a *SitesStoreApiService) SitesTermStoreSetsRelationsGetRefSet(ctx _context.Context, siteId string, setId string, relationId string) ApiSitesTermStoreSetsRelationsGetRefSetRequest {
	return ApiSitesTermStoreSetsRelationsGetRefSetRequest{
		ApiService: a,
		ctx: ctx,
		siteId: siteId,
		setId: setId,
		relationId: relationId,
	}
}

// Execute executes the request
//  @return string
func (a *SitesStoreApiService) SitesTermStoreSetsRelationsGetRefSetExecute(r ApiSitesTermStoreSetsRelationsGetRefSetRequest) (string, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  string
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SitesStoreApiService.SitesTermStoreSetsRelationsGetRefSet")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sites/{site-id}/termStore/sets/{set-id}/relations/{relation-id}/set/$ref"
	localVarPath = strings.Replace(localVarPath, "{"+"site-id"+"}", _neturl.PathEscape(parameterToString(r.siteId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"set-id"+"}", _neturl.PathEscape(parameterToString(r.setId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"relation-id"+"}", _neturl.PathEscape(parameterToString(r.relationId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSitesTermStoreSetsRelationsGetRefToTermRequest struct {
	ctx _context.Context
	ApiService *SitesStoreApiService
	siteId string
	setId string
	relationId string
}


func (r ApiSitesTermStoreSetsRelationsGetRefToTermRequest) Execute() (string, *_nethttp.Response, error) {
	return r.ApiService.SitesTermStoreSetsRelationsGetRefToTermExecute(r)
}

/*
SitesTermStoreSetsRelationsGetRefToTerm Get ref of toTerm from sites

The to [term] of the relation. The term to which the relationship is defined.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param siteId key: id of site
 @param setId key: id of set
 @param relationId key: id of relation
 @return ApiSitesTermStoreSetsRelationsGetRefToTermRequest
*/
func (a *SitesStoreApiService) SitesTermStoreSetsRelationsGetRefToTerm(ctx _context.Context, siteId string, setId string, relationId string) ApiSitesTermStoreSetsRelationsGetRefToTermRequest {
	return ApiSitesTermStoreSetsRelationsGetRefToTermRequest{
		ApiService: a,
		ctx: ctx,
		siteId: siteId,
		setId: setId,
		relationId: relationId,
	}
}

// Execute executes the request
//  @return string
func (a *SitesStoreApiService) SitesTermStoreSetsRelationsGetRefToTermExecute(r ApiSitesTermStoreSetsRelationsGetRefToTermRequest) (string, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  string
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SitesStoreApiService.SitesTermStoreSetsRelationsGetRefToTerm")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sites/{site-id}/termStore/sets/{set-id}/relations/{relation-id}/toTerm/$ref"
	localVarPath = strings.Replace(localVarPath, "{"+"site-id"+"}", _neturl.PathEscape(parameterToString(r.siteId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"set-id"+"}", _neturl.PathEscape(parameterToString(r.setId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"relation-id"+"}", _neturl.PathEscape(parameterToString(r.relationId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSitesTermStoreSetsRelationsGetSetRequest struct {
	ctx _context.Context
	ApiService *SitesStoreApiService
	siteId string
	setId string
	relationId string
	select_ *[]string
	expand *[]string
}

// Select properties to be returned
func (r ApiSitesTermStoreSetsRelationsGetSetRequest) Select_(select_ []string) ApiSitesTermStoreSetsRelationsGetSetRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiSitesTermStoreSetsRelationsGetSetRequest) Expand(expand []string) ApiSitesTermStoreSetsRelationsGetSetRequest {
	r.expand = &expand
	return r
}

func (r ApiSitesTermStoreSetsRelationsGetSetRequest) Execute() (MicrosoftGraphTermStoreSet, *_nethttp.Response, error) {
	return r.ApiService.SitesTermStoreSetsRelationsGetSetExecute(r)
}

/*
SitesTermStoreSetsRelationsGetSet Get set from sites

The [set] in which the relation is relevant.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param siteId key: id of site
 @param setId key: id of set
 @param relationId key: id of relation
 @return ApiSitesTermStoreSetsRelationsGetSetRequest
*/
func (a *SitesStoreApiService) SitesTermStoreSetsRelationsGetSet(ctx _context.Context, siteId string, setId string, relationId string) ApiSitesTermStoreSetsRelationsGetSetRequest {
	return ApiSitesTermStoreSetsRelationsGetSetRequest{
		ApiService: a,
		ctx: ctx,
		siteId: siteId,
		setId: setId,
		relationId: relationId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphTermStoreSet
func (a *SitesStoreApiService) SitesTermStoreSetsRelationsGetSetExecute(r ApiSitesTermStoreSetsRelationsGetSetRequest) (MicrosoftGraphTermStoreSet, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphTermStoreSet
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SitesStoreApiService.SitesTermStoreSetsRelationsGetSet")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sites/{site-id}/termStore/sets/{set-id}/relations/{relation-id}/set"
	localVarPath = strings.Replace(localVarPath, "{"+"site-id"+"}", _neturl.PathEscape(parameterToString(r.siteId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"set-id"+"}", _neturl.PathEscape(parameterToString(r.setId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"relation-id"+"}", _neturl.PathEscape(parameterToString(r.relationId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSitesTermStoreSetsRelationsGetToTermRequest struct {
	ctx _context.Context
	ApiService *SitesStoreApiService
	siteId string
	setId string
	relationId string
	select_ *[]string
	expand *[]string
}

// Select properties to be returned
func (r ApiSitesTermStoreSetsRelationsGetToTermRequest) Select_(select_ []string) ApiSitesTermStoreSetsRelationsGetToTermRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiSitesTermStoreSetsRelationsGetToTermRequest) Expand(expand []string) ApiSitesTermStoreSetsRelationsGetToTermRequest {
	r.expand = &expand
	return r
}

func (r ApiSitesTermStoreSetsRelationsGetToTermRequest) Execute() (MicrosoftGraphTermStoreTerm, *_nethttp.Response, error) {
	return r.ApiService.SitesTermStoreSetsRelationsGetToTermExecute(r)
}

/*
SitesTermStoreSetsRelationsGetToTerm Get toTerm from sites

The to [term] of the relation. The term to which the relationship is defined.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param siteId key: id of site
 @param setId key: id of set
 @param relationId key: id of relation
 @return ApiSitesTermStoreSetsRelationsGetToTermRequest
*/
func (a *SitesStoreApiService) SitesTermStoreSetsRelationsGetToTerm(ctx _context.Context, siteId string, setId string, relationId string) ApiSitesTermStoreSetsRelationsGetToTermRequest {
	return ApiSitesTermStoreSetsRelationsGetToTermRequest{
		ApiService: a,
		ctx: ctx,
		siteId: siteId,
		setId: setId,
		relationId: relationId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphTermStoreTerm
func (a *SitesStoreApiService) SitesTermStoreSetsRelationsGetToTermExecute(r ApiSitesTermStoreSetsRelationsGetToTermRequest) (MicrosoftGraphTermStoreTerm, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphTermStoreTerm
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SitesStoreApiService.SitesTermStoreSetsRelationsGetToTerm")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sites/{site-id}/termStore/sets/{set-id}/relations/{relation-id}/toTerm"
	localVarPath = strings.Replace(localVarPath, "{"+"site-id"+"}", _neturl.PathEscape(parameterToString(r.siteId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"set-id"+"}", _neturl.PathEscape(parameterToString(r.setId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"relation-id"+"}", _neturl.PathEscape(parameterToString(r.relationId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSitesTermStoreSetsRelationsUpdateRefFromTermRequest struct {
	ctx _context.Context
	ApiService *SitesStoreApiService
	siteId string
	setId string
	relationId string
	requestBody *map[string]map[string]interface{}
}

// New navigation property ref values
func (r ApiSitesTermStoreSetsRelationsUpdateRefFromTermRequest) RequestBody(requestBody map[string]map[string]interface{}) ApiSitesTermStoreSetsRelationsUpdateRefFromTermRequest {
	r.requestBody = &requestBody
	return r
}

func (r ApiSitesTermStoreSetsRelationsUpdateRefFromTermRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.SitesTermStoreSetsRelationsUpdateRefFromTermExecute(r)
}

/*
SitesTermStoreSetsRelationsUpdateRefFromTerm Update the ref of navigation property fromTerm in sites

The from [term] of the relation. The term from which the relationship is defined. A null value would indicate the relation is directly with the [set].

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param siteId key: id of site
 @param setId key: id of set
 @param relationId key: id of relation
 @return ApiSitesTermStoreSetsRelationsUpdateRefFromTermRequest
*/
func (a *SitesStoreApiService) SitesTermStoreSetsRelationsUpdateRefFromTerm(ctx _context.Context, siteId string, setId string, relationId string) ApiSitesTermStoreSetsRelationsUpdateRefFromTermRequest {
	return ApiSitesTermStoreSetsRelationsUpdateRefFromTermRequest{
		ApiService: a,
		ctx: ctx,
		siteId: siteId,
		setId: setId,
		relationId: relationId,
	}
}

// Execute executes the request
func (a *SitesStoreApiService) SitesTermStoreSetsRelationsUpdateRefFromTermExecute(r ApiSitesTermStoreSetsRelationsUpdateRefFromTermRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPut
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SitesStoreApiService.SitesTermStoreSetsRelationsUpdateRefFromTerm")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sites/{site-id}/termStore/sets/{set-id}/relations/{relation-id}/fromTerm/$ref"
	localVarPath = strings.Replace(localVarPath, "{"+"site-id"+"}", _neturl.PathEscape(parameterToString(r.siteId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"set-id"+"}", _neturl.PathEscape(parameterToString(r.setId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"relation-id"+"}", _neturl.PathEscape(parameterToString(r.relationId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.requestBody == nil {
		return nil, reportError("requestBody is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.requestBody
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiSitesTermStoreSetsRelationsUpdateRefSetRequest struct {
	ctx _context.Context
	ApiService *SitesStoreApiService
	siteId string
	setId string
	relationId string
	requestBody *map[string]map[string]interface{}
}

// New navigation property ref values
func (r ApiSitesTermStoreSetsRelationsUpdateRefSetRequest) RequestBody(requestBody map[string]map[string]interface{}) ApiSitesTermStoreSetsRelationsUpdateRefSetRequest {
	r.requestBody = &requestBody
	return r
}

func (r ApiSitesTermStoreSetsRelationsUpdateRefSetRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.SitesTermStoreSetsRelationsUpdateRefSetExecute(r)
}

/*
SitesTermStoreSetsRelationsUpdateRefSet Update the ref of navigation property set in sites

The [set] in which the relation is relevant.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param siteId key: id of site
 @param setId key: id of set
 @param relationId key: id of relation
 @return ApiSitesTermStoreSetsRelationsUpdateRefSetRequest
*/
func (a *SitesStoreApiService) SitesTermStoreSetsRelationsUpdateRefSet(ctx _context.Context, siteId string, setId string, relationId string) ApiSitesTermStoreSetsRelationsUpdateRefSetRequest {
	return ApiSitesTermStoreSetsRelationsUpdateRefSetRequest{
		ApiService: a,
		ctx: ctx,
		siteId: siteId,
		setId: setId,
		relationId: relationId,
	}
}

// Execute executes the request
func (a *SitesStoreApiService) SitesTermStoreSetsRelationsUpdateRefSetExecute(r ApiSitesTermStoreSetsRelationsUpdateRefSetRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPut
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SitesStoreApiService.SitesTermStoreSetsRelationsUpdateRefSet")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sites/{site-id}/termStore/sets/{set-id}/relations/{relation-id}/set/$ref"
	localVarPath = strings.Replace(localVarPath, "{"+"site-id"+"}", _neturl.PathEscape(parameterToString(r.siteId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"set-id"+"}", _neturl.PathEscape(parameterToString(r.setId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"relation-id"+"}", _neturl.PathEscape(parameterToString(r.relationId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.requestBody == nil {
		return nil, reportError("requestBody is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.requestBody
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiSitesTermStoreSetsRelationsUpdateRefToTermRequest struct {
	ctx _context.Context
	ApiService *SitesStoreApiService
	siteId string
	setId string
	relationId string
	requestBody *map[string]map[string]interface{}
}

// New navigation property ref values
func (r ApiSitesTermStoreSetsRelationsUpdateRefToTermRequest) RequestBody(requestBody map[string]map[string]interface{}) ApiSitesTermStoreSetsRelationsUpdateRefToTermRequest {
	r.requestBody = &requestBody
	return r
}

func (r ApiSitesTermStoreSetsRelationsUpdateRefToTermRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.SitesTermStoreSetsRelationsUpdateRefToTermExecute(r)
}

/*
SitesTermStoreSetsRelationsUpdateRefToTerm Update the ref of navigation property toTerm in sites

The to [term] of the relation. The term to which the relationship is defined.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param siteId key: id of site
 @param setId key: id of set
 @param relationId key: id of relation
 @return ApiSitesTermStoreSetsRelationsUpdateRefToTermRequest
*/
func (a *SitesStoreApiService) SitesTermStoreSetsRelationsUpdateRefToTerm(ctx _context.Context, siteId string, setId string, relationId string) ApiSitesTermStoreSetsRelationsUpdateRefToTermRequest {
	return ApiSitesTermStoreSetsRelationsUpdateRefToTermRequest{
		ApiService: a,
		ctx: ctx,
		siteId: siteId,
		setId: setId,
		relationId: relationId,
	}
}

// Execute executes the request
func (a *SitesStoreApiService) SitesTermStoreSetsRelationsUpdateRefToTermExecute(r ApiSitesTermStoreSetsRelationsUpdateRefToTermRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPut
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SitesStoreApiService.SitesTermStoreSetsRelationsUpdateRefToTerm")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sites/{site-id}/termStore/sets/{set-id}/relations/{relation-id}/toTerm/$ref"
	localVarPath = strings.Replace(localVarPath, "{"+"site-id"+"}", _neturl.PathEscape(parameterToString(r.siteId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"set-id"+"}", _neturl.PathEscape(parameterToString(r.setId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"relation-id"+"}", _neturl.PathEscape(parameterToString(r.relationId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.requestBody == nil {
		return nil, reportError("requestBody is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.requestBody
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiSitesTermStoreSetsTermsCreateChildrenRequest struct {
	ctx _context.Context
	ApiService *SitesStoreApiService
	siteId string
	setId string
	termId string
	microsoftGraphTermStoreTerm *MicrosoftGraphTermStoreTerm
}

// New navigation property
func (r ApiSitesTermStoreSetsTermsCreateChildrenRequest) MicrosoftGraphTermStoreTerm(microsoftGraphTermStoreTerm MicrosoftGraphTermStoreTerm) ApiSitesTermStoreSetsTermsCreateChildrenRequest {
	r.microsoftGraphTermStoreTerm = &microsoftGraphTermStoreTerm
	return r
}

func (r ApiSitesTermStoreSetsTermsCreateChildrenRequest) Execute() (MicrosoftGraphTermStoreTerm, *_nethttp.Response, error) {
	return r.ApiService.SitesTermStoreSetsTermsCreateChildrenExecute(r)
}

/*
SitesTermStoreSetsTermsCreateChildren Create new navigation property to children for sites

Children of current term.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param siteId key: id of site
 @param setId key: id of set
 @param termId key: id of term
 @return ApiSitesTermStoreSetsTermsCreateChildrenRequest
*/
func (a *SitesStoreApiService) SitesTermStoreSetsTermsCreateChildren(ctx _context.Context, siteId string, setId string, termId string) ApiSitesTermStoreSetsTermsCreateChildrenRequest {
	return ApiSitesTermStoreSetsTermsCreateChildrenRequest{
		ApiService: a,
		ctx: ctx,
		siteId: siteId,
		setId: setId,
		termId: termId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphTermStoreTerm
func (a *SitesStoreApiService) SitesTermStoreSetsTermsCreateChildrenExecute(r ApiSitesTermStoreSetsTermsCreateChildrenRequest) (MicrosoftGraphTermStoreTerm, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphTermStoreTerm
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SitesStoreApiService.SitesTermStoreSetsTermsCreateChildren")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sites/{site-id}/termStore/sets/{set-id}/terms/{term-id}/children"
	localVarPath = strings.Replace(localVarPath, "{"+"site-id"+"}", _neturl.PathEscape(parameterToString(r.siteId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"set-id"+"}", _neturl.PathEscape(parameterToString(r.setId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"term-id"+"}", _neturl.PathEscape(parameterToString(r.termId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphTermStoreTerm == nil {
		return localVarReturnValue, nil, reportError("microsoftGraphTermStoreTerm is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphTermStoreTerm
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSitesTermStoreSetsTermsCreateRelationsRequest struct {
	ctx _context.Context
	ApiService *SitesStoreApiService
	siteId string
	setId string
	termId string
	microsoftGraphTermStoreRelation *MicrosoftGraphTermStoreRelation
}

// New navigation property
func (r ApiSitesTermStoreSetsTermsCreateRelationsRequest) MicrosoftGraphTermStoreRelation(microsoftGraphTermStoreRelation MicrosoftGraphTermStoreRelation) ApiSitesTermStoreSetsTermsCreateRelationsRequest {
	r.microsoftGraphTermStoreRelation = &microsoftGraphTermStoreRelation
	return r
}

func (r ApiSitesTermStoreSetsTermsCreateRelationsRequest) Execute() (MicrosoftGraphTermStoreRelation, *_nethttp.Response, error) {
	return r.ApiService.SitesTermStoreSetsTermsCreateRelationsExecute(r)
}

/*
SitesTermStoreSetsTermsCreateRelations Create new navigation property to relations for sites

To indicate which terms are related to the current term as either pinned or reused.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param siteId key: id of site
 @param setId key: id of set
 @param termId key: id of term
 @return ApiSitesTermStoreSetsTermsCreateRelationsRequest
*/
func (a *SitesStoreApiService) SitesTermStoreSetsTermsCreateRelations(ctx _context.Context, siteId string, setId string, termId string) ApiSitesTermStoreSetsTermsCreateRelationsRequest {
	return ApiSitesTermStoreSetsTermsCreateRelationsRequest{
		ApiService: a,
		ctx: ctx,
		siteId: siteId,
		setId: setId,
		termId: termId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphTermStoreRelation
func (a *SitesStoreApiService) SitesTermStoreSetsTermsCreateRelationsExecute(r ApiSitesTermStoreSetsTermsCreateRelationsRequest) (MicrosoftGraphTermStoreRelation, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphTermStoreRelation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SitesStoreApiService.SitesTermStoreSetsTermsCreateRelations")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sites/{site-id}/termStore/sets/{set-id}/terms/{term-id}/relations"
	localVarPath = strings.Replace(localVarPath, "{"+"site-id"+"}", _neturl.PathEscape(parameterToString(r.siteId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"set-id"+"}", _neturl.PathEscape(parameterToString(r.setId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"term-id"+"}", _neturl.PathEscape(parameterToString(r.termId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphTermStoreRelation == nil {
		return localVarReturnValue, nil, reportError("microsoftGraphTermStoreRelation is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphTermStoreRelation
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSitesTermStoreSetsTermsDeleteChildrenRequest struct {
	ctx _context.Context
	ApiService *SitesStoreApiService
	siteId string
	setId string
	termId string
	termId1 string
	ifMatch *string
}

// ETag
func (r ApiSitesTermStoreSetsTermsDeleteChildrenRequest) IfMatch(ifMatch string) ApiSitesTermStoreSetsTermsDeleteChildrenRequest {
	r.ifMatch = &ifMatch
	return r
}

func (r ApiSitesTermStoreSetsTermsDeleteChildrenRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.SitesTermStoreSetsTermsDeleteChildrenExecute(r)
}

/*
SitesTermStoreSetsTermsDeleteChildren Delete navigation property children for sites

Children of current term.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param siteId key: id of site
 @param setId key: id of set
 @param termId key: id of term
 @param termId1 key: id of term
 @return ApiSitesTermStoreSetsTermsDeleteChildrenRequest
*/
func (a *SitesStoreApiService) SitesTermStoreSetsTermsDeleteChildren(ctx _context.Context, siteId string, setId string, termId string, termId1 string) ApiSitesTermStoreSetsTermsDeleteChildrenRequest {
	return ApiSitesTermStoreSetsTermsDeleteChildrenRequest{
		ApiService: a,
		ctx: ctx,
		siteId: siteId,
		setId: setId,
		termId: termId,
		termId1: termId1,
	}
}

// Execute executes the request
func (a *SitesStoreApiService) SitesTermStoreSetsTermsDeleteChildrenExecute(r ApiSitesTermStoreSetsTermsDeleteChildrenRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SitesStoreApiService.SitesTermStoreSetsTermsDeleteChildren")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sites/{site-id}/termStore/sets/{set-id}/terms/{term-id}/children/{term-id1}"
	localVarPath = strings.Replace(localVarPath, "{"+"site-id"+"}", _neturl.PathEscape(parameterToString(r.siteId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"set-id"+"}", _neturl.PathEscape(parameterToString(r.setId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"term-id"+"}", _neturl.PathEscape(parameterToString(r.termId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"term-id1"+"}", _neturl.PathEscape(parameterToString(r.termId1, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ifMatch != nil {
		localVarHeaderParams["If-Match"] = parameterToString(*r.ifMatch, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiSitesTermStoreSetsTermsDeleteRefSetRequest struct {
	ctx _context.Context
	ApiService *SitesStoreApiService
	siteId string
	setId string
	termId string
	ifMatch *string
}

// ETag
func (r ApiSitesTermStoreSetsTermsDeleteRefSetRequest) IfMatch(ifMatch string) ApiSitesTermStoreSetsTermsDeleteRefSetRequest {
	r.ifMatch = &ifMatch
	return r
}

func (r ApiSitesTermStoreSetsTermsDeleteRefSetRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.SitesTermStoreSetsTermsDeleteRefSetExecute(r)
}

/*
SitesTermStoreSetsTermsDeleteRefSet Delete ref of navigation property set for sites

The [set] in which the term is created.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param siteId key: id of site
 @param setId key: id of set
 @param termId key: id of term
 @return ApiSitesTermStoreSetsTermsDeleteRefSetRequest
*/
func (a *SitesStoreApiService) SitesTermStoreSetsTermsDeleteRefSet(ctx _context.Context, siteId string, setId string, termId string) ApiSitesTermStoreSetsTermsDeleteRefSetRequest {
	return ApiSitesTermStoreSetsTermsDeleteRefSetRequest{
		ApiService: a,
		ctx: ctx,
		siteId: siteId,
		setId: setId,
		termId: termId,
	}
}

// Execute executes the request
func (a *SitesStoreApiService) SitesTermStoreSetsTermsDeleteRefSetExecute(r ApiSitesTermStoreSetsTermsDeleteRefSetRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SitesStoreApiService.SitesTermStoreSetsTermsDeleteRefSet")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sites/{site-id}/termStore/sets/{set-id}/terms/{term-id}/set/$ref"
	localVarPath = strings.Replace(localVarPath, "{"+"site-id"+"}", _neturl.PathEscape(parameterToString(r.siteId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"set-id"+"}", _neturl.PathEscape(parameterToString(r.setId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"term-id"+"}", _neturl.PathEscape(parameterToString(r.termId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ifMatch != nil {
		localVarHeaderParams["If-Match"] = parameterToString(*r.ifMatch, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiSitesTermStoreSetsTermsDeleteRelationsRequest struct {
	ctx _context.Context
	ApiService *SitesStoreApiService
	siteId string
	setId string
	termId string
	relationId string
	ifMatch *string
}

// ETag
func (r ApiSitesTermStoreSetsTermsDeleteRelationsRequest) IfMatch(ifMatch string) ApiSitesTermStoreSetsTermsDeleteRelationsRequest {
	r.ifMatch = &ifMatch
	return r
}

func (r ApiSitesTermStoreSetsTermsDeleteRelationsRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.SitesTermStoreSetsTermsDeleteRelationsExecute(r)
}

/*
SitesTermStoreSetsTermsDeleteRelations Delete navigation property relations for sites

To indicate which terms are related to the current term as either pinned or reused.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param siteId key: id of site
 @param setId key: id of set
 @param termId key: id of term
 @param relationId key: id of relation
 @return ApiSitesTermStoreSetsTermsDeleteRelationsRequest
*/
func (a *SitesStoreApiService) SitesTermStoreSetsTermsDeleteRelations(ctx _context.Context, siteId string, setId string, termId string, relationId string) ApiSitesTermStoreSetsTermsDeleteRelationsRequest {
	return ApiSitesTermStoreSetsTermsDeleteRelationsRequest{
		ApiService: a,
		ctx: ctx,
		siteId: siteId,
		setId: setId,
		termId: termId,
		relationId: relationId,
	}
}

// Execute executes the request
func (a *SitesStoreApiService) SitesTermStoreSetsTermsDeleteRelationsExecute(r ApiSitesTermStoreSetsTermsDeleteRelationsRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SitesStoreApiService.SitesTermStoreSetsTermsDeleteRelations")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sites/{site-id}/termStore/sets/{set-id}/terms/{term-id}/relations/{relation-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"site-id"+"}", _neturl.PathEscape(parameterToString(r.siteId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"set-id"+"}", _neturl.PathEscape(parameterToString(r.setId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"term-id"+"}", _neturl.PathEscape(parameterToString(r.termId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"relation-id"+"}", _neturl.PathEscape(parameterToString(r.relationId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ifMatch != nil {
		localVarHeaderParams["If-Match"] = parameterToString(*r.ifMatch, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiSitesTermStoreSetsTermsGetChildrenRequest struct {
	ctx _context.Context
	ApiService *SitesStoreApiService
	siteId string
	setId string
	termId string
	termId1 string
	select_ *[]string
	expand *[]string
}

// Select properties to be returned
func (r ApiSitesTermStoreSetsTermsGetChildrenRequest) Select_(select_ []string) ApiSitesTermStoreSetsTermsGetChildrenRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiSitesTermStoreSetsTermsGetChildrenRequest) Expand(expand []string) ApiSitesTermStoreSetsTermsGetChildrenRequest {
	r.expand = &expand
	return r
}

func (r ApiSitesTermStoreSetsTermsGetChildrenRequest) Execute() (MicrosoftGraphTermStoreTerm, *_nethttp.Response, error) {
	return r.ApiService.SitesTermStoreSetsTermsGetChildrenExecute(r)
}

/*
SitesTermStoreSetsTermsGetChildren Get children from sites

Children of current term.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param siteId key: id of site
 @param setId key: id of set
 @param termId key: id of term
 @param termId1 key: id of term
 @return ApiSitesTermStoreSetsTermsGetChildrenRequest
*/
func (a *SitesStoreApiService) SitesTermStoreSetsTermsGetChildren(ctx _context.Context, siteId string, setId string, termId string, termId1 string) ApiSitesTermStoreSetsTermsGetChildrenRequest {
	return ApiSitesTermStoreSetsTermsGetChildrenRequest{
		ApiService: a,
		ctx: ctx,
		siteId: siteId,
		setId: setId,
		termId: termId,
		termId1: termId1,
	}
}

// Execute executes the request
//  @return MicrosoftGraphTermStoreTerm
func (a *SitesStoreApiService) SitesTermStoreSetsTermsGetChildrenExecute(r ApiSitesTermStoreSetsTermsGetChildrenRequest) (MicrosoftGraphTermStoreTerm, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphTermStoreTerm
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SitesStoreApiService.SitesTermStoreSetsTermsGetChildren")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sites/{site-id}/termStore/sets/{set-id}/terms/{term-id}/children/{term-id1}"
	localVarPath = strings.Replace(localVarPath, "{"+"site-id"+"}", _neturl.PathEscape(parameterToString(r.siteId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"set-id"+"}", _neturl.PathEscape(parameterToString(r.setId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"term-id"+"}", _neturl.PathEscape(parameterToString(r.termId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"term-id1"+"}", _neturl.PathEscape(parameterToString(r.termId1, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSitesTermStoreSetsTermsGetRefSetRequest struct {
	ctx _context.Context
	ApiService *SitesStoreApiService
	siteId string
	setId string
	termId string
}


func (r ApiSitesTermStoreSetsTermsGetRefSetRequest) Execute() (string, *_nethttp.Response, error) {
	return r.ApiService.SitesTermStoreSetsTermsGetRefSetExecute(r)
}

/*
SitesTermStoreSetsTermsGetRefSet Get ref of set from sites

The [set] in which the term is created.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param siteId key: id of site
 @param setId key: id of set
 @param termId key: id of term
 @return ApiSitesTermStoreSetsTermsGetRefSetRequest
*/
func (a *SitesStoreApiService) SitesTermStoreSetsTermsGetRefSet(ctx _context.Context, siteId string, setId string, termId string) ApiSitesTermStoreSetsTermsGetRefSetRequest {
	return ApiSitesTermStoreSetsTermsGetRefSetRequest{
		ApiService: a,
		ctx: ctx,
		siteId: siteId,
		setId: setId,
		termId: termId,
	}
}

// Execute executes the request
//  @return string
func (a *SitesStoreApiService) SitesTermStoreSetsTermsGetRefSetExecute(r ApiSitesTermStoreSetsTermsGetRefSetRequest) (string, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  string
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SitesStoreApiService.SitesTermStoreSetsTermsGetRefSet")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sites/{site-id}/termStore/sets/{set-id}/terms/{term-id}/set/$ref"
	localVarPath = strings.Replace(localVarPath, "{"+"site-id"+"}", _neturl.PathEscape(parameterToString(r.siteId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"set-id"+"}", _neturl.PathEscape(parameterToString(r.setId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"term-id"+"}", _neturl.PathEscape(parameterToString(r.termId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSitesTermStoreSetsTermsGetRelationsRequest struct {
	ctx _context.Context
	ApiService *SitesStoreApiService
	siteId string
	setId string
	termId string
	relationId string
	select_ *[]string
	expand *[]string
}

// Select properties to be returned
func (r ApiSitesTermStoreSetsTermsGetRelationsRequest) Select_(select_ []string) ApiSitesTermStoreSetsTermsGetRelationsRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiSitesTermStoreSetsTermsGetRelationsRequest) Expand(expand []string) ApiSitesTermStoreSetsTermsGetRelationsRequest {
	r.expand = &expand
	return r
}

func (r ApiSitesTermStoreSetsTermsGetRelationsRequest) Execute() (MicrosoftGraphTermStoreRelation, *_nethttp.Response, error) {
	return r.ApiService.SitesTermStoreSetsTermsGetRelationsExecute(r)
}

/*
SitesTermStoreSetsTermsGetRelations Get relations from sites

To indicate which terms are related to the current term as either pinned or reused.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param siteId key: id of site
 @param setId key: id of set
 @param termId key: id of term
 @param relationId key: id of relation
 @return ApiSitesTermStoreSetsTermsGetRelationsRequest
*/
func (a *SitesStoreApiService) SitesTermStoreSetsTermsGetRelations(ctx _context.Context, siteId string, setId string, termId string, relationId string) ApiSitesTermStoreSetsTermsGetRelationsRequest {
	return ApiSitesTermStoreSetsTermsGetRelationsRequest{
		ApiService: a,
		ctx: ctx,
		siteId: siteId,
		setId: setId,
		termId: termId,
		relationId: relationId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphTermStoreRelation
func (a *SitesStoreApiService) SitesTermStoreSetsTermsGetRelationsExecute(r ApiSitesTermStoreSetsTermsGetRelationsRequest) (MicrosoftGraphTermStoreRelation, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphTermStoreRelation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SitesStoreApiService.SitesTermStoreSetsTermsGetRelations")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sites/{site-id}/termStore/sets/{set-id}/terms/{term-id}/relations/{relation-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"site-id"+"}", _neturl.PathEscape(parameterToString(r.siteId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"set-id"+"}", _neturl.PathEscape(parameterToString(r.setId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"term-id"+"}", _neturl.PathEscape(parameterToString(r.termId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"relation-id"+"}", _neturl.PathEscape(parameterToString(r.relationId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSitesTermStoreSetsTermsGetSetRequest struct {
	ctx _context.Context
	ApiService *SitesStoreApiService
	siteId string
	setId string
	termId string
	select_ *[]string
	expand *[]string
}

// Select properties to be returned
func (r ApiSitesTermStoreSetsTermsGetSetRequest) Select_(select_ []string) ApiSitesTermStoreSetsTermsGetSetRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiSitesTermStoreSetsTermsGetSetRequest) Expand(expand []string) ApiSitesTermStoreSetsTermsGetSetRequest {
	r.expand = &expand
	return r
}

func (r ApiSitesTermStoreSetsTermsGetSetRequest) Execute() (MicrosoftGraphTermStoreSet, *_nethttp.Response, error) {
	return r.ApiService.SitesTermStoreSetsTermsGetSetExecute(r)
}

/*
SitesTermStoreSetsTermsGetSet Get set from sites

The [set] in which the term is created.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param siteId key: id of site
 @param setId key: id of set
 @param termId key: id of term
 @return ApiSitesTermStoreSetsTermsGetSetRequest
*/
func (a *SitesStoreApiService) SitesTermStoreSetsTermsGetSet(ctx _context.Context, siteId string, setId string, termId string) ApiSitesTermStoreSetsTermsGetSetRequest {
	return ApiSitesTermStoreSetsTermsGetSetRequest{
		ApiService: a,
		ctx: ctx,
		siteId: siteId,
		setId: setId,
		termId: termId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphTermStoreSet
func (a *SitesStoreApiService) SitesTermStoreSetsTermsGetSetExecute(r ApiSitesTermStoreSetsTermsGetSetRequest) (MicrosoftGraphTermStoreSet, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphTermStoreSet
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SitesStoreApiService.SitesTermStoreSetsTermsGetSet")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sites/{site-id}/termStore/sets/{set-id}/terms/{term-id}/set"
	localVarPath = strings.Replace(localVarPath, "{"+"site-id"+"}", _neturl.PathEscape(parameterToString(r.siteId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"set-id"+"}", _neturl.PathEscape(parameterToString(r.setId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"term-id"+"}", _neturl.PathEscape(parameterToString(r.termId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSitesTermStoreSetsTermsListChildrenRequest struct {
	ctx _context.Context
	ApiService *SitesStoreApiService
	siteId string
	setId string
	termId string
	top *int32
	skip *int32
	search *string
	filter *string
	count *bool
	orderby *[]string
	select_ *[]string
	expand *[]string
}

// Show only the first n items
func (r ApiSitesTermStoreSetsTermsListChildrenRequest) Top(top int32) ApiSitesTermStoreSetsTermsListChildrenRequest {
	r.top = &top
	return r
}
// Skip the first n items
func (r ApiSitesTermStoreSetsTermsListChildrenRequest) Skip(skip int32) ApiSitesTermStoreSetsTermsListChildrenRequest {
	r.skip = &skip
	return r
}
// Search items by search phrases
func (r ApiSitesTermStoreSetsTermsListChildrenRequest) Search(search string) ApiSitesTermStoreSetsTermsListChildrenRequest {
	r.search = &search
	return r
}
// Filter items by property values
func (r ApiSitesTermStoreSetsTermsListChildrenRequest) Filter(filter string) ApiSitesTermStoreSetsTermsListChildrenRequest {
	r.filter = &filter
	return r
}
// Include count of items
func (r ApiSitesTermStoreSetsTermsListChildrenRequest) Count(count bool) ApiSitesTermStoreSetsTermsListChildrenRequest {
	r.count = &count
	return r
}
// Order items by property values
func (r ApiSitesTermStoreSetsTermsListChildrenRequest) Orderby(orderby []string) ApiSitesTermStoreSetsTermsListChildrenRequest {
	r.orderby = &orderby
	return r
}
// Select properties to be returned
func (r ApiSitesTermStoreSetsTermsListChildrenRequest) Select_(select_ []string) ApiSitesTermStoreSetsTermsListChildrenRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiSitesTermStoreSetsTermsListChildrenRequest) Expand(expand []string) ApiSitesTermStoreSetsTermsListChildrenRequest {
	r.expand = &expand
	return r
}

func (r ApiSitesTermStoreSetsTermsListChildrenRequest) Execute() (CollectionOfTerm, *_nethttp.Response, error) {
	return r.ApiService.SitesTermStoreSetsTermsListChildrenExecute(r)
}

/*
SitesTermStoreSetsTermsListChildren Get children from sites

Children of current term.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param siteId key: id of site
 @param setId key: id of set
 @param termId key: id of term
 @return ApiSitesTermStoreSetsTermsListChildrenRequest
*/
func (a *SitesStoreApiService) SitesTermStoreSetsTermsListChildren(ctx _context.Context, siteId string, setId string, termId string) ApiSitesTermStoreSetsTermsListChildrenRequest {
	return ApiSitesTermStoreSetsTermsListChildrenRequest{
		ApiService: a,
		ctx: ctx,
		siteId: siteId,
		setId: setId,
		termId: termId,
	}
}

// Execute executes the request
//  @return CollectionOfTerm
func (a *SitesStoreApiService) SitesTermStoreSetsTermsListChildrenExecute(r ApiSitesTermStoreSetsTermsListChildrenRequest) (CollectionOfTerm, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  CollectionOfTerm
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SitesStoreApiService.SitesTermStoreSetsTermsListChildren")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sites/{site-id}/termStore/sets/{set-id}/terms/{term-id}/children"
	localVarPath = strings.Replace(localVarPath, "{"+"site-id"+"}", _neturl.PathEscape(parameterToString(r.siteId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"set-id"+"}", _neturl.PathEscape(parameterToString(r.setId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"term-id"+"}", _neturl.PathEscape(parameterToString(r.termId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.top != nil {
		localVarQueryParams.Add("$top", parameterToString(*r.top, ""))
	}
	if r.skip != nil {
		localVarQueryParams.Add("$skip", parameterToString(*r.skip, ""))
	}
	if r.search != nil {
		localVarQueryParams.Add("$search", parameterToString(*r.search, ""))
	}
	if r.filter != nil {
		localVarQueryParams.Add("$filter", parameterToString(*r.filter, ""))
	}
	if r.count != nil {
		localVarQueryParams.Add("$count", parameterToString(*r.count, ""))
	}
	if r.orderby != nil {
		localVarQueryParams.Add("$orderby", parameterToString(*r.orderby, "csv"))
	}
	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSitesTermStoreSetsTermsListRelationsRequest struct {
	ctx _context.Context
	ApiService *SitesStoreApiService
	siteId string
	setId string
	termId string
	top *int32
	skip *int32
	search *string
	filter *string
	count *bool
	orderby *[]string
	select_ *[]string
	expand *[]string
}

// Show only the first n items
func (r ApiSitesTermStoreSetsTermsListRelationsRequest) Top(top int32) ApiSitesTermStoreSetsTermsListRelationsRequest {
	r.top = &top
	return r
}
// Skip the first n items
func (r ApiSitesTermStoreSetsTermsListRelationsRequest) Skip(skip int32) ApiSitesTermStoreSetsTermsListRelationsRequest {
	r.skip = &skip
	return r
}
// Search items by search phrases
func (r ApiSitesTermStoreSetsTermsListRelationsRequest) Search(search string) ApiSitesTermStoreSetsTermsListRelationsRequest {
	r.search = &search
	return r
}
// Filter items by property values
func (r ApiSitesTermStoreSetsTermsListRelationsRequest) Filter(filter string) ApiSitesTermStoreSetsTermsListRelationsRequest {
	r.filter = &filter
	return r
}
// Include count of items
func (r ApiSitesTermStoreSetsTermsListRelationsRequest) Count(count bool) ApiSitesTermStoreSetsTermsListRelationsRequest {
	r.count = &count
	return r
}
// Order items by property values
func (r ApiSitesTermStoreSetsTermsListRelationsRequest) Orderby(orderby []string) ApiSitesTermStoreSetsTermsListRelationsRequest {
	r.orderby = &orderby
	return r
}
// Select properties to be returned
func (r ApiSitesTermStoreSetsTermsListRelationsRequest) Select_(select_ []string) ApiSitesTermStoreSetsTermsListRelationsRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiSitesTermStoreSetsTermsListRelationsRequest) Expand(expand []string) ApiSitesTermStoreSetsTermsListRelationsRequest {
	r.expand = &expand
	return r
}

func (r ApiSitesTermStoreSetsTermsListRelationsRequest) Execute() (CollectionOfRelation, *_nethttp.Response, error) {
	return r.ApiService.SitesTermStoreSetsTermsListRelationsExecute(r)
}

/*
SitesTermStoreSetsTermsListRelations Get relations from sites

To indicate which terms are related to the current term as either pinned or reused.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param siteId key: id of site
 @param setId key: id of set
 @param termId key: id of term
 @return ApiSitesTermStoreSetsTermsListRelationsRequest
*/
func (a *SitesStoreApiService) SitesTermStoreSetsTermsListRelations(ctx _context.Context, siteId string, setId string, termId string) ApiSitesTermStoreSetsTermsListRelationsRequest {
	return ApiSitesTermStoreSetsTermsListRelationsRequest{
		ApiService: a,
		ctx: ctx,
		siteId: siteId,
		setId: setId,
		termId: termId,
	}
}

// Execute executes the request
//  @return CollectionOfRelation
func (a *SitesStoreApiService) SitesTermStoreSetsTermsListRelationsExecute(r ApiSitesTermStoreSetsTermsListRelationsRequest) (CollectionOfRelation, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  CollectionOfRelation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SitesStoreApiService.SitesTermStoreSetsTermsListRelations")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sites/{site-id}/termStore/sets/{set-id}/terms/{term-id}/relations"
	localVarPath = strings.Replace(localVarPath, "{"+"site-id"+"}", _neturl.PathEscape(parameterToString(r.siteId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"set-id"+"}", _neturl.PathEscape(parameterToString(r.setId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"term-id"+"}", _neturl.PathEscape(parameterToString(r.termId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.top != nil {
		localVarQueryParams.Add("$top", parameterToString(*r.top, ""))
	}
	if r.skip != nil {
		localVarQueryParams.Add("$skip", parameterToString(*r.skip, ""))
	}
	if r.search != nil {
		localVarQueryParams.Add("$search", parameterToString(*r.search, ""))
	}
	if r.filter != nil {
		localVarQueryParams.Add("$filter", parameterToString(*r.filter, ""))
	}
	if r.count != nil {
		localVarQueryParams.Add("$count", parameterToString(*r.count, ""))
	}
	if r.orderby != nil {
		localVarQueryParams.Add("$orderby", parameterToString(*r.orderby, "csv"))
	}
	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSitesTermStoreSetsTermsRelationsDeleteRefFromTermRequest struct {
	ctx _context.Context
	ApiService *SitesStoreApiService
	siteId string
	setId string
	termId string
	relationId string
	ifMatch *string
}

// ETag
func (r ApiSitesTermStoreSetsTermsRelationsDeleteRefFromTermRequest) IfMatch(ifMatch string) ApiSitesTermStoreSetsTermsRelationsDeleteRefFromTermRequest {
	r.ifMatch = &ifMatch
	return r
}

func (r ApiSitesTermStoreSetsTermsRelationsDeleteRefFromTermRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.SitesTermStoreSetsTermsRelationsDeleteRefFromTermExecute(r)
}

/*
SitesTermStoreSetsTermsRelationsDeleteRefFromTerm Delete ref of navigation property fromTerm for sites

The from [term] of the relation. The term from which the relationship is defined. A null value would indicate the relation is directly with the [set].

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param siteId key: id of site
 @param setId key: id of set
 @param termId key: id of term
 @param relationId key: id of relation
 @return ApiSitesTermStoreSetsTermsRelationsDeleteRefFromTermRequest
*/
func (a *SitesStoreApiService) SitesTermStoreSetsTermsRelationsDeleteRefFromTerm(ctx _context.Context, siteId string, setId string, termId string, relationId string) ApiSitesTermStoreSetsTermsRelationsDeleteRefFromTermRequest {
	return ApiSitesTermStoreSetsTermsRelationsDeleteRefFromTermRequest{
		ApiService: a,
		ctx: ctx,
		siteId: siteId,
		setId: setId,
		termId: termId,
		relationId: relationId,
	}
}

// Execute executes the request
func (a *SitesStoreApiService) SitesTermStoreSetsTermsRelationsDeleteRefFromTermExecute(r ApiSitesTermStoreSetsTermsRelationsDeleteRefFromTermRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SitesStoreApiService.SitesTermStoreSetsTermsRelationsDeleteRefFromTerm")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sites/{site-id}/termStore/sets/{set-id}/terms/{term-id}/relations/{relation-id}/fromTerm/$ref"
	localVarPath = strings.Replace(localVarPath, "{"+"site-id"+"}", _neturl.PathEscape(parameterToString(r.siteId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"set-id"+"}", _neturl.PathEscape(parameterToString(r.setId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"term-id"+"}", _neturl.PathEscape(parameterToString(r.termId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"relation-id"+"}", _neturl.PathEscape(parameterToString(r.relationId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ifMatch != nil {
		localVarHeaderParams["If-Match"] = parameterToString(*r.ifMatch, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiSitesTermStoreSetsTermsRelationsDeleteRefSetRequest struct {
	ctx _context.Context
	ApiService *SitesStoreApiService
	siteId string
	setId string
	termId string
	relationId string
	ifMatch *string
}

// ETag
func (r ApiSitesTermStoreSetsTermsRelationsDeleteRefSetRequest) IfMatch(ifMatch string) ApiSitesTermStoreSetsTermsRelationsDeleteRefSetRequest {
	r.ifMatch = &ifMatch
	return r
}

func (r ApiSitesTermStoreSetsTermsRelationsDeleteRefSetRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.SitesTermStoreSetsTermsRelationsDeleteRefSetExecute(r)
}

/*
SitesTermStoreSetsTermsRelationsDeleteRefSet Delete ref of navigation property set for sites

The [set] in which the relation is relevant.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param siteId key: id of site
 @param setId key: id of set
 @param termId key: id of term
 @param relationId key: id of relation
 @return ApiSitesTermStoreSetsTermsRelationsDeleteRefSetRequest
*/
func (a *SitesStoreApiService) SitesTermStoreSetsTermsRelationsDeleteRefSet(ctx _context.Context, siteId string, setId string, termId string, relationId string) ApiSitesTermStoreSetsTermsRelationsDeleteRefSetRequest {
	return ApiSitesTermStoreSetsTermsRelationsDeleteRefSetRequest{
		ApiService: a,
		ctx: ctx,
		siteId: siteId,
		setId: setId,
		termId: termId,
		relationId: relationId,
	}
}

// Execute executes the request
func (a *SitesStoreApiService) SitesTermStoreSetsTermsRelationsDeleteRefSetExecute(r ApiSitesTermStoreSetsTermsRelationsDeleteRefSetRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SitesStoreApiService.SitesTermStoreSetsTermsRelationsDeleteRefSet")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sites/{site-id}/termStore/sets/{set-id}/terms/{term-id}/relations/{relation-id}/set/$ref"
	localVarPath = strings.Replace(localVarPath, "{"+"site-id"+"}", _neturl.PathEscape(parameterToString(r.siteId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"set-id"+"}", _neturl.PathEscape(parameterToString(r.setId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"term-id"+"}", _neturl.PathEscape(parameterToString(r.termId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"relation-id"+"}", _neturl.PathEscape(parameterToString(r.relationId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ifMatch != nil {
		localVarHeaderParams["If-Match"] = parameterToString(*r.ifMatch, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiSitesTermStoreSetsTermsRelationsDeleteRefToTermRequest struct {
	ctx _context.Context
	ApiService *SitesStoreApiService
	siteId string
	setId string
	termId string
	relationId string
	ifMatch *string
}

// ETag
func (r ApiSitesTermStoreSetsTermsRelationsDeleteRefToTermRequest) IfMatch(ifMatch string) ApiSitesTermStoreSetsTermsRelationsDeleteRefToTermRequest {
	r.ifMatch = &ifMatch
	return r
}

func (r ApiSitesTermStoreSetsTermsRelationsDeleteRefToTermRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.SitesTermStoreSetsTermsRelationsDeleteRefToTermExecute(r)
}

/*
SitesTermStoreSetsTermsRelationsDeleteRefToTerm Delete ref of navigation property toTerm for sites

The to [term] of the relation. The term to which the relationship is defined.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param siteId key: id of site
 @param setId key: id of set
 @param termId key: id of term
 @param relationId key: id of relation
 @return ApiSitesTermStoreSetsTermsRelationsDeleteRefToTermRequest
*/
func (a *SitesStoreApiService) SitesTermStoreSetsTermsRelationsDeleteRefToTerm(ctx _context.Context, siteId string, setId string, termId string, relationId string) ApiSitesTermStoreSetsTermsRelationsDeleteRefToTermRequest {
	return ApiSitesTermStoreSetsTermsRelationsDeleteRefToTermRequest{
		ApiService: a,
		ctx: ctx,
		siteId: siteId,
		setId: setId,
		termId: termId,
		relationId: relationId,
	}
}

// Execute executes the request
func (a *SitesStoreApiService) SitesTermStoreSetsTermsRelationsDeleteRefToTermExecute(r ApiSitesTermStoreSetsTermsRelationsDeleteRefToTermRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SitesStoreApiService.SitesTermStoreSetsTermsRelationsDeleteRefToTerm")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sites/{site-id}/termStore/sets/{set-id}/terms/{term-id}/relations/{relation-id}/toTerm/$ref"
	localVarPath = strings.Replace(localVarPath, "{"+"site-id"+"}", _neturl.PathEscape(parameterToString(r.siteId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"set-id"+"}", _neturl.PathEscape(parameterToString(r.setId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"term-id"+"}", _neturl.PathEscape(parameterToString(r.termId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"relation-id"+"}", _neturl.PathEscape(parameterToString(r.relationId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ifMatch != nil {
		localVarHeaderParams["If-Match"] = parameterToString(*r.ifMatch, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiSitesTermStoreSetsTermsRelationsGetFromTermRequest struct {
	ctx _context.Context
	ApiService *SitesStoreApiService
	siteId string
	setId string
	termId string
	relationId string
	select_ *[]string
	expand *[]string
}

// Select properties to be returned
func (r ApiSitesTermStoreSetsTermsRelationsGetFromTermRequest) Select_(select_ []string) ApiSitesTermStoreSetsTermsRelationsGetFromTermRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiSitesTermStoreSetsTermsRelationsGetFromTermRequest) Expand(expand []string) ApiSitesTermStoreSetsTermsRelationsGetFromTermRequest {
	r.expand = &expand
	return r
}

func (r ApiSitesTermStoreSetsTermsRelationsGetFromTermRequest) Execute() (MicrosoftGraphTermStoreTerm, *_nethttp.Response, error) {
	return r.ApiService.SitesTermStoreSetsTermsRelationsGetFromTermExecute(r)
}

/*
SitesTermStoreSetsTermsRelationsGetFromTerm Get fromTerm from sites

The from [term] of the relation. The term from which the relationship is defined. A null value would indicate the relation is directly with the [set].

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param siteId key: id of site
 @param setId key: id of set
 @param termId key: id of term
 @param relationId key: id of relation
 @return ApiSitesTermStoreSetsTermsRelationsGetFromTermRequest
*/
func (a *SitesStoreApiService) SitesTermStoreSetsTermsRelationsGetFromTerm(ctx _context.Context, siteId string, setId string, termId string, relationId string) ApiSitesTermStoreSetsTermsRelationsGetFromTermRequest {
	return ApiSitesTermStoreSetsTermsRelationsGetFromTermRequest{
		ApiService: a,
		ctx: ctx,
		siteId: siteId,
		setId: setId,
		termId: termId,
		relationId: relationId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphTermStoreTerm
func (a *SitesStoreApiService) SitesTermStoreSetsTermsRelationsGetFromTermExecute(r ApiSitesTermStoreSetsTermsRelationsGetFromTermRequest) (MicrosoftGraphTermStoreTerm, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphTermStoreTerm
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SitesStoreApiService.SitesTermStoreSetsTermsRelationsGetFromTerm")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sites/{site-id}/termStore/sets/{set-id}/terms/{term-id}/relations/{relation-id}/fromTerm"
	localVarPath = strings.Replace(localVarPath, "{"+"site-id"+"}", _neturl.PathEscape(parameterToString(r.siteId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"set-id"+"}", _neturl.PathEscape(parameterToString(r.setId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"term-id"+"}", _neturl.PathEscape(parameterToString(r.termId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"relation-id"+"}", _neturl.PathEscape(parameterToString(r.relationId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSitesTermStoreSetsTermsRelationsGetRefFromTermRequest struct {
	ctx _context.Context
	ApiService *SitesStoreApiService
	siteId string
	setId string
	termId string
	relationId string
}


func (r ApiSitesTermStoreSetsTermsRelationsGetRefFromTermRequest) Execute() (string, *_nethttp.Response, error) {
	return r.ApiService.SitesTermStoreSetsTermsRelationsGetRefFromTermExecute(r)
}

/*
SitesTermStoreSetsTermsRelationsGetRefFromTerm Get ref of fromTerm from sites

The from [term] of the relation. The term from which the relationship is defined. A null value would indicate the relation is directly with the [set].

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param siteId key: id of site
 @param setId key: id of set
 @param termId key: id of term
 @param relationId key: id of relation
 @return ApiSitesTermStoreSetsTermsRelationsGetRefFromTermRequest
*/
func (a *SitesStoreApiService) SitesTermStoreSetsTermsRelationsGetRefFromTerm(ctx _context.Context, siteId string, setId string, termId string, relationId string) ApiSitesTermStoreSetsTermsRelationsGetRefFromTermRequest {
	return ApiSitesTermStoreSetsTermsRelationsGetRefFromTermRequest{
		ApiService: a,
		ctx: ctx,
		siteId: siteId,
		setId: setId,
		termId: termId,
		relationId: relationId,
	}
}

// Execute executes the request
//  @return string
func (a *SitesStoreApiService) SitesTermStoreSetsTermsRelationsGetRefFromTermExecute(r ApiSitesTermStoreSetsTermsRelationsGetRefFromTermRequest) (string, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  string
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SitesStoreApiService.SitesTermStoreSetsTermsRelationsGetRefFromTerm")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sites/{site-id}/termStore/sets/{set-id}/terms/{term-id}/relations/{relation-id}/fromTerm/$ref"
	localVarPath = strings.Replace(localVarPath, "{"+"site-id"+"}", _neturl.PathEscape(parameterToString(r.siteId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"set-id"+"}", _neturl.PathEscape(parameterToString(r.setId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"term-id"+"}", _neturl.PathEscape(parameterToString(r.termId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"relation-id"+"}", _neturl.PathEscape(parameterToString(r.relationId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSitesTermStoreSetsTermsRelationsGetRefSetRequest struct {
	ctx _context.Context
	ApiService *SitesStoreApiService
	siteId string
	setId string
	termId string
	relationId string
}


func (r ApiSitesTermStoreSetsTermsRelationsGetRefSetRequest) Execute() (string, *_nethttp.Response, error) {
	return r.ApiService.SitesTermStoreSetsTermsRelationsGetRefSetExecute(r)
}

/*
SitesTermStoreSetsTermsRelationsGetRefSet Get ref of set from sites

The [set] in which the relation is relevant.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param siteId key: id of site
 @param setId key: id of set
 @param termId key: id of term
 @param relationId key: id of relation
 @return ApiSitesTermStoreSetsTermsRelationsGetRefSetRequest
*/
func (a *SitesStoreApiService) SitesTermStoreSetsTermsRelationsGetRefSet(ctx _context.Context, siteId string, setId string, termId string, relationId string) ApiSitesTermStoreSetsTermsRelationsGetRefSetRequest {
	return ApiSitesTermStoreSetsTermsRelationsGetRefSetRequest{
		ApiService: a,
		ctx: ctx,
		siteId: siteId,
		setId: setId,
		termId: termId,
		relationId: relationId,
	}
}

// Execute executes the request
//  @return string
func (a *SitesStoreApiService) SitesTermStoreSetsTermsRelationsGetRefSetExecute(r ApiSitesTermStoreSetsTermsRelationsGetRefSetRequest) (string, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  string
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SitesStoreApiService.SitesTermStoreSetsTermsRelationsGetRefSet")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sites/{site-id}/termStore/sets/{set-id}/terms/{term-id}/relations/{relation-id}/set/$ref"
	localVarPath = strings.Replace(localVarPath, "{"+"site-id"+"}", _neturl.PathEscape(parameterToString(r.siteId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"set-id"+"}", _neturl.PathEscape(parameterToString(r.setId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"term-id"+"}", _neturl.PathEscape(parameterToString(r.termId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"relation-id"+"}", _neturl.PathEscape(parameterToString(r.relationId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSitesTermStoreSetsTermsRelationsGetRefToTermRequest struct {
	ctx _context.Context
	ApiService *SitesStoreApiService
	siteId string
	setId string
	termId string
	relationId string
}


func (r ApiSitesTermStoreSetsTermsRelationsGetRefToTermRequest) Execute() (string, *_nethttp.Response, error) {
	return r.ApiService.SitesTermStoreSetsTermsRelationsGetRefToTermExecute(r)
}

/*
SitesTermStoreSetsTermsRelationsGetRefToTerm Get ref of toTerm from sites

The to [term] of the relation. The term to which the relationship is defined.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param siteId key: id of site
 @param setId key: id of set
 @param termId key: id of term
 @param relationId key: id of relation
 @return ApiSitesTermStoreSetsTermsRelationsGetRefToTermRequest
*/
func (a *SitesStoreApiService) SitesTermStoreSetsTermsRelationsGetRefToTerm(ctx _context.Context, siteId string, setId string, termId string, relationId string) ApiSitesTermStoreSetsTermsRelationsGetRefToTermRequest {
	return ApiSitesTermStoreSetsTermsRelationsGetRefToTermRequest{
		ApiService: a,
		ctx: ctx,
		siteId: siteId,
		setId: setId,
		termId: termId,
		relationId: relationId,
	}
}

// Execute executes the request
//  @return string
func (a *SitesStoreApiService) SitesTermStoreSetsTermsRelationsGetRefToTermExecute(r ApiSitesTermStoreSetsTermsRelationsGetRefToTermRequest) (string, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  string
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SitesStoreApiService.SitesTermStoreSetsTermsRelationsGetRefToTerm")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sites/{site-id}/termStore/sets/{set-id}/terms/{term-id}/relations/{relation-id}/toTerm/$ref"
	localVarPath = strings.Replace(localVarPath, "{"+"site-id"+"}", _neturl.PathEscape(parameterToString(r.siteId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"set-id"+"}", _neturl.PathEscape(parameterToString(r.setId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"term-id"+"}", _neturl.PathEscape(parameterToString(r.termId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"relation-id"+"}", _neturl.PathEscape(parameterToString(r.relationId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSitesTermStoreSetsTermsRelationsGetSetRequest struct {
	ctx _context.Context
	ApiService *SitesStoreApiService
	siteId string
	setId string
	termId string
	relationId string
	select_ *[]string
	expand *[]string
}

// Select properties to be returned
func (r ApiSitesTermStoreSetsTermsRelationsGetSetRequest) Select_(select_ []string) ApiSitesTermStoreSetsTermsRelationsGetSetRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiSitesTermStoreSetsTermsRelationsGetSetRequest) Expand(expand []string) ApiSitesTermStoreSetsTermsRelationsGetSetRequest {
	r.expand = &expand
	return r
}

func (r ApiSitesTermStoreSetsTermsRelationsGetSetRequest) Execute() (MicrosoftGraphTermStoreSet, *_nethttp.Response, error) {
	return r.ApiService.SitesTermStoreSetsTermsRelationsGetSetExecute(r)
}

/*
SitesTermStoreSetsTermsRelationsGetSet Get set from sites

The [set] in which the relation is relevant.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param siteId key: id of site
 @param setId key: id of set
 @param termId key: id of term
 @param relationId key: id of relation
 @return ApiSitesTermStoreSetsTermsRelationsGetSetRequest
*/
func (a *SitesStoreApiService) SitesTermStoreSetsTermsRelationsGetSet(ctx _context.Context, siteId string, setId string, termId string, relationId string) ApiSitesTermStoreSetsTermsRelationsGetSetRequest {
	return ApiSitesTermStoreSetsTermsRelationsGetSetRequest{
		ApiService: a,
		ctx: ctx,
		siteId: siteId,
		setId: setId,
		termId: termId,
		relationId: relationId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphTermStoreSet
func (a *SitesStoreApiService) SitesTermStoreSetsTermsRelationsGetSetExecute(r ApiSitesTermStoreSetsTermsRelationsGetSetRequest) (MicrosoftGraphTermStoreSet, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphTermStoreSet
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SitesStoreApiService.SitesTermStoreSetsTermsRelationsGetSet")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sites/{site-id}/termStore/sets/{set-id}/terms/{term-id}/relations/{relation-id}/set"
	localVarPath = strings.Replace(localVarPath, "{"+"site-id"+"}", _neturl.PathEscape(parameterToString(r.siteId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"set-id"+"}", _neturl.PathEscape(parameterToString(r.setId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"term-id"+"}", _neturl.PathEscape(parameterToString(r.termId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"relation-id"+"}", _neturl.PathEscape(parameterToString(r.relationId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSitesTermStoreSetsTermsRelationsGetToTermRequest struct {
	ctx _context.Context
	ApiService *SitesStoreApiService
	siteId string
	setId string
	termId string
	relationId string
	select_ *[]string
	expand *[]string
}

// Select properties to be returned
func (r ApiSitesTermStoreSetsTermsRelationsGetToTermRequest) Select_(select_ []string) ApiSitesTermStoreSetsTermsRelationsGetToTermRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiSitesTermStoreSetsTermsRelationsGetToTermRequest) Expand(expand []string) ApiSitesTermStoreSetsTermsRelationsGetToTermRequest {
	r.expand = &expand
	return r
}

func (r ApiSitesTermStoreSetsTermsRelationsGetToTermRequest) Execute() (MicrosoftGraphTermStoreTerm, *_nethttp.Response, error) {
	return r.ApiService.SitesTermStoreSetsTermsRelationsGetToTermExecute(r)
}

/*
SitesTermStoreSetsTermsRelationsGetToTerm Get toTerm from sites

The to [term] of the relation. The term to which the relationship is defined.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param siteId key: id of site
 @param setId key: id of set
 @param termId key: id of term
 @param relationId key: id of relation
 @return ApiSitesTermStoreSetsTermsRelationsGetToTermRequest
*/
func (a *SitesStoreApiService) SitesTermStoreSetsTermsRelationsGetToTerm(ctx _context.Context, siteId string, setId string, termId string, relationId string) ApiSitesTermStoreSetsTermsRelationsGetToTermRequest {
	return ApiSitesTermStoreSetsTermsRelationsGetToTermRequest{
		ApiService: a,
		ctx: ctx,
		siteId: siteId,
		setId: setId,
		termId: termId,
		relationId: relationId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphTermStoreTerm
func (a *SitesStoreApiService) SitesTermStoreSetsTermsRelationsGetToTermExecute(r ApiSitesTermStoreSetsTermsRelationsGetToTermRequest) (MicrosoftGraphTermStoreTerm, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphTermStoreTerm
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SitesStoreApiService.SitesTermStoreSetsTermsRelationsGetToTerm")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sites/{site-id}/termStore/sets/{set-id}/terms/{term-id}/relations/{relation-id}/toTerm"
	localVarPath = strings.Replace(localVarPath, "{"+"site-id"+"}", _neturl.PathEscape(parameterToString(r.siteId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"set-id"+"}", _neturl.PathEscape(parameterToString(r.setId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"term-id"+"}", _neturl.PathEscape(parameterToString(r.termId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"relation-id"+"}", _neturl.PathEscape(parameterToString(r.relationId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSitesTermStoreSetsTermsRelationsUpdateRefFromTermRequest struct {
	ctx _context.Context
	ApiService *SitesStoreApiService
	siteId string
	setId string
	termId string
	relationId string
	requestBody *map[string]map[string]interface{}
}

// New navigation property ref values
func (r ApiSitesTermStoreSetsTermsRelationsUpdateRefFromTermRequest) RequestBody(requestBody map[string]map[string]interface{}) ApiSitesTermStoreSetsTermsRelationsUpdateRefFromTermRequest {
	r.requestBody = &requestBody
	return r
}

func (r ApiSitesTermStoreSetsTermsRelationsUpdateRefFromTermRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.SitesTermStoreSetsTermsRelationsUpdateRefFromTermExecute(r)
}

/*
SitesTermStoreSetsTermsRelationsUpdateRefFromTerm Update the ref of navigation property fromTerm in sites

The from [term] of the relation. The term from which the relationship is defined. A null value would indicate the relation is directly with the [set].

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param siteId key: id of site
 @param setId key: id of set
 @param termId key: id of term
 @param relationId key: id of relation
 @return ApiSitesTermStoreSetsTermsRelationsUpdateRefFromTermRequest
*/
func (a *SitesStoreApiService) SitesTermStoreSetsTermsRelationsUpdateRefFromTerm(ctx _context.Context, siteId string, setId string, termId string, relationId string) ApiSitesTermStoreSetsTermsRelationsUpdateRefFromTermRequest {
	return ApiSitesTermStoreSetsTermsRelationsUpdateRefFromTermRequest{
		ApiService: a,
		ctx: ctx,
		siteId: siteId,
		setId: setId,
		termId: termId,
		relationId: relationId,
	}
}

// Execute executes the request
func (a *SitesStoreApiService) SitesTermStoreSetsTermsRelationsUpdateRefFromTermExecute(r ApiSitesTermStoreSetsTermsRelationsUpdateRefFromTermRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPut
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SitesStoreApiService.SitesTermStoreSetsTermsRelationsUpdateRefFromTerm")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sites/{site-id}/termStore/sets/{set-id}/terms/{term-id}/relations/{relation-id}/fromTerm/$ref"
	localVarPath = strings.Replace(localVarPath, "{"+"site-id"+"}", _neturl.PathEscape(parameterToString(r.siteId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"set-id"+"}", _neturl.PathEscape(parameterToString(r.setId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"term-id"+"}", _neturl.PathEscape(parameterToString(r.termId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"relation-id"+"}", _neturl.PathEscape(parameterToString(r.relationId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.requestBody == nil {
		return nil, reportError("requestBody is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.requestBody
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiSitesTermStoreSetsTermsRelationsUpdateRefSetRequest struct {
	ctx _context.Context
	ApiService *SitesStoreApiService
	siteId string
	setId string
	termId string
	relationId string
	requestBody *map[string]map[string]interface{}
}

// New navigation property ref values
func (r ApiSitesTermStoreSetsTermsRelationsUpdateRefSetRequest) RequestBody(requestBody map[string]map[string]interface{}) ApiSitesTermStoreSetsTermsRelationsUpdateRefSetRequest {
	r.requestBody = &requestBody
	return r
}

func (r ApiSitesTermStoreSetsTermsRelationsUpdateRefSetRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.SitesTermStoreSetsTermsRelationsUpdateRefSetExecute(r)
}

/*
SitesTermStoreSetsTermsRelationsUpdateRefSet Update the ref of navigation property set in sites

The [set] in which the relation is relevant.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param siteId key: id of site
 @param setId key: id of set
 @param termId key: id of term
 @param relationId key: id of relation
 @return ApiSitesTermStoreSetsTermsRelationsUpdateRefSetRequest
*/
func (a *SitesStoreApiService) SitesTermStoreSetsTermsRelationsUpdateRefSet(ctx _context.Context, siteId string, setId string, termId string, relationId string) ApiSitesTermStoreSetsTermsRelationsUpdateRefSetRequest {
	return ApiSitesTermStoreSetsTermsRelationsUpdateRefSetRequest{
		ApiService: a,
		ctx: ctx,
		siteId: siteId,
		setId: setId,
		termId: termId,
		relationId: relationId,
	}
}

// Execute executes the request
func (a *SitesStoreApiService) SitesTermStoreSetsTermsRelationsUpdateRefSetExecute(r ApiSitesTermStoreSetsTermsRelationsUpdateRefSetRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPut
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SitesStoreApiService.SitesTermStoreSetsTermsRelationsUpdateRefSet")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sites/{site-id}/termStore/sets/{set-id}/terms/{term-id}/relations/{relation-id}/set/$ref"
	localVarPath = strings.Replace(localVarPath, "{"+"site-id"+"}", _neturl.PathEscape(parameterToString(r.siteId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"set-id"+"}", _neturl.PathEscape(parameterToString(r.setId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"term-id"+"}", _neturl.PathEscape(parameterToString(r.termId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"relation-id"+"}", _neturl.PathEscape(parameterToString(r.relationId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.requestBody == nil {
		return nil, reportError("requestBody is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.requestBody
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiSitesTermStoreSetsTermsRelationsUpdateRefToTermRequest struct {
	ctx _context.Context
	ApiService *SitesStoreApiService
	siteId string
	setId string
	termId string
	relationId string
	requestBody *map[string]map[string]interface{}
}

// New navigation property ref values
func (r ApiSitesTermStoreSetsTermsRelationsUpdateRefToTermRequest) RequestBody(requestBody map[string]map[string]interface{}) ApiSitesTermStoreSetsTermsRelationsUpdateRefToTermRequest {
	r.requestBody = &requestBody
	return r
}

func (r ApiSitesTermStoreSetsTermsRelationsUpdateRefToTermRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.SitesTermStoreSetsTermsRelationsUpdateRefToTermExecute(r)
}

/*
SitesTermStoreSetsTermsRelationsUpdateRefToTerm Update the ref of navigation property toTerm in sites

The to [term] of the relation. The term to which the relationship is defined.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param siteId key: id of site
 @param setId key: id of set
 @param termId key: id of term
 @param relationId key: id of relation
 @return ApiSitesTermStoreSetsTermsRelationsUpdateRefToTermRequest
*/
func (a *SitesStoreApiService) SitesTermStoreSetsTermsRelationsUpdateRefToTerm(ctx _context.Context, siteId string, setId string, termId string, relationId string) ApiSitesTermStoreSetsTermsRelationsUpdateRefToTermRequest {
	return ApiSitesTermStoreSetsTermsRelationsUpdateRefToTermRequest{
		ApiService: a,
		ctx: ctx,
		siteId: siteId,
		setId: setId,
		termId: termId,
		relationId: relationId,
	}
}

// Execute executes the request
func (a *SitesStoreApiService) SitesTermStoreSetsTermsRelationsUpdateRefToTermExecute(r ApiSitesTermStoreSetsTermsRelationsUpdateRefToTermRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPut
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SitesStoreApiService.SitesTermStoreSetsTermsRelationsUpdateRefToTerm")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sites/{site-id}/termStore/sets/{set-id}/terms/{term-id}/relations/{relation-id}/toTerm/$ref"
	localVarPath = strings.Replace(localVarPath, "{"+"site-id"+"}", _neturl.PathEscape(parameterToString(r.siteId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"set-id"+"}", _neturl.PathEscape(parameterToString(r.setId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"term-id"+"}", _neturl.PathEscape(parameterToString(r.termId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"relation-id"+"}", _neturl.PathEscape(parameterToString(r.relationId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.requestBody == nil {
		return nil, reportError("requestBody is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.requestBody
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiSitesTermStoreSetsTermsUpdateChildrenRequest struct {
	ctx _context.Context
	ApiService *SitesStoreApiService
	siteId string
	setId string
	termId string
	termId1 string
	microsoftGraphTermStoreTerm *MicrosoftGraphTermStoreTerm
}

// New navigation property values
func (r ApiSitesTermStoreSetsTermsUpdateChildrenRequest) MicrosoftGraphTermStoreTerm(microsoftGraphTermStoreTerm MicrosoftGraphTermStoreTerm) ApiSitesTermStoreSetsTermsUpdateChildrenRequest {
	r.microsoftGraphTermStoreTerm = &microsoftGraphTermStoreTerm
	return r
}

func (r ApiSitesTermStoreSetsTermsUpdateChildrenRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.SitesTermStoreSetsTermsUpdateChildrenExecute(r)
}

/*
SitesTermStoreSetsTermsUpdateChildren Update the navigation property children in sites

Children of current term.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param siteId key: id of site
 @param setId key: id of set
 @param termId key: id of term
 @param termId1 key: id of term
 @return ApiSitesTermStoreSetsTermsUpdateChildrenRequest
*/
func (a *SitesStoreApiService) SitesTermStoreSetsTermsUpdateChildren(ctx _context.Context, siteId string, setId string, termId string, termId1 string) ApiSitesTermStoreSetsTermsUpdateChildrenRequest {
	return ApiSitesTermStoreSetsTermsUpdateChildrenRequest{
		ApiService: a,
		ctx: ctx,
		siteId: siteId,
		setId: setId,
		termId: termId,
		termId1: termId1,
	}
}

// Execute executes the request
func (a *SitesStoreApiService) SitesTermStoreSetsTermsUpdateChildrenExecute(r ApiSitesTermStoreSetsTermsUpdateChildrenRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPatch
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SitesStoreApiService.SitesTermStoreSetsTermsUpdateChildren")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sites/{site-id}/termStore/sets/{set-id}/terms/{term-id}/children/{term-id1}"
	localVarPath = strings.Replace(localVarPath, "{"+"site-id"+"}", _neturl.PathEscape(parameterToString(r.siteId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"set-id"+"}", _neturl.PathEscape(parameterToString(r.setId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"term-id"+"}", _neturl.PathEscape(parameterToString(r.termId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"term-id1"+"}", _neturl.PathEscape(parameterToString(r.termId1, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphTermStoreTerm == nil {
		return nil, reportError("microsoftGraphTermStoreTerm is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphTermStoreTerm
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiSitesTermStoreSetsTermsUpdateRefSetRequest struct {
	ctx _context.Context
	ApiService *SitesStoreApiService
	siteId string
	setId string
	termId string
	requestBody *map[string]map[string]interface{}
}

// New navigation property ref values
func (r ApiSitesTermStoreSetsTermsUpdateRefSetRequest) RequestBody(requestBody map[string]map[string]interface{}) ApiSitesTermStoreSetsTermsUpdateRefSetRequest {
	r.requestBody = &requestBody
	return r
}

func (r ApiSitesTermStoreSetsTermsUpdateRefSetRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.SitesTermStoreSetsTermsUpdateRefSetExecute(r)
}

/*
SitesTermStoreSetsTermsUpdateRefSet Update the ref of navigation property set in sites

The [set] in which the term is created.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param siteId key: id of site
 @param setId key: id of set
 @param termId key: id of term
 @return ApiSitesTermStoreSetsTermsUpdateRefSetRequest
*/
func (a *SitesStoreApiService) SitesTermStoreSetsTermsUpdateRefSet(ctx _context.Context, siteId string, setId string, termId string) ApiSitesTermStoreSetsTermsUpdateRefSetRequest {
	return ApiSitesTermStoreSetsTermsUpdateRefSetRequest{
		ApiService: a,
		ctx: ctx,
		siteId: siteId,
		setId: setId,
		termId: termId,
	}
}

// Execute executes the request
func (a *SitesStoreApiService) SitesTermStoreSetsTermsUpdateRefSetExecute(r ApiSitesTermStoreSetsTermsUpdateRefSetRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPut
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SitesStoreApiService.SitesTermStoreSetsTermsUpdateRefSet")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sites/{site-id}/termStore/sets/{set-id}/terms/{term-id}/set/$ref"
	localVarPath = strings.Replace(localVarPath, "{"+"site-id"+"}", _neturl.PathEscape(parameterToString(r.siteId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"set-id"+"}", _neturl.PathEscape(parameterToString(r.setId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"term-id"+"}", _neturl.PathEscape(parameterToString(r.termId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.requestBody == nil {
		return nil, reportError("requestBody is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.requestBody
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiSitesTermStoreSetsTermsUpdateRelationsRequest struct {
	ctx _context.Context
	ApiService *SitesStoreApiService
	siteId string
	setId string
	termId string
	relationId string
	microsoftGraphTermStoreRelation *MicrosoftGraphTermStoreRelation
}

// New navigation property values
func (r ApiSitesTermStoreSetsTermsUpdateRelationsRequest) MicrosoftGraphTermStoreRelation(microsoftGraphTermStoreRelation MicrosoftGraphTermStoreRelation) ApiSitesTermStoreSetsTermsUpdateRelationsRequest {
	r.microsoftGraphTermStoreRelation = &microsoftGraphTermStoreRelation
	return r
}

func (r ApiSitesTermStoreSetsTermsUpdateRelationsRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.SitesTermStoreSetsTermsUpdateRelationsExecute(r)
}

/*
SitesTermStoreSetsTermsUpdateRelations Update the navigation property relations in sites

To indicate which terms are related to the current term as either pinned or reused.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param siteId key: id of site
 @param setId key: id of set
 @param termId key: id of term
 @param relationId key: id of relation
 @return ApiSitesTermStoreSetsTermsUpdateRelationsRequest
*/
func (a *SitesStoreApiService) SitesTermStoreSetsTermsUpdateRelations(ctx _context.Context, siteId string, setId string, termId string, relationId string) ApiSitesTermStoreSetsTermsUpdateRelationsRequest {
	return ApiSitesTermStoreSetsTermsUpdateRelationsRequest{
		ApiService: a,
		ctx: ctx,
		siteId: siteId,
		setId: setId,
		termId: termId,
		relationId: relationId,
	}
}

// Execute executes the request
func (a *SitesStoreApiService) SitesTermStoreSetsTermsUpdateRelationsExecute(r ApiSitesTermStoreSetsTermsUpdateRelationsRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPatch
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SitesStoreApiService.SitesTermStoreSetsTermsUpdateRelations")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sites/{site-id}/termStore/sets/{set-id}/terms/{term-id}/relations/{relation-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"site-id"+"}", _neturl.PathEscape(parameterToString(r.siteId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"set-id"+"}", _neturl.PathEscape(parameterToString(r.setId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"term-id"+"}", _neturl.PathEscape(parameterToString(r.termId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"relation-id"+"}", _neturl.PathEscape(parameterToString(r.relationId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphTermStoreRelation == nil {
		return nil, reportError("microsoftGraphTermStoreRelation is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphTermStoreRelation
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiSitesTermStoreSetsUpdateChildrenRequest struct {
	ctx _context.Context
	ApiService *SitesStoreApiService
	siteId string
	setId string
	termId string
	microsoftGraphTermStoreTerm *MicrosoftGraphTermStoreTerm
}

// New navigation property values
func (r ApiSitesTermStoreSetsUpdateChildrenRequest) MicrosoftGraphTermStoreTerm(microsoftGraphTermStoreTerm MicrosoftGraphTermStoreTerm) ApiSitesTermStoreSetsUpdateChildrenRequest {
	r.microsoftGraphTermStoreTerm = &microsoftGraphTermStoreTerm
	return r
}

func (r ApiSitesTermStoreSetsUpdateChildrenRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.SitesTermStoreSetsUpdateChildrenExecute(r)
}

/*
SitesTermStoreSetsUpdateChildren Update the navigation property children in sites

Children terms of set in term [store].

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param siteId key: id of site
 @param setId key: id of set
 @param termId key: id of term
 @return ApiSitesTermStoreSetsUpdateChildrenRequest
*/
func (a *SitesStoreApiService) SitesTermStoreSetsUpdateChildren(ctx _context.Context, siteId string, setId string, termId string) ApiSitesTermStoreSetsUpdateChildrenRequest {
	return ApiSitesTermStoreSetsUpdateChildrenRequest{
		ApiService: a,
		ctx: ctx,
		siteId: siteId,
		setId: setId,
		termId: termId,
	}
}

// Execute executes the request
func (a *SitesStoreApiService) SitesTermStoreSetsUpdateChildrenExecute(r ApiSitesTermStoreSetsUpdateChildrenRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPatch
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SitesStoreApiService.SitesTermStoreSetsUpdateChildren")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sites/{site-id}/termStore/sets/{set-id}/children/{term-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"site-id"+"}", _neturl.PathEscape(parameterToString(r.siteId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"set-id"+"}", _neturl.PathEscape(parameterToString(r.setId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"term-id"+"}", _neturl.PathEscape(parameterToString(r.termId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphTermStoreTerm == nil {
		return nil, reportError("microsoftGraphTermStoreTerm is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphTermStoreTerm
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiSitesTermStoreSetsUpdateParentGroupRequest struct {
	ctx _context.Context
	ApiService *SitesStoreApiService
	siteId string
	setId string
	microsoftGraphTermStoreGroup *MicrosoftGraphTermStoreGroup
}

// New navigation property values
func (r ApiSitesTermStoreSetsUpdateParentGroupRequest) MicrosoftGraphTermStoreGroup(microsoftGraphTermStoreGroup MicrosoftGraphTermStoreGroup) ApiSitesTermStoreSetsUpdateParentGroupRequest {
	r.microsoftGraphTermStoreGroup = &microsoftGraphTermStoreGroup
	return r
}

func (r ApiSitesTermStoreSetsUpdateParentGroupRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.SitesTermStoreSetsUpdateParentGroupExecute(r)
}

/*
SitesTermStoreSetsUpdateParentGroup Update the navigation property parentGroup in sites

The parent [group] that contains the set.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param siteId key: id of site
 @param setId key: id of set
 @return ApiSitesTermStoreSetsUpdateParentGroupRequest
*/
func (a *SitesStoreApiService) SitesTermStoreSetsUpdateParentGroup(ctx _context.Context, siteId string, setId string) ApiSitesTermStoreSetsUpdateParentGroupRequest {
	return ApiSitesTermStoreSetsUpdateParentGroupRequest{
		ApiService: a,
		ctx: ctx,
		siteId: siteId,
		setId: setId,
	}
}

// Execute executes the request
func (a *SitesStoreApiService) SitesTermStoreSetsUpdateParentGroupExecute(r ApiSitesTermStoreSetsUpdateParentGroupRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPatch
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SitesStoreApiService.SitesTermStoreSetsUpdateParentGroup")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sites/{site-id}/termStore/sets/{set-id}/parentGroup"
	localVarPath = strings.Replace(localVarPath, "{"+"site-id"+"}", _neturl.PathEscape(parameterToString(r.siteId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"set-id"+"}", _neturl.PathEscape(parameterToString(r.setId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphTermStoreGroup == nil {
		return nil, reportError("microsoftGraphTermStoreGroup is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphTermStoreGroup
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiSitesTermStoreSetsUpdateRelationsRequest struct {
	ctx _context.Context
	ApiService *SitesStoreApiService
	siteId string
	setId string
	relationId string
	microsoftGraphTermStoreRelation *MicrosoftGraphTermStoreRelation
}

// New navigation property values
func (r ApiSitesTermStoreSetsUpdateRelationsRequest) MicrosoftGraphTermStoreRelation(microsoftGraphTermStoreRelation MicrosoftGraphTermStoreRelation) ApiSitesTermStoreSetsUpdateRelationsRequest {
	r.microsoftGraphTermStoreRelation = &microsoftGraphTermStoreRelation
	return r
}

func (r ApiSitesTermStoreSetsUpdateRelationsRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.SitesTermStoreSetsUpdateRelationsExecute(r)
}

/*
SitesTermStoreSetsUpdateRelations Update the navigation property relations in sites

Indicates which terms have been pinned or reused directly under the set.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param siteId key: id of site
 @param setId key: id of set
 @param relationId key: id of relation
 @return ApiSitesTermStoreSetsUpdateRelationsRequest
*/
func (a *SitesStoreApiService) SitesTermStoreSetsUpdateRelations(ctx _context.Context, siteId string, setId string, relationId string) ApiSitesTermStoreSetsUpdateRelationsRequest {
	return ApiSitesTermStoreSetsUpdateRelationsRequest{
		ApiService: a,
		ctx: ctx,
		siteId: siteId,
		setId: setId,
		relationId: relationId,
	}
}

// Execute executes the request
func (a *SitesStoreApiService) SitesTermStoreSetsUpdateRelationsExecute(r ApiSitesTermStoreSetsUpdateRelationsRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPatch
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SitesStoreApiService.SitesTermStoreSetsUpdateRelations")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sites/{site-id}/termStore/sets/{set-id}/relations/{relation-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"site-id"+"}", _neturl.PathEscape(parameterToString(r.siteId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"set-id"+"}", _neturl.PathEscape(parameterToString(r.setId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"relation-id"+"}", _neturl.PathEscape(parameterToString(r.relationId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphTermStoreRelation == nil {
		return nil, reportError("microsoftGraphTermStoreRelation is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphTermStoreRelation
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiSitesTermStoreSetsUpdateTermsRequest struct {
	ctx _context.Context
	ApiService *SitesStoreApiService
	siteId string
	setId string
	termId string
	microsoftGraphTermStoreTerm *MicrosoftGraphTermStoreTerm
}

// New navigation property values
func (r ApiSitesTermStoreSetsUpdateTermsRequest) MicrosoftGraphTermStoreTerm(microsoftGraphTermStoreTerm MicrosoftGraphTermStoreTerm) ApiSitesTermStoreSetsUpdateTermsRequest {
	r.microsoftGraphTermStoreTerm = &microsoftGraphTermStoreTerm
	return r
}

func (r ApiSitesTermStoreSetsUpdateTermsRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.SitesTermStoreSetsUpdateTermsExecute(r)
}

/*
SitesTermStoreSetsUpdateTerms Update the navigation property terms in sites

All the terms under the set.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param siteId key: id of site
 @param setId key: id of set
 @param termId key: id of term
 @return ApiSitesTermStoreSetsUpdateTermsRequest
*/
func (a *SitesStoreApiService) SitesTermStoreSetsUpdateTerms(ctx _context.Context, siteId string, setId string, termId string) ApiSitesTermStoreSetsUpdateTermsRequest {
	return ApiSitesTermStoreSetsUpdateTermsRequest{
		ApiService: a,
		ctx: ctx,
		siteId: siteId,
		setId: setId,
		termId: termId,
	}
}

// Execute executes the request
func (a *SitesStoreApiService) SitesTermStoreSetsUpdateTermsExecute(r ApiSitesTermStoreSetsUpdateTermsRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPatch
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SitesStoreApiService.SitesTermStoreSetsUpdateTerms")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sites/{site-id}/termStore/sets/{set-id}/terms/{term-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"site-id"+"}", _neturl.PathEscape(parameterToString(r.siteId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"set-id"+"}", _neturl.PathEscape(parameterToString(r.setId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"term-id"+"}", _neturl.PathEscape(parameterToString(r.termId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphTermStoreTerm == nil {
		return nil, reportError("microsoftGraphTermStoreTerm is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphTermStoreTerm
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiSitesTermStoreUpdateGroupsRequest struct {
	ctx _context.Context
	ApiService *SitesStoreApiService
	siteId string
	groupId string
	microsoftGraphTermStoreGroup *MicrosoftGraphTermStoreGroup
}

// New navigation property values
func (r ApiSitesTermStoreUpdateGroupsRequest) MicrosoftGraphTermStoreGroup(microsoftGraphTermStoreGroup MicrosoftGraphTermStoreGroup) ApiSitesTermStoreUpdateGroupsRequest {
	r.microsoftGraphTermStoreGroup = &microsoftGraphTermStoreGroup
	return r
}

func (r ApiSitesTermStoreUpdateGroupsRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.SitesTermStoreUpdateGroupsExecute(r)
}

/*
SitesTermStoreUpdateGroups Update the navigation property groups in sites

Collection of all groups available in the term store.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param siteId key: id of site
 @param groupId key: id of group
 @return ApiSitesTermStoreUpdateGroupsRequest
*/
func (a *SitesStoreApiService) SitesTermStoreUpdateGroups(ctx _context.Context, siteId string, groupId string) ApiSitesTermStoreUpdateGroupsRequest {
	return ApiSitesTermStoreUpdateGroupsRequest{
		ApiService: a,
		ctx: ctx,
		siteId: siteId,
		groupId: groupId,
	}
}

// Execute executes the request
func (a *SitesStoreApiService) SitesTermStoreUpdateGroupsExecute(r ApiSitesTermStoreUpdateGroupsRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPatch
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SitesStoreApiService.SitesTermStoreUpdateGroups")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sites/{site-id}/termStore/groups/{group-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"site-id"+"}", _neturl.PathEscape(parameterToString(r.siteId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphTermStoreGroup == nil {
		return nil, reportError("microsoftGraphTermStoreGroup is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphTermStoreGroup
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiSitesTermStoreUpdateSetsRequest struct {
	ctx _context.Context
	ApiService *SitesStoreApiService
	siteId string
	setId string
	microsoftGraphTermStoreSet *MicrosoftGraphTermStoreSet
}

// New navigation property values
func (r ApiSitesTermStoreUpdateSetsRequest) MicrosoftGraphTermStoreSet(microsoftGraphTermStoreSet MicrosoftGraphTermStoreSet) ApiSitesTermStoreUpdateSetsRequest {
	r.microsoftGraphTermStoreSet = &microsoftGraphTermStoreSet
	return r
}

func (r ApiSitesTermStoreUpdateSetsRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.SitesTermStoreUpdateSetsExecute(r)
}

/*
SitesTermStoreUpdateSets Update the navigation property sets in sites

Collection of all sets available in the term store.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param siteId key: id of site
 @param setId key: id of set
 @return ApiSitesTermStoreUpdateSetsRequest
*/
func (a *SitesStoreApiService) SitesTermStoreUpdateSets(ctx _context.Context, siteId string, setId string) ApiSitesTermStoreUpdateSetsRequest {
	return ApiSitesTermStoreUpdateSetsRequest{
		ApiService: a,
		ctx: ctx,
		siteId: siteId,
		setId: setId,
	}
}

// Execute executes the request
func (a *SitesStoreApiService) SitesTermStoreUpdateSetsExecute(r ApiSitesTermStoreUpdateSetsRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPatch
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SitesStoreApiService.SitesTermStoreUpdateSets")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sites/{site-id}/termStore/sets/{set-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"site-id"+"}", _neturl.PathEscape(parameterToString(r.siteId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"set-id"+"}", _neturl.PathEscape(parameterToString(r.setId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphTermStoreSet == nil {
		return nil, reportError("microsoftGraphTermStoreSet is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphTermStoreSet
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiSitesTermStoresCreateGroupsRequest struct {
	ctx _context.Context
	ApiService *SitesStoreApiService
	siteId string
	storeId string
	microsoftGraphTermStoreGroup *MicrosoftGraphTermStoreGroup
}

// New navigation property
func (r ApiSitesTermStoresCreateGroupsRequest) MicrosoftGraphTermStoreGroup(microsoftGraphTermStoreGroup MicrosoftGraphTermStoreGroup) ApiSitesTermStoresCreateGroupsRequest {
	r.microsoftGraphTermStoreGroup = &microsoftGraphTermStoreGroup
	return r
}

func (r ApiSitesTermStoresCreateGroupsRequest) Execute() (MicrosoftGraphTermStoreGroup, *_nethttp.Response, error) {
	return r.ApiService.SitesTermStoresCreateGroupsExecute(r)
}

/*
SitesTermStoresCreateGroups Create new navigation property to groups for sites

Collection of all groups available in the term store.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param siteId key: id of site
 @param storeId key: id of store
 @return ApiSitesTermStoresCreateGroupsRequest
*/
func (a *SitesStoreApiService) SitesTermStoresCreateGroups(ctx _context.Context, siteId string, storeId string) ApiSitesTermStoresCreateGroupsRequest {
	return ApiSitesTermStoresCreateGroupsRequest{
		ApiService: a,
		ctx: ctx,
		siteId: siteId,
		storeId: storeId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphTermStoreGroup
func (a *SitesStoreApiService) SitesTermStoresCreateGroupsExecute(r ApiSitesTermStoresCreateGroupsRequest) (MicrosoftGraphTermStoreGroup, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphTermStoreGroup
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SitesStoreApiService.SitesTermStoresCreateGroups")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sites/{site-id}/termStores/{store-id}/groups"
	localVarPath = strings.Replace(localVarPath, "{"+"site-id"+"}", _neturl.PathEscape(parameterToString(r.siteId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"store-id"+"}", _neturl.PathEscape(parameterToString(r.storeId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphTermStoreGroup == nil {
		return localVarReturnValue, nil, reportError("microsoftGraphTermStoreGroup is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphTermStoreGroup
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSitesTermStoresCreateSetsRequest struct {
	ctx _context.Context
	ApiService *SitesStoreApiService
	siteId string
	storeId string
	microsoftGraphTermStoreSet *MicrosoftGraphTermStoreSet
}

// New navigation property
func (r ApiSitesTermStoresCreateSetsRequest) MicrosoftGraphTermStoreSet(microsoftGraphTermStoreSet MicrosoftGraphTermStoreSet) ApiSitesTermStoresCreateSetsRequest {
	r.microsoftGraphTermStoreSet = &microsoftGraphTermStoreSet
	return r
}

func (r ApiSitesTermStoresCreateSetsRequest) Execute() (MicrosoftGraphTermStoreSet, *_nethttp.Response, error) {
	return r.ApiService.SitesTermStoresCreateSetsExecute(r)
}

/*
SitesTermStoresCreateSets Create new navigation property to sets for sites

Collection of all sets available in the term store.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param siteId key: id of site
 @param storeId key: id of store
 @return ApiSitesTermStoresCreateSetsRequest
*/
func (a *SitesStoreApiService) SitesTermStoresCreateSets(ctx _context.Context, siteId string, storeId string) ApiSitesTermStoresCreateSetsRequest {
	return ApiSitesTermStoresCreateSetsRequest{
		ApiService: a,
		ctx: ctx,
		siteId: siteId,
		storeId: storeId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphTermStoreSet
func (a *SitesStoreApiService) SitesTermStoresCreateSetsExecute(r ApiSitesTermStoresCreateSetsRequest) (MicrosoftGraphTermStoreSet, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphTermStoreSet
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SitesStoreApiService.SitesTermStoresCreateSets")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sites/{site-id}/termStores/{store-id}/sets"
	localVarPath = strings.Replace(localVarPath, "{"+"site-id"+"}", _neturl.PathEscape(parameterToString(r.siteId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"store-id"+"}", _neturl.PathEscape(parameterToString(r.storeId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphTermStoreSet == nil {
		return localVarReturnValue, nil, reportError("microsoftGraphTermStoreSet is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphTermStoreSet
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSitesTermStoresDeleteGroupsRequest struct {
	ctx _context.Context
	ApiService *SitesStoreApiService
	siteId string
	storeId string
	groupId string
	ifMatch *string
}

// ETag
func (r ApiSitesTermStoresDeleteGroupsRequest) IfMatch(ifMatch string) ApiSitesTermStoresDeleteGroupsRequest {
	r.ifMatch = &ifMatch
	return r
}

func (r ApiSitesTermStoresDeleteGroupsRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.SitesTermStoresDeleteGroupsExecute(r)
}

/*
SitesTermStoresDeleteGroups Delete navigation property groups for sites

Collection of all groups available in the term store.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param siteId key: id of site
 @param storeId key: id of store
 @param groupId key: id of group
 @return ApiSitesTermStoresDeleteGroupsRequest
*/
func (a *SitesStoreApiService) SitesTermStoresDeleteGroups(ctx _context.Context, siteId string, storeId string, groupId string) ApiSitesTermStoresDeleteGroupsRequest {
	return ApiSitesTermStoresDeleteGroupsRequest{
		ApiService: a,
		ctx: ctx,
		siteId: siteId,
		storeId: storeId,
		groupId: groupId,
	}
}

// Execute executes the request
func (a *SitesStoreApiService) SitesTermStoresDeleteGroupsExecute(r ApiSitesTermStoresDeleteGroupsRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SitesStoreApiService.SitesTermStoresDeleteGroups")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sites/{site-id}/termStores/{store-id}/groups/{group-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"site-id"+"}", _neturl.PathEscape(parameterToString(r.siteId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"store-id"+"}", _neturl.PathEscape(parameterToString(r.storeId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ifMatch != nil {
		localVarHeaderParams["If-Match"] = parameterToString(*r.ifMatch, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiSitesTermStoresDeleteSetsRequest struct {
	ctx _context.Context
	ApiService *SitesStoreApiService
	siteId string
	storeId string
	setId string
	ifMatch *string
}

// ETag
func (r ApiSitesTermStoresDeleteSetsRequest) IfMatch(ifMatch string) ApiSitesTermStoresDeleteSetsRequest {
	r.ifMatch = &ifMatch
	return r
}

func (r ApiSitesTermStoresDeleteSetsRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.SitesTermStoresDeleteSetsExecute(r)
}

/*
SitesTermStoresDeleteSets Delete navigation property sets for sites

Collection of all sets available in the term store.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param siteId key: id of site
 @param storeId key: id of store
 @param setId key: id of set
 @return ApiSitesTermStoresDeleteSetsRequest
*/
func (a *SitesStoreApiService) SitesTermStoresDeleteSets(ctx _context.Context, siteId string, storeId string, setId string) ApiSitesTermStoresDeleteSetsRequest {
	return ApiSitesTermStoresDeleteSetsRequest{
		ApiService: a,
		ctx: ctx,
		siteId: siteId,
		storeId: storeId,
		setId: setId,
	}
}

// Execute executes the request
func (a *SitesStoreApiService) SitesTermStoresDeleteSetsExecute(r ApiSitesTermStoresDeleteSetsRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SitesStoreApiService.SitesTermStoresDeleteSets")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sites/{site-id}/termStores/{store-id}/sets/{set-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"site-id"+"}", _neturl.PathEscape(parameterToString(r.siteId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"store-id"+"}", _neturl.PathEscape(parameterToString(r.storeId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"set-id"+"}", _neturl.PathEscape(parameterToString(r.setId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ifMatch != nil {
		localVarHeaderParams["If-Match"] = parameterToString(*r.ifMatch, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiSitesTermStoresGetGroupsRequest struct {
	ctx _context.Context
	ApiService *SitesStoreApiService
	siteId string
	storeId string
	groupId string
	select_ *[]string
	expand *[]string
}

// Select properties to be returned
func (r ApiSitesTermStoresGetGroupsRequest) Select_(select_ []string) ApiSitesTermStoresGetGroupsRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiSitesTermStoresGetGroupsRequest) Expand(expand []string) ApiSitesTermStoresGetGroupsRequest {
	r.expand = &expand
	return r
}

func (r ApiSitesTermStoresGetGroupsRequest) Execute() (MicrosoftGraphTermStoreGroup, *_nethttp.Response, error) {
	return r.ApiService.SitesTermStoresGetGroupsExecute(r)
}

/*
SitesTermStoresGetGroups Get groups from sites

Collection of all groups available in the term store.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param siteId key: id of site
 @param storeId key: id of store
 @param groupId key: id of group
 @return ApiSitesTermStoresGetGroupsRequest
*/
func (a *SitesStoreApiService) SitesTermStoresGetGroups(ctx _context.Context, siteId string, storeId string, groupId string) ApiSitesTermStoresGetGroupsRequest {
	return ApiSitesTermStoresGetGroupsRequest{
		ApiService: a,
		ctx: ctx,
		siteId: siteId,
		storeId: storeId,
		groupId: groupId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphTermStoreGroup
func (a *SitesStoreApiService) SitesTermStoresGetGroupsExecute(r ApiSitesTermStoresGetGroupsRequest) (MicrosoftGraphTermStoreGroup, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphTermStoreGroup
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SitesStoreApiService.SitesTermStoresGetGroups")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sites/{site-id}/termStores/{store-id}/groups/{group-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"site-id"+"}", _neturl.PathEscape(parameterToString(r.siteId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"store-id"+"}", _neturl.PathEscape(parameterToString(r.storeId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSitesTermStoresGetSetsRequest struct {
	ctx _context.Context
	ApiService *SitesStoreApiService
	siteId string
	storeId string
	setId string
	select_ *[]string
	expand *[]string
}

// Select properties to be returned
func (r ApiSitesTermStoresGetSetsRequest) Select_(select_ []string) ApiSitesTermStoresGetSetsRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiSitesTermStoresGetSetsRequest) Expand(expand []string) ApiSitesTermStoresGetSetsRequest {
	r.expand = &expand
	return r
}

func (r ApiSitesTermStoresGetSetsRequest) Execute() (MicrosoftGraphTermStoreSet, *_nethttp.Response, error) {
	return r.ApiService.SitesTermStoresGetSetsExecute(r)
}

/*
SitesTermStoresGetSets Get sets from sites

Collection of all sets available in the term store.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param siteId key: id of site
 @param storeId key: id of store
 @param setId key: id of set
 @return ApiSitesTermStoresGetSetsRequest
*/
func (a *SitesStoreApiService) SitesTermStoresGetSets(ctx _context.Context, siteId string, storeId string, setId string) ApiSitesTermStoresGetSetsRequest {
	return ApiSitesTermStoresGetSetsRequest{
		ApiService: a,
		ctx: ctx,
		siteId: siteId,
		storeId: storeId,
		setId: setId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphTermStoreSet
func (a *SitesStoreApiService) SitesTermStoresGetSetsExecute(r ApiSitesTermStoresGetSetsRequest) (MicrosoftGraphTermStoreSet, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphTermStoreSet
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SitesStoreApiService.SitesTermStoresGetSets")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sites/{site-id}/termStores/{store-id}/sets/{set-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"site-id"+"}", _neturl.PathEscape(parameterToString(r.siteId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"store-id"+"}", _neturl.PathEscape(parameterToString(r.storeId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"set-id"+"}", _neturl.PathEscape(parameterToString(r.setId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSitesTermStoresGroupsCreateSetsRequest struct {
	ctx _context.Context
	ApiService *SitesStoreApiService
	siteId string
	storeId string
	groupId string
	microsoftGraphTermStoreSet *MicrosoftGraphTermStoreSet
}

// New navigation property
func (r ApiSitesTermStoresGroupsCreateSetsRequest) MicrosoftGraphTermStoreSet(microsoftGraphTermStoreSet MicrosoftGraphTermStoreSet) ApiSitesTermStoresGroupsCreateSetsRequest {
	r.microsoftGraphTermStoreSet = &microsoftGraphTermStoreSet
	return r
}

func (r ApiSitesTermStoresGroupsCreateSetsRequest) Execute() (MicrosoftGraphTermStoreSet, *_nethttp.Response, error) {
	return r.ApiService.SitesTermStoresGroupsCreateSetsExecute(r)
}

/*
SitesTermStoresGroupsCreateSets Create new navigation property to sets for sites

All sets under the group in a term [store].

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param siteId key: id of site
 @param storeId key: id of store
 @param groupId key: id of group
 @return ApiSitesTermStoresGroupsCreateSetsRequest
*/
func (a *SitesStoreApiService) SitesTermStoresGroupsCreateSets(ctx _context.Context, siteId string, storeId string, groupId string) ApiSitesTermStoresGroupsCreateSetsRequest {
	return ApiSitesTermStoresGroupsCreateSetsRequest{
		ApiService: a,
		ctx: ctx,
		siteId: siteId,
		storeId: storeId,
		groupId: groupId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphTermStoreSet
func (a *SitesStoreApiService) SitesTermStoresGroupsCreateSetsExecute(r ApiSitesTermStoresGroupsCreateSetsRequest) (MicrosoftGraphTermStoreSet, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphTermStoreSet
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SitesStoreApiService.SitesTermStoresGroupsCreateSets")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sites/{site-id}/termStores/{store-id}/groups/{group-id}/sets"
	localVarPath = strings.Replace(localVarPath, "{"+"site-id"+"}", _neturl.PathEscape(parameterToString(r.siteId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"store-id"+"}", _neturl.PathEscape(parameterToString(r.storeId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphTermStoreSet == nil {
		return localVarReturnValue, nil, reportError("microsoftGraphTermStoreSet is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphTermStoreSet
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSitesTermStoresGroupsDeleteSetsRequest struct {
	ctx _context.Context
	ApiService *SitesStoreApiService
	siteId string
	storeId string
	groupId string
	setId string
	ifMatch *string
}

// ETag
func (r ApiSitesTermStoresGroupsDeleteSetsRequest) IfMatch(ifMatch string) ApiSitesTermStoresGroupsDeleteSetsRequest {
	r.ifMatch = &ifMatch
	return r
}

func (r ApiSitesTermStoresGroupsDeleteSetsRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.SitesTermStoresGroupsDeleteSetsExecute(r)
}

/*
SitesTermStoresGroupsDeleteSets Delete navigation property sets for sites

All sets under the group in a term [store].

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param siteId key: id of site
 @param storeId key: id of store
 @param groupId key: id of group
 @param setId key: id of set
 @return ApiSitesTermStoresGroupsDeleteSetsRequest
*/
func (a *SitesStoreApiService) SitesTermStoresGroupsDeleteSets(ctx _context.Context, siteId string, storeId string, groupId string, setId string) ApiSitesTermStoresGroupsDeleteSetsRequest {
	return ApiSitesTermStoresGroupsDeleteSetsRequest{
		ApiService: a,
		ctx: ctx,
		siteId: siteId,
		storeId: storeId,
		groupId: groupId,
		setId: setId,
	}
}

// Execute executes the request
func (a *SitesStoreApiService) SitesTermStoresGroupsDeleteSetsExecute(r ApiSitesTermStoresGroupsDeleteSetsRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SitesStoreApiService.SitesTermStoresGroupsDeleteSets")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sites/{site-id}/termStores/{store-id}/groups/{group-id}/sets/{set-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"site-id"+"}", _neturl.PathEscape(parameterToString(r.siteId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"store-id"+"}", _neturl.PathEscape(parameterToString(r.storeId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"set-id"+"}", _neturl.PathEscape(parameterToString(r.setId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ifMatch != nil {
		localVarHeaderParams["If-Match"] = parameterToString(*r.ifMatch, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiSitesTermStoresGroupsGetSetsRequest struct {
	ctx _context.Context
	ApiService *SitesStoreApiService
	siteId string
	storeId string
	groupId string
	setId string
	select_ *[]string
	expand *[]string
}

// Select properties to be returned
func (r ApiSitesTermStoresGroupsGetSetsRequest) Select_(select_ []string) ApiSitesTermStoresGroupsGetSetsRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiSitesTermStoresGroupsGetSetsRequest) Expand(expand []string) ApiSitesTermStoresGroupsGetSetsRequest {
	r.expand = &expand
	return r
}

func (r ApiSitesTermStoresGroupsGetSetsRequest) Execute() (MicrosoftGraphTermStoreSet, *_nethttp.Response, error) {
	return r.ApiService.SitesTermStoresGroupsGetSetsExecute(r)
}

/*
SitesTermStoresGroupsGetSets Get sets from sites

All sets under the group in a term [store].

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param siteId key: id of site
 @param storeId key: id of store
 @param groupId key: id of group
 @param setId key: id of set
 @return ApiSitesTermStoresGroupsGetSetsRequest
*/
func (a *SitesStoreApiService) SitesTermStoresGroupsGetSets(ctx _context.Context, siteId string, storeId string, groupId string, setId string) ApiSitesTermStoresGroupsGetSetsRequest {
	return ApiSitesTermStoresGroupsGetSetsRequest{
		ApiService: a,
		ctx: ctx,
		siteId: siteId,
		storeId: storeId,
		groupId: groupId,
		setId: setId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphTermStoreSet
func (a *SitesStoreApiService) SitesTermStoresGroupsGetSetsExecute(r ApiSitesTermStoresGroupsGetSetsRequest) (MicrosoftGraphTermStoreSet, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphTermStoreSet
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SitesStoreApiService.SitesTermStoresGroupsGetSets")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sites/{site-id}/termStores/{store-id}/groups/{group-id}/sets/{set-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"site-id"+"}", _neturl.PathEscape(parameterToString(r.siteId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"store-id"+"}", _neturl.PathEscape(parameterToString(r.storeId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"set-id"+"}", _neturl.PathEscape(parameterToString(r.setId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSitesTermStoresGroupsListSetsRequest struct {
	ctx _context.Context
	ApiService *SitesStoreApiService
	siteId string
	storeId string
	groupId string
	top *int32
	skip *int32
	search *string
	filter *string
	count *bool
	orderby *[]string
	select_ *[]string
	expand *[]string
}

// Show only the first n items
func (r ApiSitesTermStoresGroupsListSetsRequest) Top(top int32) ApiSitesTermStoresGroupsListSetsRequest {
	r.top = &top
	return r
}
// Skip the first n items
func (r ApiSitesTermStoresGroupsListSetsRequest) Skip(skip int32) ApiSitesTermStoresGroupsListSetsRequest {
	r.skip = &skip
	return r
}
// Search items by search phrases
func (r ApiSitesTermStoresGroupsListSetsRequest) Search(search string) ApiSitesTermStoresGroupsListSetsRequest {
	r.search = &search
	return r
}
// Filter items by property values
func (r ApiSitesTermStoresGroupsListSetsRequest) Filter(filter string) ApiSitesTermStoresGroupsListSetsRequest {
	r.filter = &filter
	return r
}
// Include count of items
func (r ApiSitesTermStoresGroupsListSetsRequest) Count(count bool) ApiSitesTermStoresGroupsListSetsRequest {
	r.count = &count
	return r
}
// Order items by property values
func (r ApiSitesTermStoresGroupsListSetsRequest) Orderby(orderby []string) ApiSitesTermStoresGroupsListSetsRequest {
	r.orderby = &orderby
	return r
}
// Select properties to be returned
func (r ApiSitesTermStoresGroupsListSetsRequest) Select_(select_ []string) ApiSitesTermStoresGroupsListSetsRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiSitesTermStoresGroupsListSetsRequest) Expand(expand []string) ApiSitesTermStoresGroupsListSetsRequest {
	r.expand = &expand
	return r
}

func (r ApiSitesTermStoresGroupsListSetsRequest) Execute() (CollectionOfSet, *_nethttp.Response, error) {
	return r.ApiService.SitesTermStoresGroupsListSetsExecute(r)
}

/*
SitesTermStoresGroupsListSets Get sets from sites

All sets under the group in a term [store].

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param siteId key: id of site
 @param storeId key: id of store
 @param groupId key: id of group
 @return ApiSitesTermStoresGroupsListSetsRequest
*/
func (a *SitesStoreApiService) SitesTermStoresGroupsListSets(ctx _context.Context, siteId string, storeId string, groupId string) ApiSitesTermStoresGroupsListSetsRequest {
	return ApiSitesTermStoresGroupsListSetsRequest{
		ApiService: a,
		ctx: ctx,
		siteId: siteId,
		storeId: storeId,
		groupId: groupId,
	}
}

// Execute executes the request
//  @return CollectionOfSet
func (a *SitesStoreApiService) SitesTermStoresGroupsListSetsExecute(r ApiSitesTermStoresGroupsListSetsRequest) (CollectionOfSet, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  CollectionOfSet
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SitesStoreApiService.SitesTermStoresGroupsListSets")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sites/{site-id}/termStores/{store-id}/groups/{group-id}/sets"
	localVarPath = strings.Replace(localVarPath, "{"+"site-id"+"}", _neturl.PathEscape(parameterToString(r.siteId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"store-id"+"}", _neturl.PathEscape(parameterToString(r.storeId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.top != nil {
		localVarQueryParams.Add("$top", parameterToString(*r.top, ""))
	}
	if r.skip != nil {
		localVarQueryParams.Add("$skip", parameterToString(*r.skip, ""))
	}
	if r.search != nil {
		localVarQueryParams.Add("$search", parameterToString(*r.search, ""))
	}
	if r.filter != nil {
		localVarQueryParams.Add("$filter", parameterToString(*r.filter, ""))
	}
	if r.count != nil {
		localVarQueryParams.Add("$count", parameterToString(*r.count, ""))
	}
	if r.orderby != nil {
		localVarQueryParams.Add("$orderby", parameterToString(*r.orderby, "csv"))
	}
	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSitesTermStoresGroupsSetsChildrenCreateChildrenRequest struct {
	ctx _context.Context
	ApiService *SitesStoreApiService
	siteId string
	storeId string
	groupId string
	setId string
	termId string
	microsoftGraphTermStoreTerm *MicrosoftGraphTermStoreTerm
}

// New navigation property
func (r ApiSitesTermStoresGroupsSetsChildrenCreateChildrenRequest) MicrosoftGraphTermStoreTerm(microsoftGraphTermStoreTerm MicrosoftGraphTermStoreTerm) ApiSitesTermStoresGroupsSetsChildrenCreateChildrenRequest {
	r.microsoftGraphTermStoreTerm = &microsoftGraphTermStoreTerm
	return r
}

func (r ApiSitesTermStoresGroupsSetsChildrenCreateChildrenRequest) Execute() (MicrosoftGraphTermStoreTerm, *_nethttp.Response, error) {
	return r.ApiService.SitesTermStoresGroupsSetsChildrenCreateChildrenExecute(r)
}

/*
SitesTermStoresGroupsSetsChildrenCreateChildren Create new navigation property to children for sites

Children of current term.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param siteId key: id of site
 @param storeId key: id of store
 @param groupId key: id of group
 @param setId key: id of set
 @param termId key: id of term
 @return ApiSitesTermStoresGroupsSetsChildrenCreateChildrenRequest
*/
func (a *SitesStoreApiService) SitesTermStoresGroupsSetsChildrenCreateChildren(ctx _context.Context, siteId string, storeId string, groupId string, setId string, termId string) ApiSitesTermStoresGroupsSetsChildrenCreateChildrenRequest {
	return ApiSitesTermStoresGroupsSetsChildrenCreateChildrenRequest{
		ApiService: a,
		ctx: ctx,
		siteId: siteId,
		storeId: storeId,
		groupId: groupId,
		setId: setId,
		termId: termId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphTermStoreTerm
func (a *SitesStoreApiService) SitesTermStoresGroupsSetsChildrenCreateChildrenExecute(r ApiSitesTermStoresGroupsSetsChildrenCreateChildrenRequest) (MicrosoftGraphTermStoreTerm, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphTermStoreTerm
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SitesStoreApiService.SitesTermStoresGroupsSetsChildrenCreateChildren")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sites/{site-id}/termStores/{store-id}/groups/{group-id}/sets/{set-id}/children/{term-id}/children"
	localVarPath = strings.Replace(localVarPath, "{"+"site-id"+"}", _neturl.PathEscape(parameterToString(r.siteId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"store-id"+"}", _neturl.PathEscape(parameterToString(r.storeId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"set-id"+"}", _neturl.PathEscape(parameterToString(r.setId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"term-id"+"}", _neturl.PathEscape(parameterToString(r.termId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphTermStoreTerm == nil {
		return localVarReturnValue, nil, reportError("microsoftGraphTermStoreTerm is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphTermStoreTerm
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSitesTermStoresGroupsSetsChildrenCreateRelationsRequest struct {
	ctx _context.Context
	ApiService *SitesStoreApiService
	siteId string
	storeId string
	groupId string
	setId string
	termId string
	microsoftGraphTermStoreRelation *MicrosoftGraphTermStoreRelation
}

// New navigation property
func (r ApiSitesTermStoresGroupsSetsChildrenCreateRelationsRequest) MicrosoftGraphTermStoreRelation(microsoftGraphTermStoreRelation MicrosoftGraphTermStoreRelation) ApiSitesTermStoresGroupsSetsChildrenCreateRelationsRequest {
	r.microsoftGraphTermStoreRelation = &microsoftGraphTermStoreRelation
	return r
}

func (r ApiSitesTermStoresGroupsSetsChildrenCreateRelationsRequest) Execute() (MicrosoftGraphTermStoreRelation, *_nethttp.Response, error) {
	return r.ApiService.SitesTermStoresGroupsSetsChildrenCreateRelationsExecute(r)
}

/*
SitesTermStoresGroupsSetsChildrenCreateRelations Create new navigation property to relations for sites

To indicate which terms are related to the current term as either pinned or reused.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param siteId key: id of site
 @param storeId key: id of store
 @param groupId key: id of group
 @param setId key: id of set
 @param termId key: id of term
 @return ApiSitesTermStoresGroupsSetsChildrenCreateRelationsRequest
*/
func (a *SitesStoreApiService) SitesTermStoresGroupsSetsChildrenCreateRelations(ctx _context.Context, siteId string, storeId string, groupId string, setId string, termId string) ApiSitesTermStoresGroupsSetsChildrenCreateRelationsRequest {
	return ApiSitesTermStoresGroupsSetsChildrenCreateRelationsRequest{
		ApiService: a,
		ctx: ctx,
		siteId: siteId,
		storeId: storeId,
		groupId: groupId,
		setId: setId,
		termId: termId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphTermStoreRelation
func (a *SitesStoreApiService) SitesTermStoresGroupsSetsChildrenCreateRelationsExecute(r ApiSitesTermStoresGroupsSetsChildrenCreateRelationsRequest) (MicrosoftGraphTermStoreRelation, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphTermStoreRelation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SitesStoreApiService.SitesTermStoresGroupsSetsChildrenCreateRelations")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sites/{site-id}/termStores/{store-id}/groups/{group-id}/sets/{set-id}/children/{term-id}/relations"
	localVarPath = strings.Replace(localVarPath, "{"+"site-id"+"}", _neturl.PathEscape(parameterToString(r.siteId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"store-id"+"}", _neturl.PathEscape(parameterToString(r.storeId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"set-id"+"}", _neturl.PathEscape(parameterToString(r.setId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"term-id"+"}", _neturl.PathEscape(parameterToString(r.termId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphTermStoreRelation == nil {
		return localVarReturnValue, nil, reportError("microsoftGraphTermStoreRelation is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphTermStoreRelation
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSitesTermStoresGroupsSetsChildrenDeleteChildrenRequest struct {
	ctx _context.Context
	ApiService *SitesStoreApiService
	siteId string
	storeId string
	groupId string
	setId string
	termId string
	termId1 string
	ifMatch *string
}

// ETag
func (r ApiSitesTermStoresGroupsSetsChildrenDeleteChildrenRequest) IfMatch(ifMatch string) ApiSitesTermStoresGroupsSetsChildrenDeleteChildrenRequest {
	r.ifMatch = &ifMatch
	return r
}

func (r ApiSitesTermStoresGroupsSetsChildrenDeleteChildrenRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.SitesTermStoresGroupsSetsChildrenDeleteChildrenExecute(r)
}

/*
SitesTermStoresGroupsSetsChildrenDeleteChildren Delete navigation property children for sites

Children of current term.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param siteId key: id of site
 @param storeId key: id of store
 @param groupId key: id of group
 @param setId key: id of set
 @param termId key: id of term
 @param termId1 key: id of term
 @return ApiSitesTermStoresGroupsSetsChildrenDeleteChildrenRequest
*/
func (a *SitesStoreApiService) SitesTermStoresGroupsSetsChildrenDeleteChildren(ctx _context.Context, siteId string, storeId string, groupId string, setId string, termId string, termId1 string) ApiSitesTermStoresGroupsSetsChildrenDeleteChildrenRequest {
	return ApiSitesTermStoresGroupsSetsChildrenDeleteChildrenRequest{
		ApiService: a,
		ctx: ctx,
		siteId: siteId,
		storeId: storeId,
		groupId: groupId,
		setId: setId,
		termId: termId,
		termId1: termId1,
	}
}

// Execute executes the request
func (a *SitesStoreApiService) SitesTermStoresGroupsSetsChildrenDeleteChildrenExecute(r ApiSitesTermStoresGroupsSetsChildrenDeleteChildrenRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SitesStoreApiService.SitesTermStoresGroupsSetsChildrenDeleteChildren")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sites/{site-id}/termStores/{store-id}/groups/{group-id}/sets/{set-id}/children/{term-id}/children/{term-id1}"
	localVarPath = strings.Replace(localVarPath, "{"+"site-id"+"}", _neturl.PathEscape(parameterToString(r.siteId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"store-id"+"}", _neturl.PathEscape(parameterToString(r.storeId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"set-id"+"}", _neturl.PathEscape(parameterToString(r.setId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"term-id"+"}", _neturl.PathEscape(parameterToString(r.termId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"term-id1"+"}", _neturl.PathEscape(parameterToString(r.termId1, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ifMatch != nil {
		localVarHeaderParams["If-Match"] = parameterToString(*r.ifMatch, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiSitesTermStoresGroupsSetsChildrenDeleteRefSetRequest struct {
	ctx _context.Context
	ApiService *SitesStoreApiService
	siteId string
	storeId string
	groupId string
	setId string
	termId string
	ifMatch *string
}

// ETag
func (r ApiSitesTermStoresGroupsSetsChildrenDeleteRefSetRequest) IfMatch(ifMatch string) ApiSitesTermStoresGroupsSetsChildrenDeleteRefSetRequest {
	r.ifMatch = &ifMatch
	return r
}

func (r ApiSitesTermStoresGroupsSetsChildrenDeleteRefSetRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.SitesTermStoresGroupsSetsChildrenDeleteRefSetExecute(r)
}

/*
SitesTermStoresGroupsSetsChildrenDeleteRefSet Delete ref of navigation property set for sites

The [set] in which the term is created.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param siteId key: id of site
 @param storeId key: id of store
 @param groupId key: id of group
 @param setId key: id of set
 @param termId key: id of term
 @return ApiSitesTermStoresGroupsSetsChildrenDeleteRefSetRequest
*/
func (a *SitesStoreApiService) SitesTermStoresGroupsSetsChildrenDeleteRefSet(ctx _context.Context, siteId string, storeId string, groupId string, setId string, termId string) ApiSitesTermStoresGroupsSetsChildrenDeleteRefSetRequest {
	return ApiSitesTermStoresGroupsSetsChildrenDeleteRefSetRequest{
		ApiService: a,
		ctx: ctx,
		siteId: siteId,
		storeId: storeId,
		groupId: groupId,
		setId: setId,
		termId: termId,
	}
}

// Execute executes the request
func (a *SitesStoreApiService) SitesTermStoresGroupsSetsChildrenDeleteRefSetExecute(r ApiSitesTermStoresGroupsSetsChildrenDeleteRefSetRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SitesStoreApiService.SitesTermStoresGroupsSetsChildrenDeleteRefSet")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sites/{site-id}/termStores/{store-id}/groups/{group-id}/sets/{set-id}/children/{term-id}/set/$ref"
	localVarPath = strings.Replace(localVarPath, "{"+"site-id"+"}", _neturl.PathEscape(parameterToString(r.siteId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"store-id"+"}", _neturl.PathEscape(parameterToString(r.storeId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"set-id"+"}", _neturl.PathEscape(parameterToString(r.setId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"term-id"+"}", _neturl.PathEscape(parameterToString(r.termId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ifMatch != nil {
		localVarHeaderParams["If-Match"] = parameterToString(*r.ifMatch, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiSitesTermStoresGroupsSetsChildrenDeleteRelationsRequest struct {
	ctx _context.Context
	ApiService *SitesStoreApiService
	siteId string
	storeId string
	groupId string
	setId string
	termId string
	relationId string
	ifMatch *string
}

// ETag
func (r ApiSitesTermStoresGroupsSetsChildrenDeleteRelationsRequest) IfMatch(ifMatch string) ApiSitesTermStoresGroupsSetsChildrenDeleteRelationsRequest {
	r.ifMatch = &ifMatch
	return r
}

func (r ApiSitesTermStoresGroupsSetsChildrenDeleteRelationsRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.SitesTermStoresGroupsSetsChildrenDeleteRelationsExecute(r)
}

/*
SitesTermStoresGroupsSetsChildrenDeleteRelations Delete navigation property relations for sites

To indicate which terms are related to the current term as either pinned or reused.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param siteId key: id of site
 @param storeId key: id of store
 @param groupId key: id of group
 @param setId key: id of set
 @param termId key: id of term
 @param relationId key: id of relation
 @return ApiSitesTermStoresGroupsSetsChildrenDeleteRelationsRequest
*/
func (a *SitesStoreApiService) SitesTermStoresGroupsSetsChildrenDeleteRelations(ctx _context.Context, siteId string, storeId string, groupId string, setId string, termId string, relationId string) ApiSitesTermStoresGroupsSetsChildrenDeleteRelationsRequest {
	return ApiSitesTermStoresGroupsSetsChildrenDeleteRelationsRequest{
		ApiService: a,
		ctx: ctx,
		siteId: siteId,
		storeId: storeId,
		groupId: groupId,
		setId: setId,
		termId: termId,
		relationId: relationId,
	}
}

// Execute executes the request
func (a *SitesStoreApiService) SitesTermStoresGroupsSetsChildrenDeleteRelationsExecute(r ApiSitesTermStoresGroupsSetsChildrenDeleteRelationsRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SitesStoreApiService.SitesTermStoresGroupsSetsChildrenDeleteRelations")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sites/{site-id}/termStores/{store-id}/groups/{group-id}/sets/{set-id}/children/{term-id}/relations/{relation-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"site-id"+"}", _neturl.PathEscape(parameterToString(r.siteId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"store-id"+"}", _neturl.PathEscape(parameterToString(r.storeId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"set-id"+"}", _neturl.PathEscape(parameterToString(r.setId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"term-id"+"}", _neturl.PathEscape(parameterToString(r.termId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"relation-id"+"}", _neturl.PathEscape(parameterToString(r.relationId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ifMatch != nil {
		localVarHeaderParams["If-Match"] = parameterToString(*r.ifMatch, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiSitesTermStoresGroupsSetsChildrenGetChildrenRequest struct {
	ctx _context.Context
	ApiService *SitesStoreApiService
	siteId string
	storeId string
	groupId string
	setId string
	termId string
	termId1 string
	select_ *[]string
	expand *[]string
}

// Select properties to be returned
func (r ApiSitesTermStoresGroupsSetsChildrenGetChildrenRequest) Select_(select_ []string) ApiSitesTermStoresGroupsSetsChildrenGetChildrenRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiSitesTermStoresGroupsSetsChildrenGetChildrenRequest) Expand(expand []string) ApiSitesTermStoresGroupsSetsChildrenGetChildrenRequest {
	r.expand = &expand
	return r
}

func (r ApiSitesTermStoresGroupsSetsChildrenGetChildrenRequest) Execute() (MicrosoftGraphTermStoreTerm, *_nethttp.Response, error) {
	return r.ApiService.SitesTermStoresGroupsSetsChildrenGetChildrenExecute(r)
}

/*
SitesTermStoresGroupsSetsChildrenGetChildren Get children from sites

Children of current term.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param siteId key: id of site
 @param storeId key: id of store
 @param groupId key: id of group
 @param setId key: id of set
 @param termId key: id of term
 @param termId1 key: id of term
 @return ApiSitesTermStoresGroupsSetsChildrenGetChildrenRequest
*/
func (a *SitesStoreApiService) SitesTermStoresGroupsSetsChildrenGetChildren(ctx _context.Context, siteId string, storeId string, groupId string, setId string, termId string, termId1 string) ApiSitesTermStoresGroupsSetsChildrenGetChildrenRequest {
	return ApiSitesTermStoresGroupsSetsChildrenGetChildrenRequest{
		ApiService: a,
		ctx: ctx,
		siteId: siteId,
		storeId: storeId,
		groupId: groupId,
		setId: setId,
		termId: termId,
		termId1: termId1,
	}
}

// Execute executes the request
//  @return MicrosoftGraphTermStoreTerm
func (a *SitesStoreApiService) SitesTermStoresGroupsSetsChildrenGetChildrenExecute(r ApiSitesTermStoresGroupsSetsChildrenGetChildrenRequest) (MicrosoftGraphTermStoreTerm, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphTermStoreTerm
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SitesStoreApiService.SitesTermStoresGroupsSetsChildrenGetChildren")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sites/{site-id}/termStores/{store-id}/groups/{group-id}/sets/{set-id}/children/{term-id}/children/{term-id1}"
	localVarPath = strings.Replace(localVarPath, "{"+"site-id"+"}", _neturl.PathEscape(parameterToString(r.siteId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"store-id"+"}", _neturl.PathEscape(parameterToString(r.storeId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"set-id"+"}", _neturl.PathEscape(parameterToString(r.setId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"term-id"+"}", _neturl.PathEscape(parameterToString(r.termId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"term-id1"+"}", _neturl.PathEscape(parameterToString(r.termId1, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSitesTermStoresGroupsSetsChildrenGetRefSetRequest struct {
	ctx _context.Context
	ApiService *SitesStoreApiService
	siteId string
	storeId string
	groupId string
	setId string
	termId string
}


func (r ApiSitesTermStoresGroupsSetsChildrenGetRefSetRequest) Execute() (string, *_nethttp.Response, error) {
	return r.ApiService.SitesTermStoresGroupsSetsChildrenGetRefSetExecute(r)
}

/*
SitesTermStoresGroupsSetsChildrenGetRefSet Get ref of set from sites

The [set] in which the term is created.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param siteId key: id of site
 @param storeId key: id of store
 @param groupId key: id of group
 @param setId key: id of set
 @param termId key: id of term
 @return ApiSitesTermStoresGroupsSetsChildrenGetRefSetRequest
*/
func (a *SitesStoreApiService) SitesTermStoresGroupsSetsChildrenGetRefSet(ctx _context.Context, siteId string, storeId string, groupId string, setId string, termId string) ApiSitesTermStoresGroupsSetsChildrenGetRefSetRequest {
	return ApiSitesTermStoresGroupsSetsChildrenGetRefSetRequest{
		ApiService: a,
		ctx: ctx,
		siteId: siteId,
		storeId: storeId,
		groupId: groupId,
		setId: setId,
		termId: termId,
	}
}

// Execute executes the request
//  @return string
func (a *SitesStoreApiService) SitesTermStoresGroupsSetsChildrenGetRefSetExecute(r ApiSitesTermStoresGroupsSetsChildrenGetRefSetRequest) (string, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  string
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SitesStoreApiService.SitesTermStoresGroupsSetsChildrenGetRefSet")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sites/{site-id}/termStores/{store-id}/groups/{group-id}/sets/{set-id}/children/{term-id}/set/$ref"
	localVarPath = strings.Replace(localVarPath, "{"+"site-id"+"}", _neturl.PathEscape(parameterToString(r.siteId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"store-id"+"}", _neturl.PathEscape(parameterToString(r.storeId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"set-id"+"}", _neturl.PathEscape(parameterToString(r.setId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"term-id"+"}", _neturl.PathEscape(parameterToString(r.termId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSitesTermStoresGroupsSetsChildrenGetRelationsRequest struct {
	ctx _context.Context
	ApiService *SitesStoreApiService
	siteId string
	storeId string
	groupId string
	setId string
	termId string
	relationId string
	select_ *[]string
	expand *[]string
}

// Select properties to be returned
func (r ApiSitesTermStoresGroupsSetsChildrenGetRelationsRequest) Select_(select_ []string) ApiSitesTermStoresGroupsSetsChildrenGetRelationsRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiSitesTermStoresGroupsSetsChildrenGetRelationsRequest) Expand(expand []string) ApiSitesTermStoresGroupsSetsChildrenGetRelationsRequest {
	r.expand = &expand
	return r
}

func (r ApiSitesTermStoresGroupsSetsChildrenGetRelationsRequest) Execute() (MicrosoftGraphTermStoreRelation, *_nethttp.Response, error) {
	return r.ApiService.SitesTermStoresGroupsSetsChildrenGetRelationsExecute(r)
}

/*
SitesTermStoresGroupsSetsChildrenGetRelations Get relations from sites

To indicate which terms are related to the current term as either pinned or reused.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param siteId key: id of site
 @param storeId key: id of store
 @param groupId key: id of group
 @param setId key: id of set
 @param termId key: id of term
 @param relationId key: id of relation
 @return ApiSitesTermStoresGroupsSetsChildrenGetRelationsRequest
*/
func (a *SitesStoreApiService) SitesTermStoresGroupsSetsChildrenGetRelations(ctx _context.Context, siteId string, storeId string, groupId string, setId string, termId string, relationId string) ApiSitesTermStoresGroupsSetsChildrenGetRelationsRequest {
	return ApiSitesTermStoresGroupsSetsChildrenGetRelationsRequest{
		ApiService: a,
		ctx: ctx,
		siteId: siteId,
		storeId: storeId,
		groupId: groupId,
		setId: setId,
		termId: termId,
		relationId: relationId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphTermStoreRelation
func (a *SitesStoreApiService) SitesTermStoresGroupsSetsChildrenGetRelationsExecute(r ApiSitesTermStoresGroupsSetsChildrenGetRelationsRequest) (MicrosoftGraphTermStoreRelation, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphTermStoreRelation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SitesStoreApiService.SitesTermStoresGroupsSetsChildrenGetRelations")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sites/{site-id}/termStores/{store-id}/groups/{group-id}/sets/{set-id}/children/{term-id}/relations/{relation-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"site-id"+"}", _neturl.PathEscape(parameterToString(r.siteId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"store-id"+"}", _neturl.PathEscape(parameterToString(r.storeId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"set-id"+"}", _neturl.PathEscape(parameterToString(r.setId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"term-id"+"}", _neturl.PathEscape(parameterToString(r.termId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"relation-id"+"}", _neturl.PathEscape(parameterToString(r.relationId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSitesTermStoresGroupsSetsChildrenGetSetRequest struct {
	ctx _context.Context
	ApiService *SitesStoreApiService
	siteId string
	storeId string
	groupId string
	setId string
	termId string
	select_ *[]string
	expand *[]string
}

// Select properties to be returned
func (r ApiSitesTermStoresGroupsSetsChildrenGetSetRequest) Select_(select_ []string) ApiSitesTermStoresGroupsSetsChildrenGetSetRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiSitesTermStoresGroupsSetsChildrenGetSetRequest) Expand(expand []string) ApiSitesTermStoresGroupsSetsChildrenGetSetRequest {
	r.expand = &expand
	return r
}

func (r ApiSitesTermStoresGroupsSetsChildrenGetSetRequest) Execute() (MicrosoftGraphTermStoreSet, *_nethttp.Response, error) {
	return r.ApiService.SitesTermStoresGroupsSetsChildrenGetSetExecute(r)
}

/*
SitesTermStoresGroupsSetsChildrenGetSet Get set from sites

The [set] in which the term is created.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param siteId key: id of site
 @param storeId key: id of store
 @param groupId key: id of group
 @param setId key: id of set
 @param termId key: id of term
 @return ApiSitesTermStoresGroupsSetsChildrenGetSetRequest
*/
func (a *SitesStoreApiService) SitesTermStoresGroupsSetsChildrenGetSet(ctx _context.Context, siteId string, storeId string, groupId string, setId string, termId string) ApiSitesTermStoresGroupsSetsChildrenGetSetRequest {
	return ApiSitesTermStoresGroupsSetsChildrenGetSetRequest{
		ApiService: a,
		ctx: ctx,
		siteId: siteId,
		storeId: storeId,
		groupId: groupId,
		setId: setId,
		termId: termId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphTermStoreSet
func (a *SitesStoreApiService) SitesTermStoresGroupsSetsChildrenGetSetExecute(r ApiSitesTermStoresGroupsSetsChildrenGetSetRequest) (MicrosoftGraphTermStoreSet, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphTermStoreSet
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SitesStoreApiService.SitesTermStoresGroupsSetsChildrenGetSet")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sites/{site-id}/termStores/{store-id}/groups/{group-id}/sets/{set-id}/children/{term-id}/set"
	localVarPath = strings.Replace(localVarPath, "{"+"site-id"+"}", _neturl.PathEscape(parameterToString(r.siteId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"store-id"+"}", _neturl.PathEscape(parameterToString(r.storeId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"set-id"+"}", _neturl.PathEscape(parameterToString(r.setId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"term-id"+"}", _neturl.PathEscape(parameterToString(r.termId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSitesTermStoresGroupsSetsChildrenListChildrenRequest struct {
	ctx _context.Context
	ApiService *SitesStoreApiService
	siteId string
	storeId string
	groupId string
	setId string
	termId string
	top *int32
	skip *int32
	search *string
	filter *string
	count *bool
	orderby *[]string
	select_ *[]string
	expand *[]string
}

// Show only the first n items
func (r ApiSitesTermStoresGroupsSetsChildrenListChildrenRequest) Top(top int32) ApiSitesTermStoresGroupsSetsChildrenListChildrenRequest {
	r.top = &top
	return r
}
// Skip the first n items
func (r ApiSitesTermStoresGroupsSetsChildrenListChildrenRequest) Skip(skip int32) ApiSitesTermStoresGroupsSetsChildrenListChildrenRequest {
	r.skip = &skip
	return r
}
// Search items by search phrases
func (r ApiSitesTermStoresGroupsSetsChildrenListChildrenRequest) Search(search string) ApiSitesTermStoresGroupsSetsChildrenListChildrenRequest {
	r.search = &search
	return r
}
// Filter items by property values
func (r ApiSitesTermStoresGroupsSetsChildrenListChildrenRequest) Filter(filter string) ApiSitesTermStoresGroupsSetsChildrenListChildrenRequest {
	r.filter = &filter
	return r
}
// Include count of items
func (r ApiSitesTermStoresGroupsSetsChildrenListChildrenRequest) Count(count bool) ApiSitesTermStoresGroupsSetsChildrenListChildrenRequest {
	r.count = &count
	return r
}
// Order items by property values
func (r ApiSitesTermStoresGroupsSetsChildrenListChildrenRequest) Orderby(orderby []string) ApiSitesTermStoresGroupsSetsChildrenListChildrenRequest {
	r.orderby = &orderby
	return r
}
// Select properties to be returned
func (r ApiSitesTermStoresGroupsSetsChildrenListChildrenRequest) Select_(select_ []string) ApiSitesTermStoresGroupsSetsChildrenListChildrenRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiSitesTermStoresGroupsSetsChildrenListChildrenRequest) Expand(expand []string) ApiSitesTermStoresGroupsSetsChildrenListChildrenRequest {
	r.expand = &expand
	return r
}

func (r ApiSitesTermStoresGroupsSetsChildrenListChildrenRequest) Execute() (CollectionOfTerm, *_nethttp.Response, error) {
	return r.ApiService.SitesTermStoresGroupsSetsChildrenListChildrenExecute(r)
}

/*
SitesTermStoresGroupsSetsChildrenListChildren Get children from sites

Children of current term.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param siteId key: id of site
 @param storeId key: id of store
 @param groupId key: id of group
 @param setId key: id of set
 @param termId key: id of term
 @return ApiSitesTermStoresGroupsSetsChildrenListChildrenRequest
*/
func (a *SitesStoreApiService) SitesTermStoresGroupsSetsChildrenListChildren(ctx _context.Context, siteId string, storeId string, groupId string, setId string, termId string) ApiSitesTermStoresGroupsSetsChildrenListChildrenRequest {
	return ApiSitesTermStoresGroupsSetsChildrenListChildrenRequest{
		ApiService: a,
		ctx: ctx,
		siteId: siteId,
		storeId: storeId,
		groupId: groupId,
		setId: setId,
		termId: termId,
	}
}

// Execute executes the request
//  @return CollectionOfTerm
func (a *SitesStoreApiService) SitesTermStoresGroupsSetsChildrenListChildrenExecute(r ApiSitesTermStoresGroupsSetsChildrenListChildrenRequest) (CollectionOfTerm, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  CollectionOfTerm
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SitesStoreApiService.SitesTermStoresGroupsSetsChildrenListChildren")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sites/{site-id}/termStores/{store-id}/groups/{group-id}/sets/{set-id}/children/{term-id}/children"
	localVarPath = strings.Replace(localVarPath, "{"+"site-id"+"}", _neturl.PathEscape(parameterToString(r.siteId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"store-id"+"}", _neturl.PathEscape(parameterToString(r.storeId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"set-id"+"}", _neturl.PathEscape(parameterToString(r.setId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"term-id"+"}", _neturl.PathEscape(parameterToString(r.termId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.top != nil {
		localVarQueryParams.Add("$top", parameterToString(*r.top, ""))
	}
	if r.skip != nil {
		localVarQueryParams.Add("$skip", parameterToString(*r.skip, ""))
	}
	if r.search != nil {
		localVarQueryParams.Add("$search", parameterToString(*r.search, ""))
	}
	if r.filter != nil {
		localVarQueryParams.Add("$filter", parameterToString(*r.filter, ""))
	}
	if r.count != nil {
		localVarQueryParams.Add("$count", parameterToString(*r.count, ""))
	}
	if r.orderby != nil {
		localVarQueryParams.Add("$orderby", parameterToString(*r.orderby, "csv"))
	}
	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSitesTermStoresGroupsSetsChildrenListRelationsRequest struct {
	ctx _context.Context
	ApiService *SitesStoreApiService
	siteId string
	storeId string
	groupId string
	setId string
	termId string
	top *int32
	skip *int32
	search *string
	filter *string
	count *bool
	orderby *[]string
	select_ *[]string
	expand *[]string
}

// Show only the first n items
func (r ApiSitesTermStoresGroupsSetsChildrenListRelationsRequest) Top(top int32) ApiSitesTermStoresGroupsSetsChildrenListRelationsRequest {
	r.top = &top
	return r
}
// Skip the first n items
func (r ApiSitesTermStoresGroupsSetsChildrenListRelationsRequest) Skip(skip int32) ApiSitesTermStoresGroupsSetsChildrenListRelationsRequest {
	r.skip = &skip
	return r
}
// Search items by search phrases
func (r ApiSitesTermStoresGroupsSetsChildrenListRelationsRequest) Search(search string) ApiSitesTermStoresGroupsSetsChildrenListRelationsRequest {
	r.search = &search
	return r
}
// Filter items by property values
func (r ApiSitesTermStoresGroupsSetsChildrenListRelationsRequest) Filter(filter string) ApiSitesTermStoresGroupsSetsChildrenListRelationsRequest {
	r.filter = &filter
	return r
}
// Include count of items
func (r ApiSitesTermStoresGroupsSetsChildrenListRelationsRequest) Count(count bool) ApiSitesTermStoresGroupsSetsChildrenListRelationsRequest {
	r.count = &count
	return r
}
// Order items by property values
func (r ApiSitesTermStoresGroupsSetsChildrenListRelationsRequest) Orderby(orderby []string) ApiSitesTermStoresGroupsSetsChildrenListRelationsRequest {
	r.orderby = &orderby
	return r
}
// Select properties to be returned
func (r ApiSitesTermStoresGroupsSetsChildrenListRelationsRequest) Select_(select_ []string) ApiSitesTermStoresGroupsSetsChildrenListRelationsRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiSitesTermStoresGroupsSetsChildrenListRelationsRequest) Expand(expand []string) ApiSitesTermStoresGroupsSetsChildrenListRelationsRequest {
	r.expand = &expand
	return r
}

func (r ApiSitesTermStoresGroupsSetsChildrenListRelationsRequest) Execute() (CollectionOfRelation, *_nethttp.Response, error) {
	return r.ApiService.SitesTermStoresGroupsSetsChildrenListRelationsExecute(r)
}

/*
SitesTermStoresGroupsSetsChildrenListRelations Get relations from sites

To indicate which terms are related to the current term as either pinned or reused.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param siteId key: id of site
 @param storeId key: id of store
 @param groupId key: id of group
 @param setId key: id of set
 @param termId key: id of term
 @return ApiSitesTermStoresGroupsSetsChildrenListRelationsRequest
*/
func (a *SitesStoreApiService) SitesTermStoresGroupsSetsChildrenListRelations(ctx _context.Context, siteId string, storeId string, groupId string, setId string, termId string) ApiSitesTermStoresGroupsSetsChildrenListRelationsRequest {
	return ApiSitesTermStoresGroupsSetsChildrenListRelationsRequest{
		ApiService: a,
		ctx: ctx,
		siteId: siteId,
		storeId: storeId,
		groupId: groupId,
		setId: setId,
		termId: termId,
	}
}

// Execute executes the request
//  @return CollectionOfRelation
func (a *SitesStoreApiService) SitesTermStoresGroupsSetsChildrenListRelationsExecute(r ApiSitesTermStoresGroupsSetsChildrenListRelationsRequest) (CollectionOfRelation, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  CollectionOfRelation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SitesStoreApiService.SitesTermStoresGroupsSetsChildrenListRelations")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sites/{site-id}/termStores/{store-id}/groups/{group-id}/sets/{set-id}/children/{term-id}/relations"
	localVarPath = strings.Replace(localVarPath, "{"+"site-id"+"}", _neturl.PathEscape(parameterToString(r.siteId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"store-id"+"}", _neturl.PathEscape(parameterToString(r.storeId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"set-id"+"}", _neturl.PathEscape(parameterToString(r.setId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"term-id"+"}", _neturl.PathEscape(parameterToString(r.termId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.top != nil {
		localVarQueryParams.Add("$top", parameterToString(*r.top, ""))
	}
	if r.skip != nil {
		localVarQueryParams.Add("$skip", parameterToString(*r.skip, ""))
	}
	if r.search != nil {
		localVarQueryParams.Add("$search", parameterToString(*r.search, ""))
	}
	if r.filter != nil {
		localVarQueryParams.Add("$filter", parameterToString(*r.filter, ""))
	}
	if r.count != nil {
		localVarQueryParams.Add("$count", parameterToString(*r.count, ""))
	}
	if r.orderby != nil {
		localVarQueryParams.Add("$orderby", parameterToString(*r.orderby, "csv"))
	}
	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSitesTermStoresGroupsSetsChildrenRelationsDeleteRefFromTermRequest struct {
	ctx _context.Context
	ApiService *SitesStoreApiService
	siteId string
	storeId string
	groupId string
	setId string
	termId string
	relationId string
	ifMatch *string
}

// ETag
func (r ApiSitesTermStoresGroupsSetsChildrenRelationsDeleteRefFromTermRequest) IfMatch(ifMatch string) ApiSitesTermStoresGroupsSetsChildrenRelationsDeleteRefFromTermRequest {
	r.ifMatch = &ifMatch
	return r
}

func (r ApiSitesTermStoresGroupsSetsChildrenRelationsDeleteRefFromTermRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.SitesTermStoresGroupsSetsChildrenRelationsDeleteRefFromTermExecute(r)
}

/*
SitesTermStoresGroupsSetsChildrenRelationsDeleteRefFromTerm Delete ref of navigation property fromTerm for sites

The from [term] of the relation. The term from which the relationship is defined. A null value would indicate the relation is directly with the [set].

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param siteId key: id of site
 @param storeId key: id of store
 @param groupId key: id of group
 @param setId key: id of set
 @param termId key: id of term
 @param relationId key: id of relation
 @return ApiSitesTermStoresGroupsSetsChildrenRelationsDeleteRefFromTermRequest
*/
func (a *SitesStoreApiService) SitesTermStoresGroupsSetsChildrenRelationsDeleteRefFromTerm(ctx _context.Context, siteId string, storeId string, groupId string, setId string, termId string, relationId string) ApiSitesTermStoresGroupsSetsChildrenRelationsDeleteRefFromTermRequest {
	return ApiSitesTermStoresGroupsSetsChildrenRelationsDeleteRefFromTermRequest{
		ApiService: a,
		ctx: ctx,
		siteId: siteId,
		storeId: storeId,
		groupId: groupId,
		setId: setId,
		termId: termId,
		relationId: relationId,
	}
}

// Execute executes the request
func (a *SitesStoreApiService) SitesTermStoresGroupsSetsChildrenRelationsDeleteRefFromTermExecute(r ApiSitesTermStoresGroupsSetsChildrenRelationsDeleteRefFromTermRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SitesStoreApiService.SitesTermStoresGroupsSetsChildrenRelationsDeleteRefFromTerm")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sites/{site-id}/termStores/{store-id}/groups/{group-id}/sets/{set-id}/children/{term-id}/relations/{relation-id}/fromTerm/$ref"
	localVarPath = strings.Replace(localVarPath, "{"+"site-id"+"}", _neturl.PathEscape(parameterToString(r.siteId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"store-id"+"}", _neturl.PathEscape(parameterToString(r.storeId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"set-id"+"}", _neturl.PathEscape(parameterToString(r.setId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"term-id"+"}", _neturl.PathEscape(parameterToString(r.termId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"relation-id"+"}", _neturl.PathEscape(parameterToString(r.relationId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ifMatch != nil {
		localVarHeaderParams["If-Match"] = parameterToString(*r.ifMatch, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiSitesTermStoresGroupsSetsChildrenRelationsDeleteRefSetRequest struct {
	ctx _context.Context
	ApiService *SitesStoreApiService
	siteId string
	storeId string
	groupId string
	setId string
	termId string
	relationId string
	ifMatch *string
}

// ETag
func (r ApiSitesTermStoresGroupsSetsChildrenRelationsDeleteRefSetRequest) IfMatch(ifMatch string) ApiSitesTermStoresGroupsSetsChildrenRelationsDeleteRefSetRequest {
	r.ifMatch = &ifMatch
	return r
}

func (r ApiSitesTermStoresGroupsSetsChildrenRelationsDeleteRefSetRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.SitesTermStoresGroupsSetsChildrenRelationsDeleteRefSetExecute(r)
}

/*
SitesTermStoresGroupsSetsChildrenRelationsDeleteRefSet Delete ref of navigation property set for sites

The [set] in which the relation is relevant.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param siteId key: id of site
 @param storeId key: id of store
 @param groupId key: id of group
 @param setId key: id of set
 @param termId key: id of term
 @param relationId key: id of relation
 @return ApiSitesTermStoresGroupsSetsChildrenRelationsDeleteRefSetRequest
*/
func (a *SitesStoreApiService) SitesTermStoresGroupsSetsChildrenRelationsDeleteRefSet(ctx _context.Context, siteId string, storeId string, groupId string, setId string, termId string, relationId string) ApiSitesTermStoresGroupsSetsChildrenRelationsDeleteRefSetRequest {
	return ApiSitesTermStoresGroupsSetsChildrenRelationsDeleteRefSetRequest{
		ApiService: a,
		ctx: ctx,
		siteId: siteId,
		storeId: storeId,
		groupId: groupId,
		setId: setId,
		termId: termId,
		relationId: relationId,
	}
}

// Execute executes the request
func (a *SitesStoreApiService) SitesTermStoresGroupsSetsChildrenRelationsDeleteRefSetExecute(r ApiSitesTermStoresGroupsSetsChildrenRelationsDeleteRefSetRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SitesStoreApiService.SitesTermStoresGroupsSetsChildrenRelationsDeleteRefSet")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sites/{site-id}/termStores/{store-id}/groups/{group-id}/sets/{set-id}/children/{term-id}/relations/{relation-id}/set/$ref"
	localVarPath = strings.Replace(localVarPath, "{"+"site-id"+"}", _neturl.PathEscape(parameterToString(r.siteId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"store-id"+"}", _neturl.PathEscape(parameterToString(r.storeId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"set-id"+"}", _neturl.PathEscape(parameterToString(r.setId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"term-id"+"}", _neturl.PathEscape(parameterToString(r.termId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"relation-id"+"}", _neturl.PathEscape(parameterToString(r.relationId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ifMatch != nil {
		localVarHeaderParams["If-Match"] = parameterToString(*r.ifMatch, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiSitesTermStoresGroupsSetsChildrenRelationsDeleteRefToTermRequest struct {
	ctx _context.Context
	ApiService *SitesStoreApiService
	siteId string
	storeId string
	groupId string
	setId string
	termId string
	relationId string
	ifMatch *string
}

// ETag
func (r ApiSitesTermStoresGroupsSetsChildrenRelationsDeleteRefToTermRequest) IfMatch(ifMatch string) ApiSitesTermStoresGroupsSetsChildrenRelationsDeleteRefToTermRequest {
	r.ifMatch = &ifMatch
	return r
}

func (r ApiSitesTermStoresGroupsSetsChildrenRelationsDeleteRefToTermRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.SitesTermStoresGroupsSetsChildrenRelationsDeleteRefToTermExecute(r)
}

/*
SitesTermStoresGroupsSetsChildrenRelationsDeleteRefToTerm Delete ref of navigation property toTerm for sites

The to [term] of the relation. The term to which the relationship is defined.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param siteId key: id of site
 @param storeId key: id of store
 @param groupId key: id of group
 @param setId key: id of set
 @param termId key: id of term
 @param relationId key: id of relation
 @return ApiSitesTermStoresGroupsSetsChildrenRelationsDeleteRefToTermRequest
*/
func (a *SitesStoreApiService) SitesTermStoresGroupsSetsChildrenRelationsDeleteRefToTerm(ctx _context.Context, siteId string, storeId string, groupId string, setId string, termId string, relationId string) ApiSitesTermStoresGroupsSetsChildrenRelationsDeleteRefToTermRequest {
	return ApiSitesTermStoresGroupsSetsChildrenRelationsDeleteRefToTermRequest{
		ApiService: a,
		ctx: ctx,
		siteId: siteId,
		storeId: storeId,
		groupId: groupId,
		setId: setId,
		termId: termId,
		relationId: relationId,
	}
}

// Execute executes the request
func (a *SitesStoreApiService) SitesTermStoresGroupsSetsChildrenRelationsDeleteRefToTermExecute(r ApiSitesTermStoresGroupsSetsChildrenRelationsDeleteRefToTermRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SitesStoreApiService.SitesTermStoresGroupsSetsChildrenRelationsDeleteRefToTerm")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sites/{site-id}/termStores/{store-id}/groups/{group-id}/sets/{set-id}/children/{term-id}/relations/{relation-id}/toTerm/$ref"
	localVarPath = strings.Replace(localVarPath, "{"+"site-id"+"}", _neturl.PathEscape(parameterToString(r.siteId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"store-id"+"}", _neturl.PathEscape(parameterToString(r.storeId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"set-id"+"}", _neturl.PathEscape(parameterToString(r.setId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"term-id"+"}", _neturl.PathEscape(parameterToString(r.termId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"relation-id"+"}", _neturl.PathEscape(parameterToString(r.relationId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ifMatch != nil {
		localVarHeaderParams["If-Match"] = parameterToString(*r.ifMatch, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiSitesTermStoresGroupsSetsChildrenRelationsGetFromTermRequest struct {
	ctx _context.Context
	ApiService *SitesStoreApiService
	siteId string
	storeId string
	groupId string
	setId string
	termId string
	relationId string
	select_ *[]string
	expand *[]string
}

// Select properties to be returned
func (r ApiSitesTermStoresGroupsSetsChildrenRelationsGetFromTermRequest) Select_(select_ []string) ApiSitesTermStoresGroupsSetsChildrenRelationsGetFromTermRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiSitesTermStoresGroupsSetsChildrenRelationsGetFromTermRequest) Expand(expand []string) ApiSitesTermStoresGroupsSetsChildrenRelationsGetFromTermRequest {
	r.expand = &expand
	return r
}

func (r ApiSitesTermStoresGroupsSetsChildrenRelationsGetFromTermRequest) Execute() (MicrosoftGraphTermStoreTerm, *_nethttp.Response, error) {
	return r.ApiService.SitesTermStoresGroupsSetsChildrenRelationsGetFromTermExecute(r)
}

/*
SitesTermStoresGroupsSetsChildrenRelationsGetFromTerm Get fromTerm from sites

The from [term] of the relation. The term from which the relationship is defined. A null value would indicate the relation is directly with the [set].

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param siteId key: id of site
 @param storeId key: id of store
 @param groupId key: id of group
 @param setId key: id of set
 @param termId key: id of term
 @param relationId key: id of relation
 @return ApiSitesTermStoresGroupsSetsChildrenRelationsGetFromTermRequest
*/
func (a *SitesStoreApiService) SitesTermStoresGroupsSetsChildrenRelationsGetFromTerm(ctx _context.Context, siteId string, storeId string, groupId string, setId string, termId string, relationId string) ApiSitesTermStoresGroupsSetsChildrenRelationsGetFromTermRequest {
	return ApiSitesTermStoresGroupsSetsChildrenRelationsGetFromTermRequest{
		ApiService: a,
		ctx: ctx,
		siteId: siteId,
		storeId: storeId,
		groupId: groupId,
		setId: setId,
		termId: termId,
		relationId: relationId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphTermStoreTerm
func (a *SitesStoreApiService) SitesTermStoresGroupsSetsChildrenRelationsGetFromTermExecute(r ApiSitesTermStoresGroupsSetsChildrenRelationsGetFromTermRequest) (MicrosoftGraphTermStoreTerm, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphTermStoreTerm
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SitesStoreApiService.SitesTermStoresGroupsSetsChildrenRelationsGetFromTerm")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sites/{site-id}/termStores/{store-id}/groups/{group-id}/sets/{set-id}/children/{term-id}/relations/{relation-id}/fromTerm"
	localVarPath = strings.Replace(localVarPath, "{"+"site-id"+"}", _neturl.PathEscape(parameterToString(r.siteId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"store-id"+"}", _neturl.PathEscape(parameterToString(r.storeId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"set-id"+"}", _neturl.PathEscape(parameterToString(r.setId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"term-id"+"}", _neturl.PathEscape(parameterToString(r.termId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"relation-id"+"}", _neturl.PathEscape(parameterToString(r.relationId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSitesTermStoresGroupsSetsChildrenRelationsGetRefFromTermRequest struct {
	ctx _context.Context
	ApiService *SitesStoreApiService
	siteId string
	storeId string
	groupId string
	setId string
	termId string
	relationId string
}


func (r ApiSitesTermStoresGroupsSetsChildrenRelationsGetRefFromTermRequest) Execute() (string, *_nethttp.Response, error) {
	return r.ApiService.SitesTermStoresGroupsSetsChildrenRelationsGetRefFromTermExecute(r)
}

/*
SitesTermStoresGroupsSetsChildrenRelationsGetRefFromTerm Get ref of fromTerm from sites

The from [term] of the relation. The term from which the relationship is defined. A null value would indicate the relation is directly with the [set].

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param siteId key: id of site
 @param storeId key: id of store
 @param groupId key: id of group
 @param setId key: id of set
 @param termId key: id of term
 @param relationId key: id of relation
 @return ApiSitesTermStoresGroupsSetsChildrenRelationsGetRefFromTermRequest
*/
func (a *SitesStoreApiService) SitesTermStoresGroupsSetsChildrenRelationsGetRefFromTerm(ctx _context.Context, siteId string, storeId string, groupId string, setId string, termId string, relationId string) ApiSitesTermStoresGroupsSetsChildrenRelationsGetRefFromTermRequest {
	return ApiSitesTermStoresGroupsSetsChildrenRelationsGetRefFromTermRequest{
		ApiService: a,
		ctx: ctx,
		siteId: siteId,
		storeId: storeId,
		groupId: groupId,
		setId: setId,
		termId: termId,
		relationId: relationId,
	}
}

// Execute executes the request
//  @return string
func (a *SitesStoreApiService) SitesTermStoresGroupsSetsChildrenRelationsGetRefFromTermExecute(r ApiSitesTermStoresGroupsSetsChildrenRelationsGetRefFromTermRequest) (string, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  string
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SitesStoreApiService.SitesTermStoresGroupsSetsChildrenRelationsGetRefFromTerm")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sites/{site-id}/termStores/{store-id}/groups/{group-id}/sets/{set-id}/children/{term-id}/relations/{relation-id}/fromTerm/$ref"
	localVarPath = strings.Replace(localVarPath, "{"+"site-id"+"}", _neturl.PathEscape(parameterToString(r.siteId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"store-id"+"}", _neturl.PathEscape(parameterToString(r.storeId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"set-id"+"}", _neturl.PathEscape(parameterToString(r.setId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"term-id"+"}", _neturl.PathEscape(parameterToString(r.termId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"relation-id"+"}", _neturl.PathEscape(parameterToString(r.relationId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSitesTermStoresGroupsSetsChildrenRelationsGetRefSetRequest struct {
	ctx _context.Context
	ApiService *SitesStoreApiService
	siteId string
	storeId string
	groupId string
	setId string
	termId string
	relationId string
}


func (r ApiSitesTermStoresGroupsSetsChildrenRelationsGetRefSetRequest) Execute() (string, *_nethttp.Response, error) {
	return r.ApiService.SitesTermStoresGroupsSetsChildrenRelationsGetRefSetExecute(r)
}

/*
SitesTermStoresGroupsSetsChildrenRelationsGetRefSet Get ref of set from sites

The [set] in which the relation is relevant.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param siteId key: id of site
 @param storeId key: id of store
 @param groupId key: id of group
 @param setId key: id of set
 @param termId key: id of term
 @param relationId key: id of relation
 @return ApiSitesTermStoresGroupsSetsChildrenRelationsGetRefSetRequest
*/
func (a *SitesStoreApiService) SitesTermStoresGroupsSetsChildrenRelationsGetRefSet(ctx _context.Context, siteId string, storeId string, groupId string, setId string, termId string, relationId string) ApiSitesTermStoresGroupsSetsChildrenRelationsGetRefSetRequest {
	return ApiSitesTermStoresGroupsSetsChildrenRelationsGetRefSetRequest{
		ApiService: a,
		ctx: ctx,
		siteId: siteId,
		storeId: storeId,
		groupId: groupId,
		setId: setId,
		termId: termId,
		relationId: relationId,
	}
}

// Execute executes the request
//  @return string
func (a *SitesStoreApiService) SitesTermStoresGroupsSetsChildrenRelationsGetRefSetExecute(r ApiSitesTermStoresGroupsSetsChildrenRelationsGetRefSetRequest) (string, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  string
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SitesStoreApiService.SitesTermStoresGroupsSetsChildrenRelationsGetRefSet")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sites/{site-id}/termStores/{store-id}/groups/{group-id}/sets/{set-id}/children/{term-id}/relations/{relation-id}/set/$ref"
	localVarPath = strings.Replace(localVarPath, "{"+"site-id"+"}", _neturl.PathEscape(parameterToString(r.siteId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"store-id"+"}", _neturl.PathEscape(parameterToString(r.storeId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"set-id"+"}", _neturl.PathEscape(parameterToString(r.setId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"term-id"+"}", _neturl.PathEscape(parameterToString(r.termId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"relation-id"+"}", _neturl.PathEscape(parameterToString(r.relationId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSitesTermStoresGroupsSetsChildrenRelationsGetRefToTermRequest struct {
	ctx _context.Context
	ApiService *SitesStoreApiService
	siteId string
	storeId string
	groupId string
	setId string
	termId string
	relationId string
}


func (r ApiSitesTermStoresGroupsSetsChildrenRelationsGetRefToTermRequest) Execute() (string, *_nethttp.Response, error) {
	return r.ApiService.SitesTermStoresGroupsSetsChildrenRelationsGetRefToTermExecute(r)
}

/*
SitesTermStoresGroupsSetsChildrenRelationsGetRefToTerm Get ref of toTerm from sites

The to [term] of the relation. The term to which the relationship is defined.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param siteId key: id of site
 @param storeId key: id of store
 @param groupId key: id of group
 @param setId key: id of set
 @param termId key: id of term
 @param relationId key: id of relation
 @return ApiSitesTermStoresGroupsSetsChildrenRelationsGetRefToTermRequest
*/
func (a *SitesStoreApiService) SitesTermStoresGroupsSetsChildrenRelationsGetRefToTerm(ctx _context.Context, siteId string, storeId string, groupId string, setId string, termId string, relationId string) ApiSitesTermStoresGroupsSetsChildrenRelationsGetRefToTermRequest {
	return ApiSitesTermStoresGroupsSetsChildrenRelationsGetRefToTermRequest{
		ApiService: a,
		ctx: ctx,
		siteId: siteId,
		storeId: storeId,
		groupId: groupId,
		setId: setId,
		termId: termId,
		relationId: relationId,
	}
}

// Execute executes the request
//  @return string
func (a *SitesStoreApiService) SitesTermStoresGroupsSetsChildrenRelationsGetRefToTermExecute(r ApiSitesTermStoresGroupsSetsChildrenRelationsGetRefToTermRequest) (string, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  string
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SitesStoreApiService.SitesTermStoresGroupsSetsChildrenRelationsGetRefToTerm")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sites/{site-id}/termStores/{store-id}/groups/{group-id}/sets/{set-id}/children/{term-id}/relations/{relation-id}/toTerm/$ref"
	localVarPath = strings.Replace(localVarPath, "{"+"site-id"+"}", _neturl.PathEscape(parameterToString(r.siteId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"store-id"+"}", _neturl.PathEscape(parameterToString(r.storeId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"set-id"+"}", _neturl.PathEscape(parameterToString(r.setId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"term-id"+"}", _neturl.PathEscape(parameterToString(r.termId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"relation-id"+"}", _neturl.PathEscape(parameterToString(r.relationId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSitesTermStoresGroupsSetsChildrenRelationsGetSetRequest struct {
	ctx _context.Context
	ApiService *SitesStoreApiService
	siteId string
	storeId string
	groupId string
	setId string
	termId string
	relationId string
	select_ *[]string
	expand *[]string
}

// Select properties to be returned
func (r ApiSitesTermStoresGroupsSetsChildrenRelationsGetSetRequest) Select_(select_ []string) ApiSitesTermStoresGroupsSetsChildrenRelationsGetSetRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiSitesTermStoresGroupsSetsChildrenRelationsGetSetRequest) Expand(expand []string) ApiSitesTermStoresGroupsSetsChildrenRelationsGetSetRequest {
	r.expand = &expand
	return r
}

func (r ApiSitesTermStoresGroupsSetsChildrenRelationsGetSetRequest) Execute() (MicrosoftGraphTermStoreSet, *_nethttp.Response, error) {
	return r.ApiService.SitesTermStoresGroupsSetsChildrenRelationsGetSetExecute(r)
}

/*
SitesTermStoresGroupsSetsChildrenRelationsGetSet Get set from sites

The [set] in which the relation is relevant.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param siteId key: id of site
 @param storeId key: id of store
 @param groupId key: id of group
 @param setId key: id of set
 @param termId key: id of term
 @param relationId key: id of relation
 @return ApiSitesTermStoresGroupsSetsChildrenRelationsGetSetRequest
*/
func (a *SitesStoreApiService) SitesTermStoresGroupsSetsChildrenRelationsGetSet(ctx _context.Context, siteId string, storeId string, groupId string, setId string, termId string, relationId string) ApiSitesTermStoresGroupsSetsChildrenRelationsGetSetRequest {
	return ApiSitesTermStoresGroupsSetsChildrenRelationsGetSetRequest{
		ApiService: a,
		ctx: ctx,
		siteId: siteId,
		storeId: storeId,
		groupId: groupId,
		setId: setId,
		termId: termId,
		relationId: relationId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphTermStoreSet
func (a *SitesStoreApiService) SitesTermStoresGroupsSetsChildrenRelationsGetSetExecute(r ApiSitesTermStoresGroupsSetsChildrenRelationsGetSetRequest) (MicrosoftGraphTermStoreSet, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphTermStoreSet
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SitesStoreApiService.SitesTermStoresGroupsSetsChildrenRelationsGetSet")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sites/{site-id}/termStores/{store-id}/groups/{group-id}/sets/{set-id}/children/{term-id}/relations/{relation-id}/set"
	localVarPath = strings.Replace(localVarPath, "{"+"site-id"+"}", _neturl.PathEscape(parameterToString(r.siteId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"store-id"+"}", _neturl.PathEscape(parameterToString(r.storeId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"set-id"+"}", _neturl.PathEscape(parameterToString(r.setId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"term-id"+"}", _neturl.PathEscape(parameterToString(r.termId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"relation-id"+"}", _neturl.PathEscape(parameterToString(r.relationId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSitesTermStoresGroupsSetsChildrenRelationsGetToTermRequest struct {
	ctx _context.Context
	ApiService *SitesStoreApiService
	siteId string
	storeId string
	groupId string
	setId string
	termId string
	relationId string
	select_ *[]string
	expand *[]string
}

// Select properties to be returned
func (r ApiSitesTermStoresGroupsSetsChildrenRelationsGetToTermRequest) Select_(select_ []string) ApiSitesTermStoresGroupsSetsChildrenRelationsGetToTermRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiSitesTermStoresGroupsSetsChildrenRelationsGetToTermRequest) Expand(expand []string) ApiSitesTermStoresGroupsSetsChildrenRelationsGetToTermRequest {
	r.expand = &expand
	return r
}

func (r ApiSitesTermStoresGroupsSetsChildrenRelationsGetToTermRequest) Execute() (MicrosoftGraphTermStoreTerm, *_nethttp.Response, error) {
	return r.ApiService.SitesTermStoresGroupsSetsChildrenRelationsGetToTermExecute(r)
}

/*
SitesTermStoresGroupsSetsChildrenRelationsGetToTerm Get toTerm from sites

The to [term] of the relation. The term to which the relationship is defined.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param siteId key: id of site
 @param storeId key: id of store
 @param groupId key: id of group
 @param setId key: id of set
 @param termId key: id of term
 @param relationId key: id of relation
 @return ApiSitesTermStoresGroupsSetsChildrenRelationsGetToTermRequest
*/
func (a *SitesStoreApiService) SitesTermStoresGroupsSetsChildrenRelationsGetToTerm(ctx _context.Context, siteId string, storeId string, groupId string, setId string, termId string, relationId string) ApiSitesTermStoresGroupsSetsChildrenRelationsGetToTermRequest {
	return ApiSitesTermStoresGroupsSetsChildrenRelationsGetToTermRequest{
		ApiService: a,
		ctx: ctx,
		siteId: siteId,
		storeId: storeId,
		groupId: groupId,
		setId: setId,
		termId: termId,
		relationId: relationId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphTermStoreTerm
func (a *SitesStoreApiService) SitesTermStoresGroupsSetsChildrenRelationsGetToTermExecute(r ApiSitesTermStoresGroupsSetsChildrenRelationsGetToTermRequest) (MicrosoftGraphTermStoreTerm, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphTermStoreTerm
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SitesStoreApiService.SitesTermStoresGroupsSetsChildrenRelationsGetToTerm")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sites/{site-id}/termStores/{store-id}/groups/{group-id}/sets/{set-id}/children/{term-id}/relations/{relation-id}/toTerm"
	localVarPath = strings.Replace(localVarPath, "{"+"site-id"+"}", _neturl.PathEscape(parameterToString(r.siteId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"store-id"+"}", _neturl.PathEscape(parameterToString(r.storeId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"set-id"+"}", _neturl.PathEscape(parameterToString(r.setId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"term-id"+"}", _neturl.PathEscape(parameterToString(r.termId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"relation-id"+"}", _neturl.PathEscape(parameterToString(r.relationId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSitesTermStoresGroupsSetsChildrenRelationsUpdateRefFromTermRequest struct {
	ctx _context.Context
	ApiService *SitesStoreApiService
	siteId string
	storeId string
	groupId string
	setId string
	termId string
	relationId string
	requestBody *map[string]map[string]interface{}
}

// New navigation property ref values
func (r ApiSitesTermStoresGroupsSetsChildrenRelationsUpdateRefFromTermRequest) RequestBody(requestBody map[string]map[string]interface{}) ApiSitesTermStoresGroupsSetsChildrenRelationsUpdateRefFromTermRequest {
	r.requestBody = &requestBody
	return r
}

func (r ApiSitesTermStoresGroupsSetsChildrenRelationsUpdateRefFromTermRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.SitesTermStoresGroupsSetsChildrenRelationsUpdateRefFromTermExecute(r)
}

/*
SitesTermStoresGroupsSetsChildrenRelationsUpdateRefFromTerm Update the ref of navigation property fromTerm in sites

The from [term] of the relation. The term from which the relationship is defined. A null value would indicate the relation is directly with the [set].

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param siteId key: id of site
 @param storeId key: id of store
 @param groupId key: id of group
 @param setId key: id of set
 @param termId key: id of term
 @param relationId key: id of relation
 @return ApiSitesTermStoresGroupsSetsChildrenRelationsUpdateRefFromTermRequest
*/
func (a *SitesStoreApiService) SitesTermStoresGroupsSetsChildrenRelationsUpdateRefFromTerm(ctx _context.Context, siteId string, storeId string, groupId string, setId string, termId string, relationId string) ApiSitesTermStoresGroupsSetsChildrenRelationsUpdateRefFromTermRequest {
	return ApiSitesTermStoresGroupsSetsChildrenRelationsUpdateRefFromTermRequest{
		ApiService: a,
		ctx: ctx,
		siteId: siteId,
		storeId: storeId,
		groupId: groupId,
		setId: setId,
		termId: termId,
		relationId: relationId,
	}
}

// Execute executes the request
func (a *SitesStoreApiService) SitesTermStoresGroupsSetsChildrenRelationsUpdateRefFromTermExecute(r ApiSitesTermStoresGroupsSetsChildrenRelationsUpdateRefFromTermRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPut
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SitesStoreApiService.SitesTermStoresGroupsSetsChildrenRelationsUpdateRefFromTerm")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sites/{site-id}/termStores/{store-id}/groups/{group-id}/sets/{set-id}/children/{term-id}/relations/{relation-id}/fromTerm/$ref"
	localVarPath = strings.Replace(localVarPath, "{"+"site-id"+"}", _neturl.PathEscape(parameterToString(r.siteId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"store-id"+"}", _neturl.PathEscape(parameterToString(r.storeId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"set-id"+"}", _neturl.PathEscape(parameterToString(r.setId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"term-id"+"}", _neturl.PathEscape(parameterToString(r.termId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"relation-id"+"}", _neturl.PathEscape(parameterToString(r.relationId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.requestBody == nil {
		return nil, reportError("requestBody is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.requestBody
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiSitesTermStoresGroupsSetsChildrenRelationsUpdateRefSetRequest struct {
	ctx _context.Context
	ApiService *SitesStoreApiService
	siteId string
	storeId string
	groupId string
	setId string
	termId string
	relationId string
	requestBody *map[string]map[string]interface{}
}

// New navigation property ref values
func (r ApiSitesTermStoresGroupsSetsChildrenRelationsUpdateRefSetRequest) RequestBody(requestBody map[string]map[string]interface{}) ApiSitesTermStoresGroupsSetsChildrenRelationsUpdateRefSetRequest {
	r.requestBody = &requestBody
	return r
}

func (r ApiSitesTermStoresGroupsSetsChildrenRelationsUpdateRefSetRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.SitesTermStoresGroupsSetsChildrenRelationsUpdateRefSetExecute(r)
}

/*
SitesTermStoresGroupsSetsChildrenRelationsUpdateRefSet Update the ref of navigation property set in sites

The [set] in which the relation is relevant.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param siteId key: id of site
 @param storeId key: id of store
 @param groupId key: id of group
 @param setId key: id of set
 @param termId key: id of term
 @param relationId key: id of relation
 @return ApiSitesTermStoresGroupsSetsChildrenRelationsUpdateRefSetRequest
*/
func (a *SitesStoreApiService) SitesTermStoresGroupsSetsChildrenRelationsUpdateRefSet(ctx _context.Context, siteId string, storeId string, groupId string, setId string, termId string, relationId string) ApiSitesTermStoresGroupsSetsChildrenRelationsUpdateRefSetRequest {
	return ApiSitesTermStoresGroupsSetsChildrenRelationsUpdateRefSetRequest{
		ApiService: a,
		ctx: ctx,
		siteId: siteId,
		storeId: storeId,
		groupId: groupId,
		setId: setId,
		termId: termId,
		relationId: relationId,
	}
}

// Execute executes the request
func (a *SitesStoreApiService) SitesTermStoresGroupsSetsChildrenRelationsUpdateRefSetExecute(r ApiSitesTermStoresGroupsSetsChildrenRelationsUpdateRefSetRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPut
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SitesStoreApiService.SitesTermStoresGroupsSetsChildrenRelationsUpdateRefSet")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sites/{site-id}/termStores/{store-id}/groups/{group-id}/sets/{set-id}/children/{term-id}/relations/{relation-id}/set/$ref"
	localVarPath = strings.Replace(localVarPath, "{"+"site-id"+"}", _neturl.PathEscape(parameterToString(r.siteId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"store-id"+"}", _neturl.PathEscape(parameterToString(r.storeId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"set-id"+"}", _neturl.PathEscape(parameterToString(r.setId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"term-id"+"}", _neturl.PathEscape(parameterToString(r.termId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"relation-id"+"}", _neturl.PathEscape(parameterToString(r.relationId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.requestBody == nil {
		return nil, reportError("requestBody is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.requestBody
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiSitesTermStoresGroupsSetsChildrenRelationsUpdateRefToTermRequest struct {
	ctx _context.Context
	ApiService *SitesStoreApiService
	siteId string
	storeId string
	groupId string
	setId string
	termId string
	relationId string
	requestBody *map[string]map[string]interface{}
}

// New navigation property ref values
func (r ApiSitesTermStoresGroupsSetsChildrenRelationsUpdateRefToTermRequest) RequestBody(requestBody map[string]map[string]interface{}) ApiSitesTermStoresGroupsSetsChildrenRelationsUpdateRefToTermRequest {
	r.requestBody = &requestBody
	return r
}

func (r ApiSitesTermStoresGroupsSetsChildrenRelationsUpdateRefToTermRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.SitesTermStoresGroupsSetsChildrenRelationsUpdateRefToTermExecute(r)
}

/*
SitesTermStoresGroupsSetsChildrenRelationsUpdateRefToTerm Update the ref of navigation property toTerm in sites

The to [term] of the relation. The term to which the relationship is defined.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param siteId key: id of site
 @param storeId key: id of store
 @param groupId key: id of group
 @param setId key: id of set
 @param termId key: id of term
 @param relationId key: id of relation
 @return ApiSitesTermStoresGroupsSetsChildrenRelationsUpdateRefToTermRequest
*/
func (a *SitesStoreApiService) SitesTermStoresGroupsSetsChildrenRelationsUpdateRefToTerm(ctx _context.Context, siteId string, storeId string, groupId string, setId string, termId string, relationId string) ApiSitesTermStoresGroupsSetsChildrenRelationsUpdateRefToTermRequest {
	return ApiSitesTermStoresGroupsSetsChildrenRelationsUpdateRefToTermRequest{
		ApiService: a,
		ctx: ctx,
		siteId: siteId,
		storeId: storeId,
		groupId: groupId,
		setId: setId,
		termId: termId,
		relationId: relationId,
	}
}

// Execute executes the request
func (a *SitesStoreApiService) SitesTermStoresGroupsSetsChildrenRelationsUpdateRefToTermExecute(r ApiSitesTermStoresGroupsSetsChildrenRelationsUpdateRefToTermRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPut
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SitesStoreApiService.SitesTermStoresGroupsSetsChildrenRelationsUpdateRefToTerm")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sites/{site-id}/termStores/{store-id}/groups/{group-id}/sets/{set-id}/children/{term-id}/relations/{relation-id}/toTerm/$ref"
	localVarPath = strings.Replace(localVarPath, "{"+"site-id"+"}", _neturl.PathEscape(parameterToString(r.siteId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"store-id"+"}", _neturl.PathEscape(parameterToString(r.storeId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"set-id"+"}", _neturl.PathEscape(parameterToString(r.setId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"term-id"+"}", _neturl.PathEscape(parameterToString(r.termId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"relation-id"+"}", _neturl.PathEscape(parameterToString(r.relationId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.requestBody == nil {
		return nil, reportError("requestBody is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.requestBody
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiSitesTermStoresGroupsSetsChildrenUpdateChildrenRequest struct {
	ctx _context.Context
	ApiService *SitesStoreApiService
	siteId string
	storeId string
	groupId string
	setId string
	termId string
	termId1 string
	microsoftGraphTermStoreTerm *MicrosoftGraphTermStoreTerm
}

// New navigation property values
func (r ApiSitesTermStoresGroupsSetsChildrenUpdateChildrenRequest) MicrosoftGraphTermStoreTerm(microsoftGraphTermStoreTerm MicrosoftGraphTermStoreTerm) ApiSitesTermStoresGroupsSetsChildrenUpdateChildrenRequest {
	r.microsoftGraphTermStoreTerm = &microsoftGraphTermStoreTerm
	return r
}

func (r ApiSitesTermStoresGroupsSetsChildrenUpdateChildrenRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.SitesTermStoresGroupsSetsChildrenUpdateChildrenExecute(r)
}

/*
SitesTermStoresGroupsSetsChildrenUpdateChildren Update the navigation property children in sites

Children of current term.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param siteId key: id of site
 @param storeId key: id of store
 @param groupId key: id of group
 @param setId key: id of set
 @param termId key: id of term
 @param termId1 key: id of term
 @return ApiSitesTermStoresGroupsSetsChildrenUpdateChildrenRequest
*/
func (a *SitesStoreApiService) SitesTermStoresGroupsSetsChildrenUpdateChildren(ctx _context.Context, siteId string, storeId string, groupId string, setId string, termId string, termId1 string) ApiSitesTermStoresGroupsSetsChildrenUpdateChildrenRequest {
	return ApiSitesTermStoresGroupsSetsChildrenUpdateChildrenRequest{
		ApiService: a,
		ctx: ctx,
		siteId: siteId,
		storeId: storeId,
		groupId: groupId,
		setId: setId,
		termId: termId,
		termId1: termId1,
	}
}

// Execute executes the request
func (a *SitesStoreApiService) SitesTermStoresGroupsSetsChildrenUpdateChildrenExecute(r ApiSitesTermStoresGroupsSetsChildrenUpdateChildrenRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPatch
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SitesStoreApiService.SitesTermStoresGroupsSetsChildrenUpdateChildren")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sites/{site-id}/termStores/{store-id}/groups/{group-id}/sets/{set-id}/children/{term-id}/children/{term-id1}"
	localVarPath = strings.Replace(localVarPath, "{"+"site-id"+"}", _neturl.PathEscape(parameterToString(r.siteId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"store-id"+"}", _neturl.PathEscape(parameterToString(r.storeId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"set-id"+"}", _neturl.PathEscape(parameterToString(r.setId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"term-id"+"}", _neturl.PathEscape(parameterToString(r.termId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"term-id1"+"}", _neturl.PathEscape(parameterToString(r.termId1, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphTermStoreTerm == nil {
		return nil, reportError("microsoftGraphTermStoreTerm is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphTermStoreTerm
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiSitesTermStoresGroupsSetsChildrenUpdateRefSetRequest struct {
	ctx _context.Context
	ApiService *SitesStoreApiService
	siteId string
	storeId string
	groupId string
	setId string
	termId string
	requestBody *map[string]map[string]interface{}
}

// New navigation property ref values
func (r ApiSitesTermStoresGroupsSetsChildrenUpdateRefSetRequest) RequestBody(requestBody map[string]map[string]interface{}) ApiSitesTermStoresGroupsSetsChildrenUpdateRefSetRequest {
	r.requestBody = &requestBody
	return r
}

func (r ApiSitesTermStoresGroupsSetsChildrenUpdateRefSetRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.SitesTermStoresGroupsSetsChildrenUpdateRefSetExecute(r)
}

/*
SitesTermStoresGroupsSetsChildrenUpdateRefSet Update the ref of navigation property set in sites

The [set] in which the term is created.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param siteId key: id of site
 @param storeId key: id of store
 @param groupId key: id of group
 @param setId key: id of set
 @param termId key: id of term
 @return ApiSitesTermStoresGroupsSetsChildrenUpdateRefSetRequest
*/
func (a *SitesStoreApiService) SitesTermStoresGroupsSetsChildrenUpdateRefSet(ctx _context.Context, siteId string, storeId string, groupId string, setId string, termId string) ApiSitesTermStoresGroupsSetsChildrenUpdateRefSetRequest {
	return ApiSitesTermStoresGroupsSetsChildrenUpdateRefSetRequest{
		ApiService: a,
		ctx: ctx,
		siteId: siteId,
		storeId: storeId,
		groupId: groupId,
		setId: setId,
		termId: termId,
	}
}

// Execute executes the request
func (a *SitesStoreApiService) SitesTermStoresGroupsSetsChildrenUpdateRefSetExecute(r ApiSitesTermStoresGroupsSetsChildrenUpdateRefSetRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPut
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SitesStoreApiService.SitesTermStoresGroupsSetsChildrenUpdateRefSet")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sites/{site-id}/termStores/{store-id}/groups/{group-id}/sets/{set-id}/children/{term-id}/set/$ref"
	localVarPath = strings.Replace(localVarPath, "{"+"site-id"+"}", _neturl.PathEscape(parameterToString(r.siteId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"store-id"+"}", _neturl.PathEscape(parameterToString(r.storeId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"set-id"+"}", _neturl.PathEscape(parameterToString(r.setId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"term-id"+"}", _neturl.PathEscape(parameterToString(r.termId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.requestBody == nil {
		return nil, reportError("requestBody is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.requestBody
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiSitesTermStoresGroupsSetsChildrenUpdateRelationsRequest struct {
	ctx _context.Context
	ApiService *SitesStoreApiService
	siteId string
	storeId string
	groupId string
	setId string
	termId string
	relationId string
	microsoftGraphTermStoreRelation *MicrosoftGraphTermStoreRelation
}

// New navigation property values
func (r ApiSitesTermStoresGroupsSetsChildrenUpdateRelationsRequest) MicrosoftGraphTermStoreRelation(microsoftGraphTermStoreRelation MicrosoftGraphTermStoreRelation) ApiSitesTermStoresGroupsSetsChildrenUpdateRelationsRequest {
	r.microsoftGraphTermStoreRelation = &microsoftGraphTermStoreRelation
	return r
}

func (r ApiSitesTermStoresGroupsSetsChildrenUpdateRelationsRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.SitesTermStoresGroupsSetsChildrenUpdateRelationsExecute(r)
}

/*
SitesTermStoresGroupsSetsChildrenUpdateRelations Update the navigation property relations in sites

To indicate which terms are related to the current term as either pinned or reused.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param siteId key: id of site
 @param storeId key: id of store
 @param groupId key: id of group
 @param setId key: id of set
 @param termId key: id of term
 @param relationId key: id of relation
 @return ApiSitesTermStoresGroupsSetsChildrenUpdateRelationsRequest
*/
func (a *SitesStoreApiService) SitesTermStoresGroupsSetsChildrenUpdateRelations(ctx _context.Context, siteId string, storeId string, groupId string, setId string, termId string, relationId string) ApiSitesTermStoresGroupsSetsChildrenUpdateRelationsRequest {
	return ApiSitesTermStoresGroupsSetsChildrenUpdateRelationsRequest{
		ApiService: a,
		ctx: ctx,
		siteId: siteId,
		storeId: storeId,
		groupId: groupId,
		setId: setId,
		termId: termId,
		relationId: relationId,
	}
}

// Execute executes the request
func (a *SitesStoreApiService) SitesTermStoresGroupsSetsChildrenUpdateRelationsExecute(r ApiSitesTermStoresGroupsSetsChildrenUpdateRelationsRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPatch
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SitesStoreApiService.SitesTermStoresGroupsSetsChildrenUpdateRelations")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sites/{site-id}/termStores/{store-id}/groups/{group-id}/sets/{set-id}/children/{term-id}/relations/{relation-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"site-id"+"}", _neturl.PathEscape(parameterToString(r.siteId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"store-id"+"}", _neturl.PathEscape(parameterToString(r.storeId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"set-id"+"}", _neturl.PathEscape(parameterToString(r.setId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"term-id"+"}", _neturl.PathEscape(parameterToString(r.termId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"relation-id"+"}", _neturl.PathEscape(parameterToString(r.relationId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphTermStoreRelation == nil {
		return nil, reportError("microsoftGraphTermStoreRelation is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphTermStoreRelation
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiSitesTermStoresGroupsSetsCreateChildrenRequest struct {
	ctx _context.Context
	ApiService *SitesStoreApiService
	siteId string
	storeId string
	groupId string
	setId string
	microsoftGraphTermStoreTerm *MicrosoftGraphTermStoreTerm
}

// New navigation property
func (r ApiSitesTermStoresGroupsSetsCreateChildrenRequest) MicrosoftGraphTermStoreTerm(microsoftGraphTermStoreTerm MicrosoftGraphTermStoreTerm) ApiSitesTermStoresGroupsSetsCreateChildrenRequest {
	r.microsoftGraphTermStoreTerm = &microsoftGraphTermStoreTerm
	return r
}

func (r ApiSitesTermStoresGroupsSetsCreateChildrenRequest) Execute() (MicrosoftGraphTermStoreTerm, *_nethttp.Response, error) {
	return r.ApiService.SitesTermStoresGroupsSetsCreateChildrenExecute(r)
}

/*
SitesTermStoresGroupsSetsCreateChildren Create new navigation property to children for sites

Children terms of set in term [store].

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param siteId key: id of site
 @param storeId key: id of store
 @param groupId key: id of group
 @param setId key: id of set
 @return ApiSitesTermStoresGroupsSetsCreateChildrenRequest
*/
func (a *SitesStoreApiService) SitesTermStoresGroupsSetsCreateChildren(ctx _context.Context, siteId string, storeId string, groupId string, setId string) ApiSitesTermStoresGroupsSetsCreateChildrenRequest {
	return ApiSitesTermStoresGroupsSetsCreateChildrenRequest{
		ApiService: a,
		ctx: ctx,
		siteId: siteId,
		storeId: storeId,
		groupId: groupId,
		setId: setId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphTermStoreTerm
func (a *SitesStoreApiService) SitesTermStoresGroupsSetsCreateChildrenExecute(r ApiSitesTermStoresGroupsSetsCreateChildrenRequest) (MicrosoftGraphTermStoreTerm, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphTermStoreTerm
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SitesStoreApiService.SitesTermStoresGroupsSetsCreateChildren")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sites/{site-id}/termStores/{store-id}/groups/{group-id}/sets/{set-id}/children"
	localVarPath = strings.Replace(localVarPath, "{"+"site-id"+"}", _neturl.PathEscape(parameterToString(r.siteId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"store-id"+"}", _neturl.PathEscape(parameterToString(r.storeId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"set-id"+"}", _neturl.PathEscape(parameterToString(r.setId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphTermStoreTerm == nil {
		return localVarReturnValue, nil, reportError("microsoftGraphTermStoreTerm is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphTermStoreTerm
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSitesTermStoresGroupsSetsCreateRelationsRequest struct {
	ctx _context.Context
	ApiService *SitesStoreApiService
	siteId string
	storeId string
	groupId string
	setId string
	microsoftGraphTermStoreRelation *MicrosoftGraphTermStoreRelation
}

// New navigation property
func (r ApiSitesTermStoresGroupsSetsCreateRelationsRequest) MicrosoftGraphTermStoreRelation(microsoftGraphTermStoreRelation MicrosoftGraphTermStoreRelation) ApiSitesTermStoresGroupsSetsCreateRelationsRequest {
	r.microsoftGraphTermStoreRelation = &microsoftGraphTermStoreRelation
	return r
}

func (r ApiSitesTermStoresGroupsSetsCreateRelationsRequest) Execute() (MicrosoftGraphTermStoreRelation, *_nethttp.Response, error) {
	return r.ApiService.SitesTermStoresGroupsSetsCreateRelationsExecute(r)
}

/*
SitesTermStoresGroupsSetsCreateRelations Create new navigation property to relations for sites

Indicates which terms have been pinned or reused directly under the set.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param siteId key: id of site
 @param storeId key: id of store
 @param groupId key: id of group
 @param setId key: id of set
 @return ApiSitesTermStoresGroupsSetsCreateRelationsRequest
*/
func (a *SitesStoreApiService) SitesTermStoresGroupsSetsCreateRelations(ctx _context.Context, siteId string, storeId string, groupId string, setId string) ApiSitesTermStoresGroupsSetsCreateRelationsRequest {
	return ApiSitesTermStoresGroupsSetsCreateRelationsRequest{
		ApiService: a,
		ctx: ctx,
		siteId: siteId,
		storeId: storeId,
		groupId: groupId,
		setId: setId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphTermStoreRelation
func (a *SitesStoreApiService) SitesTermStoresGroupsSetsCreateRelationsExecute(r ApiSitesTermStoresGroupsSetsCreateRelationsRequest) (MicrosoftGraphTermStoreRelation, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphTermStoreRelation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SitesStoreApiService.SitesTermStoresGroupsSetsCreateRelations")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sites/{site-id}/termStores/{store-id}/groups/{group-id}/sets/{set-id}/relations"
	localVarPath = strings.Replace(localVarPath, "{"+"site-id"+"}", _neturl.PathEscape(parameterToString(r.siteId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"store-id"+"}", _neturl.PathEscape(parameterToString(r.storeId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"set-id"+"}", _neturl.PathEscape(parameterToString(r.setId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphTermStoreRelation == nil {
		return localVarReturnValue, nil, reportError("microsoftGraphTermStoreRelation is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphTermStoreRelation
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSitesTermStoresGroupsSetsCreateTermsRequest struct {
	ctx _context.Context
	ApiService *SitesStoreApiService
	siteId string
	storeId string
	groupId string
	setId string
	microsoftGraphTermStoreTerm *MicrosoftGraphTermStoreTerm
}

// New navigation property
func (r ApiSitesTermStoresGroupsSetsCreateTermsRequest) MicrosoftGraphTermStoreTerm(microsoftGraphTermStoreTerm MicrosoftGraphTermStoreTerm) ApiSitesTermStoresGroupsSetsCreateTermsRequest {
	r.microsoftGraphTermStoreTerm = &microsoftGraphTermStoreTerm
	return r
}

func (r ApiSitesTermStoresGroupsSetsCreateTermsRequest) Execute() (MicrosoftGraphTermStoreTerm, *_nethttp.Response, error) {
	return r.ApiService.SitesTermStoresGroupsSetsCreateTermsExecute(r)
}

/*
SitesTermStoresGroupsSetsCreateTerms Create new navigation property to terms for sites

All the terms under the set.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param siteId key: id of site
 @param storeId key: id of store
 @param groupId key: id of group
 @param setId key: id of set
 @return ApiSitesTermStoresGroupsSetsCreateTermsRequest
*/
func (a *SitesStoreApiService) SitesTermStoresGroupsSetsCreateTerms(ctx _context.Context, siteId string, storeId string, groupId string, setId string) ApiSitesTermStoresGroupsSetsCreateTermsRequest {
	return ApiSitesTermStoresGroupsSetsCreateTermsRequest{
		ApiService: a,
		ctx: ctx,
		siteId: siteId,
		storeId: storeId,
		groupId: groupId,
		setId: setId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphTermStoreTerm
func (a *SitesStoreApiService) SitesTermStoresGroupsSetsCreateTermsExecute(r ApiSitesTermStoresGroupsSetsCreateTermsRequest) (MicrosoftGraphTermStoreTerm, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphTermStoreTerm
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SitesStoreApiService.SitesTermStoresGroupsSetsCreateTerms")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sites/{site-id}/termStores/{store-id}/groups/{group-id}/sets/{set-id}/terms"
	localVarPath = strings.Replace(localVarPath, "{"+"site-id"+"}", _neturl.PathEscape(parameterToString(r.siteId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"store-id"+"}", _neturl.PathEscape(parameterToString(r.storeId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"set-id"+"}", _neturl.PathEscape(parameterToString(r.setId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphTermStoreTerm == nil {
		return localVarReturnValue, nil, reportError("microsoftGraphTermStoreTerm is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphTermStoreTerm
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSitesTermStoresGroupsSetsDeleteChildrenRequest struct {
	ctx _context.Context
	ApiService *SitesStoreApiService
	siteId string
	storeId string
	groupId string
	setId string
	termId string
	ifMatch *string
}

// ETag
func (r ApiSitesTermStoresGroupsSetsDeleteChildrenRequest) IfMatch(ifMatch string) ApiSitesTermStoresGroupsSetsDeleteChildrenRequest {
	r.ifMatch = &ifMatch
	return r
}

func (r ApiSitesTermStoresGroupsSetsDeleteChildrenRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.SitesTermStoresGroupsSetsDeleteChildrenExecute(r)
}

/*
SitesTermStoresGroupsSetsDeleteChildren Delete navigation property children for sites

Children terms of set in term [store].

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param siteId key: id of site
 @param storeId key: id of store
 @param groupId key: id of group
 @param setId key: id of set
 @param termId key: id of term
 @return ApiSitesTermStoresGroupsSetsDeleteChildrenRequest
*/
func (a *SitesStoreApiService) SitesTermStoresGroupsSetsDeleteChildren(ctx _context.Context, siteId string, storeId string, groupId string, setId string, termId string) ApiSitesTermStoresGroupsSetsDeleteChildrenRequest {
	return ApiSitesTermStoresGroupsSetsDeleteChildrenRequest{
		ApiService: a,
		ctx: ctx,
		siteId: siteId,
		storeId: storeId,
		groupId: groupId,
		setId: setId,
		termId: termId,
	}
}

// Execute executes the request
func (a *SitesStoreApiService) SitesTermStoresGroupsSetsDeleteChildrenExecute(r ApiSitesTermStoresGroupsSetsDeleteChildrenRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SitesStoreApiService.SitesTermStoresGroupsSetsDeleteChildren")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sites/{site-id}/termStores/{store-id}/groups/{group-id}/sets/{set-id}/children/{term-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"site-id"+"}", _neturl.PathEscape(parameterToString(r.siteId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"store-id"+"}", _neturl.PathEscape(parameterToString(r.storeId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"set-id"+"}", _neturl.PathEscape(parameterToString(r.setId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"term-id"+"}", _neturl.PathEscape(parameterToString(r.termId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ifMatch != nil {
		localVarHeaderParams["If-Match"] = parameterToString(*r.ifMatch, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiSitesTermStoresGroupsSetsDeleteParentGroupRequest struct {
	ctx _context.Context
	ApiService *SitesStoreApiService
	siteId string
	storeId string
	groupId string
	setId string
	ifMatch *string
}

// ETag
func (r ApiSitesTermStoresGroupsSetsDeleteParentGroupRequest) IfMatch(ifMatch string) ApiSitesTermStoresGroupsSetsDeleteParentGroupRequest {
	r.ifMatch = &ifMatch
	return r
}

func (r ApiSitesTermStoresGroupsSetsDeleteParentGroupRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.SitesTermStoresGroupsSetsDeleteParentGroupExecute(r)
}

/*
SitesTermStoresGroupsSetsDeleteParentGroup Delete navigation property parentGroup for sites

The parent [group] that contains the set.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param siteId key: id of site
 @param storeId key: id of store
 @param groupId key: id of group
 @param setId key: id of set
 @return ApiSitesTermStoresGroupsSetsDeleteParentGroupRequest
*/
func (a *SitesStoreApiService) SitesTermStoresGroupsSetsDeleteParentGroup(ctx _context.Context, siteId string, storeId string, groupId string, setId string) ApiSitesTermStoresGroupsSetsDeleteParentGroupRequest {
	return ApiSitesTermStoresGroupsSetsDeleteParentGroupRequest{
		ApiService: a,
		ctx: ctx,
		siteId: siteId,
		storeId: storeId,
		groupId: groupId,
		setId: setId,
	}
}

// Execute executes the request
func (a *SitesStoreApiService) SitesTermStoresGroupsSetsDeleteParentGroupExecute(r ApiSitesTermStoresGroupsSetsDeleteParentGroupRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SitesStoreApiService.SitesTermStoresGroupsSetsDeleteParentGroup")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sites/{site-id}/termStores/{store-id}/groups/{group-id}/sets/{set-id}/parentGroup"
	localVarPath = strings.Replace(localVarPath, "{"+"site-id"+"}", _neturl.PathEscape(parameterToString(r.siteId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"store-id"+"}", _neturl.PathEscape(parameterToString(r.storeId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"set-id"+"}", _neturl.PathEscape(parameterToString(r.setId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ifMatch != nil {
		localVarHeaderParams["If-Match"] = parameterToString(*r.ifMatch, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiSitesTermStoresGroupsSetsDeleteRelationsRequest struct {
	ctx _context.Context
	ApiService *SitesStoreApiService
	siteId string
	storeId string
	groupId string
	setId string
	relationId string
	ifMatch *string
}

// ETag
func (r ApiSitesTermStoresGroupsSetsDeleteRelationsRequest) IfMatch(ifMatch string) ApiSitesTermStoresGroupsSetsDeleteRelationsRequest {
	r.ifMatch = &ifMatch
	return r
}

func (r ApiSitesTermStoresGroupsSetsDeleteRelationsRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.SitesTermStoresGroupsSetsDeleteRelationsExecute(r)
}

/*
SitesTermStoresGroupsSetsDeleteRelations Delete navigation property relations for sites

Indicates which terms have been pinned or reused directly under the set.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param siteId key: id of site
 @param storeId key: id of store
 @param groupId key: id of group
 @param setId key: id of set
 @param relationId key: id of relation
 @return ApiSitesTermStoresGroupsSetsDeleteRelationsRequest
*/
func (a *SitesStoreApiService) SitesTermStoresGroupsSetsDeleteRelations(ctx _context.Context, siteId string, storeId string, groupId string, setId string, relationId string) ApiSitesTermStoresGroupsSetsDeleteRelationsRequest {
	return ApiSitesTermStoresGroupsSetsDeleteRelationsRequest{
		ApiService: a,
		ctx: ctx,
		siteId: siteId,
		storeId: storeId,
		groupId: groupId,
		setId: setId,
		relationId: relationId,
	}
}

// Execute executes the request
func (a *SitesStoreApiService) SitesTermStoresGroupsSetsDeleteRelationsExecute(r ApiSitesTermStoresGroupsSetsDeleteRelationsRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SitesStoreApiService.SitesTermStoresGroupsSetsDeleteRelations")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sites/{site-id}/termStores/{store-id}/groups/{group-id}/sets/{set-id}/relations/{relation-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"site-id"+"}", _neturl.PathEscape(parameterToString(r.siteId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"store-id"+"}", _neturl.PathEscape(parameterToString(r.storeId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"set-id"+"}", _neturl.PathEscape(parameterToString(r.setId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"relation-id"+"}", _neturl.PathEscape(parameterToString(r.relationId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ifMatch != nil {
		localVarHeaderParams["If-Match"] = parameterToString(*r.ifMatch, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiSitesTermStoresGroupsSetsDeleteTermsRequest struct {
	ctx _context.Context
	ApiService *SitesStoreApiService
	siteId string
	storeId string
	groupId string
	setId string
	termId string
	ifMatch *string
}

// ETag
func (r ApiSitesTermStoresGroupsSetsDeleteTermsRequest) IfMatch(ifMatch string) ApiSitesTermStoresGroupsSetsDeleteTermsRequest {
	r.ifMatch = &ifMatch
	return r
}

func (r ApiSitesTermStoresGroupsSetsDeleteTermsRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.SitesTermStoresGroupsSetsDeleteTermsExecute(r)
}

/*
SitesTermStoresGroupsSetsDeleteTerms Delete navigation property terms for sites

All the terms under the set.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param siteId key: id of site
 @param storeId key: id of store
 @param groupId key: id of group
 @param setId key: id of set
 @param termId key: id of term
 @return ApiSitesTermStoresGroupsSetsDeleteTermsRequest
*/
func (a *SitesStoreApiService) SitesTermStoresGroupsSetsDeleteTerms(ctx _context.Context, siteId string, storeId string, groupId string, setId string, termId string) ApiSitesTermStoresGroupsSetsDeleteTermsRequest {
	return ApiSitesTermStoresGroupsSetsDeleteTermsRequest{
		ApiService: a,
		ctx: ctx,
		siteId: siteId,
		storeId: storeId,
		groupId: groupId,
		setId: setId,
		termId: termId,
	}
}

// Execute executes the request
func (a *SitesStoreApiService) SitesTermStoresGroupsSetsDeleteTermsExecute(r ApiSitesTermStoresGroupsSetsDeleteTermsRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SitesStoreApiService.SitesTermStoresGroupsSetsDeleteTerms")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sites/{site-id}/termStores/{store-id}/groups/{group-id}/sets/{set-id}/terms/{term-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"site-id"+"}", _neturl.PathEscape(parameterToString(r.siteId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"store-id"+"}", _neturl.PathEscape(parameterToString(r.storeId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"set-id"+"}", _neturl.PathEscape(parameterToString(r.setId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"term-id"+"}", _neturl.PathEscape(parameterToString(r.termId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ifMatch != nil {
		localVarHeaderParams["If-Match"] = parameterToString(*r.ifMatch, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiSitesTermStoresGroupsSetsGetChildrenRequest struct {
	ctx _context.Context
	ApiService *SitesStoreApiService
	siteId string
	storeId string
	groupId string
	setId string
	termId string
	select_ *[]string
	expand *[]string
}

// Select properties to be returned
func (r ApiSitesTermStoresGroupsSetsGetChildrenRequest) Select_(select_ []string) ApiSitesTermStoresGroupsSetsGetChildrenRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiSitesTermStoresGroupsSetsGetChildrenRequest) Expand(expand []string) ApiSitesTermStoresGroupsSetsGetChildrenRequest {
	r.expand = &expand
	return r
}

func (r ApiSitesTermStoresGroupsSetsGetChildrenRequest) Execute() (MicrosoftGraphTermStoreTerm, *_nethttp.Response, error) {
	return r.ApiService.SitesTermStoresGroupsSetsGetChildrenExecute(r)
}

/*
SitesTermStoresGroupsSetsGetChildren Get children from sites

Children terms of set in term [store].

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param siteId key: id of site
 @param storeId key: id of store
 @param groupId key: id of group
 @param setId key: id of set
 @param termId key: id of term
 @return ApiSitesTermStoresGroupsSetsGetChildrenRequest
*/
func (a *SitesStoreApiService) SitesTermStoresGroupsSetsGetChildren(ctx _context.Context, siteId string, storeId string, groupId string, setId string, termId string) ApiSitesTermStoresGroupsSetsGetChildrenRequest {
	return ApiSitesTermStoresGroupsSetsGetChildrenRequest{
		ApiService: a,
		ctx: ctx,
		siteId: siteId,
		storeId: storeId,
		groupId: groupId,
		setId: setId,
		termId: termId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphTermStoreTerm
func (a *SitesStoreApiService) SitesTermStoresGroupsSetsGetChildrenExecute(r ApiSitesTermStoresGroupsSetsGetChildrenRequest) (MicrosoftGraphTermStoreTerm, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphTermStoreTerm
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SitesStoreApiService.SitesTermStoresGroupsSetsGetChildren")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sites/{site-id}/termStores/{store-id}/groups/{group-id}/sets/{set-id}/children/{term-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"site-id"+"}", _neturl.PathEscape(parameterToString(r.siteId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"store-id"+"}", _neturl.PathEscape(parameterToString(r.storeId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"set-id"+"}", _neturl.PathEscape(parameterToString(r.setId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"term-id"+"}", _neturl.PathEscape(parameterToString(r.termId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSitesTermStoresGroupsSetsGetParentGroupRequest struct {
	ctx _context.Context
	ApiService *SitesStoreApiService
	siteId string
	storeId string
	groupId string
	setId string
	select_ *[]string
	expand *[]string
}

// Select properties to be returned
func (r ApiSitesTermStoresGroupsSetsGetParentGroupRequest) Select_(select_ []string) ApiSitesTermStoresGroupsSetsGetParentGroupRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiSitesTermStoresGroupsSetsGetParentGroupRequest) Expand(expand []string) ApiSitesTermStoresGroupsSetsGetParentGroupRequest {
	r.expand = &expand
	return r
}

func (r ApiSitesTermStoresGroupsSetsGetParentGroupRequest) Execute() (MicrosoftGraphTermStoreGroup, *_nethttp.Response, error) {
	return r.ApiService.SitesTermStoresGroupsSetsGetParentGroupExecute(r)
}

/*
SitesTermStoresGroupsSetsGetParentGroup Get parentGroup from sites

The parent [group] that contains the set.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param siteId key: id of site
 @param storeId key: id of store
 @param groupId key: id of group
 @param setId key: id of set
 @return ApiSitesTermStoresGroupsSetsGetParentGroupRequest
*/
func (a *SitesStoreApiService) SitesTermStoresGroupsSetsGetParentGroup(ctx _context.Context, siteId string, storeId string, groupId string, setId string) ApiSitesTermStoresGroupsSetsGetParentGroupRequest {
	return ApiSitesTermStoresGroupsSetsGetParentGroupRequest{
		ApiService: a,
		ctx: ctx,
		siteId: siteId,
		storeId: storeId,
		groupId: groupId,
		setId: setId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphTermStoreGroup
func (a *SitesStoreApiService) SitesTermStoresGroupsSetsGetParentGroupExecute(r ApiSitesTermStoresGroupsSetsGetParentGroupRequest) (MicrosoftGraphTermStoreGroup, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphTermStoreGroup
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SitesStoreApiService.SitesTermStoresGroupsSetsGetParentGroup")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sites/{site-id}/termStores/{store-id}/groups/{group-id}/sets/{set-id}/parentGroup"
	localVarPath = strings.Replace(localVarPath, "{"+"site-id"+"}", _neturl.PathEscape(parameterToString(r.siteId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"store-id"+"}", _neturl.PathEscape(parameterToString(r.storeId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"set-id"+"}", _neturl.PathEscape(parameterToString(r.setId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSitesTermStoresGroupsSetsGetRelationsRequest struct {
	ctx _context.Context
	ApiService *SitesStoreApiService
	siteId string
	storeId string
	groupId string
	setId string
	relationId string
	select_ *[]string
	expand *[]string
}

// Select properties to be returned
func (r ApiSitesTermStoresGroupsSetsGetRelationsRequest) Select_(select_ []string) ApiSitesTermStoresGroupsSetsGetRelationsRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiSitesTermStoresGroupsSetsGetRelationsRequest) Expand(expand []string) ApiSitesTermStoresGroupsSetsGetRelationsRequest {
	r.expand = &expand
	return r
}

func (r ApiSitesTermStoresGroupsSetsGetRelationsRequest) Execute() (MicrosoftGraphTermStoreRelation, *_nethttp.Response, error) {
	return r.ApiService.SitesTermStoresGroupsSetsGetRelationsExecute(r)
}

/*
SitesTermStoresGroupsSetsGetRelations Get relations from sites

Indicates which terms have been pinned or reused directly under the set.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param siteId key: id of site
 @param storeId key: id of store
 @param groupId key: id of group
 @param setId key: id of set
 @param relationId key: id of relation
 @return ApiSitesTermStoresGroupsSetsGetRelationsRequest
*/
func (a *SitesStoreApiService) SitesTermStoresGroupsSetsGetRelations(ctx _context.Context, siteId string, storeId string, groupId string, setId string, relationId string) ApiSitesTermStoresGroupsSetsGetRelationsRequest {
	return ApiSitesTermStoresGroupsSetsGetRelationsRequest{
		ApiService: a,
		ctx: ctx,
		siteId: siteId,
		storeId: storeId,
		groupId: groupId,
		setId: setId,
		relationId: relationId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphTermStoreRelation
func (a *SitesStoreApiService) SitesTermStoresGroupsSetsGetRelationsExecute(r ApiSitesTermStoresGroupsSetsGetRelationsRequest) (MicrosoftGraphTermStoreRelation, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphTermStoreRelation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SitesStoreApiService.SitesTermStoresGroupsSetsGetRelations")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sites/{site-id}/termStores/{store-id}/groups/{group-id}/sets/{set-id}/relations/{relation-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"site-id"+"}", _neturl.PathEscape(parameterToString(r.siteId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"store-id"+"}", _neturl.PathEscape(parameterToString(r.storeId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"set-id"+"}", _neturl.PathEscape(parameterToString(r.setId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"relation-id"+"}", _neturl.PathEscape(parameterToString(r.relationId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSitesTermStoresGroupsSetsGetTermsRequest struct {
	ctx _context.Context
	ApiService *SitesStoreApiService
	siteId string
	storeId string
	groupId string
	setId string
	termId string
	select_ *[]string
	expand *[]string
}

// Select properties to be returned
func (r ApiSitesTermStoresGroupsSetsGetTermsRequest) Select_(select_ []string) ApiSitesTermStoresGroupsSetsGetTermsRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiSitesTermStoresGroupsSetsGetTermsRequest) Expand(expand []string) ApiSitesTermStoresGroupsSetsGetTermsRequest {
	r.expand = &expand
	return r
}

func (r ApiSitesTermStoresGroupsSetsGetTermsRequest) Execute() (MicrosoftGraphTermStoreTerm, *_nethttp.Response, error) {
	return r.ApiService.SitesTermStoresGroupsSetsGetTermsExecute(r)
}

/*
SitesTermStoresGroupsSetsGetTerms Get terms from sites

All the terms under the set.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param siteId key: id of site
 @param storeId key: id of store
 @param groupId key: id of group
 @param setId key: id of set
 @param termId key: id of term
 @return ApiSitesTermStoresGroupsSetsGetTermsRequest
*/
func (a *SitesStoreApiService) SitesTermStoresGroupsSetsGetTerms(ctx _context.Context, siteId string, storeId string, groupId string, setId string, termId string) ApiSitesTermStoresGroupsSetsGetTermsRequest {
	return ApiSitesTermStoresGroupsSetsGetTermsRequest{
		ApiService: a,
		ctx: ctx,
		siteId: siteId,
		storeId: storeId,
		groupId: groupId,
		setId: setId,
		termId: termId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphTermStoreTerm
func (a *SitesStoreApiService) SitesTermStoresGroupsSetsGetTermsExecute(r ApiSitesTermStoresGroupsSetsGetTermsRequest) (MicrosoftGraphTermStoreTerm, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphTermStoreTerm
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SitesStoreApiService.SitesTermStoresGroupsSetsGetTerms")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sites/{site-id}/termStores/{store-id}/groups/{group-id}/sets/{set-id}/terms/{term-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"site-id"+"}", _neturl.PathEscape(parameterToString(r.siteId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"store-id"+"}", _neturl.PathEscape(parameterToString(r.storeId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"set-id"+"}", _neturl.PathEscape(parameterToString(r.setId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"term-id"+"}", _neturl.PathEscape(parameterToString(r.termId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSitesTermStoresGroupsSetsListChildrenRequest struct {
	ctx _context.Context
	ApiService *SitesStoreApiService
	siteId string
	storeId string
	groupId string
	setId string
	top *int32
	skip *int32
	search *string
	filter *string
	count *bool
	orderby *[]string
	select_ *[]string
	expand *[]string
}

// Show only the first n items
func (r ApiSitesTermStoresGroupsSetsListChildrenRequest) Top(top int32) ApiSitesTermStoresGroupsSetsListChildrenRequest {
	r.top = &top
	return r
}
// Skip the first n items
func (r ApiSitesTermStoresGroupsSetsListChildrenRequest) Skip(skip int32) ApiSitesTermStoresGroupsSetsListChildrenRequest {
	r.skip = &skip
	return r
}
// Search items by search phrases
func (r ApiSitesTermStoresGroupsSetsListChildrenRequest) Search(search string) ApiSitesTermStoresGroupsSetsListChildrenRequest {
	r.search = &search
	return r
}
// Filter items by property values
func (r ApiSitesTermStoresGroupsSetsListChildrenRequest) Filter(filter string) ApiSitesTermStoresGroupsSetsListChildrenRequest {
	r.filter = &filter
	return r
}
// Include count of items
func (r ApiSitesTermStoresGroupsSetsListChildrenRequest) Count(count bool) ApiSitesTermStoresGroupsSetsListChildrenRequest {
	r.count = &count
	return r
}
// Order items by property values
func (r ApiSitesTermStoresGroupsSetsListChildrenRequest) Orderby(orderby []string) ApiSitesTermStoresGroupsSetsListChildrenRequest {
	r.orderby = &orderby
	return r
}
// Select properties to be returned
func (r ApiSitesTermStoresGroupsSetsListChildrenRequest) Select_(select_ []string) ApiSitesTermStoresGroupsSetsListChildrenRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiSitesTermStoresGroupsSetsListChildrenRequest) Expand(expand []string) ApiSitesTermStoresGroupsSetsListChildrenRequest {
	r.expand = &expand
	return r
}

func (r ApiSitesTermStoresGroupsSetsListChildrenRequest) Execute() (CollectionOfTerm, *_nethttp.Response, error) {
	return r.ApiService.SitesTermStoresGroupsSetsListChildrenExecute(r)
}

/*
SitesTermStoresGroupsSetsListChildren Get children from sites

Children terms of set in term [store].

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param siteId key: id of site
 @param storeId key: id of store
 @param groupId key: id of group
 @param setId key: id of set
 @return ApiSitesTermStoresGroupsSetsListChildrenRequest
*/
func (a *SitesStoreApiService) SitesTermStoresGroupsSetsListChildren(ctx _context.Context, siteId string, storeId string, groupId string, setId string) ApiSitesTermStoresGroupsSetsListChildrenRequest {
	return ApiSitesTermStoresGroupsSetsListChildrenRequest{
		ApiService: a,
		ctx: ctx,
		siteId: siteId,
		storeId: storeId,
		groupId: groupId,
		setId: setId,
	}
}

// Execute executes the request
//  @return CollectionOfTerm
func (a *SitesStoreApiService) SitesTermStoresGroupsSetsListChildrenExecute(r ApiSitesTermStoresGroupsSetsListChildrenRequest) (CollectionOfTerm, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  CollectionOfTerm
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SitesStoreApiService.SitesTermStoresGroupsSetsListChildren")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sites/{site-id}/termStores/{store-id}/groups/{group-id}/sets/{set-id}/children"
	localVarPath = strings.Replace(localVarPath, "{"+"site-id"+"}", _neturl.PathEscape(parameterToString(r.siteId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"store-id"+"}", _neturl.PathEscape(parameterToString(r.storeId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"set-id"+"}", _neturl.PathEscape(parameterToString(r.setId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.top != nil {
		localVarQueryParams.Add("$top", parameterToString(*r.top, ""))
	}
	if r.skip != nil {
		localVarQueryParams.Add("$skip", parameterToString(*r.skip, ""))
	}
	if r.search != nil {
		localVarQueryParams.Add("$search", parameterToString(*r.search, ""))
	}
	if r.filter != nil {
		localVarQueryParams.Add("$filter", parameterToString(*r.filter, ""))
	}
	if r.count != nil {
		localVarQueryParams.Add("$count", parameterToString(*r.count, ""))
	}
	if r.orderby != nil {
		localVarQueryParams.Add("$orderby", parameterToString(*r.orderby, "csv"))
	}
	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSitesTermStoresGroupsSetsListRelationsRequest struct {
	ctx _context.Context
	ApiService *SitesStoreApiService
	siteId string
	storeId string
	groupId string
	setId string
	top *int32
	skip *int32
	search *string
	filter *string
	count *bool
	orderby *[]string
	select_ *[]string
	expand *[]string
}

// Show only the first n items
func (r ApiSitesTermStoresGroupsSetsListRelationsRequest) Top(top int32) ApiSitesTermStoresGroupsSetsListRelationsRequest {
	r.top = &top
	return r
}
// Skip the first n items
func (r ApiSitesTermStoresGroupsSetsListRelationsRequest) Skip(skip int32) ApiSitesTermStoresGroupsSetsListRelationsRequest {
	r.skip = &skip
	return r
}
// Search items by search phrases
func (r ApiSitesTermStoresGroupsSetsListRelationsRequest) Search(search string) ApiSitesTermStoresGroupsSetsListRelationsRequest {
	r.search = &search
	return r
}
// Filter items by property values
func (r ApiSitesTermStoresGroupsSetsListRelationsRequest) Filter(filter string) ApiSitesTermStoresGroupsSetsListRelationsRequest {
	r.filter = &filter
	return r
}
// Include count of items
func (r ApiSitesTermStoresGroupsSetsListRelationsRequest) Count(count bool) ApiSitesTermStoresGroupsSetsListRelationsRequest {
	r.count = &count
	return r
}
// Order items by property values
func (r ApiSitesTermStoresGroupsSetsListRelationsRequest) Orderby(orderby []string) ApiSitesTermStoresGroupsSetsListRelationsRequest {
	r.orderby = &orderby
	return r
}
// Select properties to be returned
func (r ApiSitesTermStoresGroupsSetsListRelationsRequest) Select_(select_ []string) ApiSitesTermStoresGroupsSetsListRelationsRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiSitesTermStoresGroupsSetsListRelationsRequest) Expand(expand []string) ApiSitesTermStoresGroupsSetsListRelationsRequest {
	r.expand = &expand
	return r
}

func (r ApiSitesTermStoresGroupsSetsListRelationsRequest) Execute() (CollectionOfRelation, *_nethttp.Response, error) {
	return r.ApiService.SitesTermStoresGroupsSetsListRelationsExecute(r)
}

/*
SitesTermStoresGroupsSetsListRelations Get relations from sites

Indicates which terms have been pinned or reused directly under the set.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param siteId key: id of site
 @param storeId key: id of store
 @param groupId key: id of group
 @param setId key: id of set
 @return ApiSitesTermStoresGroupsSetsListRelationsRequest
*/
func (a *SitesStoreApiService) SitesTermStoresGroupsSetsListRelations(ctx _context.Context, siteId string, storeId string, groupId string, setId string) ApiSitesTermStoresGroupsSetsListRelationsRequest {
	return ApiSitesTermStoresGroupsSetsListRelationsRequest{
		ApiService: a,
		ctx: ctx,
		siteId: siteId,
		storeId: storeId,
		groupId: groupId,
		setId: setId,
	}
}

// Execute executes the request
//  @return CollectionOfRelation
func (a *SitesStoreApiService) SitesTermStoresGroupsSetsListRelationsExecute(r ApiSitesTermStoresGroupsSetsListRelationsRequest) (CollectionOfRelation, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  CollectionOfRelation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SitesStoreApiService.SitesTermStoresGroupsSetsListRelations")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sites/{site-id}/termStores/{store-id}/groups/{group-id}/sets/{set-id}/relations"
	localVarPath = strings.Replace(localVarPath, "{"+"site-id"+"}", _neturl.PathEscape(parameterToString(r.siteId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"store-id"+"}", _neturl.PathEscape(parameterToString(r.storeId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"set-id"+"}", _neturl.PathEscape(parameterToString(r.setId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.top != nil {
		localVarQueryParams.Add("$top", parameterToString(*r.top, ""))
	}
	if r.skip != nil {
		localVarQueryParams.Add("$skip", parameterToString(*r.skip, ""))
	}
	if r.search != nil {
		localVarQueryParams.Add("$search", parameterToString(*r.search, ""))
	}
	if r.filter != nil {
		localVarQueryParams.Add("$filter", parameterToString(*r.filter, ""))
	}
	if r.count != nil {
		localVarQueryParams.Add("$count", parameterToString(*r.count, ""))
	}
	if r.orderby != nil {
		localVarQueryParams.Add("$orderby", parameterToString(*r.orderby, "csv"))
	}
	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSitesTermStoresGroupsSetsListTermsRequest struct {
	ctx _context.Context
	ApiService *SitesStoreApiService
	siteId string
	storeId string
	groupId string
	setId string
	top *int32
	skip *int32
	search *string
	filter *string
	count *bool
	orderby *[]string
	select_ *[]string
	expand *[]string
}

// Show only the first n items
func (r ApiSitesTermStoresGroupsSetsListTermsRequest) Top(top int32) ApiSitesTermStoresGroupsSetsListTermsRequest {
	r.top = &top
	return r
}
// Skip the first n items
func (r ApiSitesTermStoresGroupsSetsListTermsRequest) Skip(skip int32) ApiSitesTermStoresGroupsSetsListTermsRequest {
	r.skip = &skip
	return r
}
// Search items by search phrases
func (r ApiSitesTermStoresGroupsSetsListTermsRequest) Search(search string) ApiSitesTermStoresGroupsSetsListTermsRequest {
	r.search = &search
	return r
}
// Filter items by property values
func (r ApiSitesTermStoresGroupsSetsListTermsRequest) Filter(filter string) ApiSitesTermStoresGroupsSetsListTermsRequest {
	r.filter = &filter
	return r
}
// Include count of items
func (r ApiSitesTermStoresGroupsSetsListTermsRequest) Count(count bool) ApiSitesTermStoresGroupsSetsListTermsRequest {
	r.count = &count
	return r
}
// Order items by property values
func (r ApiSitesTermStoresGroupsSetsListTermsRequest) Orderby(orderby []string) ApiSitesTermStoresGroupsSetsListTermsRequest {
	r.orderby = &orderby
	return r
}
// Select properties to be returned
func (r ApiSitesTermStoresGroupsSetsListTermsRequest) Select_(select_ []string) ApiSitesTermStoresGroupsSetsListTermsRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiSitesTermStoresGroupsSetsListTermsRequest) Expand(expand []string) ApiSitesTermStoresGroupsSetsListTermsRequest {
	r.expand = &expand
	return r
}

func (r ApiSitesTermStoresGroupsSetsListTermsRequest) Execute() (CollectionOfTerm, *_nethttp.Response, error) {
	return r.ApiService.SitesTermStoresGroupsSetsListTermsExecute(r)
}

/*
SitesTermStoresGroupsSetsListTerms Get terms from sites

All the terms under the set.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param siteId key: id of site
 @param storeId key: id of store
 @param groupId key: id of group
 @param setId key: id of set
 @return ApiSitesTermStoresGroupsSetsListTermsRequest
*/
func (a *SitesStoreApiService) SitesTermStoresGroupsSetsListTerms(ctx _context.Context, siteId string, storeId string, groupId string, setId string) ApiSitesTermStoresGroupsSetsListTermsRequest {
	return ApiSitesTermStoresGroupsSetsListTermsRequest{
		ApiService: a,
		ctx: ctx,
		siteId: siteId,
		storeId: storeId,
		groupId: groupId,
		setId: setId,
	}
}

// Execute executes the request
//  @return CollectionOfTerm
func (a *SitesStoreApiService) SitesTermStoresGroupsSetsListTermsExecute(r ApiSitesTermStoresGroupsSetsListTermsRequest) (CollectionOfTerm, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  CollectionOfTerm
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SitesStoreApiService.SitesTermStoresGroupsSetsListTerms")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sites/{site-id}/termStores/{store-id}/groups/{group-id}/sets/{set-id}/terms"
	localVarPath = strings.Replace(localVarPath, "{"+"site-id"+"}", _neturl.PathEscape(parameterToString(r.siteId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"store-id"+"}", _neturl.PathEscape(parameterToString(r.storeId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"set-id"+"}", _neturl.PathEscape(parameterToString(r.setId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.top != nil {
		localVarQueryParams.Add("$top", parameterToString(*r.top, ""))
	}
	if r.skip != nil {
		localVarQueryParams.Add("$skip", parameterToString(*r.skip, ""))
	}
	if r.search != nil {
		localVarQueryParams.Add("$search", parameterToString(*r.search, ""))
	}
	if r.filter != nil {
		localVarQueryParams.Add("$filter", parameterToString(*r.filter, ""))
	}
	if r.count != nil {
		localVarQueryParams.Add("$count", parameterToString(*r.count, ""))
	}
	if r.orderby != nil {
		localVarQueryParams.Add("$orderby", parameterToString(*r.orderby, "csv"))
	}
	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSitesTermStoresGroupsSetsRelationsDeleteRefFromTermRequest struct {
	ctx _context.Context
	ApiService *SitesStoreApiService
	siteId string
	storeId string
	groupId string
	setId string
	relationId string
	ifMatch *string
}

// ETag
func (r ApiSitesTermStoresGroupsSetsRelationsDeleteRefFromTermRequest) IfMatch(ifMatch string) ApiSitesTermStoresGroupsSetsRelationsDeleteRefFromTermRequest {
	r.ifMatch = &ifMatch
	return r
}

func (r ApiSitesTermStoresGroupsSetsRelationsDeleteRefFromTermRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.SitesTermStoresGroupsSetsRelationsDeleteRefFromTermExecute(r)
}

/*
SitesTermStoresGroupsSetsRelationsDeleteRefFromTerm Delete ref of navigation property fromTerm for sites

The from [term] of the relation. The term from which the relationship is defined. A null value would indicate the relation is directly with the [set].

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param siteId key: id of site
 @param storeId key: id of store
 @param groupId key: id of group
 @param setId key: id of set
 @param relationId key: id of relation
 @return ApiSitesTermStoresGroupsSetsRelationsDeleteRefFromTermRequest
*/
func (a *SitesStoreApiService) SitesTermStoresGroupsSetsRelationsDeleteRefFromTerm(ctx _context.Context, siteId string, storeId string, groupId string, setId string, relationId string) ApiSitesTermStoresGroupsSetsRelationsDeleteRefFromTermRequest {
	return ApiSitesTermStoresGroupsSetsRelationsDeleteRefFromTermRequest{
		ApiService: a,
		ctx: ctx,
		siteId: siteId,
		storeId: storeId,
		groupId: groupId,
		setId: setId,
		relationId: relationId,
	}
}

// Execute executes the request
func (a *SitesStoreApiService) SitesTermStoresGroupsSetsRelationsDeleteRefFromTermExecute(r ApiSitesTermStoresGroupsSetsRelationsDeleteRefFromTermRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SitesStoreApiService.SitesTermStoresGroupsSetsRelationsDeleteRefFromTerm")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sites/{site-id}/termStores/{store-id}/groups/{group-id}/sets/{set-id}/relations/{relation-id}/fromTerm/$ref"
	localVarPath = strings.Replace(localVarPath, "{"+"site-id"+"}", _neturl.PathEscape(parameterToString(r.siteId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"store-id"+"}", _neturl.PathEscape(parameterToString(r.storeId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"set-id"+"}", _neturl.PathEscape(parameterToString(r.setId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"relation-id"+"}", _neturl.PathEscape(parameterToString(r.relationId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ifMatch != nil {
		localVarHeaderParams["If-Match"] = parameterToString(*r.ifMatch, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiSitesTermStoresGroupsSetsRelationsDeleteRefSetRequest struct {
	ctx _context.Context
	ApiService *SitesStoreApiService
	siteId string
	storeId string
	groupId string
	setId string
	relationId string
	ifMatch *string
}

// ETag
func (r ApiSitesTermStoresGroupsSetsRelationsDeleteRefSetRequest) IfMatch(ifMatch string) ApiSitesTermStoresGroupsSetsRelationsDeleteRefSetRequest {
	r.ifMatch = &ifMatch
	return r
}

func (r ApiSitesTermStoresGroupsSetsRelationsDeleteRefSetRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.SitesTermStoresGroupsSetsRelationsDeleteRefSetExecute(r)
}

/*
SitesTermStoresGroupsSetsRelationsDeleteRefSet Delete ref of navigation property set for sites

The [set] in which the relation is relevant.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param siteId key: id of site
 @param storeId key: id of store
 @param groupId key: id of group
 @param setId key: id of set
 @param relationId key: id of relation
 @return ApiSitesTermStoresGroupsSetsRelationsDeleteRefSetRequest
*/
func (a *SitesStoreApiService) SitesTermStoresGroupsSetsRelationsDeleteRefSet(ctx _context.Context, siteId string, storeId string, groupId string, setId string, relationId string) ApiSitesTermStoresGroupsSetsRelationsDeleteRefSetRequest {
	return ApiSitesTermStoresGroupsSetsRelationsDeleteRefSetRequest{
		ApiService: a,
		ctx: ctx,
		siteId: siteId,
		storeId: storeId,
		groupId: groupId,
		setId: setId,
		relationId: relationId,
	}
}

// Execute executes the request
func (a *SitesStoreApiService) SitesTermStoresGroupsSetsRelationsDeleteRefSetExecute(r ApiSitesTermStoresGroupsSetsRelationsDeleteRefSetRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SitesStoreApiService.SitesTermStoresGroupsSetsRelationsDeleteRefSet")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sites/{site-id}/termStores/{store-id}/groups/{group-id}/sets/{set-id}/relations/{relation-id}/set/$ref"
	localVarPath = strings.Replace(localVarPath, "{"+"site-id"+"}", _neturl.PathEscape(parameterToString(r.siteId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"store-id"+"}", _neturl.PathEscape(parameterToString(r.storeId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"set-id"+"}", _neturl.PathEscape(parameterToString(r.setId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"relation-id"+"}", _neturl.PathEscape(parameterToString(r.relationId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ifMatch != nil {
		localVarHeaderParams["If-Match"] = parameterToString(*r.ifMatch, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiSitesTermStoresGroupsSetsRelationsDeleteRefToTermRequest struct {
	ctx _context.Context
	ApiService *SitesStoreApiService
	siteId string
	storeId string
	groupId string
	setId string
	relationId string
	ifMatch *string
}

// ETag
func (r ApiSitesTermStoresGroupsSetsRelationsDeleteRefToTermRequest) IfMatch(ifMatch string) ApiSitesTermStoresGroupsSetsRelationsDeleteRefToTermRequest {
	r.ifMatch = &ifMatch
	return r
}

func (r ApiSitesTermStoresGroupsSetsRelationsDeleteRefToTermRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.SitesTermStoresGroupsSetsRelationsDeleteRefToTermExecute(r)
}

/*
SitesTermStoresGroupsSetsRelationsDeleteRefToTerm Delete ref of navigation property toTerm for sites

The to [term] of the relation. The term to which the relationship is defined.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param siteId key: id of site
 @param storeId key: id of store
 @param groupId key: id of group
 @param setId key: id of set
 @param relationId key: id of relation
 @return ApiSitesTermStoresGroupsSetsRelationsDeleteRefToTermRequest
*/
func (a *SitesStoreApiService) SitesTermStoresGroupsSetsRelationsDeleteRefToTerm(ctx _context.Context, siteId string, storeId string, groupId string, setId string, relationId string) ApiSitesTermStoresGroupsSetsRelationsDeleteRefToTermRequest {
	return ApiSitesTermStoresGroupsSetsRelationsDeleteRefToTermRequest{
		ApiService: a,
		ctx: ctx,
		siteId: siteId,
		storeId: storeId,
		groupId: groupId,
		setId: setId,
		relationId: relationId,
	}
}

// Execute executes the request
func (a *SitesStoreApiService) SitesTermStoresGroupsSetsRelationsDeleteRefToTermExecute(r ApiSitesTermStoresGroupsSetsRelationsDeleteRefToTermRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SitesStoreApiService.SitesTermStoresGroupsSetsRelationsDeleteRefToTerm")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sites/{site-id}/termStores/{store-id}/groups/{group-id}/sets/{set-id}/relations/{relation-id}/toTerm/$ref"
	localVarPath = strings.Replace(localVarPath, "{"+"site-id"+"}", _neturl.PathEscape(parameterToString(r.siteId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"store-id"+"}", _neturl.PathEscape(parameterToString(r.storeId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"set-id"+"}", _neturl.PathEscape(parameterToString(r.setId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"relation-id"+"}", _neturl.PathEscape(parameterToString(r.relationId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ifMatch != nil {
		localVarHeaderParams["If-Match"] = parameterToString(*r.ifMatch, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiSitesTermStoresGroupsSetsRelationsGetFromTermRequest struct {
	ctx _context.Context
	ApiService *SitesStoreApiService
	siteId string
	storeId string
	groupId string
	setId string
	relationId string
	select_ *[]string
	expand *[]string
}

// Select properties to be returned
func (r ApiSitesTermStoresGroupsSetsRelationsGetFromTermRequest) Select_(select_ []string) ApiSitesTermStoresGroupsSetsRelationsGetFromTermRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiSitesTermStoresGroupsSetsRelationsGetFromTermRequest) Expand(expand []string) ApiSitesTermStoresGroupsSetsRelationsGetFromTermRequest {
	r.expand = &expand
	return r
}

func (r ApiSitesTermStoresGroupsSetsRelationsGetFromTermRequest) Execute() (MicrosoftGraphTermStoreTerm, *_nethttp.Response, error) {
	return r.ApiService.SitesTermStoresGroupsSetsRelationsGetFromTermExecute(r)
}

/*
SitesTermStoresGroupsSetsRelationsGetFromTerm Get fromTerm from sites

The from [term] of the relation. The term from which the relationship is defined. A null value would indicate the relation is directly with the [set].

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param siteId key: id of site
 @param storeId key: id of store
 @param groupId key: id of group
 @param setId key: id of set
 @param relationId key: id of relation
 @return ApiSitesTermStoresGroupsSetsRelationsGetFromTermRequest
*/
func (a *SitesStoreApiService) SitesTermStoresGroupsSetsRelationsGetFromTerm(ctx _context.Context, siteId string, storeId string, groupId string, setId string, relationId string) ApiSitesTermStoresGroupsSetsRelationsGetFromTermRequest {
	return ApiSitesTermStoresGroupsSetsRelationsGetFromTermRequest{
		ApiService: a,
		ctx: ctx,
		siteId: siteId,
		storeId: storeId,
		groupId: groupId,
		setId: setId,
		relationId: relationId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphTermStoreTerm
func (a *SitesStoreApiService) SitesTermStoresGroupsSetsRelationsGetFromTermExecute(r ApiSitesTermStoresGroupsSetsRelationsGetFromTermRequest) (MicrosoftGraphTermStoreTerm, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphTermStoreTerm
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SitesStoreApiService.SitesTermStoresGroupsSetsRelationsGetFromTerm")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sites/{site-id}/termStores/{store-id}/groups/{group-id}/sets/{set-id}/relations/{relation-id}/fromTerm"
	localVarPath = strings.Replace(localVarPath, "{"+"site-id"+"}", _neturl.PathEscape(parameterToString(r.siteId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"store-id"+"}", _neturl.PathEscape(parameterToString(r.storeId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"set-id"+"}", _neturl.PathEscape(parameterToString(r.setId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"relation-id"+"}", _neturl.PathEscape(parameterToString(r.relationId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSitesTermStoresGroupsSetsRelationsGetRefFromTermRequest struct {
	ctx _context.Context
	ApiService *SitesStoreApiService
	siteId string
	storeId string
	groupId string
	setId string
	relationId string
}


func (r ApiSitesTermStoresGroupsSetsRelationsGetRefFromTermRequest) Execute() (string, *_nethttp.Response, error) {
	return r.ApiService.SitesTermStoresGroupsSetsRelationsGetRefFromTermExecute(r)
}

/*
SitesTermStoresGroupsSetsRelationsGetRefFromTerm Get ref of fromTerm from sites

The from [term] of the relation. The term from which the relationship is defined. A null value would indicate the relation is directly with the [set].

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param siteId key: id of site
 @param storeId key: id of store
 @param groupId key: id of group
 @param setId key: id of set
 @param relationId key: id of relation
 @return ApiSitesTermStoresGroupsSetsRelationsGetRefFromTermRequest
*/
func (a *SitesStoreApiService) SitesTermStoresGroupsSetsRelationsGetRefFromTerm(ctx _context.Context, siteId string, storeId string, groupId string, setId string, relationId string) ApiSitesTermStoresGroupsSetsRelationsGetRefFromTermRequest {
	return ApiSitesTermStoresGroupsSetsRelationsGetRefFromTermRequest{
		ApiService: a,
		ctx: ctx,
		siteId: siteId,
		storeId: storeId,
		groupId: groupId,
		setId: setId,
		relationId: relationId,
	}
}

// Execute executes the request
//  @return string
func (a *SitesStoreApiService) SitesTermStoresGroupsSetsRelationsGetRefFromTermExecute(r ApiSitesTermStoresGroupsSetsRelationsGetRefFromTermRequest) (string, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  string
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SitesStoreApiService.SitesTermStoresGroupsSetsRelationsGetRefFromTerm")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sites/{site-id}/termStores/{store-id}/groups/{group-id}/sets/{set-id}/relations/{relation-id}/fromTerm/$ref"
	localVarPath = strings.Replace(localVarPath, "{"+"site-id"+"}", _neturl.PathEscape(parameterToString(r.siteId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"store-id"+"}", _neturl.PathEscape(parameterToString(r.storeId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"set-id"+"}", _neturl.PathEscape(parameterToString(r.setId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"relation-id"+"}", _neturl.PathEscape(parameterToString(r.relationId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSitesTermStoresGroupsSetsRelationsGetRefSetRequest struct {
	ctx _context.Context
	ApiService *SitesStoreApiService
	siteId string
	storeId string
	groupId string
	setId string
	relationId string
}


func (r ApiSitesTermStoresGroupsSetsRelationsGetRefSetRequest) Execute() (string, *_nethttp.Response, error) {
	return r.ApiService.SitesTermStoresGroupsSetsRelationsGetRefSetExecute(r)
}

/*
SitesTermStoresGroupsSetsRelationsGetRefSet Get ref of set from sites

The [set] in which the relation is relevant.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param siteId key: id of site
 @param storeId key: id of store
 @param groupId key: id of group
 @param setId key: id of set
 @param relationId key: id of relation
 @return ApiSitesTermStoresGroupsSetsRelationsGetRefSetRequest
*/
func (a *SitesStoreApiService) SitesTermStoresGroupsSetsRelationsGetRefSet(ctx _context.Context, siteId string, storeId string, groupId string, setId string, relationId string) ApiSitesTermStoresGroupsSetsRelationsGetRefSetRequest {
	return ApiSitesTermStoresGroupsSetsRelationsGetRefSetRequest{
		ApiService: a,
		ctx: ctx,
		siteId: siteId,
		storeId: storeId,
		groupId: groupId,
		setId: setId,
		relationId: relationId,
	}
}

// Execute executes the request
//  @return string
func (a *SitesStoreApiService) SitesTermStoresGroupsSetsRelationsGetRefSetExecute(r ApiSitesTermStoresGroupsSetsRelationsGetRefSetRequest) (string, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  string
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SitesStoreApiService.SitesTermStoresGroupsSetsRelationsGetRefSet")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sites/{site-id}/termStores/{store-id}/groups/{group-id}/sets/{set-id}/relations/{relation-id}/set/$ref"
	localVarPath = strings.Replace(localVarPath, "{"+"site-id"+"}", _neturl.PathEscape(parameterToString(r.siteId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"store-id"+"}", _neturl.PathEscape(parameterToString(r.storeId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"set-id"+"}", _neturl.PathEscape(parameterToString(r.setId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"relation-id"+"}", _neturl.PathEscape(parameterToString(r.relationId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSitesTermStoresGroupsSetsRelationsGetRefToTermRequest struct {
	ctx _context.Context
	ApiService *SitesStoreApiService
	siteId string
	storeId string
	groupId string
	setId string
	relationId string
}


func (r ApiSitesTermStoresGroupsSetsRelationsGetRefToTermRequest) Execute() (string, *_nethttp.Response, error) {
	return r.ApiService.SitesTermStoresGroupsSetsRelationsGetRefToTermExecute(r)
}

/*
SitesTermStoresGroupsSetsRelationsGetRefToTerm Get ref of toTerm from sites

The to [term] of the relation. The term to which the relationship is defined.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param siteId key: id of site
 @param storeId key: id of store
 @param groupId key: id of group
 @param setId key: id of set
 @param relationId key: id of relation
 @return ApiSitesTermStoresGroupsSetsRelationsGetRefToTermRequest
*/
func (a *SitesStoreApiService) SitesTermStoresGroupsSetsRelationsGetRefToTerm(ctx _context.Context, siteId string, storeId string, groupId string, setId string, relationId string) ApiSitesTermStoresGroupsSetsRelationsGetRefToTermRequest {
	return ApiSitesTermStoresGroupsSetsRelationsGetRefToTermRequest{
		ApiService: a,
		ctx: ctx,
		siteId: siteId,
		storeId: storeId,
		groupId: groupId,
		setId: setId,
		relationId: relationId,
	}
}

// Execute executes the request
//  @return string
func (a *SitesStoreApiService) SitesTermStoresGroupsSetsRelationsGetRefToTermExecute(r ApiSitesTermStoresGroupsSetsRelationsGetRefToTermRequest) (string, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  string
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SitesStoreApiService.SitesTermStoresGroupsSetsRelationsGetRefToTerm")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sites/{site-id}/termStores/{store-id}/groups/{group-id}/sets/{set-id}/relations/{relation-id}/toTerm/$ref"
	localVarPath = strings.Replace(localVarPath, "{"+"site-id"+"}", _neturl.PathEscape(parameterToString(r.siteId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"store-id"+"}", _neturl.PathEscape(parameterToString(r.storeId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"set-id"+"}", _neturl.PathEscape(parameterToString(r.setId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"relation-id"+"}", _neturl.PathEscape(parameterToString(r.relationId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSitesTermStoresGroupsSetsRelationsGetSetRequest struct {
	ctx _context.Context
	ApiService *SitesStoreApiService
	siteId string
	storeId string
	groupId string
	setId string
	relationId string
	select_ *[]string
	expand *[]string
}

// Select properties to be returned
func (r ApiSitesTermStoresGroupsSetsRelationsGetSetRequest) Select_(select_ []string) ApiSitesTermStoresGroupsSetsRelationsGetSetRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiSitesTermStoresGroupsSetsRelationsGetSetRequest) Expand(expand []string) ApiSitesTermStoresGroupsSetsRelationsGetSetRequest {
	r.expand = &expand
	return r
}

func (r ApiSitesTermStoresGroupsSetsRelationsGetSetRequest) Execute() (MicrosoftGraphTermStoreSet, *_nethttp.Response, error) {
	return r.ApiService.SitesTermStoresGroupsSetsRelationsGetSetExecute(r)
}

/*
SitesTermStoresGroupsSetsRelationsGetSet Get set from sites

The [set] in which the relation is relevant.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param siteId key: id of site
 @param storeId key: id of store
 @param groupId key: id of group
 @param setId key: id of set
 @param relationId key: id of relation
 @return ApiSitesTermStoresGroupsSetsRelationsGetSetRequest
*/
func (a *SitesStoreApiService) SitesTermStoresGroupsSetsRelationsGetSet(ctx _context.Context, siteId string, storeId string, groupId string, setId string, relationId string) ApiSitesTermStoresGroupsSetsRelationsGetSetRequest {
	return ApiSitesTermStoresGroupsSetsRelationsGetSetRequest{
		ApiService: a,
		ctx: ctx,
		siteId: siteId,
		storeId: storeId,
		groupId: groupId,
		setId: setId,
		relationId: relationId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphTermStoreSet
func (a *SitesStoreApiService) SitesTermStoresGroupsSetsRelationsGetSetExecute(r ApiSitesTermStoresGroupsSetsRelationsGetSetRequest) (MicrosoftGraphTermStoreSet, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphTermStoreSet
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SitesStoreApiService.SitesTermStoresGroupsSetsRelationsGetSet")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sites/{site-id}/termStores/{store-id}/groups/{group-id}/sets/{set-id}/relations/{relation-id}/set"
	localVarPath = strings.Replace(localVarPath, "{"+"site-id"+"}", _neturl.PathEscape(parameterToString(r.siteId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"store-id"+"}", _neturl.PathEscape(parameterToString(r.storeId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"set-id"+"}", _neturl.PathEscape(parameterToString(r.setId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"relation-id"+"}", _neturl.PathEscape(parameterToString(r.relationId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSitesTermStoresGroupsSetsRelationsGetToTermRequest struct {
	ctx _context.Context
	ApiService *SitesStoreApiService
	siteId string
	storeId string
	groupId string
	setId string
	relationId string
	select_ *[]string
	expand *[]string
}

// Select properties to be returned
func (r ApiSitesTermStoresGroupsSetsRelationsGetToTermRequest) Select_(select_ []string) ApiSitesTermStoresGroupsSetsRelationsGetToTermRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiSitesTermStoresGroupsSetsRelationsGetToTermRequest) Expand(expand []string) ApiSitesTermStoresGroupsSetsRelationsGetToTermRequest {
	r.expand = &expand
	return r
}

func (r ApiSitesTermStoresGroupsSetsRelationsGetToTermRequest) Execute() (MicrosoftGraphTermStoreTerm, *_nethttp.Response, error) {
	return r.ApiService.SitesTermStoresGroupsSetsRelationsGetToTermExecute(r)
}

/*
SitesTermStoresGroupsSetsRelationsGetToTerm Get toTerm from sites

The to [term] of the relation. The term to which the relationship is defined.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param siteId key: id of site
 @param storeId key: id of store
 @param groupId key: id of group
 @param setId key: id of set
 @param relationId key: id of relation
 @return ApiSitesTermStoresGroupsSetsRelationsGetToTermRequest
*/
func (a *SitesStoreApiService) SitesTermStoresGroupsSetsRelationsGetToTerm(ctx _context.Context, siteId string, storeId string, groupId string, setId string, relationId string) ApiSitesTermStoresGroupsSetsRelationsGetToTermRequest {
	return ApiSitesTermStoresGroupsSetsRelationsGetToTermRequest{
		ApiService: a,
		ctx: ctx,
		siteId: siteId,
		storeId: storeId,
		groupId: groupId,
		setId: setId,
		relationId: relationId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphTermStoreTerm
func (a *SitesStoreApiService) SitesTermStoresGroupsSetsRelationsGetToTermExecute(r ApiSitesTermStoresGroupsSetsRelationsGetToTermRequest) (MicrosoftGraphTermStoreTerm, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphTermStoreTerm
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SitesStoreApiService.SitesTermStoresGroupsSetsRelationsGetToTerm")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sites/{site-id}/termStores/{store-id}/groups/{group-id}/sets/{set-id}/relations/{relation-id}/toTerm"
	localVarPath = strings.Replace(localVarPath, "{"+"site-id"+"}", _neturl.PathEscape(parameterToString(r.siteId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"store-id"+"}", _neturl.PathEscape(parameterToString(r.storeId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"set-id"+"}", _neturl.PathEscape(parameterToString(r.setId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"relation-id"+"}", _neturl.PathEscape(parameterToString(r.relationId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSitesTermStoresGroupsSetsRelationsUpdateRefFromTermRequest struct {
	ctx _context.Context
	ApiService *SitesStoreApiService
	siteId string
	storeId string
	groupId string
	setId string
	relationId string
	requestBody *map[string]map[string]interface{}
}

// New navigation property ref values
func (r ApiSitesTermStoresGroupsSetsRelationsUpdateRefFromTermRequest) RequestBody(requestBody map[string]map[string]interface{}) ApiSitesTermStoresGroupsSetsRelationsUpdateRefFromTermRequest {
	r.requestBody = &requestBody
	return r
}

func (r ApiSitesTermStoresGroupsSetsRelationsUpdateRefFromTermRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.SitesTermStoresGroupsSetsRelationsUpdateRefFromTermExecute(r)
}

/*
SitesTermStoresGroupsSetsRelationsUpdateRefFromTerm Update the ref of navigation property fromTerm in sites

The from [term] of the relation. The term from which the relationship is defined. A null value would indicate the relation is directly with the [set].

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param siteId key: id of site
 @param storeId key: id of store
 @param groupId key: id of group
 @param setId key: id of set
 @param relationId key: id of relation
 @return ApiSitesTermStoresGroupsSetsRelationsUpdateRefFromTermRequest
*/
func (a *SitesStoreApiService) SitesTermStoresGroupsSetsRelationsUpdateRefFromTerm(ctx _context.Context, siteId string, storeId string, groupId string, setId string, relationId string) ApiSitesTermStoresGroupsSetsRelationsUpdateRefFromTermRequest {
	return ApiSitesTermStoresGroupsSetsRelationsUpdateRefFromTermRequest{
		ApiService: a,
		ctx: ctx,
		siteId: siteId,
		storeId: storeId,
		groupId: groupId,
		setId: setId,
		relationId: relationId,
	}
}

// Execute executes the request
func (a *SitesStoreApiService) SitesTermStoresGroupsSetsRelationsUpdateRefFromTermExecute(r ApiSitesTermStoresGroupsSetsRelationsUpdateRefFromTermRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPut
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SitesStoreApiService.SitesTermStoresGroupsSetsRelationsUpdateRefFromTerm")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sites/{site-id}/termStores/{store-id}/groups/{group-id}/sets/{set-id}/relations/{relation-id}/fromTerm/$ref"
	localVarPath = strings.Replace(localVarPath, "{"+"site-id"+"}", _neturl.PathEscape(parameterToString(r.siteId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"store-id"+"}", _neturl.PathEscape(parameterToString(r.storeId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"set-id"+"}", _neturl.PathEscape(parameterToString(r.setId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"relation-id"+"}", _neturl.PathEscape(parameterToString(r.relationId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.requestBody == nil {
		return nil, reportError("requestBody is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.requestBody
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiSitesTermStoresGroupsSetsRelationsUpdateRefSetRequest struct {
	ctx _context.Context
	ApiService *SitesStoreApiService
	siteId string
	storeId string
	groupId string
	setId string
	relationId string
	requestBody *map[string]map[string]interface{}
}

// New navigation property ref values
func (r ApiSitesTermStoresGroupsSetsRelationsUpdateRefSetRequest) RequestBody(requestBody map[string]map[string]interface{}) ApiSitesTermStoresGroupsSetsRelationsUpdateRefSetRequest {
	r.requestBody = &requestBody
	return r
}

func (r ApiSitesTermStoresGroupsSetsRelationsUpdateRefSetRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.SitesTermStoresGroupsSetsRelationsUpdateRefSetExecute(r)
}

/*
SitesTermStoresGroupsSetsRelationsUpdateRefSet Update the ref of navigation property set in sites

The [set] in which the relation is relevant.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param siteId key: id of site
 @param storeId key: id of store
 @param groupId key: id of group
 @param setId key: id of set
 @param relationId key: id of relation
 @return ApiSitesTermStoresGroupsSetsRelationsUpdateRefSetRequest
*/
func (a *SitesStoreApiService) SitesTermStoresGroupsSetsRelationsUpdateRefSet(ctx _context.Context, siteId string, storeId string, groupId string, setId string, relationId string) ApiSitesTermStoresGroupsSetsRelationsUpdateRefSetRequest {
	return ApiSitesTermStoresGroupsSetsRelationsUpdateRefSetRequest{
		ApiService: a,
		ctx: ctx,
		siteId: siteId,
		storeId: storeId,
		groupId: groupId,
		setId: setId,
		relationId: relationId,
	}
}

// Execute executes the request
func (a *SitesStoreApiService) SitesTermStoresGroupsSetsRelationsUpdateRefSetExecute(r ApiSitesTermStoresGroupsSetsRelationsUpdateRefSetRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPut
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SitesStoreApiService.SitesTermStoresGroupsSetsRelationsUpdateRefSet")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sites/{site-id}/termStores/{store-id}/groups/{group-id}/sets/{set-id}/relations/{relation-id}/set/$ref"
	localVarPath = strings.Replace(localVarPath, "{"+"site-id"+"}", _neturl.PathEscape(parameterToString(r.siteId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"store-id"+"}", _neturl.PathEscape(parameterToString(r.storeId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"set-id"+"}", _neturl.PathEscape(parameterToString(r.setId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"relation-id"+"}", _neturl.PathEscape(parameterToString(r.relationId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.requestBody == nil {
		return nil, reportError("requestBody is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.requestBody
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiSitesTermStoresGroupsSetsRelationsUpdateRefToTermRequest struct {
	ctx _context.Context
	ApiService *SitesStoreApiService
	siteId string
	storeId string
	groupId string
	setId string
	relationId string
	requestBody *map[string]map[string]interface{}
}

// New navigation property ref values
func (r ApiSitesTermStoresGroupsSetsRelationsUpdateRefToTermRequest) RequestBody(requestBody map[string]map[string]interface{}) ApiSitesTermStoresGroupsSetsRelationsUpdateRefToTermRequest {
	r.requestBody = &requestBody
	return r
}

func (r ApiSitesTermStoresGroupsSetsRelationsUpdateRefToTermRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.SitesTermStoresGroupsSetsRelationsUpdateRefToTermExecute(r)
}

/*
SitesTermStoresGroupsSetsRelationsUpdateRefToTerm Update the ref of navigation property toTerm in sites

The to [term] of the relation. The term to which the relationship is defined.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param siteId key: id of site
 @param storeId key: id of store
 @param groupId key: id of group
 @param setId key: id of set
 @param relationId key: id of relation
 @return ApiSitesTermStoresGroupsSetsRelationsUpdateRefToTermRequest
*/
func (a *SitesStoreApiService) SitesTermStoresGroupsSetsRelationsUpdateRefToTerm(ctx _context.Context, siteId string, storeId string, groupId string, setId string, relationId string) ApiSitesTermStoresGroupsSetsRelationsUpdateRefToTermRequest {
	return ApiSitesTermStoresGroupsSetsRelationsUpdateRefToTermRequest{
		ApiService: a,
		ctx: ctx,
		siteId: siteId,
		storeId: storeId,
		groupId: groupId,
		setId: setId,
		relationId: relationId,
	}
}

// Execute executes the request
func (a *SitesStoreApiService) SitesTermStoresGroupsSetsRelationsUpdateRefToTermExecute(r ApiSitesTermStoresGroupsSetsRelationsUpdateRefToTermRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPut
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SitesStoreApiService.SitesTermStoresGroupsSetsRelationsUpdateRefToTerm")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sites/{site-id}/termStores/{store-id}/groups/{group-id}/sets/{set-id}/relations/{relation-id}/toTerm/$ref"
	localVarPath = strings.Replace(localVarPath, "{"+"site-id"+"}", _neturl.PathEscape(parameterToString(r.siteId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"store-id"+"}", _neturl.PathEscape(parameterToString(r.storeId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"set-id"+"}", _neturl.PathEscape(parameterToString(r.setId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"relation-id"+"}", _neturl.PathEscape(parameterToString(r.relationId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.requestBody == nil {
		return nil, reportError("requestBody is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.requestBody
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiSitesTermStoresGroupsSetsTermsCreateChildrenRequest struct {
	ctx _context.Context
	ApiService *SitesStoreApiService
	siteId string
	storeId string
	groupId string
	setId string
	termId string
	microsoftGraphTermStoreTerm *MicrosoftGraphTermStoreTerm
}

// New navigation property
func (r ApiSitesTermStoresGroupsSetsTermsCreateChildrenRequest) MicrosoftGraphTermStoreTerm(microsoftGraphTermStoreTerm MicrosoftGraphTermStoreTerm) ApiSitesTermStoresGroupsSetsTermsCreateChildrenRequest {
	r.microsoftGraphTermStoreTerm = &microsoftGraphTermStoreTerm
	return r
}

func (r ApiSitesTermStoresGroupsSetsTermsCreateChildrenRequest) Execute() (MicrosoftGraphTermStoreTerm, *_nethttp.Response, error) {
	return r.ApiService.SitesTermStoresGroupsSetsTermsCreateChildrenExecute(r)
}

/*
SitesTermStoresGroupsSetsTermsCreateChildren Create new navigation property to children for sites

Children of current term.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param siteId key: id of site
 @param storeId key: id of store
 @param groupId key: id of group
 @param setId key: id of set
 @param termId key: id of term
 @return ApiSitesTermStoresGroupsSetsTermsCreateChildrenRequest
*/
func (a *SitesStoreApiService) SitesTermStoresGroupsSetsTermsCreateChildren(ctx _context.Context, siteId string, storeId string, groupId string, setId string, termId string) ApiSitesTermStoresGroupsSetsTermsCreateChildrenRequest {
	return ApiSitesTermStoresGroupsSetsTermsCreateChildrenRequest{
		ApiService: a,
		ctx: ctx,
		siteId: siteId,
		storeId: storeId,
		groupId: groupId,
		setId: setId,
		termId: termId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphTermStoreTerm
func (a *SitesStoreApiService) SitesTermStoresGroupsSetsTermsCreateChildrenExecute(r ApiSitesTermStoresGroupsSetsTermsCreateChildrenRequest) (MicrosoftGraphTermStoreTerm, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphTermStoreTerm
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SitesStoreApiService.SitesTermStoresGroupsSetsTermsCreateChildren")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sites/{site-id}/termStores/{store-id}/groups/{group-id}/sets/{set-id}/terms/{term-id}/children"
	localVarPath = strings.Replace(localVarPath, "{"+"site-id"+"}", _neturl.PathEscape(parameterToString(r.siteId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"store-id"+"}", _neturl.PathEscape(parameterToString(r.storeId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"set-id"+"}", _neturl.PathEscape(parameterToString(r.setId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"term-id"+"}", _neturl.PathEscape(parameterToString(r.termId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphTermStoreTerm == nil {
		return localVarReturnValue, nil, reportError("microsoftGraphTermStoreTerm is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphTermStoreTerm
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSitesTermStoresGroupsSetsTermsCreateRelationsRequest struct {
	ctx _context.Context
	ApiService *SitesStoreApiService
	siteId string
	storeId string
	groupId string
	setId string
	termId string
	microsoftGraphTermStoreRelation *MicrosoftGraphTermStoreRelation
}

// New navigation property
func (r ApiSitesTermStoresGroupsSetsTermsCreateRelationsRequest) MicrosoftGraphTermStoreRelation(microsoftGraphTermStoreRelation MicrosoftGraphTermStoreRelation) ApiSitesTermStoresGroupsSetsTermsCreateRelationsRequest {
	r.microsoftGraphTermStoreRelation = &microsoftGraphTermStoreRelation
	return r
}

func (r ApiSitesTermStoresGroupsSetsTermsCreateRelationsRequest) Execute() (MicrosoftGraphTermStoreRelation, *_nethttp.Response, error) {
	return r.ApiService.SitesTermStoresGroupsSetsTermsCreateRelationsExecute(r)
}

/*
SitesTermStoresGroupsSetsTermsCreateRelations Create new navigation property to relations for sites

To indicate which terms are related to the current term as either pinned or reused.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param siteId key: id of site
 @param storeId key: id of store
 @param groupId key: id of group
 @param setId key: id of set
 @param termId key: id of term
 @return ApiSitesTermStoresGroupsSetsTermsCreateRelationsRequest
*/
func (a *SitesStoreApiService) SitesTermStoresGroupsSetsTermsCreateRelations(ctx _context.Context, siteId string, storeId string, groupId string, setId string, termId string) ApiSitesTermStoresGroupsSetsTermsCreateRelationsRequest {
	return ApiSitesTermStoresGroupsSetsTermsCreateRelationsRequest{
		ApiService: a,
		ctx: ctx,
		siteId: siteId,
		storeId: storeId,
		groupId: groupId,
		setId: setId,
		termId: termId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphTermStoreRelation
func (a *SitesStoreApiService) SitesTermStoresGroupsSetsTermsCreateRelationsExecute(r ApiSitesTermStoresGroupsSetsTermsCreateRelationsRequest) (MicrosoftGraphTermStoreRelation, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphTermStoreRelation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SitesStoreApiService.SitesTermStoresGroupsSetsTermsCreateRelations")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sites/{site-id}/termStores/{store-id}/groups/{group-id}/sets/{set-id}/terms/{term-id}/relations"
	localVarPath = strings.Replace(localVarPath, "{"+"site-id"+"}", _neturl.PathEscape(parameterToString(r.siteId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"store-id"+"}", _neturl.PathEscape(parameterToString(r.storeId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"set-id"+"}", _neturl.PathEscape(parameterToString(r.setId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"term-id"+"}", _neturl.PathEscape(parameterToString(r.termId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphTermStoreRelation == nil {
		return localVarReturnValue, nil, reportError("microsoftGraphTermStoreRelation is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphTermStoreRelation
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSitesTermStoresGroupsSetsTermsDeleteChildrenRequest struct {
	ctx _context.Context
	ApiService *SitesStoreApiService
	siteId string
	storeId string
	groupId string
	setId string
	termId string
	termId1 string
	ifMatch *string
}

// ETag
func (r ApiSitesTermStoresGroupsSetsTermsDeleteChildrenRequest) IfMatch(ifMatch string) ApiSitesTermStoresGroupsSetsTermsDeleteChildrenRequest {
	r.ifMatch = &ifMatch
	return r
}

func (r ApiSitesTermStoresGroupsSetsTermsDeleteChildrenRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.SitesTermStoresGroupsSetsTermsDeleteChildrenExecute(r)
}

/*
SitesTermStoresGroupsSetsTermsDeleteChildren Delete navigation property children for sites

Children of current term.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param siteId key: id of site
 @param storeId key: id of store
 @param groupId key: id of group
 @param setId key: id of set
 @param termId key: id of term
 @param termId1 key: id of term
 @return ApiSitesTermStoresGroupsSetsTermsDeleteChildrenRequest
*/
func (a *SitesStoreApiService) SitesTermStoresGroupsSetsTermsDeleteChildren(ctx _context.Context, siteId string, storeId string, groupId string, setId string, termId string, termId1 string) ApiSitesTermStoresGroupsSetsTermsDeleteChildrenRequest {
	return ApiSitesTermStoresGroupsSetsTermsDeleteChildrenRequest{
		ApiService: a,
		ctx: ctx,
		siteId: siteId,
		storeId: storeId,
		groupId: groupId,
		setId: setId,
		termId: termId,
		termId1: termId1,
	}
}

// Execute executes the request
func (a *SitesStoreApiService) SitesTermStoresGroupsSetsTermsDeleteChildrenExecute(r ApiSitesTermStoresGroupsSetsTermsDeleteChildrenRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SitesStoreApiService.SitesTermStoresGroupsSetsTermsDeleteChildren")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sites/{site-id}/termStores/{store-id}/groups/{group-id}/sets/{set-id}/terms/{term-id}/children/{term-id1}"
	localVarPath = strings.Replace(localVarPath, "{"+"site-id"+"}", _neturl.PathEscape(parameterToString(r.siteId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"store-id"+"}", _neturl.PathEscape(parameterToString(r.storeId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"set-id"+"}", _neturl.PathEscape(parameterToString(r.setId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"term-id"+"}", _neturl.PathEscape(parameterToString(r.termId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"term-id1"+"}", _neturl.PathEscape(parameterToString(r.termId1, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ifMatch != nil {
		localVarHeaderParams["If-Match"] = parameterToString(*r.ifMatch, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiSitesTermStoresGroupsSetsTermsDeleteRefSetRequest struct {
	ctx _context.Context
	ApiService *SitesStoreApiService
	siteId string
	storeId string
	groupId string
	setId string
	termId string
	ifMatch *string
}

// ETag
func (r ApiSitesTermStoresGroupsSetsTermsDeleteRefSetRequest) IfMatch(ifMatch string) ApiSitesTermStoresGroupsSetsTermsDeleteRefSetRequest {
	r.ifMatch = &ifMatch
	return r
}

func (r ApiSitesTermStoresGroupsSetsTermsDeleteRefSetRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.SitesTermStoresGroupsSetsTermsDeleteRefSetExecute(r)
}

/*
SitesTermStoresGroupsSetsTermsDeleteRefSet Delete ref of navigation property set for sites

The [set] in which the term is created.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param siteId key: id of site
 @param storeId key: id of store
 @param groupId key: id of group
 @param setId key: id of set
 @param termId key: id of term
 @return ApiSitesTermStoresGroupsSetsTermsDeleteRefSetRequest
*/
func (a *SitesStoreApiService) SitesTermStoresGroupsSetsTermsDeleteRefSet(ctx _context.Context, siteId string, storeId string, groupId string, setId string, termId string) ApiSitesTermStoresGroupsSetsTermsDeleteRefSetRequest {
	return ApiSitesTermStoresGroupsSetsTermsDeleteRefSetRequest{
		ApiService: a,
		ctx: ctx,
		siteId: siteId,
		storeId: storeId,
		groupId: groupId,
		setId: setId,
		termId: termId,
	}
}

// Execute executes the request
func (a *SitesStoreApiService) SitesTermStoresGroupsSetsTermsDeleteRefSetExecute(r ApiSitesTermStoresGroupsSetsTermsDeleteRefSetRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SitesStoreApiService.SitesTermStoresGroupsSetsTermsDeleteRefSet")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sites/{site-id}/termStores/{store-id}/groups/{group-id}/sets/{set-id}/terms/{term-id}/set/$ref"
	localVarPath = strings.Replace(localVarPath, "{"+"site-id"+"}", _neturl.PathEscape(parameterToString(r.siteId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"store-id"+"}", _neturl.PathEscape(parameterToString(r.storeId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"set-id"+"}", _neturl.PathEscape(parameterToString(r.setId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"term-id"+"}", _neturl.PathEscape(parameterToString(r.termId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ifMatch != nil {
		localVarHeaderParams["If-Match"] = parameterToString(*r.ifMatch, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiSitesTermStoresGroupsSetsTermsDeleteRelationsRequest struct {
	ctx _context.Context
	ApiService *SitesStoreApiService
	siteId string
	storeId string
	groupId string
	setId string
	termId string
	relationId string
	ifMatch *string
}

// ETag
func (r ApiSitesTermStoresGroupsSetsTermsDeleteRelationsRequest) IfMatch(ifMatch string) ApiSitesTermStoresGroupsSetsTermsDeleteRelationsRequest {
	r.ifMatch = &ifMatch
	return r
}

func (r ApiSitesTermStoresGroupsSetsTermsDeleteRelationsRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.SitesTermStoresGroupsSetsTermsDeleteRelationsExecute(r)
}

/*
SitesTermStoresGroupsSetsTermsDeleteRelations Delete navigation property relations for sites

To indicate which terms are related to the current term as either pinned or reused.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param siteId key: id of site
 @param storeId key: id of store
 @param groupId key: id of group
 @param setId key: id of set
 @param termId key: id of term
 @param relationId key: id of relation
 @return ApiSitesTermStoresGroupsSetsTermsDeleteRelationsRequest
*/
func (a *SitesStoreApiService) SitesTermStoresGroupsSetsTermsDeleteRelations(ctx _context.Context, siteId string, storeId string, groupId string, setId string, termId string, relationId string) ApiSitesTermStoresGroupsSetsTermsDeleteRelationsRequest {
	return ApiSitesTermStoresGroupsSetsTermsDeleteRelationsRequest{
		ApiService: a,
		ctx: ctx,
		siteId: siteId,
		storeId: storeId,
		groupId: groupId,
		setId: setId,
		termId: termId,
		relationId: relationId,
	}
}

// Execute executes the request
func (a *SitesStoreApiService) SitesTermStoresGroupsSetsTermsDeleteRelationsExecute(r ApiSitesTermStoresGroupsSetsTermsDeleteRelationsRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SitesStoreApiService.SitesTermStoresGroupsSetsTermsDeleteRelations")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sites/{site-id}/termStores/{store-id}/groups/{group-id}/sets/{set-id}/terms/{term-id}/relations/{relation-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"site-id"+"}", _neturl.PathEscape(parameterToString(r.siteId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"store-id"+"}", _neturl.PathEscape(parameterToString(r.storeId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"set-id"+"}", _neturl.PathEscape(parameterToString(r.setId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"term-id"+"}", _neturl.PathEscape(parameterToString(r.termId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"relation-id"+"}", _neturl.PathEscape(parameterToString(r.relationId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ifMatch != nil {
		localVarHeaderParams["If-Match"] = parameterToString(*r.ifMatch, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiSitesTermStoresGroupsSetsTermsGetChildrenRequest struct {
	ctx _context.Context
	ApiService *SitesStoreApiService
	siteId string
	storeId string
	groupId string
	setId string
	termId string
	termId1 string
	select_ *[]string
	expand *[]string
}

// Select properties to be returned
func (r ApiSitesTermStoresGroupsSetsTermsGetChildrenRequest) Select_(select_ []string) ApiSitesTermStoresGroupsSetsTermsGetChildrenRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiSitesTermStoresGroupsSetsTermsGetChildrenRequest) Expand(expand []string) ApiSitesTermStoresGroupsSetsTermsGetChildrenRequest {
	r.expand = &expand
	return r
}

func (r ApiSitesTermStoresGroupsSetsTermsGetChildrenRequest) Execute() (MicrosoftGraphTermStoreTerm, *_nethttp.Response, error) {
	return r.ApiService.SitesTermStoresGroupsSetsTermsGetChildrenExecute(r)
}

/*
SitesTermStoresGroupsSetsTermsGetChildren Get children from sites

Children of current term.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param siteId key: id of site
 @param storeId key: id of store
 @param groupId key: id of group
 @param setId key: id of set
 @param termId key: id of term
 @param termId1 key: id of term
 @return ApiSitesTermStoresGroupsSetsTermsGetChildrenRequest
*/
func (a *SitesStoreApiService) SitesTermStoresGroupsSetsTermsGetChildren(ctx _context.Context, siteId string, storeId string, groupId string, setId string, termId string, termId1 string) ApiSitesTermStoresGroupsSetsTermsGetChildrenRequest {
	return ApiSitesTermStoresGroupsSetsTermsGetChildrenRequest{
		ApiService: a,
		ctx: ctx,
		siteId: siteId,
		storeId: storeId,
		groupId: groupId,
		setId: setId,
		termId: termId,
		termId1: termId1,
	}
}

// Execute executes the request
//  @return MicrosoftGraphTermStoreTerm
func (a *SitesStoreApiService) SitesTermStoresGroupsSetsTermsGetChildrenExecute(r ApiSitesTermStoresGroupsSetsTermsGetChildrenRequest) (MicrosoftGraphTermStoreTerm, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphTermStoreTerm
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SitesStoreApiService.SitesTermStoresGroupsSetsTermsGetChildren")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sites/{site-id}/termStores/{store-id}/groups/{group-id}/sets/{set-id}/terms/{term-id}/children/{term-id1}"
	localVarPath = strings.Replace(localVarPath, "{"+"site-id"+"}", _neturl.PathEscape(parameterToString(r.siteId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"store-id"+"}", _neturl.PathEscape(parameterToString(r.storeId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"set-id"+"}", _neturl.PathEscape(parameterToString(r.setId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"term-id"+"}", _neturl.PathEscape(parameterToString(r.termId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"term-id1"+"}", _neturl.PathEscape(parameterToString(r.termId1, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSitesTermStoresGroupsSetsTermsGetRefSetRequest struct {
	ctx _context.Context
	ApiService *SitesStoreApiService
	siteId string
	storeId string
	groupId string
	setId string
	termId string
}


func (r ApiSitesTermStoresGroupsSetsTermsGetRefSetRequest) Execute() (string, *_nethttp.Response, error) {
	return r.ApiService.SitesTermStoresGroupsSetsTermsGetRefSetExecute(r)
}

/*
SitesTermStoresGroupsSetsTermsGetRefSet Get ref of set from sites

The [set] in which the term is created.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param siteId key: id of site
 @param storeId key: id of store
 @param groupId key: id of group
 @param setId key: id of set
 @param termId key: id of term
 @return ApiSitesTermStoresGroupsSetsTermsGetRefSetRequest
*/
func (a *SitesStoreApiService) SitesTermStoresGroupsSetsTermsGetRefSet(ctx _context.Context, siteId string, storeId string, groupId string, setId string, termId string) ApiSitesTermStoresGroupsSetsTermsGetRefSetRequest {
	return ApiSitesTermStoresGroupsSetsTermsGetRefSetRequest{
		ApiService: a,
		ctx: ctx,
		siteId: siteId,
		storeId: storeId,
		groupId: groupId,
		setId: setId,
		termId: termId,
	}
}

// Execute executes the request
//  @return string
func (a *SitesStoreApiService) SitesTermStoresGroupsSetsTermsGetRefSetExecute(r ApiSitesTermStoresGroupsSetsTermsGetRefSetRequest) (string, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  string
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SitesStoreApiService.SitesTermStoresGroupsSetsTermsGetRefSet")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sites/{site-id}/termStores/{store-id}/groups/{group-id}/sets/{set-id}/terms/{term-id}/set/$ref"
	localVarPath = strings.Replace(localVarPath, "{"+"site-id"+"}", _neturl.PathEscape(parameterToString(r.siteId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"store-id"+"}", _neturl.PathEscape(parameterToString(r.storeId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"set-id"+"}", _neturl.PathEscape(parameterToString(r.setId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"term-id"+"}", _neturl.PathEscape(parameterToString(r.termId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSitesTermStoresGroupsSetsTermsGetRelationsRequest struct {
	ctx _context.Context
	ApiService *SitesStoreApiService
	siteId string
	storeId string
	groupId string
	setId string
	termId string
	relationId string
	select_ *[]string
	expand *[]string
}

// Select properties to be returned
func (r ApiSitesTermStoresGroupsSetsTermsGetRelationsRequest) Select_(select_ []string) ApiSitesTermStoresGroupsSetsTermsGetRelationsRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiSitesTermStoresGroupsSetsTermsGetRelationsRequest) Expand(expand []string) ApiSitesTermStoresGroupsSetsTermsGetRelationsRequest {
	r.expand = &expand
	return r
}

func (r ApiSitesTermStoresGroupsSetsTermsGetRelationsRequest) Execute() (MicrosoftGraphTermStoreRelation, *_nethttp.Response, error) {
	return r.ApiService.SitesTermStoresGroupsSetsTermsGetRelationsExecute(r)
}

/*
SitesTermStoresGroupsSetsTermsGetRelations Get relations from sites

To indicate which terms are related to the current term as either pinned or reused.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param siteId key: id of site
 @param storeId key: id of store
 @param groupId key: id of group
 @param setId key: id of set
 @param termId key: id of term
 @param relationId key: id of relation
 @return ApiSitesTermStoresGroupsSetsTermsGetRelationsRequest
*/
func (a *SitesStoreApiService) SitesTermStoresGroupsSetsTermsGetRelations(ctx _context.Context, siteId string, storeId string, groupId string, setId string, termId string, relationId string) ApiSitesTermStoresGroupsSetsTermsGetRelationsRequest {
	return ApiSitesTermStoresGroupsSetsTermsGetRelationsRequest{
		ApiService: a,
		ctx: ctx,
		siteId: siteId,
		storeId: storeId,
		groupId: groupId,
		setId: setId,
		termId: termId,
		relationId: relationId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphTermStoreRelation
func (a *SitesStoreApiService) SitesTermStoresGroupsSetsTermsGetRelationsExecute(r ApiSitesTermStoresGroupsSetsTermsGetRelationsRequest) (MicrosoftGraphTermStoreRelation, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphTermStoreRelation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SitesStoreApiService.SitesTermStoresGroupsSetsTermsGetRelations")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sites/{site-id}/termStores/{store-id}/groups/{group-id}/sets/{set-id}/terms/{term-id}/relations/{relation-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"site-id"+"}", _neturl.PathEscape(parameterToString(r.siteId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"store-id"+"}", _neturl.PathEscape(parameterToString(r.storeId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"set-id"+"}", _neturl.PathEscape(parameterToString(r.setId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"term-id"+"}", _neturl.PathEscape(parameterToString(r.termId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"relation-id"+"}", _neturl.PathEscape(parameterToString(r.relationId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSitesTermStoresGroupsSetsTermsGetSetRequest struct {
	ctx _context.Context
	ApiService *SitesStoreApiService
	siteId string
	storeId string
	groupId string
	setId string
	termId string
	select_ *[]string
	expand *[]string
}

// Select properties to be returned
func (r ApiSitesTermStoresGroupsSetsTermsGetSetRequest) Select_(select_ []string) ApiSitesTermStoresGroupsSetsTermsGetSetRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiSitesTermStoresGroupsSetsTermsGetSetRequest) Expand(expand []string) ApiSitesTermStoresGroupsSetsTermsGetSetRequest {
	r.expand = &expand
	return r
}

func (r ApiSitesTermStoresGroupsSetsTermsGetSetRequest) Execute() (MicrosoftGraphTermStoreSet, *_nethttp.Response, error) {
	return r.ApiService.SitesTermStoresGroupsSetsTermsGetSetExecute(r)
}

/*
SitesTermStoresGroupsSetsTermsGetSet Get set from sites

The [set] in which the term is created.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param siteId key: id of site
 @param storeId key: id of store
 @param groupId key: id of group
 @param setId key: id of set
 @param termId key: id of term
 @return ApiSitesTermStoresGroupsSetsTermsGetSetRequest
*/
func (a *SitesStoreApiService) SitesTermStoresGroupsSetsTermsGetSet(ctx _context.Context, siteId string, storeId string, groupId string, setId string, termId string) ApiSitesTermStoresGroupsSetsTermsGetSetRequest {
	return ApiSitesTermStoresGroupsSetsTermsGetSetRequest{
		ApiService: a,
		ctx: ctx,
		siteId: siteId,
		storeId: storeId,
		groupId: groupId,
		setId: setId,
		termId: termId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphTermStoreSet
func (a *SitesStoreApiService) SitesTermStoresGroupsSetsTermsGetSetExecute(r ApiSitesTermStoresGroupsSetsTermsGetSetRequest) (MicrosoftGraphTermStoreSet, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphTermStoreSet
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SitesStoreApiService.SitesTermStoresGroupsSetsTermsGetSet")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sites/{site-id}/termStores/{store-id}/groups/{group-id}/sets/{set-id}/terms/{term-id}/set"
	localVarPath = strings.Replace(localVarPath, "{"+"site-id"+"}", _neturl.PathEscape(parameterToString(r.siteId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"store-id"+"}", _neturl.PathEscape(parameterToString(r.storeId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"set-id"+"}", _neturl.PathEscape(parameterToString(r.setId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"term-id"+"}", _neturl.PathEscape(parameterToString(r.termId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSitesTermStoresGroupsSetsTermsListChildrenRequest struct {
	ctx _context.Context
	ApiService *SitesStoreApiService
	siteId string
	storeId string
	groupId string
	setId string
	termId string
	top *int32
	skip *int32
	search *string
	filter *string
	count *bool
	orderby *[]string
	select_ *[]string
	expand *[]string
}

// Show only the first n items
func (r ApiSitesTermStoresGroupsSetsTermsListChildrenRequest) Top(top int32) ApiSitesTermStoresGroupsSetsTermsListChildrenRequest {
	r.top = &top
	return r
}
// Skip the first n items
func (r ApiSitesTermStoresGroupsSetsTermsListChildrenRequest) Skip(skip int32) ApiSitesTermStoresGroupsSetsTermsListChildrenRequest {
	r.skip = &skip
	return r
}
// Search items by search phrases
func (r ApiSitesTermStoresGroupsSetsTermsListChildrenRequest) Search(search string) ApiSitesTermStoresGroupsSetsTermsListChildrenRequest {
	r.search = &search
	return r
}
// Filter items by property values
func (r ApiSitesTermStoresGroupsSetsTermsListChildrenRequest) Filter(filter string) ApiSitesTermStoresGroupsSetsTermsListChildrenRequest {
	r.filter = &filter
	return r
}
// Include count of items
func (r ApiSitesTermStoresGroupsSetsTermsListChildrenRequest) Count(count bool) ApiSitesTermStoresGroupsSetsTermsListChildrenRequest {
	r.count = &count
	return r
}
// Order items by property values
func (r ApiSitesTermStoresGroupsSetsTermsListChildrenRequest) Orderby(orderby []string) ApiSitesTermStoresGroupsSetsTermsListChildrenRequest {
	r.orderby = &orderby
	return r
}
// Select properties to be returned
func (r ApiSitesTermStoresGroupsSetsTermsListChildrenRequest) Select_(select_ []string) ApiSitesTermStoresGroupsSetsTermsListChildrenRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiSitesTermStoresGroupsSetsTermsListChildrenRequest) Expand(expand []string) ApiSitesTermStoresGroupsSetsTermsListChildrenRequest {
	r.expand = &expand
	return r
}

func (r ApiSitesTermStoresGroupsSetsTermsListChildrenRequest) Execute() (CollectionOfTerm, *_nethttp.Response, error) {
	return r.ApiService.SitesTermStoresGroupsSetsTermsListChildrenExecute(r)
}

/*
SitesTermStoresGroupsSetsTermsListChildren Get children from sites

Children of current term.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param siteId key: id of site
 @param storeId key: id of store
 @param groupId key: id of group
 @param setId key: id of set
 @param termId key: id of term
 @return ApiSitesTermStoresGroupsSetsTermsListChildrenRequest
*/
func (a *SitesStoreApiService) SitesTermStoresGroupsSetsTermsListChildren(ctx _context.Context, siteId string, storeId string, groupId string, setId string, termId string) ApiSitesTermStoresGroupsSetsTermsListChildrenRequest {
	return ApiSitesTermStoresGroupsSetsTermsListChildrenRequest{
		ApiService: a,
		ctx: ctx,
		siteId: siteId,
		storeId: storeId,
		groupId: groupId,
		setId: setId,
		termId: termId,
	}
}

// Execute executes the request
//  @return CollectionOfTerm
func (a *SitesStoreApiService) SitesTermStoresGroupsSetsTermsListChildrenExecute(r ApiSitesTermStoresGroupsSetsTermsListChildrenRequest) (CollectionOfTerm, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  CollectionOfTerm
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SitesStoreApiService.SitesTermStoresGroupsSetsTermsListChildren")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sites/{site-id}/termStores/{store-id}/groups/{group-id}/sets/{set-id}/terms/{term-id}/children"
	localVarPath = strings.Replace(localVarPath, "{"+"site-id"+"}", _neturl.PathEscape(parameterToString(r.siteId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"store-id"+"}", _neturl.PathEscape(parameterToString(r.storeId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"set-id"+"}", _neturl.PathEscape(parameterToString(r.setId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"term-id"+"}", _neturl.PathEscape(parameterToString(r.termId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.top != nil {
		localVarQueryParams.Add("$top", parameterToString(*r.top, ""))
	}
	if r.skip != nil {
		localVarQueryParams.Add("$skip", parameterToString(*r.skip, ""))
	}
	if r.search != nil {
		localVarQueryParams.Add("$search", parameterToString(*r.search, ""))
	}
	if r.filter != nil {
		localVarQueryParams.Add("$filter", parameterToString(*r.filter, ""))
	}
	if r.count != nil {
		localVarQueryParams.Add("$count", parameterToString(*r.count, ""))
	}
	if r.orderby != nil {
		localVarQueryParams.Add("$orderby", parameterToString(*r.orderby, "csv"))
	}
	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSitesTermStoresGroupsSetsTermsListRelationsRequest struct {
	ctx _context.Context
	ApiService *SitesStoreApiService
	siteId string
	storeId string
	groupId string
	setId string
	termId string
	top *int32
	skip *int32
	search *string
	filter *string
	count *bool
	orderby *[]string
	select_ *[]string
	expand *[]string
}

// Show only the first n items
func (r ApiSitesTermStoresGroupsSetsTermsListRelationsRequest) Top(top int32) ApiSitesTermStoresGroupsSetsTermsListRelationsRequest {
	r.top = &top
	return r
}
// Skip the first n items
func (r ApiSitesTermStoresGroupsSetsTermsListRelationsRequest) Skip(skip int32) ApiSitesTermStoresGroupsSetsTermsListRelationsRequest {
	r.skip = &skip
	return r
}
// Search items by search phrases
func (r ApiSitesTermStoresGroupsSetsTermsListRelationsRequest) Search(search string) ApiSitesTermStoresGroupsSetsTermsListRelationsRequest {
	r.search = &search
	return r
}
// Filter items by property values
func (r ApiSitesTermStoresGroupsSetsTermsListRelationsRequest) Filter(filter string) ApiSitesTermStoresGroupsSetsTermsListRelationsRequest {
	r.filter = &filter
	return r
}
// Include count of items
func (r ApiSitesTermStoresGroupsSetsTermsListRelationsRequest) Count(count bool) ApiSitesTermStoresGroupsSetsTermsListRelationsRequest {
	r.count = &count
	return r
}
// Order items by property values
func (r ApiSitesTermStoresGroupsSetsTermsListRelationsRequest) Orderby(orderby []string) ApiSitesTermStoresGroupsSetsTermsListRelationsRequest {
	r.orderby = &orderby
	return r
}
// Select properties to be returned
func (r ApiSitesTermStoresGroupsSetsTermsListRelationsRequest) Select_(select_ []string) ApiSitesTermStoresGroupsSetsTermsListRelationsRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiSitesTermStoresGroupsSetsTermsListRelationsRequest) Expand(expand []string) ApiSitesTermStoresGroupsSetsTermsListRelationsRequest {
	r.expand = &expand
	return r
}

func (r ApiSitesTermStoresGroupsSetsTermsListRelationsRequest) Execute() (CollectionOfRelation, *_nethttp.Response, error) {
	return r.ApiService.SitesTermStoresGroupsSetsTermsListRelationsExecute(r)
}

/*
SitesTermStoresGroupsSetsTermsListRelations Get relations from sites

To indicate which terms are related to the current term as either pinned or reused.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param siteId key: id of site
 @param storeId key: id of store
 @param groupId key: id of group
 @param setId key: id of set
 @param termId key: id of term
 @return ApiSitesTermStoresGroupsSetsTermsListRelationsRequest
*/
func (a *SitesStoreApiService) SitesTermStoresGroupsSetsTermsListRelations(ctx _context.Context, siteId string, storeId string, groupId string, setId string, termId string) ApiSitesTermStoresGroupsSetsTermsListRelationsRequest {
	return ApiSitesTermStoresGroupsSetsTermsListRelationsRequest{
		ApiService: a,
		ctx: ctx,
		siteId: siteId,
		storeId: storeId,
		groupId: groupId,
		setId: setId,
		termId: termId,
	}
}

// Execute executes the request
//  @return CollectionOfRelation
func (a *SitesStoreApiService) SitesTermStoresGroupsSetsTermsListRelationsExecute(r ApiSitesTermStoresGroupsSetsTermsListRelationsRequest) (CollectionOfRelation, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  CollectionOfRelation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SitesStoreApiService.SitesTermStoresGroupsSetsTermsListRelations")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sites/{site-id}/termStores/{store-id}/groups/{group-id}/sets/{set-id}/terms/{term-id}/relations"
	localVarPath = strings.Replace(localVarPath, "{"+"site-id"+"}", _neturl.PathEscape(parameterToString(r.siteId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"store-id"+"}", _neturl.PathEscape(parameterToString(r.storeId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"set-id"+"}", _neturl.PathEscape(parameterToString(r.setId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"term-id"+"}", _neturl.PathEscape(parameterToString(r.termId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.top != nil {
		localVarQueryParams.Add("$top", parameterToString(*r.top, ""))
	}
	if r.skip != nil {
		localVarQueryParams.Add("$skip", parameterToString(*r.skip, ""))
	}
	if r.search != nil {
		localVarQueryParams.Add("$search", parameterToString(*r.search, ""))
	}
	if r.filter != nil {
		localVarQueryParams.Add("$filter", parameterToString(*r.filter, ""))
	}
	if r.count != nil {
		localVarQueryParams.Add("$count", parameterToString(*r.count, ""))
	}
	if r.orderby != nil {
		localVarQueryParams.Add("$orderby", parameterToString(*r.orderby, "csv"))
	}
	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSitesTermStoresGroupsSetsTermsRelationsDeleteRefFromTermRequest struct {
	ctx _context.Context
	ApiService *SitesStoreApiService
	siteId string
	storeId string
	groupId string
	setId string
	termId string
	relationId string
	ifMatch *string
}

// ETag
func (r ApiSitesTermStoresGroupsSetsTermsRelationsDeleteRefFromTermRequest) IfMatch(ifMatch string) ApiSitesTermStoresGroupsSetsTermsRelationsDeleteRefFromTermRequest {
	r.ifMatch = &ifMatch
	return r
}

func (r ApiSitesTermStoresGroupsSetsTermsRelationsDeleteRefFromTermRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.SitesTermStoresGroupsSetsTermsRelationsDeleteRefFromTermExecute(r)
}

/*
SitesTermStoresGroupsSetsTermsRelationsDeleteRefFromTerm Delete ref of navigation property fromTerm for sites

The from [term] of the relation. The term from which the relationship is defined. A null value would indicate the relation is directly with the [set].

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param siteId key: id of site
 @param storeId key: id of store
 @param groupId key: id of group
 @param setId key: id of set
 @param termId key: id of term
 @param relationId key: id of relation
 @return ApiSitesTermStoresGroupsSetsTermsRelationsDeleteRefFromTermRequest
*/
func (a *SitesStoreApiService) SitesTermStoresGroupsSetsTermsRelationsDeleteRefFromTerm(ctx _context.Context, siteId string, storeId string, groupId string, setId string, termId string, relationId string) ApiSitesTermStoresGroupsSetsTermsRelationsDeleteRefFromTermRequest {
	return ApiSitesTermStoresGroupsSetsTermsRelationsDeleteRefFromTermRequest{
		ApiService: a,
		ctx: ctx,
		siteId: siteId,
		storeId: storeId,
		groupId: groupId,
		setId: setId,
		termId: termId,
		relationId: relationId,
	}
}

// Execute executes the request
func (a *SitesStoreApiService) SitesTermStoresGroupsSetsTermsRelationsDeleteRefFromTermExecute(r ApiSitesTermStoresGroupsSetsTermsRelationsDeleteRefFromTermRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SitesStoreApiService.SitesTermStoresGroupsSetsTermsRelationsDeleteRefFromTerm")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sites/{site-id}/termStores/{store-id}/groups/{group-id}/sets/{set-id}/terms/{term-id}/relations/{relation-id}/fromTerm/$ref"
	localVarPath = strings.Replace(localVarPath, "{"+"site-id"+"}", _neturl.PathEscape(parameterToString(r.siteId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"store-id"+"}", _neturl.PathEscape(parameterToString(r.storeId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"set-id"+"}", _neturl.PathEscape(parameterToString(r.setId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"term-id"+"}", _neturl.PathEscape(parameterToString(r.termId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"relation-id"+"}", _neturl.PathEscape(parameterToString(r.relationId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ifMatch != nil {
		localVarHeaderParams["If-Match"] = parameterToString(*r.ifMatch, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiSitesTermStoresGroupsSetsTermsRelationsDeleteRefSetRequest struct {
	ctx _context.Context
	ApiService *SitesStoreApiService
	siteId string
	storeId string
	groupId string
	setId string
	termId string
	relationId string
	ifMatch *string
}

// ETag
func (r ApiSitesTermStoresGroupsSetsTermsRelationsDeleteRefSetRequest) IfMatch(ifMatch string) ApiSitesTermStoresGroupsSetsTermsRelationsDeleteRefSetRequest {
	r.ifMatch = &ifMatch
	return r
}

func (r ApiSitesTermStoresGroupsSetsTermsRelationsDeleteRefSetRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.SitesTermStoresGroupsSetsTermsRelationsDeleteRefSetExecute(r)
}

/*
SitesTermStoresGroupsSetsTermsRelationsDeleteRefSet Delete ref of navigation property set for sites

The [set] in which the relation is relevant.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param siteId key: id of site
 @param storeId key: id of store
 @param groupId key: id of group
 @param setId key: id of set
 @param termId key: id of term
 @param relationId key: id of relation
 @return ApiSitesTermStoresGroupsSetsTermsRelationsDeleteRefSetRequest
*/
func (a *SitesStoreApiService) SitesTermStoresGroupsSetsTermsRelationsDeleteRefSet(ctx _context.Context, siteId string, storeId string, groupId string, setId string, termId string, relationId string) ApiSitesTermStoresGroupsSetsTermsRelationsDeleteRefSetRequest {
	return ApiSitesTermStoresGroupsSetsTermsRelationsDeleteRefSetRequest{
		ApiService: a,
		ctx: ctx,
		siteId: siteId,
		storeId: storeId,
		groupId: groupId,
		setId: setId,
		termId: termId,
		relationId: relationId,
	}
}

// Execute executes the request
func (a *SitesStoreApiService) SitesTermStoresGroupsSetsTermsRelationsDeleteRefSetExecute(r ApiSitesTermStoresGroupsSetsTermsRelationsDeleteRefSetRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SitesStoreApiService.SitesTermStoresGroupsSetsTermsRelationsDeleteRefSet")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sites/{site-id}/termStores/{store-id}/groups/{group-id}/sets/{set-id}/terms/{term-id}/relations/{relation-id}/set/$ref"
	localVarPath = strings.Replace(localVarPath, "{"+"site-id"+"}", _neturl.PathEscape(parameterToString(r.siteId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"store-id"+"}", _neturl.PathEscape(parameterToString(r.storeId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"set-id"+"}", _neturl.PathEscape(parameterToString(r.setId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"term-id"+"}", _neturl.PathEscape(parameterToString(r.termId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"relation-id"+"}", _neturl.PathEscape(parameterToString(r.relationId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ifMatch != nil {
		localVarHeaderParams["If-Match"] = parameterToString(*r.ifMatch, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiSitesTermStoresGroupsSetsTermsRelationsDeleteRefToTermRequest struct {
	ctx _context.Context
	ApiService *SitesStoreApiService
	siteId string
	storeId string
	groupId string
	setId string
	termId string
	relationId string
	ifMatch *string
}

// ETag
func (r ApiSitesTermStoresGroupsSetsTermsRelationsDeleteRefToTermRequest) IfMatch(ifMatch string) ApiSitesTermStoresGroupsSetsTermsRelationsDeleteRefToTermRequest {
	r.ifMatch = &ifMatch
	return r
}

func (r ApiSitesTermStoresGroupsSetsTermsRelationsDeleteRefToTermRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.SitesTermStoresGroupsSetsTermsRelationsDeleteRefToTermExecute(r)
}

/*
SitesTermStoresGroupsSetsTermsRelationsDeleteRefToTerm Delete ref of navigation property toTerm for sites

The to [term] of the relation. The term to which the relationship is defined.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param siteId key: id of site
 @param storeId key: id of store
 @param groupId key: id of group
 @param setId key: id of set
 @param termId key: id of term
 @param relationId key: id of relation
 @return ApiSitesTermStoresGroupsSetsTermsRelationsDeleteRefToTermRequest
*/
func (a *SitesStoreApiService) SitesTermStoresGroupsSetsTermsRelationsDeleteRefToTerm(ctx _context.Context, siteId string, storeId string, groupId string, setId string, termId string, relationId string) ApiSitesTermStoresGroupsSetsTermsRelationsDeleteRefToTermRequest {
	return ApiSitesTermStoresGroupsSetsTermsRelationsDeleteRefToTermRequest{
		ApiService: a,
		ctx: ctx,
		siteId: siteId,
		storeId: storeId,
		groupId: groupId,
		setId: setId,
		termId: termId,
		relationId: relationId,
	}
}

// Execute executes the request
func (a *SitesStoreApiService) SitesTermStoresGroupsSetsTermsRelationsDeleteRefToTermExecute(r ApiSitesTermStoresGroupsSetsTermsRelationsDeleteRefToTermRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SitesStoreApiService.SitesTermStoresGroupsSetsTermsRelationsDeleteRefToTerm")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sites/{site-id}/termStores/{store-id}/groups/{group-id}/sets/{set-id}/terms/{term-id}/relations/{relation-id}/toTerm/$ref"
	localVarPath = strings.Replace(localVarPath, "{"+"site-id"+"}", _neturl.PathEscape(parameterToString(r.siteId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"store-id"+"}", _neturl.PathEscape(parameterToString(r.storeId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"set-id"+"}", _neturl.PathEscape(parameterToString(r.setId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"term-id"+"}", _neturl.PathEscape(parameterToString(r.termId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"relation-id"+"}", _neturl.PathEscape(parameterToString(r.relationId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ifMatch != nil {
		localVarHeaderParams["If-Match"] = parameterToString(*r.ifMatch, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiSitesTermStoresGroupsSetsTermsRelationsGetFromTermRequest struct {
	ctx _context.Context
	ApiService *SitesStoreApiService
	siteId string
	storeId string
	groupId string
	setId string
	termId string
	relationId string
	select_ *[]string
	expand *[]string
}

// Select properties to be returned
func (r ApiSitesTermStoresGroupsSetsTermsRelationsGetFromTermRequest) Select_(select_ []string) ApiSitesTermStoresGroupsSetsTermsRelationsGetFromTermRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiSitesTermStoresGroupsSetsTermsRelationsGetFromTermRequest) Expand(expand []string) ApiSitesTermStoresGroupsSetsTermsRelationsGetFromTermRequest {
	r.expand = &expand
	return r
}

func (r ApiSitesTermStoresGroupsSetsTermsRelationsGetFromTermRequest) Execute() (MicrosoftGraphTermStoreTerm, *_nethttp.Response, error) {
	return r.ApiService.SitesTermStoresGroupsSetsTermsRelationsGetFromTermExecute(r)
}

/*
SitesTermStoresGroupsSetsTermsRelationsGetFromTerm Get fromTerm from sites

The from [term] of the relation. The term from which the relationship is defined. A null value would indicate the relation is directly with the [set].

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param siteId key: id of site
 @param storeId key: id of store
 @param groupId key: id of group
 @param setId key: id of set
 @param termId key: id of term
 @param relationId key: id of relation
 @return ApiSitesTermStoresGroupsSetsTermsRelationsGetFromTermRequest
*/
func (a *SitesStoreApiService) SitesTermStoresGroupsSetsTermsRelationsGetFromTerm(ctx _context.Context, siteId string, storeId string, groupId string, setId string, termId string, relationId string) ApiSitesTermStoresGroupsSetsTermsRelationsGetFromTermRequest {
	return ApiSitesTermStoresGroupsSetsTermsRelationsGetFromTermRequest{
		ApiService: a,
		ctx: ctx,
		siteId: siteId,
		storeId: storeId,
		groupId: groupId,
		setId: setId,
		termId: termId,
		relationId: relationId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphTermStoreTerm
func (a *SitesStoreApiService) SitesTermStoresGroupsSetsTermsRelationsGetFromTermExecute(r ApiSitesTermStoresGroupsSetsTermsRelationsGetFromTermRequest) (MicrosoftGraphTermStoreTerm, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphTermStoreTerm
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SitesStoreApiService.SitesTermStoresGroupsSetsTermsRelationsGetFromTerm")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sites/{site-id}/termStores/{store-id}/groups/{group-id}/sets/{set-id}/terms/{term-id}/relations/{relation-id}/fromTerm"
	localVarPath = strings.Replace(localVarPath, "{"+"site-id"+"}", _neturl.PathEscape(parameterToString(r.siteId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"store-id"+"}", _neturl.PathEscape(parameterToString(r.storeId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"set-id"+"}", _neturl.PathEscape(parameterToString(r.setId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"term-id"+"}", _neturl.PathEscape(parameterToString(r.termId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"relation-id"+"}", _neturl.PathEscape(parameterToString(r.relationId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSitesTermStoresGroupsSetsTermsRelationsGetRefFromTermRequest struct {
	ctx _context.Context
	ApiService *SitesStoreApiService
	siteId string
	storeId string
	groupId string
	setId string
	termId string
	relationId string
}


func (r ApiSitesTermStoresGroupsSetsTermsRelationsGetRefFromTermRequest) Execute() (string, *_nethttp.Response, error) {
	return r.ApiService.SitesTermStoresGroupsSetsTermsRelationsGetRefFromTermExecute(r)
}

/*
SitesTermStoresGroupsSetsTermsRelationsGetRefFromTerm Get ref of fromTerm from sites

The from [term] of the relation. The term from which the relationship is defined. A null value would indicate the relation is directly with the [set].

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param siteId key: id of site
 @param storeId key: id of store
 @param groupId key: id of group
 @param setId key: id of set
 @param termId key: id of term
 @param relationId key: id of relation
 @return ApiSitesTermStoresGroupsSetsTermsRelationsGetRefFromTermRequest
*/
func (a *SitesStoreApiService) SitesTermStoresGroupsSetsTermsRelationsGetRefFromTerm(ctx _context.Context, siteId string, storeId string, groupId string, setId string, termId string, relationId string) ApiSitesTermStoresGroupsSetsTermsRelationsGetRefFromTermRequest {
	return ApiSitesTermStoresGroupsSetsTermsRelationsGetRefFromTermRequest{
		ApiService: a,
		ctx: ctx,
		siteId: siteId,
		storeId: storeId,
		groupId: groupId,
		setId: setId,
		termId: termId,
		relationId: relationId,
	}
}

// Execute executes the request
//  @return string
func (a *SitesStoreApiService) SitesTermStoresGroupsSetsTermsRelationsGetRefFromTermExecute(r ApiSitesTermStoresGroupsSetsTermsRelationsGetRefFromTermRequest) (string, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  string
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SitesStoreApiService.SitesTermStoresGroupsSetsTermsRelationsGetRefFromTerm")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sites/{site-id}/termStores/{store-id}/groups/{group-id}/sets/{set-id}/terms/{term-id}/relations/{relation-id}/fromTerm/$ref"
	localVarPath = strings.Replace(localVarPath, "{"+"site-id"+"}", _neturl.PathEscape(parameterToString(r.siteId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"store-id"+"}", _neturl.PathEscape(parameterToString(r.storeId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"set-id"+"}", _neturl.PathEscape(parameterToString(r.setId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"term-id"+"}", _neturl.PathEscape(parameterToString(r.termId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"relation-id"+"}", _neturl.PathEscape(parameterToString(r.relationId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSitesTermStoresGroupsSetsTermsRelationsGetRefSetRequest struct {
	ctx _context.Context
	ApiService *SitesStoreApiService
	siteId string
	storeId string
	groupId string
	setId string
	termId string
	relationId string
}


func (r ApiSitesTermStoresGroupsSetsTermsRelationsGetRefSetRequest) Execute() (string, *_nethttp.Response, error) {
	return r.ApiService.SitesTermStoresGroupsSetsTermsRelationsGetRefSetExecute(r)
}

/*
SitesTermStoresGroupsSetsTermsRelationsGetRefSet Get ref of set from sites

The [set] in which the relation is relevant.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param siteId key: id of site
 @param storeId key: id of store
 @param groupId key: id of group
 @param setId key: id of set
 @param termId key: id of term
 @param relationId key: id of relation
 @return ApiSitesTermStoresGroupsSetsTermsRelationsGetRefSetRequest
*/
func (a *SitesStoreApiService) SitesTermStoresGroupsSetsTermsRelationsGetRefSet(ctx _context.Context, siteId string, storeId string, groupId string, setId string, termId string, relationId string) ApiSitesTermStoresGroupsSetsTermsRelationsGetRefSetRequest {
	return ApiSitesTermStoresGroupsSetsTermsRelationsGetRefSetRequest{
		ApiService: a,
		ctx: ctx,
		siteId: siteId,
		storeId: storeId,
		groupId: groupId,
		setId: setId,
		termId: termId,
		relationId: relationId,
	}
}

// Execute executes the request
//  @return string
func (a *SitesStoreApiService) SitesTermStoresGroupsSetsTermsRelationsGetRefSetExecute(r ApiSitesTermStoresGroupsSetsTermsRelationsGetRefSetRequest) (string, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  string
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SitesStoreApiService.SitesTermStoresGroupsSetsTermsRelationsGetRefSet")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sites/{site-id}/termStores/{store-id}/groups/{group-id}/sets/{set-id}/terms/{term-id}/relations/{relation-id}/set/$ref"
	localVarPath = strings.Replace(localVarPath, "{"+"site-id"+"}", _neturl.PathEscape(parameterToString(r.siteId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"store-id"+"}", _neturl.PathEscape(parameterToString(r.storeId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"set-id"+"}", _neturl.PathEscape(parameterToString(r.setId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"term-id"+"}", _neturl.PathEscape(parameterToString(r.termId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"relation-id"+"}", _neturl.PathEscape(parameterToString(r.relationId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSitesTermStoresGroupsSetsTermsRelationsGetRefToTermRequest struct {
	ctx _context.Context
	ApiService *SitesStoreApiService
	siteId string
	storeId string
	groupId string
	setId string
	termId string
	relationId string
}


func (r ApiSitesTermStoresGroupsSetsTermsRelationsGetRefToTermRequest) Execute() (string, *_nethttp.Response, error) {
	return r.ApiService.SitesTermStoresGroupsSetsTermsRelationsGetRefToTermExecute(r)
}

/*
SitesTermStoresGroupsSetsTermsRelationsGetRefToTerm Get ref of toTerm from sites

The to [term] of the relation. The term to which the relationship is defined.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param siteId key: id of site
 @param storeId key: id of store
 @param groupId key: id of group
 @param setId key: id of set
 @param termId key: id of term
 @param relationId key: id of relation
 @return ApiSitesTermStoresGroupsSetsTermsRelationsGetRefToTermRequest
*/
func (a *SitesStoreApiService) SitesTermStoresGroupsSetsTermsRelationsGetRefToTerm(ctx _context.Context, siteId string, storeId string, groupId string, setId string, termId string, relationId string) ApiSitesTermStoresGroupsSetsTermsRelationsGetRefToTermRequest {
	return ApiSitesTermStoresGroupsSetsTermsRelationsGetRefToTermRequest{
		ApiService: a,
		ctx: ctx,
		siteId: siteId,
		storeId: storeId,
		groupId: groupId,
		setId: setId,
		termId: termId,
		relationId: relationId,
	}
}

// Execute executes the request
//  @return string
func (a *SitesStoreApiService) SitesTermStoresGroupsSetsTermsRelationsGetRefToTermExecute(r ApiSitesTermStoresGroupsSetsTermsRelationsGetRefToTermRequest) (string, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  string
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SitesStoreApiService.SitesTermStoresGroupsSetsTermsRelationsGetRefToTerm")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sites/{site-id}/termStores/{store-id}/groups/{group-id}/sets/{set-id}/terms/{term-id}/relations/{relation-id}/toTerm/$ref"
	localVarPath = strings.Replace(localVarPath, "{"+"site-id"+"}", _neturl.PathEscape(parameterToString(r.siteId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"store-id"+"}", _neturl.PathEscape(parameterToString(r.storeId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"set-id"+"}", _neturl.PathEscape(parameterToString(r.setId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"term-id"+"}", _neturl.PathEscape(parameterToString(r.termId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"relation-id"+"}", _neturl.PathEscape(parameterToString(r.relationId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSitesTermStoresGroupsSetsTermsRelationsGetSetRequest struct {
	ctx _context.Context
	ApiService *SitesStoreApiService
	siteId string
	storeId string
	groupId string
	setId string
	termId string
	relationId string
	select_ *[]string
	expand *[]string
}

// Select properties to be returned
func (r ApiSitesTermStoresGroupsSetsTermsRelationsGetSetRequest) Select_(select_ []string) ApiSitesTermStoresGroupsSetsTermsRelationsGetSetRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiSitesTermStoresGroupsSetsTermsRelationsGetSetRequest) Expand(expand []string) ApiSitesTermStoresGroupsSetsTermsRelationsGetSetRequest {
	r.expand = &expand
	return r
}

func (r ApiSitesTermStoresGroupsSetsTermsRelationsGetSetRequest) Execute() (MicrosoftGraphTermStoreSet, *_nethttp.Response, error) {
	return r.ApiService.SitesTermStoresGroupsSetsTermsRelationsGetSetExecute(r)
}

/*
SitesTermStoresGroupsSetsTermsRelationsGetSet Get set from sites

The [set] in which the relation is relevant.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param siteId key: id of site
 @param storeId key: id of store
 @param groupId key: id of group
 @param setId key: id of set
 @param termId key: id of term
 @param relationId key: id of relation
 @return ApiSitesTermStoresGroupsSetsTermsRelationsGetSetRequest
*/
func (a *SitesStoreApiService) SitesTermStoresGroupsSetsTermsRelationsGetSet(ctx _context.Context, siteId string, storeId string, groupId string, setId string, termId string, relationId string) ApiSitesTermStoresGroupsSetsTermsRelationsGetSetRequest {
	return ApiSitesTermStoresGroupsSetsTermsRelationsGetSetRequest{
		ApiService: a,
		ctx: ctx,
		siteId: siteId,
		storeId: storeId,
		groupId: groupId,
		setId: setId,
		termId: termId,
		relationId: relationId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphTermStoreSet
func (a *SitesStoreApiService) SitesTermStoresGroupsSetsTermsRelationsGetSetExecute(r ApiSitesTermStoresGroupsSetsTermsRelationsGetSetRequest) (MicrosoftGraphTermStoreSet, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphTermStoreSet
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SitesStoreApiService.SitesTermStoresGroupsSetsTermsRelationsGetSet")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sites/{site-id}/termStores/{store-id}/groups/{group-id}/sets/{set-id}/terms/{term-id}/relations/{relation-id}/set"
	localVarPath = strings.Replace(localVarPath, "{"+"site-id"+"}", _neturl.PathEscape(parameterToString(r.siteId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"store-id"+"}", _neturl.PathEscape(parameterToString(r.storeId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"set-id"+"}", _neturl.PathEscape(parameterToString(r.setId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"term-id"+"}", _neturl.PathEscape(parameterToString(r.termId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"relation-id"+"}", _neturl.PathEscape(parameterToString(r.relationId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSitesTermStoresGroupsSetsTermsRelationsGetToTermRequest struct {
	ctx _context.Context
	ApiService *SitesStoreApiService
	siteId string
	storeId string
	groupId string
	setId string
	termId string
	relationId string
	select_ *[]string
	expand *[]string
}

// Select properties to be returned
func (r ApiSitesTermStoresGroupsSetsTermsRelationsGetToTermRequest) Select_(select_ []string) ApiSitesTermStoresGroupsSetsTermsRelationsGetToTermRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiSitesTermStoresGroupsSetsTermsRelationsGetToTermRequest) Expand(expand []string) ApiSitesTermStoresGroupsSetsTermsRelationsGetToTermRequest {
	r.expand = &expand
	return r
}

func (r ApiSitesTermStoresGroupsSetsTermsRelationsGetToTermRequest) Execute() (MicrosoftGraphTermStoreTerm, *_nethttp.Response, error) {
	return r.ApiService.SitesTermStoresGroupsSetsTermsRelationsGetToTermExecute(r)
}

/*
SitesTermStoresGroupsSetsTermsRelationsGetToTerm Get toTerm from sites

The to [term] of the relation. The term to which the relationship is defined.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param siteId key: id of site
 @param storeId key: id of store
 @param groupId key: id of group
 @param setId key: id of set
 @param termId key: id of term
 @param relationId key: id of relation
 @return ApiSitesTermStoresGroupsSetsTermsRelationsGetToTermRequest
*/
func (a *SitesStoreApiService) SitesTermStoresGroupsSetsTermsRelationsGetToTerm(ctx _context.Context, siteId string, storeId string, groupId string, setId string, termId string, relationId string) ApiSitesTermStoresGroupsSetsTermsRelationsGetToTermRequest {
	return ApiSitesTermStoresGroupsSetsTermsRelationsGetToTermRequest{
		ApiService: a,
		ctx: ctx,
		siteId: siteId,
		storeId: storeId,
		groupId: groupId,
		setId: setId,
		termId: termId,
		relationId: relationId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphTermStoreTerm
func (a *SitesStoreApiService) SitesTermStoresGroupsSetsTermsRelationsGetToTermExecute(r ApiSitesTermStoresGroupsSetsTermsRelationsGetToTermRequest) (MicrosoftGraphTermStoreTerm, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphTermStoreTerm
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SitesStoreApiService.SitesTermStoresGroupsSetsTermsRelationsGetToTerm")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sites/{site-id}/termStores/{store-id}/groups/{group-id}/sets/{set-id}/terms/{term-id}/relations/{relation-id}/toTerm"
	localVarPath = strings.Replace(localVarPath, "{"+"site-id"+"}", _neturl.PathEscape(parameterToString(r.siteId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"store-id"+"}", _neturl.PathEscape(parameterToString(r.storeId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"set-id"+"}", _neturl.PathEscape(parameterToString(r.setId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"term-id"+"}", _neturl.PathEscape(parameterToString(r.termId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"relation-id"+"}", _neturl.PathEscape(parameterToString(r.relationId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSitesTermStoresGroupsSetsTermsRelationsUpdateRefFromTermRequest struct {
	ctx _context.Context
	ApiService *SitesStoreApiService
	siteId string
	storeId string
	groupId string
	setId string
	termId string
	relationId string
	requestBody *map[string]map[string]interface{}
}

// New navigation property ref values
func (r ApiSitesTermStoresGroupsSetsTermsRelationsUpdateRefFromTermRequest) RequestBody(requestBody map[string]map[string]interface{}) ApiSitesTermStoresGroupsSetsTermsRelationsUpdateRefFromTermRequest {
	r.requestBody = &requestBody
	return r
}

func (r ApiSitesTermStoresGroupsSetsTermsRelationsUpdateRefFromTermRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.SitesTermStoresGroupsSetsTermsRelationsUpdateRefFromTermExecute(r)
}

/*
SitesTermStoresGroupsSetsTermsRelationsUpdateRefFromTerm Update the ref of navigation property fromTerm in sites

The from [term] of the relation. The term from which the relationship is defined. A null value would indicate the relation is directly with the [set].

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param siteId key: id of site
 @param storeId key: id of store
 @param groupId key: id of group
 @param setId key: id of set
 @param termId key: id of term
 @param relationId key: id of relation
 @return ApiSitesTermStoresGroupsSetsTermsRelationsUpdateRefFromTermRequest
*/
func (a *SitesStoreApiService) SitesTermStoresGroupsSetsTermsRelationsUpdateRefFromTerm(ctx _context.Context, siteId string, storeId string, groupId string, setId string, termId string, relationId string) ApiSitesTermStoresGroupsSetsTermsRelationsUpdateRefFromTermRequest {
	return ApiSitesTermStoresGroupsSetsTermsRelationsUpdateRefFromTermRequest{
		ApiService: a,
		ctx: ctx,
		siteId: siteId,
		storeId: storeId,
		groupId: groupId,
		setId: setId,
		termId: termId,
		relationId: relationId,
	}
}

// Execute executes the request
func (a *SitesStoreApiService) SitesTermStoresGroupsSetsTermsRelationsUpdateRefFromTermExecute(r ApiSitesTermStoresGroupsSetsTermsRelationsUpdateRefFromTermRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPut
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SitesStoreApiService.SitesTermStoresGroupsSetsTermsRelationsUpdateRefFromTerm")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sites/{site-id}/termStores/{store-id}/groups/{group-id}/sets/{set-id}/terms/{term-id}/relations/{relation-id}/fromTerm/$ref"
	localVarPath = strings.Replace(localVarPath, "{"+"site-id"+"}", _neturl.PathEscape(parameterToString(r.siteId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"store-id"+"}", _neturl.PathEscape(parameterToString(r.storeId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"set-id"+"}", _neturl.PathEscape(parameterToString(r.setId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"term-id"+"}", _neturl.PathEscape(parameterToString(r.termId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"relation-id"+"}", _neturl.PathEscape(parameterToString(r.relationId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.requestBody == nil {
		return nil, reportError("requestBody is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.requestBody
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiSitesTermStoresGroupsSetsTermsRelationsUpdateRefSetRequest struct {
	ctx _context.Context
	ApiService *SitesStoreApiService
	siteId string
	storeId string
	groupId string
	setId string
	termId string
	relationId string
	requestBody *map[string]map[string]interface{}
}

// New navigation property ref values
func (r ApiSitesTermStoresGroupsSetsTermsRelationsUpdateRefSetRequest) RequestBody(requestBody map[string]map[string]interface{}) ApiSitesTermStoresGroupsSetsTermsRelationsUpdateRefSetRequest {
	r.requestBody = &requestBody
	return r
}

func (r ApiSitesTermStoresGroupsSetsTermsRelationsUpdateRefSetRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.SitesTermStoresGroupsSetsTermsRelationsUpdateRefSetExecute(r)
}

/*
SitesTermStoresGroupsSetsTermsRelationsUpdateRefSet Update the ref of navigation property set in sites

The [set] in which the relation is relevant.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param siteId key: id of site
 @param storeId key: id of store
 @param groupId key: id of group
 @param setId key: id of set
 @param termId key: id of term
 @param relationId key: id of relation
 @return ApiSitesTermStoresGroupsSetsTermsRelationsUpdateRefSetRequest
*/
func (a *SitesStoreApiService) SitesTermStoresGroupsSetsTermsRelationsUpdateRefSet(ctx _context.Context, siteId string, storeId string, groupId string, setId string, termId string, relationId string) ApiSitesTermStoresGroupsSetsTermsRelationsUpdateRefSetRequest {
	return ApiSitesTermStoresGroupsSetsTermsRelationsUpdateRefSetRequest{
		ApiService: a,
		ctx: ctx,
		siteId: siteId,
		storeId: storeId,
		groupId: groupId,
		setId: setId,
		termId: termId,
		relationId: relationId,
	}
}

// Execute executes the request
func (a *SitesStoreApiService) SitesTermStoresGroupsSetsTermsRelationsUpdateRefSetExecute(r ApiSitesTermStoresGroupsSetsTermsRelationsUpdateRefSetRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPut
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SitesStoreApiService.SitesTermStoresGroupsSetsTermsRelationsUpdateRefSet")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sites/{site-id}/termStores/{store-id}/groups/{group-id}/sets/{set-id}/terms/{term-id}/relations/{relation-id}/set/$ref"
	localVarPath = strings.Replace(localVarPath, "{"+"site-id"+"}", _neturl.PathEscape(parameterToString(r.siteId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"store-id"+"}", _neturl.PathEscape(parameterToString(r.storeId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"set-id"+"}", _neturl.PathEscape(parameterToString(r.setId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"term-id"+"}", _neturl.PathEscape(parameterToString(r.termId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"relation-id"+"}", _neturl.PathEscape(parameterToString(r.relationId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.requestBody == nil {
		return nil, reportError("requestBody is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.requestBody
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiSitesTermStoresGroupsSetsTermsRelationsUpdateRefToTermRequest struct {
	ctx _context.Context
	ApiService *SitesStoreApiService
	siteId string
	storeId string
	groupId string
	setId string
	termId string
	relationId string
	requestBody *map[string]map[string]interface{}
}

// New navigation property ref values
func (r ApiSitesTermStoresGroupsSetsTermsRelationsUpdateRefToTermRequest) RequestBody(requestBody map[string]map[string]interface{}) ApiSitesTermStoresGroupsSetsTermsRelationsUpdateRefToTermRequest {
	r.requestBody = &requestBody
	return r
}

func (r ApiSitesTermStoresGroupsSetsTermsRelationsUpdateRefToTermRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.SitesTermStoresGroupsSetsTermsRelationsUpdateRefToTermExecute(r)
}

/*
SitesTermStoresGroupsSetsTermsRelationsUpdateRefToTerm Update the ref of navigation property toTerm in sites

The to [term] of the relation. The term to which the relationship is defined.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param siteId key: id of site
 @param storeId key: id of store
 @param groupId key: id of group
 @param setId key: id of set
 @param termId key: id of term
 @param relationId key: id of relation
 @return ApiSitesTermStoresGroupsSetsTermsRelationsUpdateRefToTermRequest
*/
func (a *SitesStoreApiService) SitesTermStoresGroupsSetsTermsRelationsUpdateRefToTerm(ctx _context.Context, siteId string, storeId string, groupId string, setId string, termId string, relationId string) ApiSitesTermStoresGroupsSetsTermsRelationsUpdateRefToTermRequest {
	return ApiSitesTermStoresGroupsSetsTermsRelationsUpdateRefToTermRequest{
		ApiService: a,
		ctx: ctx,
		siteId: siteId,
		storeId: storeId,
		groupId: groupId,
		setId: setId,
		termId: termId,
		relationId: relationId,
	}
}

// Execute executes the request
func (a *SitesStoreApiService) SitesTermStoresGroupsSetsTermsRelationsUpdateRefToTermExecute(r ApiSitesTermStoresGroupsSetsTermsRelationsUpdateRefToTermRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPut
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SitesStoreApiService.SitesTermStoresGroupsSetsTermsRelationsUpdateRefToTerm")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sites/{site-id}/termStores/{store-id}/groups/{group-id}/sets/{set-id}/terms/{term-id}/relations/{relation-id}/toTerm/$ref"
	localVarPath = strings.Replace(localVarPath, "{"+"site-id"+"}", _neturl.PathEscape(parameterToString(r.siteId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"store-id"+"}", _neturl.PathEscape(parameterToString(r.storeId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"set-id"+"}", _neturl.PathEscape(parameterToString(r.setId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"term-id"+"}", _neturl.PathEscape(parameterToString(r.termId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"relation-id"+"}", _neturl.PathEscape(parameterToString(r.relationId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.requestBody == nil {
		return nil, reportError("requestBody is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.requestBody
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiSitesTermStoresGroupsSetsTermsUpdateChildrenRequest struct {
	ctx _context.Context
	ApiService *SitesStoreApiService
	siteId string
	storeId string
	groupId string
	setId string
	termId string
	termId1 string
	microsoftGraphTermStoreTerm *MicrosoftGraphTermStoreTerm
}

// New navigation property values
func (r ApiSitesTermStoresGroupsSetsTermsUpdateChildrenRequest) MicrosoftGraphTermStoreTerm(microsoftGraphTermStoreTerm MicrosoftGraphTermStoreTerm) ApiSitesTermStoresGroupsSetsTermsUpdateChildrenRequest {
	r.microsoftGraphTermStoreTerm = &microsoftGraphTermStoreTerm
	return r
}

func (r ApiSitesTermStoresGroupsSetsTermsUpdateChildrenRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.SitesTermStoresGroupsSetsTermsUpdateChildrenExecute(r)
}

/*
SitesTermStoresGroupsSetsTermsUpdateChildren Update the navigation property children in sites

Children of current term.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param siteId key: id of site
 @param storeId key: id of store
 @param groupId key: id of group
 @param setId key: id of set
 @param termId key: id of term
 @param termId1 key: id of term
 @return ApiSitesTermStoresGroupsSetsTermsUpdateChildrenRequest
*/
func (a *SitesStoreApiService) SitesTermStoresGroupsSetsTermsUpdateChildren(ctx _context.Context, siteId string, storeId string, groupId string, setId string, termId string, termId1 string) ApiSitesTermStoresGroupsSetsTermsUpdateChildrenRequest {
	return ApiSitesTermStoresGroupsSetsTermsUpdateChildrenRequest{
		ApiService: a,
		ctx: ctx,
		siteId: siteId,
		storeId: storeId,
		groupId: groupId,
		setId: setId,
		termId: termId,
		termId1: termId1,
	}
}

// Execute executes the request
func (a *SitesStoreApiService) SitesTermStoresGroupsSetsTermsUpdateChildrenExecute(r ApiSitesTermStoresGroupsSetsTermsUpdateChildrenRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPatch
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SitesStoreApiService.SitesTermStoresGroupsSetsTermsUpdateChildren")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sites/{site-id}/termStores/{store-id}/groups/{group-id}/sets/{set-id}/terms/{term-id}/children/{term-id1}"
	localVarPath = strings.Replace(localVarPath, "{"+"site-id"+"}", _neturl.PathEscape(parameterToString(r.siteId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"store-id"+"}", _neturl.PathEscape(parameterToString(r.storeId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"set-id"+"}", _neturl.PathEscape(parameterToString(r.setId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"term-id"+"}", _neturl.PathEscape(parameterToString(r.termId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"term-id1"+"}", _neturl.PathEscape(parameterToString(r.termId1, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphTermStoreTerm == nil {
		return nil, reportError("microsoftGraphTermStoreTerm is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphTermStoreTerm
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiSitesTermStoresGroupsSetsTermsUpdateRefSetRequest struct {
	ctx _context.Context
	ApiService *SitesStoreApiService
	siteId string
	storeId string
	groupId string
	setId string
	termId string
	requestBody *map[string]map[string]interface{}
}

// New navigation property ref values
func (r ApiSitesTermStoresGroupsSetsTermsUpdateRefSetRequest) RequestBody(requestBody map[string]map[string]interface{}) ApiSitesTermStoresGroupsSetsTermsUpdateRefSetRequest {
	r.requestBody = &requestBody
	return r
}

func (r ApiSitesTermStoresGroupsSetsTermsUpdateRefSetRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.SitesTermStoresGroupsSetsTermsUpdateRefSetExecute(r)
}

/*
SitesTermStoresGroupsSetsTermsUpdateRefSet Update the ref of navigation property set in sites

The [set] in which the term is created.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param siteId key: id of site
 @param storeId key: id of store
 @param groupId key: id of group
 @param setId key: id of set
 @param termId key: id of term
 @return ApiSitesTermStoresGroupsSetsTermsUpdateRefSetRequest
*/
func (a *SitesStoreApiService) SitesTermStoresGroupsSetsTermsUpdateRefSet(ctx _context.Context, siteId string, storeId string, groupId string, setId string, termId string) ApiSitesTermStoresGroupsSetsTermsUpdateRefSetRequest {
	return ApiSitesTermStoresGroupsSetsTermsUpdateRefSetRequest{
		ApiService: a,
		ctx: ctx,
		siteId: siteId,
		storeId: storeId,
		groupId: groupId,
		setId: setId,
		termId: termId,
	}
}

// Execute executes the request
func (a *SitesStoreApiService) SitesTermStoresGroupsSetsTermsUpdateRefSetExecute(r ApiSitesTermStoresGroupsSetsTermsUpdateRefSetRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPut
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SitesStoreApiService.SitesTermStoresGroupsSetsTermsUpdateRefSet")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sites/{site-id}/termStores/{store-id}/groups/{group-id}/sets/{set-id}/terms/{term-id}/set/$ref"
	localVarPath = strings.Replace(localVarPath, "{"+"site-id"+"}", _neturl.PathEscape(parameterToString(r.siteId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"store-id"+"}", _neturl.PathEscape(parameterToString(r.storeId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"set-id"+"}", _neturl.PathEscape(parameterToString(r.setId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"term-id"+"}", _neturl.PathEscape(parameterToString(r.termId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.requestBody == nil {
		return nil, reportError("requestBody is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.requestBody
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiSitesTermStoresGroupsSetsTermsUpdateRelationsRequest struct {
	ctx _context.Context
	ApiService *SitesStoreApiService
	siteId string
	storeId string
	groupId string
	setId string
	termId string
	relationId string
	microsoftGraphTermStoreRelation *MicrosoftGraphTermStoreRelation
}

// New navigation property values
func (r ApiSitesTermStoresGroupsSetsTermsUpdateRelationsRequest) MicrosoftGraphTermStoreRelation(microsoftGraphTermStoreRelation MicrosoftGraphTermStoreRelation) ApiSitesTermStoresGroupsSetsTermsUpdateRelationsRequest {
	r.microsoftGraphTermStoreRelation = &microsoftGraphTermStoreRelation
	return r
}

func (r ApiSitesTermStoresGroupsSetsTermsUpdateRelationsRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.SitesTermStoresGroupsSetsTermsUpdateRelationsExecute(r)
}

/*
SitesTermStoresGroupsSetsTermsUpdateRelations Update the navigation property relations in sites

To indicate which terms are related to the current term as either pinned or reused.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param siteId key: id of site
 @param storeId key: id of store
 @param groupId key: id of group
 @param setId key: id of set
 @param termId key: id of term
 @param relationId key: id of relation
 @return ApiSitesTermStoresGroupsSetsTermsUpdateRelationsRequest
*/
func (a *SitesStoreApiService) SitesTermStoresGroupsSetsTermsUpdateRelations(ctx _context.Context, siteId string, storeId string, groupId string, setId string, termId string, relationId string) ApiSitesTermStoresGroupsSetsTermsUpdateRelationsRequest {
	return ApiSitesTermStoresGroupsSetsTermsUpdateRelationsRequest{
		ApiService: a,
		ctx: ctx,
		siteId: siteId,
		storeId: storeId,
		groupId: groupId,
		setId: setId,
		termId: termId,
		relationId: relationId,
	}
}

// Execute executes the request
func (a *SitesStoreApiService) SitesTermStoresGroupsSetsTermsUpdateRelationsExecute(r ApiSitesTermStoresGroupsSetsTermsUpdateRelationsRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPatch
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SitesStoreApiService.SitesTermStoresGroupsSetsTermsUpdateRelations")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sites/{site-id}/termStores/{store-id}/groups/{group-id}/sets/{set-id}/terms/{term-id}/relations/{relation-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"site-id"+"}", _neturl.PathEscape(parameterToString(r.siteId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"store-id"+"}", _neturl.PathEscape(parameterToString(r.storeId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"set-id"+"}", _neturl.PathEscape(parameterToString(r.setId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"term-id"+"}", _neturl.PathEscape(parameterToString(r.termId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"relation-id"+"}", _neturl.PathEscape(parameterToString(r.relationId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphTermStoreRelation == nil {
		return nil, reportError("microsoftGraphTermStoreRelation is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphTermStoreRelation
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiSitesTermStoresGroupsSetsUpdateChildrenRequest struct {
	ctx _context.Context
	ApiService *SitesStoreApiService
	siteId string
	storeId string
	groupId string
	setId string
	termId string
	microsoftGraphTermStoreTerm *MicrosoftGraphTermStoreTerm
}

// New navigation property values
func (r ApiSitesTermStoresGroupsSetsUpdateChildrenRequest) MicrosoftGraphTermStoreTerm(microsoftGraphTermStoreTerm MicrosoftGraphTermStoreTerm) ApiSitesTermStoresGroupsSetsUpdateChildrenRequest {
	r.microsoftGraphTermStoreTerm = &microsoftGraphTermStoreTerm
	return r
}

func (r ApiSitesTermStoresGroupsSetsUpdateChildrenRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.SitesTermStoresGroupsSetsUpdateChildrenExecute(r)
}

/*
SitesTermStoresGroupsSetsUpdateChildren Update the navigation property children in sites

Children terms of set in term [store].

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param siteId key: id of site
 @param storeId key: id of store
 @param groupId key: id of group
 @param setId key: id of set
 @param termId key: id of term
 @return ApiSitesTermStoresGroupsSetsUpdateChildrenRequest
*/
func (a *SitesStoreApiService) SitesTermStoresGroupsSetsUpdateChildren(ctx _context.Context, siteId string, storeId string, groupId string, setId string, termId string) ApiSitesTermStoresGroupsSetsUpdateChildrenRequest {
	return ApiSitesTermStoresGroupsSetsUpdateChildrenRequest{
		ApiService: a,
		ctx: ctx,
		siteId: siteId,
		storeId: storeId,
		groupId: groupId,
		setId: setId,
		termId: termId,
	}
}

// Execute executes the request
func (a *SitesStoreApiService) SitesTermStoresGroupsSetsUpdateChildrenExecute(r ApiSitesTermStoresGroupsSetsUpdateChildrenRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPatch
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SitesStoreApiService.SitesTermStoresGroupsSetsUpdateChildren")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sites/{site-id}/termStores/{store-id}/groups/{group-id}/sets/{set-id}/children/{term-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"site-id"+"}", _neturl.PathEscape(parameterToString(r.siteId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"store-id"+"}", _neturl.PathEscape(parameterToString(r.storeId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"set-id"+"}", _neturl.PathEscape(parameterToString(r.setId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"term-id"+"}", _neturl.PathEscape(parameterToString(r.termId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphTermStoreTerm == nil {
		return nil, reportError("microsoftGraphTermStoreTerm is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphTermStoreTerm
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiSitesTermStoresGroupsSetsUpdateParentGroupRequest struct {
	ctx _context.Context
	ApiService *SitesStoreApiService
	siteId string
	storeId string
	groupId string
	setId string
	microsoftGraphTermStoreGroup *MicrosoftGraphTermStoreGroup
}

// New navigation property values
func (r ApiSitesTermStoresGroupsSetsUpdateParentGroupRequest) MicrosoftGraphTermStoreGroup(microsoftGraphTermStoreGroup MicrosoftGraphTermStoreGroup) ApiSitesTermStoresGroupsSetsUpdateParentGroupRequest {
	r.microsoftGraphTermStoreGroup = &microsoftGraphTermStoreGroup
	return r
}

func (r ApiSitesTermStoresGroupsSetsUpdateParentGroupRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.SitesTermStoresGroupsSetsUpdateParentGroupExecute(r)
}

/*
SitesTermStoresGroupsSetsUpdateParentGroup Update the navigation property parentGroup in sites

The parent [group] that contains the set.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param siteId key: id of site
 @param storeId key: id of store
 @param groupId key: id of group
 @param setId key: id of set
 @return ApiSitesTermStoresGroupsSetsUpdateParentGroupRequest
*/
func (a *SitesStoreApiService) SitesTermStoresGroupsSetsUpdateParentGroup(ctx _context.Context, siteId string, storeId string, groupId string, setId string) ApiSitesTermStoresGroupsSetsUpdateParentGroupRequest {
	return ApiSitesTermStoresGroupsSetsUpdateParentGroupRequest{
		ApiService: a,
		ctx: ctx,
		siteId: siteId,
		storeId: storeId,
		groupId: groupId,
		setId: setId,
	}
}

// Execute executes the request
func (a *SitesStoreApiService) SitesTermStoresGroupsSetsUpdateParentGroupExecute(r ApiSitesTermStoresGroupsSetsUpdateParentGroupRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPatch
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SitesStoreApiService.SitesTermStoresGroupsSetsUpdateParentGroup")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sites/{site-id}/termStores/{store-id}/groups/{group-id}/sets/{set-id}/parentGroup"
	localVarPath = strings.Replace(localVarPath, "{"+"site-id"+"}", _neturl.PathEscape(parameterToString(r.siteId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"store-id"+"}", _neturl.PathEscape(parameterToString(r.storeId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"set-id"+"}", _neturl.PathEscape(parameterToString(r.setId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphTermStoreGroup == nil {
		return nil, reportError("microsoftGraphTermStoreGroup is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphTermStoreGroup
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiSitesTermStoresGroupsSetsUpdateRelationsRequest struct {
	ctx _context.Context
	ApiService *SitesStoreApiService
	siteId string
	storeId string
	groupId string
	setId string
	relationId string
	microsoftGraphTermStoreRelation *MicrosoftGraphTermStoreRelation
}

// New navigation property values
func (r ApiSitesTermStoresGroupsSetsUpdateRelationsRequest) MicrosoftGraphTermStoreRelation(microsoftGraphTermStoreRelation MicrosoftGraphTermStoreRelation) ApiSitesTermStoresGroupsSetsUpdateRelationsRequest {
	r.microsoftGraphTermStoreRelation = &microsoftGraphTermStoreRelation
	return r
}

func (r ApiSitesTermStoresGroupsSetsUpdateRelationsRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.SitesTermStoresGroupsSetsUpdateRelationsExecute(r)
}

/*
SitesTermStoresGroupsSetsUpdateRelations Update the navigation property relations in sites

Indicates which terms have been pinned or reused directly under the set.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param siteId key: id of site
 @param storeId key: id of store
 @param groupId key: id of group
 @param setId key: id of set
 @param relationId key: id of relation
 @return ApiSitesTermStoresGroupsSetsUpdateRelationsRequest
*/
func (a *SitesStoreApiService) SitesTermStoresGroupsSetsUpdateRelations(ctx _context.Context, siteId string, storeId string, groupId string, setId string, relationId string) ApiSitesTermStoresGroupsSetsUpdateRelationsRequest {
	return ApiSitesTermStoresGroupsSetsUpdateRelationsRequest{
		ApiService: a,
		ctx: ctx,
		siteId: siteId,
		storeId: storeId,
		groupId: groupId,
		setId: setId,
		relationId: relationId,
	}
}

// Execute executes the request
func (a *SitesStoreApiService) SitesTermStoresGroupsSetsUpdateRelationsExecute(r ApiSitesTermStoresGroupsSetsUpdateRelationsRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPatch
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SitesStoreApiService.SitesTermStoresGroupsSetsUpdateRelations")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sites/{site-id}/termStores/{store-id}/groups/{group-id}/sets/{set-id}/relations/{relation-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"site-id"+"}", _neturl.PathEscape(parameterToString(r.siteId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"store-id"+"}", _neturl.PathEscape(parameterToString(r.storeId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"set-id"+"}", _neturl.PathEscape(parameterToString(r.setId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"relation-id"+"}", _neturl.PathEscape(parameterToString(r.relationId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphTermStoreRelation == nil {
		return nil, reportError("microsoftGraphTermStoreRelation is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphTermStoreRelation
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiSitesTermStoresGroupsSetsUpdateTermsRequest struct {
	ctx _context.Context
	ApiService *SitesStoreApiService
	siteId string
	storeId string
	groupId string
	setId string
	termId string
	microsoftGraphTermStoreTerm *MicrosoftGraphTermStoreTerm
}

// New navigation property values
func (r ApiSitesTermStoresGroupsSetsUpdateTermsRequest) MicrosoftGraphTermStoreTerm(microsoftGraphTermStoreTerm MicrosoftGraphTermStoreTerm) ApiSitesTermStoresGroupsSetsUpdateTermsRequest {
	r.microsoftGraphTermStoreTerm = &microsoftGraphTermStoreTerm
	return r
}

func (r ApiSitesTermStoresGroupsSetsUpdateTermsRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.SitesTermStoresGroupsSetsUpdateTermsExecute(r)
}

/*
SitesTermStoresGroupsSetsUpdateTerms Update the navigation property terms in sites

All the terms under the set.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param siteId key: id of site
 @param storeId key: id of store
 @param groupId key: id of group
 @param setId key: id of set
 @param termId key: id of term
 @return ApiSitesTermStoresGroupsSetsUpdateTermsRequest
*/
func (a *SitesStoreApiService) SitesTermStoresGroupsSetsUpdateTerms(ctx _context.Context, siteId string, storeId string, groupId string, setId string, termId string) ApiSitesTermStoresGroupsSetsUpdateTermsRequest {
	return ApiSitesTermStoresGroupsSetsUpdateTermsRequest{
		ApiService: a,
		ctx: ctx,
		siteId: siteId,
		storeId: storeId,
		groupId: groupId,
		setId: setId,
		termId: termId,
	}
}

// Execute executes the request
func (a *SitesStoreApiService) SitesTermStoresGroupsSetsUpdateTermsExecute(r ApiSitesTermStoresGroupsSetsUpdateTermsRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPatch
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SitesStoreApiService.SitesTermStoresGroupsSetsUpdateTerms")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sites/{site-id}/termStores/{store-id}/groups/{group-id}/sets/{set-id}/terms/{term-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"site-id"+"}", _neturl.PathEscape(parameterToString(r.siteId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"store-id"+"}", _neturl.PathEscape(parameterToString(r.storeId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"set-id"+"}", _neturl.PathEscape(parameterToString(r.setId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"term-id"+"}", _neturl.PathEscape(parameterToString(r.termId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphTermStoreTerm == nil {
		return nil, reportError("microsoftGraphTermStoreTerm is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphTermStoreTerm
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiSitesTermStoresGroupsUpdateSetsRequest struct {
	ctx _context.Context
	ApiService *SitesStoreApiService
	siteId string
	storeId string
	groupId string
	setId string
	microsoftGraphTermStoreSet *MicrosoftGraphTermStoreSet
}

// New navigation property values
func (r ApiSitesTermStoresGroupsUpdateSetsRequest) MicrosoftGraphTermStoreSet(microsoftGraphTermStoreSet MicrosoftGraphTermStoreSet) ApiSitesTermStoresGroupsUpdateSetsRequest {
	r.microsoftGraphTermStoreSet = &microsoftGraphTermStoreSet
	return r
}

func (r ApiSitesTermStoresGroupsUpdateSetsRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.SitesTermStoresGroupsUpdateSetsExecute(r)
}

/*
SitesTermStoresGroupsUpdateSets Update the navigation property sets in sites

All sets under the group in a term [store].

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param siteId key: id of site
 @param storeId key: id of store
 @param groupId key: id of group
 @param setId key: id of set
 @return ApiSitesTermStoresGroupsUpdateSetsRequest
*/
func (a *SitesStoreApiService) SitesTermStoresGroupsUpdateSets(ctx _context.Context, siteId string, storeId string, groupId string, setId string) ApiSitesTermStoresGroupsUpdateSetsRequest {
	return ApiSitesTermStoresGroupsUpdateSetsRequest{
		ApiService: a,
		ctx: ctx,
		siteId: siteId,
		storeId: storeId,
		groupId: groupId,
		setId: setId,
	}
}

// Execute executes the request
func (a *SitesStoreApiService) SitesTermStoresGroupsUpdateSetsExecute(r ApiSitesTermStoresGroupsUpdateSetsRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPatch
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SitesStoreApiService.SitesTermStoresGroupsUpdateSets")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sites/{site-id}/termStores/{store-id}/groups/{group-id}/sets/{set-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"site-id"+"}", _neturl.PathEscape(parameterToString(r.siteId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"store-id"+"}", _neturl.PathEscape(parameterToString(r.storeId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"set-id"+"}", _neturl.PathEscape(parameterToString(r.setId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphTermStoreSet == nil {
		return nil, reportError("microsoftGraphTermStoreSet is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphTermStoreSet
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiSitesTermStoresListGroupsRequest struct {
	ctx _context.Context
	ApiService *SitesStoreApiService
	siteId string
	storeId string
	top *int32
	skip *int32
	search *string
	filter *string
	count *bool
	orderby *[]string
	select_ *[]string
	expand *[]string
}

// Show only the first n items
func (r ApiSitesTermStoresListGroupsRequest) Top(top int32) ApiSitesTermStoresListGroupsRequest {
	r.top = &top
	return r
}
// Skip the first n items
func (r ApiSitesTermStoresListGroupsRequest) Skip(skip int32) ApiSitesTermStoresListGroupsRequest {
	r.skip = &skip
	return r
}
// Search items by search phrases
func (r ApiSitesTermStoresListGroupsRequest) Search(search string) ApiSitesTermStoresListGroupsRequest {
	r.search = &search
	return r
}
// Filter items by property values
func (r ApiSitesTermStoresListGroupsRequest) Filter(filter string) ApiSitesTermStoresListGroupsRequest {
	r.filter = &filter
	return r
}
// Include count of items
func (r ApiSitesTermStoresListGroupsRequest) Count(count bool) ApiSitesTermStoresListGroupsRequest {
	r.count = &count
	return r
}
// Order items by property values
func (r ApiSitesTermStoresListGroupsRequest) Orderby(orderby []string) ApiSitesTermStoresListGroupsRequest {
	r.orderby = &orderby
	return r
}
// Select properties to be returned
func (r ApiSitesTermStoresListGroupsRequest) Select_(select_ []string) ApiSitesTermStoresListGroupsRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiSitesTermStoresListGroupsRequest) Expand(expand []string) ApiSitesTermStoresListGroupsRequest {
	r.expand = &expand
	return r
}

func (r ApiSitesTermStoresListGroupsRequest) Execute() (CollectionOfGroup1, *_nethttp.Response, error) {
	return r.ApiService.SitesTermStoresListGroupsExecute(r)
}

/*
SitesTermStoresListGroups Get groups from sites

Collection of all groups available in the term store.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param siteId key: id of site
 @param storeId key: id of store
 @return ApiSitesTermStoresListGroupsRequest
*/
func (a *SitesStoreApiService) SitesTermStoresListGroups(ctx _context.Context, siteId string, storeId string) ApiSitesTermStoresListGroupsRequest {
	return ApiSitesTermStoresListGroupsRequest{
		ApiService: a,
		ctx: ctx,
		siteId: siteId,
		storeId: storeId,
	}
}

// Execute executes the request
//  @return CollectionOfGroup1
func (a *SitesStoreApiService) SitesTermStoresListGroupsExecute(r ApiSitesTermStoresListGroupsRequest) (CollectionOfGroup1, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  CollectionOfGroup1
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SitesStoreApiService.SitesTermStoresListGroups")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sites/{site-id}/termStores/{store-id}/groups"
	localVarPath = strings.Replace(localVarPath, "{"+"site-id"+"}", _neturl.PathEscape(parameterToString(r.siteId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"store-id"+"}", _neturl.PathEscape(parameterToString(r.storeId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.top != nil {
		localVarQueryParams.Add("$top", parameterToString(*r.top, ""))
	}
	if r.skip != nil {
		localVarQueryParams.Add("$skip", parameterToString(*r.skip, ""))
	}
	if r.search != nil {
		localVarQueryParams.Add("$search", parameterToString(*r.search, ""))
	}
	if r.filter != nil {
		localVarQueryParams.Add("$filter", parameterToString(*r.filter, ""))
	}
	if r.count != nil {
		localVarQueryParams.Add("$count", parameterToString(*r.count, ""))
	}
	if r.orderby != nil {
		localVarQueryParams.Add("$orderby", parameterToString(*r.orderby, "csv"))
	}
	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSitesTermStoresListSetsRequest struct {
	ctx _context.Context
	ApiService *SitesStoreApiService
	siteId string
	storeId string
	top *int32
	skip *int32
	search *string
	filter *string
	count *bool
	orderby *[]string
	select_ *[]string
	expand *[]string
}

// Show only the first n items
func (r ApiSitesTermStoresListSetsRequest) Top(top int32) ApiSitesTermStoresListSetsRequest {
	r.top = &top
	return r
}
// Skip the first n items
func (r ApiSitesTermStoresListSetsRequest) Skip(skip int32) ApiSitesTermStoresListSetsRequest {
	r.skip = &skip
	return r
}
// Search items by search phrases
func (r ApiSitesTermStoresListSetsRequest) Search(search string) ApiSitesTermStoresListSetsRequest {
	r.search = &search
	return r
}
// Filter items by property values
func (r ApiSitesTermStoresListSetsRequest) Filter(filter string) ApiSitesTermStoresListSetsRequest {
	r.filter = &filter
	return r
}
// Include count of items
func (r ApiSitesTermStoresListSetsRequest) Count(count bool) ApiSitesTermStoresListSetsRequest {
	r.count = &count
	return r
}
// Order items by property values
func (r ApiSitesTermStoresListSetsRequest) Orderby(orderby []string) ApiSitesTermStoresListSetsRequest {
	r.orderby = &orderby
	return r
}
// Select properties to be returned
func (r ApiSitesTermStoresListSetsRequest) Select_(select_ []string) ApiSitesTermStoresListSetsRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiSitesTermStoresListSetsRequest) Expand(expand []string) ApiSitesTermStoresListSetsRequest {
	r.expand = &expand
	return r
}

func (r ApiSitesTermStoresListSetsRequest) Execute() (CollectionOfSet, *_nethttp.Response, error) {
	return r.ApiService.SitesTermStoresListSetsExecute(r)
}

/*
SitesTermStoresListSets Get sets from sites

Collection of all sets available in the term store.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param siteId key: id of site
 @param storeId key: id of store
 @return ApiSitesTermStoresListSetsRequest
*/
func (a *SitesStoreApiService) SitesTermStoresListSets(ctx _context.Context, siteId string, storeId string) ApiSitesTermStoresListSetsRequest {
	return ApiSitesTermStoresListSetsRequest{
		ApiService: a,
		ctx: ctx,
		siteId: siteId,
		storeId: storeId,
	}
}

// Execute executes the request
//  @return CollectionOfSet
func (a *SitesStoreApiService) SitesTermStoresListSetsExecute(r ApiSitesTermStoresListSetsRequest) (CollectionOfSet, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  CollectionOfSet
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SitesStoreApiService.SitesTermStoresListSets")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sites/{site-id}/termStores/{store-id}/sets"
	localVarPath = strings.Replace(localVarPath, "{"+"site-id"+"}", _neturl.PathEscape(parameterToString(r.siteId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"store-id"+"}", _neturl.PathEscape(parameterToString(r.storeId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.top != nil {
		localVarQueryParams.Add("$top", parameterToString(*r.top, ""))
	}
	if r.skip != nil {
		localVarQueryParams.Add("$skip", parameterToString(*r.skip, ""))
	}
	if r.search != nil {
		localVarQueryParams.Add("$search", parameterToString(*r.search, ""))
	}
	if r.filter != nil {
		localVarQueryParams.Add("$filter", parameterToString(*r.filter, ""))
	}
	if r.count != nil {
		localVarQueryParams.Add("$count", parameterToString(*r.count, ""))
	}
	if r.orderby != nil {
		localVarQueryParams.Add("$orderby", parameterToString(*r.orderby, "csv"))
	}
	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSitesTermStoresSetsChildrenCreateChildrenRequest struct {
	ctx _context.Context
	ApiService *SitesStoreApiService
	siteId string
	storeId string
	setId string
	termId string
	microsoftGraphTermStoreTerm *MicrosoftGraphTermStoreTerm
}

// New navigation property
func (r ApiSitesTermStoresSetsChildrenCreateChildrenRequest) MicrosoftGraphTermStoreTerm(microsoftGraphTermStoreTerm MicrosoftGraphTermStoreTerm) ApiSitesTermStoresSetsChildrenCreateChildrenRequest {
	r.microsoftGraphTermStoreTerm = &microsoftGraphTermStoreTerm
	return r
}

func (r ApiSitesTermStoresSetsChildrenCreateChildrenRequest) Execute() (MicrosoftGraphTermStoreTerm, *_nethttp.Response, error) {
	return r.ApiService.SitesTermStoresSetsChildrenCreateChildrenExecute(r)
}

/*
SitesTermStoresSetsChildrenCreateChildren Create new navigation property to children for sites

Children of current term.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param siteId key: id of site
 @param storeId key: id of store
 @param setId key: id of set
 @param termId key: id of term
 @return ApiSitesTermStoresSetsChildrenCreateChildrenRequest
*/
func (a *SitesStoreApiService) SitesTermStoresSetsChildrenCreateChildren(ctx _context.Context, siteId string, storeId string, setId string, termId string) ApiSitesTermStoresSetsChildrenCreateChildrenRequest {
	return ApiSitesTermStoresSetsChildrenCreateChildrenRequest{
		ApiService: a,
		ctx: ctx,
		siteId: siteId,
		storeId: storeId,
		setId: setId,
		termId: termId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphTermStoreTerm
func (a *SitesStoreApiService) SitesTermStoresSetsChildrenCreateChildrenExecute(r ApiSitesTermStoresSetsChildrenCreateChildrenRequest) (MicrosoftGraphTermStoreTerm, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphTermStoreTerm
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SitesStoreApiService.SitesTermStoresSetsChildrenCreateChildren")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sites/{site-id}/termStores/{store-id}/sets/{set-id}/children/{term-id}/children"
	localVarPath = strings.Replace(localVarPath, "{"+"site-id"+"}", _neturl.PathEscape(parameterToString(r.siteId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"store-id"+"}", _neturl.PathEscape(parameterToString(r.storeId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"set-id"+"}", _neturl.PathEscape(parameterToString(r.setId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"term-id"+"}", _neturl.PathEscape(parameterToString(r.termId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphTermStoreTerm == nil {
		return localVarReturnValue, nil, reportError("microsoftGraphTermStoreTerm is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphTermStoreTerm
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSitesTermStoresSetsChildrenCreateRelationsRequest struct {
	ctx _context.Context
	ApiService *SitesStoreApiService
	siteId string
	storeId string
	setId string
	termId string
	microsoftGraphTermStoreRelation *MicrosoftGraphTermStoreRelation
}

// New navigation property
func (r ApiSitesTermStoresSetsChildrenCreateRelationsRequest) MicrosoftGraphTermStoreRelation(microsoftGraphTermStoreRelation MicrosoftGraphTermStoreRelation) ApiSitesTermStoresSetsChildrenCreateRelationsRequest {
	r.microsoftGraphTermStoreRelation = &microsoftGraphTermStoreRelation
	return r
}

func (r ApiSitesTermStoresSetsChildrenCreateRelationsRequest) Execute() (MicrosoftGraphTermStoreRelation, *_nethttp.Response, error) {
	return r.ApiService.SitesTermStoresSetsChildrenCreateRelationsExecute(r)
}

/*
SitesTermStoresSetsChildrenCreateRelations Create new navigation property to relations for sites

To indicate which terms are related to the current term as either pinned or reused.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param siteId key: id of site
 @param storeId key: id of store
 @param setId key: id of set
 @param termId key: id of term
 @return ApiSitesTermStoresSetsChildrenCreateRelationsRequest
*/
func (a *SitesStoreApiService) SitesTermStoresSetsChildrenCreateRelations(ctx _context.Context, siteId string, storeId string, setId string, termId string) ApiSitesTermStoresSetsChildrenCreateRelationsRequest {
	return ApiSitesTermStoresSetsChildrenCreateRelationsRequest{
		ApiService: a,
		ctx: ctx,
		siteId: siteId,
		storeId: storeId,
		setId: setId,
		termId: termId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphTermStoreRelation
func (a *SitesStoreApiService) SitesTermStoresSetsChildrenCreateRelationsExecute(r ApiSitesTermStoresSetsChildrenCreateRelationsRequest) (MicrosoftGraphTermStoreRelation, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphTermStoreRelation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SitesStoreApiService.SitesTermStoresSetsChildrenCreateRelations")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sites/{site-id}/termStores/{store-id}/sets/{set-id}/children/{term-id}/relations"
	localVarPath = strings.Replace(localVarPath, "{"+"site-id"+"}", _neturl.PathEscape(parameterToString(r.siteId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"store-id"+"}", _neturl.PathEscape(parameterToString(r.storeId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"set-id"+"}", _neturl.PathEscape(parameterToString(r.setId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"term-id"+"}", _neturl.PathEscape(parameterToString(r.termId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphTermStoreRelation == nil {
		return localVarReturnValue, nil, reportError("microsoftGraphTermStoreRelation is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphTermStoreRelation
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSitesTermStoresSetsChildrenDeleteChildrenRequest struct {
	ctx _context.Context
	ApiService *SitesStoreApiService
	siteId string
	storeId string
	setId string
	termId string
	termId1 string
	ifMatch *string
}

// ETag
func (r ApiSitesTermStoresSetsChildrenDeleteChildrenRequest) IfMatch(ifMatch string) ApiSitesTermStoresSetsChildrenDeleteChildrenRequest {
	r.ifMatch = &ifMatch
	return r
}

func (r ApiSitesTermStoresSetsChildrenDeleteChildrenRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.SitesTermStoresSetsChildrenDeleteChildrenExecute(r)
}

/*
SitesTermStoresSetsChildrenDeleteChildren Delete navigation property children for sites

Children of current term.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param siteId key: id of site
 @param storeId key: id of store
 @param setId key: id of set
 @param termId key: id of term
 @param termId1 key: id of term
 @return ApiSitesTermStoresSetsChildrenDeleteChildrenRequest
*/
func (a *SitesStoreApiService) SitesTermStoresSetsChildrenDeleteChildren(ctx _context.Context, siteId string, storeId string, setId string, termId string, termId1 string) ApiSitesTermStoresSetsChildrenDeleteChildrenRequest {
	return ApiSitesTermStoresSetsChildrenDeleteChildrenRequest{
		ApiService: a,
		ctx: ctx,
		siteId: siteId,
		storeId: storeId,
		setId: setId,
		termId: termId,
		termId1: termId1,
	}
}

// Execute executes the request
func (a *SitesStoreApiService) SitesTermStoresSetsChildrenDeleteChildrenExecute(r ApiSitesTermStoresSetsChildrenDeleteChildrenRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SitesStoreApiService.SitesTermStoresSetsChildrenDeleteChildren")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sites/{site-id}/termStores/{store-id}/sets/{set-id}/children/{term-id}/children/{term-id1}"
	localVarPath = strings.Replace(localVarPath, "{"+"site-id"+"}", _neturl.PathEscape(parameterToString(r.siteId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"store-id"+"}", _neturl.PathEscape(parameterToString(r.storeId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"set-id"+"}", _neturl.PathEscape(parameterToString(r.setId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"term-id"+"}", _neturl.PathEscape(parameterToString(r.termId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"term-id1"+"}", _neturl.PathEscape(parameterToString(r.termId1, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ifMatch != nil {
		localVarHeaderParams["If-Match"] = parameterToString(*r.ifMatch, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiSitesTermStoresSetsChildrenDeleteRefSetRequest struct {
	ctx _context.Context
	ApiService *SitesStoreApiService
	siteId string
	storeId string
	setId string
	termId string
	ifMatch *string
}

// ETag
func (r ApiSitesTermStoresSetsChildrenDeleteRefSetRequest) IfMatch(ifMatch string) ApiSitesTermStoresSetsChildrenDeleteRefSetRequest {
	r.ifMatch = &ifMatch
	return r
}

func (r ApiSitesTermStoresSetsChildrenDeleteRefSetRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.SitesTermStoresSetsChildrenDeleteRefSetExecute(r)
}

/*
SitesTermStoresSetsChildrenDeleteRefSet Delete ref of navigation property set for sites

The [set] in which the term is created.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param siteId key: id of site
 @param storeId key: id of store
 @param setId key: id of set
 @param termId key: id of term
 @return ApiSitesTermStoresSetsChildrenDeleteRefSetRequest
*/
func (a *SitesStoreApiService) SitesTermStoresSetsChildrenDeleteRefSet(ctx _context.Context, siteId string, storeId string, setId string, termId string) ApiSitesTermStoresSetsChildrenDeleteRefSetRequest {
	return ApiSitesTermStoresSetsChildrenDeleteRefSetRequest{
		ApiService: a,
		ctx: ctx,
		siteId: siteId,
		storeId: storeId,
		setId: setId,
		termId: termId,
	}
}

// Execute executes the request
func (a *SitesStoreApiService) SitesTermStoresSetsChildrenDeleteRefSetExecute(r ApiSitesTermStoresSetsChildrenDeleteRefSetRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SitesStoreApiService.SitesTermStoresSetsChildrenDeleteRefSet")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sites/{site-id}/termStores/{store-id}/sets/{set-id}/children/{term-id}/set/$ref"
	localVarPath = strings.Replace(localVarPath, "{"+"site-id"+"}", _neturl.PathEscape(parameterToString(r.siteId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"store-id"+"}", _neturl.PathEscape(parameterToString(r.storeId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"set-id"+"}", _neturl.PathEscape(parameterToString(r.setId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"term-id"+"}", _neturl.PathEscape(parameterToString(r.termId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ifMatch != nil {
		localVarHeaderParams["If-Match"] = parameterToString(*r.ifMatch, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiSitesTermStoresSetsChildrenDeleteRelationsRequest struct {
	ctx _context.Context
	ApiService *SitesStoreApiService
	siteId string
	storeId string
	setId string
	termId string
	relationId string
	ifMatch *string
}

// ETag
func (r ApiSitesTermStoresSetsChildrenDeleteRelationsRequest) IfMatch(ifMatch string) ApiSitesTermStoresSetsChildrenDeleteRelationsRequest {
	r.ifMatch = &ifMatch
	return r
}

func (r ApiSitesTermStoresSetsChildrenDeleteRelationsRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.SitesTermStoresSetsChildrenDeleteRelationsExecute(r)
}

/*
SitesTermStoresSetsChildrenDeleteRelations Delete navigation property relations for sites

To indicate which terms are related to the current term as either pinned or reused.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param siteId key: id of site
 @param storeId key: id of store
 @param setId key: id of set
 @param termId key: id of term
 @param relationId key: id of relation
 @return ApiSitesTermStoresSetsChildrenDeleteRelationsRequest
*/
func (a *SitesStoreApiService) SitesTermStoresSetsChildrenDeleteRelations(ctx _context.Context, siteId string, storeId string, setId string, termId string, relationId string) ApiSitesTermStoresSetsChildrenDeleteRelationsRequest {
	return ApiSitesTermStoresSetsChildrenDeleteRelationsRequest{
		ApiService: a,
		ctx: ctx,
		siteId: siteId,
		storeId: storeId,
		setId: setId,
		termId: termId,
		relationId: relationId,
	}
}

// Execute executes the request
func (a *SitesStoreApiService) SitesTermStoresSetsChildrenDeleteRelationsExecute(r ApiSitesTermStoresSetsChildrenDeleteRelationsRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SitesStoreApiService.SitesTermStoresSetsChildrenDeleteRelations")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sites/{site-id}/termStores/{store-id}/sets/{set-id}/children/{term-id}/relations/{relation-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"site-id"+"}", _neturl.PathEscape(parameterToString(r.siteId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"store-id"+"}", _neturl.PathEscape(parameterToString(r.storeId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"set-id"+"}", _neturl.PathEscape(parameterToString(r.setId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"term-id"+"}", _neturl.PathEscape(parameterToString(r.termId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"relation-id"+"}", _neturl.PathEscape(parameterToString(r.relationId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ifMatch != nil {
		localVarHeaderParams["If-Match"] = parameterToString(*r.ifMatch, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiSitesTermStoresSetsChildrenGetChildrenRequest struct {
	ctx _context.Context
	ApiService *SitesStoreApiService
	siteId string
	storeId string
	setId string
	termId string
	termId1 string
	select_ *[]string
	expand *[]string
}

// Select properties to be returned
func (r ApiSitesTermStoresSetsChildrenGetChildrenRequest) Select_(select_ []string) ApiSitesTermStoresSetsChildrenGetChildrenRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiSitesTermStoresSetsChildrenGetChildrenRequest) Expand(expand []string) ApiSitesTermStoresSetsChildrenGetChildrenRequest {
	r.expand = &expand
	return r
}

func (r ApiSitesTermStoresSetsChildrenGetChildrenRequest) Execute() (MicrosoftGraphTermStoreTerm, *_nethttp.Response, error) {
	return r.ApiService.SitesTermStoresSetsChildrenGetChildrenExecute(r)
}

/*
SitesTermStoresSetsChildrenGetChildren Get children from sites

Children of current term.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param siteId key: id of site
 @param storeId key: id of store
 @param setId key: id of set
 @param termId key: id of term
 @param termId1 key: id of term
 @return ApiSitesTermStoresSetsChildrenGetChildrenRequest
*/
func (a *SitesStoreApiService) SitesTermStoresSetsChildrenGetChildren(ctx _context.Context, siteId string, storeId string, setId string, termId string, termId1 string) ApiSitesTermStoresSetsChildrenGetChildrenRequest {
	return ApiSitesTermStoresSetsChildrenGetChildrenRequest{
		ApiService: a,
		ctx: ctx,
		siteId: siteId,
		storeId: storeId,
		setId: setId,
		termId: termId,
		termId1: termId1,
	}
}

// Execute executes the request
//  @return MicrosoftGraphTermStoreTerm
func (a *SitesStoreApiService) SitesTermStoresSetsChildrenGetChildrenExecute(r ApiSitesTermStoresSetsChildrenGetChildrenRequest) (MicrosoftGraphTermStoreTerm, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphTermStoreTerm
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SitesStoreApiService.SitesTermStoresSetsChildrenGetChildren")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sites/{site-id}/termStores/{store-id}/sets/{set-id}/children/{term-id}/children/{term-id1}"
	localVarPath = strings.Replace(localVarPath, "{"+"site-id"+"}", _neturl.PathEscape(parameterToString(r.siteId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"store-id"+"}", _neturl.PathEscape(parameterToString(r.storeId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"set-id"+"}", _neturl.PathEscape(parameterToString(r.setId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"term-id"+"}", _neturl.PathEscape(parameterToString(r.termId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"term-id1"+"}", _neturl.PathEscape(parameterToString(r.termId1, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSitesTermStoresSetsChildrenGetRefSetRequest struct {
	ctx _context.Context
	ApiService *SitesStoreApiService
	siteId string
	storeId string
	setId string
	termId string
}


func (r ApiSitesTermStoresSetsChildrenGetRefSetRequest) Execute() (string, *_nethttp.Response, error) {
	return r.ApiService.SitesTermStoresSetsChildrenGetRefSetExecute(r)
}

/*
SitesTermStoresSetsChildrenGetRefSet Get ref of set from sites

The [set] in which the term is created.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param siteId key: id of site
 @param storeId key: id of store
 @param setId key: id of set
 @param termId key: id of term
 @return ApiSitesTermStoresSetsChildrenGetRefSetRequest
*/
func (a *SitesStoreApiService) SitesTermStoresSetsChildrenGetRefSet(ctx _context.Context, siteId string, storeId string, setId string, termId string) ApiSitesTermStoresSetsChildrenGetRefSetRequest {
	return ApiSitesTermStoresSetsChildrenGetRefSetRequest{
		ApiService: a,
		ctx: ctx,
		siteId: siteId,
		storeId: storeId,
		setId: setId,
		termId: termId,
	}
}

// Execute executes the request
//  @return string
func (a *SitesStoreApiService) SitesTermStoresSetsChildrenGetRefSetExecute(r ApiSitesTermStoresSetsChildrenGetRefSetRequest) (string, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  string
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SitesStoreApiService.SitesTermStoresSetsChildrenGetRefSet")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sites/{site-id}/termStores/{store-id}/sets/{set-id}/children/{term-id}/set/$ref"
	localVarPath = strings.Replace(localVarPath, "{"+"site-id"+"}", _neturl.PathEscape(parameterToString(r.siteId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"store-id"+"}", _neturl.PathEscape(parameterToString(r.storeId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"set-id"+"}", _neturl.PathEscape(parameterToString(r.setId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"term-id"+"}", _neturl.PathEscape(parameterToString(r.termId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSitesTermStoresSetsChildrenGetRelationsRequest struct {
	ctx _context.Context
	ApiService *SitesStoreApiService
	siteId string
	storeId string
	setId string
	termId string
	relationId string
	select_ *[]string
	expand *[]string
}

// Select properties to be returned
func (r ApiSitesTermStoresSetsChildrenGetRelationsRequest) Select_(select_ []string) ApiSitesTermStoresSetsChildrenGetRelationsRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiSitesTermStoresSetsChildrenGetRelationsRequest) Expand(expand []string) ApiSitesTermStoresSetsChildrenGetRelationsRequest {
	r.expand = &expand
	return r
}

func (r ApiSitesTermStoresSetsChildrenGetRelationsRequest) Execute() (MicrosoftGraphTermStoreRelation, *_nethttp.Response, error) {
	return r.ApiService.SitesTermStoresSetsChildrenGetRelationsExecute(r)
}

/*
SitesTermStoresSetsChildrenGetRelations Get relations from sites

To indicate which terms are related to the current term as either pinned or reused.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param siteId key: id of site
 @param storeId key: id of store
 @param setId key: id of set
 @param termId key: id of term
 @param relationId key: id of relation
 @return ApiSitesTermStoresSetsChildrenGetRelationsRequest
*/
func (a *SitesStoreApiService) SitesTermStoresSetsChildrenGetRelations(ctx _context.Context, siteId string, storeId string, setId string, termId string, relationId string) ApiSitesTermStoresSetsChildrenGetRelationsRequest {
	return ApiSitesTermStoresSetsChildrenGetRelationsRequest{
		ApiService: a,
		ctx: ctx,
		siteId: siteId,
		storeId: storeId,
		setId: setId,
		termId: termId,
		relationId: relationId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphTermStoreRelation
func (a *SitesStoreApiService) SitesTermStoresSetsChildrenGetRelationsExecute(r ApiSitesTermStoresSetsChildrenGetRelationsRequest) (MicrosoftGraphTermStoreRelation, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphTermStoreRelation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SitesStoreApiService.SitesTermStoresSetsChildrenGetRelations")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sites/{site-id}/termStores/{store-id}/sets/{set-id}/children/{term-id}/relations/{relation-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"site-id"+"}", _neturl.PathEscape(parameterToString(r.siteId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"store-id"+"}", _neturl.PathEscape(parameterToString(r.storeId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"set-id"+"}", _neturl.PathEscape(parameterToString(r.setId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"term-id"+"}", _neturl.PathEscape(parameterToString(r.termId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"relation-id"+"}", _neturl.PathEscape(parameterToString(r.relationId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSitesTermStoresSetsChildrenGetSetRequest struct {
	ctx _context.Context
	ApiService *SitesStoreApiService
	siteId string
	storeId string
	setId string
	termId string
	select_ *[]string
	expand *[]string
}

// Select properties to be returned
func (r ApiSitesTermStoresSetsChildrenGetSetRequest) Select_(select_ []string) ApiSitesTermStoresSetsChildrenGetSetRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiSitesTermStoresSetsChildrenGetSetRequest) Expand(expand []string) ApiSitesTermStoresSetsChildrenGetSetRequest {
	r.expand = &expand
	return r
}

func (r ApiSitesTermStoresSetsChildrenGetSetRequest) Execute() (MicrosoftGraphTermStoreSet, *_nethttp.Response, error) {
	return r.ApiService.SitesTermStoresSetsChildrenGetSetExecute(r)
}

/*
SitesTermStoresSetsChildrenGetSet Get set from sites

The [set] in which the term is created.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param siteId key: id of site
 @param storeId key: id of store
 @param setId key: id of set
 @param termId key: id of term
 @return ApiSitesTermStoresSetsChildrenGetSetRequest
*/
func (a *SitesStoreApiService) SitesTermStoresSetsChildrenGetSet(ctx _context.Context, siteId string, storeId string, setId string, termId string) ApiSitesTermStoresSetsChildrenGetSetRequest {
	return ApiSitesTermStoresSetsChildrenGetSetRequest{
		ApiService: a,
		ctx: ctx,
		siteId: siteId,
		storeId: storeId,
		setId: setId,
		termId: termId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphTermStoreSet
func (a *SitesStoreApiService) SitesTermStoresSetsChildrenGetSetExecute(r ApiSitesTermStoresSetsChildrenGetSetRequest) (MicrosoftGraphTermStoreSet, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphTermStoreSet
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SitesStoreApiService.SitesTermStoresSetsChildrenGetSet")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sites/{site-id}/termStores/{store-id}/sets/{set-id}/children/{term-id}/set"
	localVarPath = strings.Replace(localVarPath, "{"+"site-id"+"}", _neturl.PathEscape(parameterToString(r.siteId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"store-id"+"}", _neturl.PathEscape(parameterToString(r.storeId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"set-id"+"}", _neturl.PathEscape(parameterToString(r.setId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"term-id"+"}", _neturl.PathEscape(parameterToString(r.termId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSitesTermStoresSetsChildrenListChildrenRequest struct {
	ctx _context.Context
	ApiService *SitesStoreApiService
	siteId string
	storeId string
	setId string
	termId string
	top *int32
	skip *int32
	search *string
	filter *string
	count *bool
	orderby *[]string
	select_ *[]string
	expand *[]string
}

// Show only the first n items
func (r ApiSitesTermStoresSetsChildrenListChildrenRequest) Top(top int32) ApiSitesTermStoresSetsChildrenListChildrenRequest {
	r.top = &top
	return r
}
// Skip the first n items
func (r ApiSitesTermStoresSetsChildrenListChildrenRequest) Skip(skip int32) ApiSitesTermStoresSetsChildrenListChildrenRequest {
	r.skip = &skip
	return r
}
// Search items by search phrases
func (r ApiSitesTermStoresSetsChildrenListChildrenRequest) Search(search string) ApiSitesTermStoresSetsChildrenListChildrenRequest {
	r.search = &search
	return r
}
// Filter items by property values
func (r ApiSitesTermStoresSetsChildrenListChildrenRequest) Filter(filter string) ApiSitesTermStoresSetsChildrenListChildrenRequest {
	r.filter = &filter
	return r
}
// Include count of items
func (r ApiSitesTermStoresSetsChildrenListChildrenRequest) Count(count bool) ApiSitesTermStoresSetsChildrenListChildrenRequest {
	r.count = &count
	return r
}
// Order items by property values
func (r ApiSitesTermStoresSetsChildrenListChildrenRequest) Orderby(orderby []string) ApiSitesTermStoresSetsChildrenListChildrenRequest {
	r.orderby = &orderby
	return r
}
// Select properties to be returned
func (r ApiSitesTermStoresSetsChildrenListChildrenRequest) Select_(select_ []string) ApiSitesTermStoresSetsChildrenListChildrenRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiSitesTermStoresSetsChildrenListChildrenRequest) Expand(expand []string) ApiSitesTermStoresSetsChildrenListChildrenRequest {
	r.expand = &expand
	return r
}

func (r ApiSitesTermStoresSetsChildrenListChildrenRequest) Execute() (CollectionOfTerm, *_nethttp.Response, error) {
	return r.ApiService.SitesTermStoresSetsChildrenListChildrenExecute(r)
}

/*
SitesTermStoresSetsChildrenListChildren Get children from sites

Children of current term.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param siteId key: id of site
 @param storeId key: id of store
 @param setId key: id of set
 @param termId key: id of term
 @return ApiSitesTermStoresSetsChildrenListChildrenRequest
*/
func (a *SitesStoreApiService) SitesTermStoresSetsChildrenListChildren(ctx _context.Context, siteId string, storeId string, setId string, termId string) ApiSitesTermStoresSetsChildrenListChildrenRequest {
	return ApiSitesTermStoresSetsChildrenListChildrenRequest{
		ApiService: a,
		ctx: ctx,
		siteId: siteId,
		storeId: storeId,
		setId: setId,
		termId: termId,
	}
}

// Execute executes the request
//  @return CollectionOfTerm
func (a *SitesStoreApiService) SitesTermStoresSetsChildrenListChildrenExecute(r ApiSitesTermStoresSetsChildrenListChildrenRequest) (CollectionOfTerm, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  CollectionOfTerm
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SitesStoreApiService.SitesTermStoresSetsChildrenListChildren")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sites/{site-id}/termStores/{store-id}/sets/{set-id}/children/{term-id}/children"
	localVarPath = strings.Replace(localVarPath, "{"+"site-id"+"}", _neturl.PathEscape(parameterToString(r.siteId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"store-id"+"}", _neturl.PathEscape(parameterToString(r.storeId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"set-id"+"}", _neturl.PathEscape(parameterToString(r.setId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"term-id"+"}", _neturl.PathEscape(parameterToString(r.termId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.top != nil {
		localVarQueryParams.Add("$top", parameterToString(*r.top, ""))
	}
	if r.skip != nil {
		localVarQueryParams.Add("$skip", parameterToString(*r.skip, ""))
	}
	if r.search != nil {
		localVarQueryParams.Add("$search", parameterToString(*r.search, ""))
	}
	if r.filter != nil {
		localVarQueryParams.Add("$filter", parameterToString(*r.filter, ""))
	}
	if r.count != nil {
		localVarQueryParams.Add("$count", parameterToString(*r.count, ""))
	}
	if r.orderby != nil {
		localVarQueryParams.Add("$orderby", parameterToString(*r.orderby, "csv"))
	}
	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSitesTermStoresSetsChildrenListRelationsRequest struct {
	ctx _context.Context
	ApiService *SitesStoreApiService
	siteId string
	storeId string
	setId string
	termId string
	top *int32
	skip *int32
	search *string
	filter *string
	count *bool
	orderby *[]string
	select_ *[]string
	expand *[]string
}

// Show only the first n items
func (r ApiSitesTermStoresSetsChildrenListRelationsRequest) Top(top int32) ApiSitesTermStoresSetsChildrenListRelationsRequest {
	r.top = &top
	return r
}
// Skip the first n items
func (r ApiSitesTermStoresSetsChildrenListRelationsRequest) Skip(skip int32) ApiSitesTermStoresSetsChildrenListRelationsRequest {
	r.skip = &skip
	return r
}
// Search items by search phrases
func (r ApiSitesTermStoresSetsChildrenListRelationsRequest) Search(search string) ApiSitesTermStoresSetsChildrenListRelationsRequest {
	r.search = &search
	return r
}
// Filter items by property values
func (r ApiSitesTermStoresSetsChildrenListRelationsRequest) Filter(filter string) ApiSitesTermStoresSetsChildrenListRelationsRequest {
	r.filter = &filter
	return r
}
// Include count of items
func (r ApiSitesTermStoresSetsChildrenListRelationsRequest) Count(count bool) ApiSitesTermStoresSetsChildrenListRelationsRequest {
	r.count = &count
	return r
}
// Order items by property values
func (r ApiSitesTermStoresSetsChildrenListRelationsRequest) Orderby(orderby []string) ApiSitesTermStoresSetsChildrenListRelationsRequest {
	r.orderby = &orderby
	return r
}
// Select properties to be returned
func (r ApiSitesTermStoresSetsChildrenListRelationsRequest) Select_(select_ []string) ApiSitesTermStoresSetsChildrenListRelationsRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiSitesTermStoresSetsChildrenListRelationsRequest) Expand(expand []string) ApiSitesTermStoresSetsChildrenListRelationsRequest {
	r.expand = &expand
	return r
}

func (r ApiSitesTermStoresSetsChildrenListRelationsRequest) Execute() (CollectionOfRelation, *_nethttp.Response, error) {
	return r.ApiService.SitesTermStoresSetsChildrenListRelationsExecute(r)
}

/*
SitesTermStoresSetsChildrenListRelations Get relations from sites

To indicate which terms are related to the current term as either pinned or reused.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param siteId key: id of site
 @param storeId key: id of store
 @param setId key: id of set
 @param termId key: id of term
 @return ApiSitesTermStoresSetsChildrenListRelationsRequest
*/
func (a *SitesStoreApiService) SitesTermStoresSetsChildrenListRelations(ctx _context.Context, siteId string, storeId string, setId string, termId string) ApiSitesTermStoresSetsChildrenListRelationsRequest {
	return ApiSitesTermStoresSetsChildrenListRelationsRequest{
		ApiService: a,
		ctx: ctx,
		siteId: siteId,
		storeId: storeId,
		setId: setId,
		termId: termId,
	}
}

// Execute executes the request
//  @return CollectionOfRelation
func (a *SitesStoreApiService) SitesTermStoresSetsChildrenListRelationsExecute(r ApiSitesTermStoresSetsChildrenListRelationsRequest) (CollectionOfRelation, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  CollectionOfRelation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SitesStoreApiService.SitesTermStoresSetsChildrenListRelations")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sites/{site-id}/termStores/{store-id}/sets/{set-id}/children/{term-id}/relations"
	localVarPath = strings.Replace(localVarPath, "{"+"site-id"+"}", _neturl.PathEscape(parameterToString(r.siteId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"store-id"+"}", _neturl.PathEscape(parameterToString(r.storeId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"set-id"+"}", _neturl.PathEscape(parameterToString(r.setId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"term-id"+"}", _neturl.PathEscape(parameterToString(r.termId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.top != nil {
		localVarQueryParams.Add("$top", parameterToString(*r.top, ""))
	}
	if r.skip != nil {
		localVarQueryParams.Add("$skip", parameterToString(*r.skip, ""))
	}
	if r.search != nil {
		localVarQueryParams.Add("$search", parameterToString(*r.search, ""))
	}
	if r.filter != nil {
		localVarQueryParams.Add("$filter", parameterToString(*r.filter, ""))
	}
	if r.count != nil {
		localVarQueryParams.Add("$count", parameterToString(*r.count, ""))
	}
	if r.orderby != nil {
		localVarQueryParams.Add("$orderby", parameterToString(*r.orderby, "csv"))
	}
	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSitesTermStoresSetsChildrenRelationsDeleteRefFromTermRequest struct {
	ctx _context.Context
	ApiService *SitesStoreApiService
	siteId string
	storeId string
	setId string
	termId string
	relationId string
	ifMatch *string
}

// ETag
func (r ApiSitesTermStoresSetsChildrenRelationsDeleteRefFromTermRequest) IfMatch(ifMatch string) ApiSitesTermStoresSetsChildrenRelationsDeleteRefFromTermRequest {
	r.ifMatch = &ifMatch
	return r
}

func (r ApiSitesTermStoresSetsChildrenRelationsDeleteRefFromTermRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.SitesTermStoresSetsChildrenRelationsDeleteRefFromTermExecute(r)
}

/*
SitesTermStoresSetsChildrenRelationsDeleteRefFromTerm Delete ref of navigation property fromTerm for sites

The from [term] of the relation. The term from which the relationship is defined. A null value would indicate the relation is directly with the [set].

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param siteId key: id of site
 @param storeId key: id of store
 @param setId key: id of set
 @param termId key: id of term
 @param relationId key: id of relation
 @return ApiSitesTermStoresSetsChildrenRelationsDeleteRefFromTermRequest
*/
func (a *SitesStoreApiService) SitesTermStoresSetsChildrenRelationsDeleteRefFromTerm(ctx _context.Context, siteId string, storeId string, setId string, termId string, relationId string) ApiSitesTermStoresSetsChildrenRelationsDeleteRefFromTermRequest {
	return ApiSitesTermStoresSetsChildrenRelationsDeleteRefFromTermRequest{
		ApiService: a,
		ctx: ctx,
		siteId: siteId,
		storeId: storeId,
		setId: setId,
		termId: termId,
		relationId: relationId,
	}
}

// Execute executes the request
func (a *SitesStoreApiService) SitesTermStoresSetsChildrenRelationsDeleteRefFromTermExecute(r ApiSitesTermStoresSetsChildrenRelationsDeleteRefFromTermRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SitesStoreApiService.SitesTermStoresSetsChildrenRelationsDeleteRefFromTerm")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sites/{site-id}/termStores/{store-id}/sets/{set-id}/children/{term-id}/relations/{relation-id}/fromTerm/$ref"
	localVarPath = strings.Replace(localVarPath, "{"+"site-id"+"}", _neturl.PathEscape(parameterToString(r.siteId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"store-id"+"}", _neturl.PathEscape(parameterToString(r.storeId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"set-id"+"}", _neturl.PathEscape(parameterToString(r.setId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"term-id"+"}", _neturl.PathEscape(parameterToString(r.termId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"relation-id"+"}", _neturl.PathEscape(parameterToString(r.relationId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ifMatch != nil {
		localVarHeaderParams["If-Match"] = parameterToString(*r.ifMatch, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiSitesTermStoresSetsChildrenRelationsDeleteRefSetRequest struct {
	ctx _context.Context
	ApiService *SitesStoreApiService
	siteId string
	storeId string
	setId string
	termId string
	relationId string
	ifMatch *string
}

// ETag
func (r ApiSitesTermStoresSetsChildrenRelationsDeleteRefSetRequest) IfMatch(ifMatch string) ApiSitesTermStoresSetsChildrenRelationsDeleteRefSetRequest {
	r.ifMatch = &ifMatch
	return r
}

func (r ApiSitesTermStoresSetsChildrenRelationsDeleteRefSetRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.SitesTermStoresSetsChildrenRelationsDeleteRefSetExecute(r)
}

/*
SitesTermStoresSetsChildrenRelationsDeleteRefSet Delete ref of navigation property set for sites

The [set] in which the relation is relevant.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param siteId key: id of site
 @param storeId key: id of store
 @param setId key: id of set
 @param termId key: id of term
 @param relationId key: id of relation
 @return ApiSitesTermStoresSetsChildrenRelationsDeleteRefSetRequest
*/
func (a *SitesStoreApiService) SitesTermStoresSetsChildrenRelationsDeleteRefSet(ctx _context.Context, siteId string, storeId string, setId string, termId string, relationId string) ApiSitesTermStoresSetsChildrenRelationsDeleteRefSetRequest {
	return ApiSitesTermStoresSetsChildrenRelationsDeleteRefSetRequest{
		ApiService: a,
		ctx: ctx,
		siteId: siteId,
		storeId: storeId,
		setId: setId,
		termId: termId,
		relationId: relationId,
	}
}

// Execute executes the request
func (a *SitesStoreApiService) SitesTermStoresSetsChildrenRelationsDeleteRefSetExecute(r ApiSitesTermStoresSetsChildrenRelationsDeleteRefSetRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SitesStoreApiService.SitesTermStoresSetsChildrenRelationsDeleteRefSet")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sites/{site-id}/termStores/{store-id}/sets/{set-id}/children/{term-id}/relations/{relation-id}/set/$ref"
	localVarPath = strings.Replace(localVarPath, "{"+"site-id"+"}", _neturl.PathEscape(parameterToString(r.siteId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"store-id"+"}", _neturl.PathEscape(parameterToString(r.storeId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"set-id"+"}", _neturl.PathEscape(parameterToString(r.setId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"term-id"+"}", _neturl.PathEscape(parameterToString(r.termId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"relation-id"+"}", _neturl.PathEscape(parameterToString(r.relationId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ifMatch != nil {
		localVarHeaderParams["If-Match"] = parameterToString(*r.ifMatch, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiSitesTermStoresSetsChildrenRelationsDeleteRefToTermRequest struct {
	ctx _context.Context
	ApiService *SitesStoreApiService
	siteId string
	storeId string
	setId string
	termId string
	relationId string
	ifMatch *string
}

// ETag
func (r ApiSitesTermStoresSetsChildrenRelationsDeleteRefToTermRequest) IfMatch(ifMatch string) ApiSitesTermStoresSetsChildrenRelationsDeleteRefToTermRequest {
	r.ifMatch = &ifMatch
	return r
}

func (r ApiSitesTermStoresSetsChildrenRelationsDeleteRefToTermRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.SitesTermStoresSetsChildrenRelationsDeleteRefToTermExecute(r)
}

/*
SitesTermStoresSetsChildrenRelationsDeleteRefToTerm Delete ref of navigation property toTerm for sites

The to [term] of the relation. The term to which the relationship is defined.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param siteId key: id of site
 @param storeId key: id of store
 @param setId key: id of set
 @param termId key: id of term
 @param relationId key: id of relation
 @return ApiSitesTermStoresSetsChildrenRelationsDeleteRefToTermRequest
*/
func (a *SitesStoreApiService) SitesTermStoresSetsChildrenRelationsDeleteRefToTerm(ctx _context.Context, siteId string, storeId string, setId string, termId string, relationId string) ApiSitesTermStoresSetsChildrenRelationsDeleteRefToTermRequest {
	return ApiSitesTermStoresSetsChildrenRelationsDeleteRefToTermRequest{
		ApiService: a,
		ctx: ctx,
		siteId: siteId,
		storeId: storeId,
		setId: setId,
		termId: termId,
		relationId: relationId,
	}
}

// Execute executes the request
func (a *SitesStoreApiService) SitesTermStoresSetsChildrenRelationsDeleteRefToTermExecute(r ApiSitesTermStoresSetsChildrenRelationsDeleteRefToTermRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SitesStoreApiService.SitesTermStoresSetsChildrenRelationsDeleteRefToTerm")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sites/{site-id}/termStores/{store-id}/sets/{set-id}/children/{term-id}/relations/{relation-id}/toTerm/$ref"
	localVarPath = strings.Replace(localVarPath, "{"+"site-id"+"}", _neturl.PathEscape(parameterToString(r.siteId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"store-id"+"}", _neturl.PathEscape(parameterToString(r.storeId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"set-id"+"}", _neturl.PathEscape(parameterToString(r.setId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"term-id"+"}", _neturl.PathEscape(parameterToString(r.termId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"relation-id"+"}", _neturl.PathEscape(parameterToString(r.relationId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ifMatch != nil {
		localVarHeaderParams["If-Match"] = parameterToString(*r.ifMatch, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiSitesTermStoresSetsChildrenRelationsGetFromTermRequest struct {
	ctx _context.Context
	ApiService *SitesStoreApiService
	siteId string
	storeId string
	setId string
	termId string
	relationId string
	select_ *[]string
	expand *[]string
}

// Select properties to be returned
func (r ApiSitesTermStoresSetsChildrenRelationsGetFromTermRequest) Select_(select_ []string) ApiSitesTermStoresSetsChildrenRelationsGetFromTermRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiSitesTermStoresSetsChildrenRelationsGetFromTermRequest) Expand(expand []string) ApiSitesTermStoresSetsChildrenRelationsGetFromTermRequest {
	r.expand = &expand
	return r
}

func (r ApiSitesTermStoresSetsChildrenRelationsGetFromTermRequest) Execute() (MicrosoftGraphTermStoreTerm, *_nethttp.Response, error) {
	return r.ApiService.SitesTermStoresSetsChildrenRelationsGetFromTermExecute(r)
}

/*
SitesTermStoresSetsChildrenRelationsGetFromTerm Get fromTerm from sites

The from [term] of the relation. The term from which the relationship is defined. A null value would indicate the relation is directly with the [set].

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param siteId key: id of site
 @param storeId key: id of store
 @param setId key: id of set
 @param termId key: id of term
 @param relationId key: id of relation
 @return ApiSitesTermStoresSetsChildrenRelationsGetFromTermRequest
*/
func (a *SitesStoreApiService) SitesTermStoresSetsChildrenRelationsGetFromTerm(ctx _context.Context, siteId string, storeId string, setId string, termId string, relationId string) ApiSitesTermStoresSetsChildrenRelationsGetFromTermRequest {
	return ApiSitesTermStoresSetsChildrenRelationsGetFromTermRequest{
		ApiService: a,
		ctx: ctx,
		siteId: siteId,
		storeId: storeId,
		setId: setId,
		termId: termId,
		relationId: relationId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphTermStoreTerm
func (a *SitesStoreApiService) SitesTermStoresSetsChildrenRelationsGetFromTermExecute(r ApiSitesTermStoresSetsChildrenRelationsGetFromTermRequest) (MicrosoftGraphTermStoreTerm, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphTermStoreTerm
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SitesStoreApiService.SitesTermStoresSetsChildrenRelationsGetFromTerm")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sites/{site-id}/termStores/{store-id}/sets/{set-id}/children/{term-id}/relations/{relation-id}/fromTerm"
	localVarPath = strings.Replace(localVarPath, "{"+"site-id"+"}", _neturl.PathEscape(parameterToString(r.siteId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"store-id"+"}", _neturl.PathEscape(parameterToString(r.storeId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"set-id"+"}", _neturl.PathEscape(parameterToString(r.setId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"term-id"+"}", _neturl.PathEscape(parameterToString(r.termId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"relation-id"+"}", _neturl.PathEscape(parameterToString(r.relationId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSitesTermStoresSetsChildrenRelationsGetRefFromTermRequest struct {
	ctx _context.Context
	ApiService *SitesStoreApiService
	siteId string
	storeId string
	setId string
	termId string
	relationId string
}


func (r ApiSitesTermStoresSetsChildrenRelationsGetRefFromTermRequest) Execute() (string, *_nethttp.Response, error) {
	return r.ApiService.SitesTermStoresSetsChildrenRelationsGetRefFromTermExecute(r)
}

/*
SitesTermStoresSetsChildrenRelationsGetRefFromTerm Get ref of fromTerm from sites

The from [term] of the relation. The term from which the relationship is defined. A null value would indicate the relation is directly with the [set].

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param siteId key: id of site
 @param storeId key: id of store
 @param setId key: id of set
 @param termId key: id of term
 @param relationId key: id of relation
 @return ApiSitesTermStoresSetsChildrenRelationsGetRefFromTermRequest
*/
func (a *SitesStoreApiService) SitesTermStoresSetsChildrenRelationsGetRefFromTerm(ctx _context.Context, siteId string, storeId string, setId string, termId string, relationId string) ApiSitesTermStoresSetsChildrenRelationsGetRefFromTermRequest {
	return ApiSitesTermStoresSetsChildrenRelationsGetRefFromTermRequest{
		ApiService: a,
		ctx: ctx,
		siteId: siteId,
		storeId: storeId,
		setId: setId,
		termId: termId,
		relationId: relationId,
	}
}

// Execute executes the request
//  @return string
func (a *SitesStoreApiService) SitesTermStoresSetsChildrenRelationsGetRefFromTermExecute(r ApiSitesTermStoresSetsChildrenRelationsGetRefFromTermRequest) (string, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  string
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SitesStoreApiService.SitesTermStoresSetsChildrenRelationsGetRefFromTerm")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sites/{site-id}/termStores/{store-id}/sets/{set-id}/children/{term-id}/relations/{relation-id}/fromTerm/$ref"
	localVarPath = strings.Replace(localVarPath, "{"+"site-id"+"}", _neturl.PathEscape(parameterToString(r.siteId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"store-id"+"}", _neturl.PathEscape(parameterToString(r.storeId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"set-id"+"}", _neturl.PathEscape(parameterToString(r.setId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"term-id"+"}", _neturl.PathEscape(parameterToString(r.termId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"relation-id"+"}", _neturl.PathEscape(parameterToString(r.relationId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSitesTermStoresSetsChildrenRelationsGetRefSetRequest struct {
	ctx _context.Context
	ApiService *SitesStoreApiService
	siteId string
	storeId string
	setId string
	termId string
	relationId string
}


func (r ApiSitesTermStoresSetsChildrenRelationsGetRefSetRequest) Execute() (string, *_nethttp.Response, error) {
	return r.ApiService.SitesTermStoresSetsChildrenRelationsGetRefSetExecute(r)
}

/*
SitesTermStoresSetsChildrenRelationsGetRefSet Get ref of set from sites

The [set] in which the relation is relevant.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param siteId key: id of site
 @param storeId key: id of store
 @param setId key: id of set
 @param termId key: id of term
 @param relationId key: id of relation
 @return ApiSitesTermStoresSetsChildrenRelationsGetRefSetRequest
*/
func (a *SitesStoreApiService) SitesTermStoresSetsChildrenRelationsGetRefSet(ctx _context.Context, siteId string, storeId string, setId string, termId string, relationId string) ApiSitesTermStoresSetsChildrenRelationsGetRefSetRequest {
	return ApiSitesTermStoresSetsChildrenRelationsGetRefSetRequest{
		ApiService: a,
		ctx: ctx,
		siteId: siteId,
		storeId: storeId,
		setId: setId,
		termId: termId,
		relationId: relationId,
	}
}

// Execute executes the request
//  @return string
func (a *SitesStoreApiService) SitesTermStoresSetsChildrenRelationsGetRefSetExecute(r ApiSitesTermStoresSetsChildrenRelationsGetRefSetRequest) (string, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  string
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SitesStoreApiService.SitesTermStoresSetsChildrenRelationsGetRefSet")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sites/{site-id}/termStores/{store-id}/sets/{set-id}/children/{term-id}/relations/{relation-id}/set/$ref"
	localVarPath = strings.Replace(localVarPath, "{"+"site-id"+"}", _neturl.PathEscape(parameterToString(r.siteId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"store-id"+"}", _neturl.PathEscape(parameterToString(r.storeId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"set-id"+"}", _neturl.PathEscape(parameterToString(r.setId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"term-id"+"}", _neturl.PathEscape(parameterToString(r.termId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"relation-id"+"}", _neturl.PathEscape(parameterToString(r.relationId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSitesTermStoresSetsChildrenRelationsGetRefToTermRequest struct {
	ctx _context.Context
	ApiService *SitesStoreApiService
	siteId string
	storeId string
	setId string
	termId string
	relationId string
}


func (r ApiSitesTermStoresSetsChildrenRelationsGetRefToTermRequest) Execute() (string, *_nethttp.Response, error) {
	return r.ApiService.SitesTermStoresSetsChildrenRelationsGetRefToTermExecute(r)
}

/*
SitesTermStoresSetsChildrenRelationsGetRefToTerm Get ref of toTerm from sites

The to [term] of the relation. The term to which the relationship is defined.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param siteId key: id of site
 @param storeId key: id of store
 @param setId key: id of set
 @param termId key: id of term
 @param relationId key: id of relation
 @return ApiSitesTermStoresSetsChildrenRelationsGetRefToTermRequest
*/
func (a *SitesStoreApiService) SitesTermStoresSetsChildrenRelationsGetRefToTerm(ctx _context.Context, siteId string, storeId string, setId string, termId string, relationId string) ApiSitesTermStoresSetsChildrenRelationsGetRefToTermRequest {
	return ApiSitesTermStoresSetsChildrenRelationsGetRefToTermRequest{
		ApiService: a,
		ctx: ctx,
		siteId: siteId,
		storeId: storeId,
		setId: setId,
		termId: termId,
		relationId: relationId,
	}
}

// Execute executes the request
//  @return string
func (a *SitesStoreApiService) SitesTermStoresSetsChildrenRelationsGetRefToTermExecute(r ApiSitesTermStoresSetsChildrenRelationsGetRefToTermRequest) (string, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  string
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SitesStoreApiService.SitesTermStoresSetsChildrenRelationsGetRefToTerm")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sites/{site-id}/termStores/{store-id}/sets/{set-id}/children/{term-id}/relations/{relation-id}/toTerm/$ref"
	localVarPath = strings.Replace(localVarPath, "{"+"site-id"+"}", _neturl.PathEscape(parameterToString(r.siteId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"store-id"+"}", _neturl.PathEscape(parameterToString(r.storeId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"set-id"+"}", _neturl.PathEscape(parameterToString(r.setId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"term-id"+"}", _neturl.PathEscape(parameterToString(r.termId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"relation-id"+"}", _neturl.PathEscape(parameterToString(r.relationId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSitesTermStoresSetsChildrenRelationsGetSetRequest struct {
	ctx _context.Context
	ApiService *SitesStoreApiService
	siteId string
	storeId string
	setId string
	termId string
	relationId string
	select_ *[]string
	expand *[]string
}

// Select properties to be returned
func (r ApiSitesTermStoresSetsChildrenRelationsGetSetRequest) Select_(select_ []string) ApiSitesTermStoresSetsChildrenRelationsGetSetRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiSitesTermStoresSetsChildrenRelationsGetSetRequest) Expand(expand []string) ApiSitesTermStoresSetsChildrenRelationsGetSetRequest {
	r.expand = &expand
	return r
}

func (r ApiSitesTermStoresSetsChildrenRelationsGetSetRequest) Execute() (MicrosoftGraphTermStoreSet, *_nethttp.Response, error) {
	return r.ApiService.SitesTermStoresSetsChildrenRelationsGetSetExecute(r)
}

/*
SitesTermStoresSetsChildrenRelationsGetSet Get set from sites

The [set] in which the relation is relevant.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param siteId key: id of site
 @param storeId key: id of store
 @param setId key: id of set
 @param termId key: id of term
 @param relationId key: id of relation
 @return ApiSitesTermStoresSetsChildrenRelationsGetSetRequest
*/
func (a *SitesStoreApiService) SitesTermStoresSetsChildrenRelationsGetSet(ctx _context.Context, siteId string, storeId string, setId string, termId string, relationId string) ApiSitesTermStoresSetsChildrenRelationsGetSetRequest {
	return ApiSitesTermStoresSetsChildrenRelationsGetSetRequest{
		ApiService: a,
		ctx: ctx,
		siteId: siteId,
		storeId: storeId,
		setId: setId,
		termId: termId,
		relationId: relationId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphTermStoreSet
func (a *SitesStoreApiService) SitesTermStoresSetsChildrenRelationsGetSetExecute(r ApiSitesTermStoresSetsChildrenRelationsGetSetRequest) (MicrosoftGraphTermStoreSet, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphTermStoreSet
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SitesStoreApiService.SitesTermStoresSetsChildrenRelationsGetSet")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sites/{site-id}/termStores/{store-id}/sets/{set-id}/children/{term-id}/relations/{relation-id}/set"
	localVarPath = strings.Replace(localVarPath, "{"+"site-id"+"}", _neturl.PathEscape(parameterToString(r.siteId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"store-id"+"}", _neturl.PathEscape(parameterToString(r.storeId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"set-id"+"}", _neturl.PathEscape(parameterToString(r.setId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"term-id"+"}", _neturl.PathEscape(parameterToString(r.termId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"relation-id"+"}", _neturl.PathEscape(parameterToString(r.relationId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSitesTermStoresSetsChildrenRelationsGetToTermRequest struct {
	ctx _context.Context
	ApiService *SitesStoreApiService
	siteId string
	storeId string
	setId string
	termId string
	relationId string
	select_ *[]string
	expand *[]string
}

// Select properties to be returned
func (r ApiSitesTermStoresSetsChildrenRelationsGetToTermRequest) Select_(select_ []string) ApiSitesTermStoresSetsChildrenRelationsGetToTermRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiSitesTermStoresSetsChildrenRelationsGetToTermRequest) Expand(expand []string) ApiSitesTermStoresSetsChildrenRelationsGetToTermRequest {
	r.expand = &expand
	return r
}

func (r ApiSitesTermStoresSetsChildrenRelationsGetToTermRequest) Execute() (MicrosoftGraphTermStoreTerm, *_nethttp.Response, error) {
	return r.ApiService.SitesTermStoresSetsChildrenRelationsGetToTermExecute(r)
}

/*
SitesTermStoresSetsChildrenRelationsGetToTerm Get toTerm from sites

The to [term] of the relation. The term to which the relationship is defined.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param siteId key: id of site
 @param storeId key: id of store
 @param setId key: id of set
 @param termId key: id of term
 @param relationId key: id of relation
 @return ApiSitesTermStoresSetsChildrenRelationsGetToTermRequest
*/
func (a *SitesStoreApiService) SitesTermStoresSetsChildrenRelationsGetToTerm(ctx _context.Context, siteId string, storeId string, setId string, termId string, relationId string) ApiSitesTermStoresSetsChildrenRelationsGetToTermRequest {
	return ApiSitesTermStoresSetsChildrenRelationsGetToTermRequest{
		ApiService: a,
		ctx: ctx,
		siteId: siteId,
		storeId: storeId,
		setId: setId,
		termId: termId,
		relationId: relationId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphTermStoreTerm
func (a *SitesStoreApiService) SitesTermStoresSetsChildrenRelationsGetToTermExecute(r ApiSitesTermStoresSetsChildrenRelationsGetToTermRequest) (MicrosoftGraphTermStoreTerm, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphTermStoreTerm
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SitesStoreApiService.SitesTermStoresSetsChildrenRelationsGetToTerm")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sites/{site-id}/termStores/{store-id}/sets/{set-id}/children/{term-id}/relations/{relation-id}/toTerm"
	localVarPath = strings.Replace(localVarPath, "{"+"site-id"+"}", _neturl.PathEscape(parameterToString(r.siteId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"store-id"+"}", _neturl.PathEscape(parameterToString(r.storeId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"set-id"+"}", _neturl.PathEscape(parameterToString(r.setId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"term-id"+"}", _neturl.PathEscape(parameterToString(r.termId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"relation-id"+"}", _neturl.PathEscape(parameterToString(r.relationId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSitesTermStoresSetsChildrenRelationsUpdateRefFromTermRequest struct {
	ctx _context.Context
	ApiService *SitesStoreApiService
	siteId string
	storeId string
	setId string
	termId string
	relationId string
	requestBody *map[string]map[string]interface{}
}

// New navigation property ref values
func (r ApiSitesTermStoresSetsChildrenRelationsUpdateRefFromTermRequest) RequestBody(requestBody map[string]map[string]interface{}) ApiSitesTermStoresSetsChildrenRelationsUpdateRefFromTermRequest {
	r.requestBody = &requestBody
	return r
}

func (r ApiSitesTermStoresSetsChildrenRelationsUpdateRefFromTermRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.SitesTermStoresSetsChildrenRelationsUpdateRefFromTermExecute(r)
}

/*
SitesTermStoresSetsChildrenRelationsUpdateRefFromTerm Update the ref of navigation property fromTerm in sites

The from [term] of the relation. The term from which the relationship is defined. A null value would indicate the relation is directly with the [set].

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param siteId key: id of site
 @param storeId key: id of store
 @param setId key: id of set
 @param termId key: id of term
 @param relationId key: id of relation
 @return ApiSitesTermStoresSetsChildrenRelationsUpdateRefFromTermRequest
*/
func (a *SitesStoreApiService) SitesTermStoresSetsChildrenRelationsUpdateRefFromTerm(ctx _context.Context, siteId string, storeId string, setId string, termId string, relationId string) ApiSitesTermStoresSetsChildrenRelationsUpdateRefFromTermRequest {
	return ApiSitesTermStoresSetsChildrenRelationsUpdateRefFromTermRequest{
		ApiService: a,
		ctx: ctx,
		siteId: siteId,
		storeId: storeId,
		setId: setId,
		termId: termId,
		relationId: relationId,
	}
}

// Execute executes the request
func (a *SitesStoreApiService) SitesTermStoresSetsChildrenRelationsUpdateRefFromTermExecute(r ApiSitesTermStoresSetsChildrenRelationsUpdateRefFromTermRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPut
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SitesStoreApiService.SitesTermStoresSetsChildrenRelationsUpdateRefFromTerm")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sites/{site-id}/termStores/{store-id}/sets/{set-id}/children/{term-id}/relations/{relation-id}/fromTerm/$ref"
	localVarPath = strings.Replace(localVarPath, "{"+"site-id"+"}", _neturl.PathEscape(parameterToString(r.siteId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"store-id"+"}", _neturl.PathEscape(parameterToString(r.storeId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"set-id"+"}", _neturl.PathEscape(parameterToString(r.setId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"term-id"+"}", _neturl.PathEscape(parameterToString(r.termId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"relation-id"+"}", _neturl.PathEscape(parameterToString(r.relationId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.requestBody == nil {
		return nil, reportError("requestBody is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.requestBody
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiSitesTermStoresSetsChildrenRelationsUpdateRefSetRequest struct {
	ctx _context.Context
	ApiService *SitesStoreApiService
	siteId string
	storeId string
	setId string
	termId string
	relationId string
	requestBody *map[string]map[string]interface{}
}

// New navigation property ref values
func (r ApiSitesTermStoresSetsChildrenRelationsUpdateRefSetRequest) RequestBody(requestBody map[string]map[string]interface{}) ApiSitesTermStoresSetsChildrenRelationsUpdateRefSetRequest {
	r.requestBody = &requestBody
	return r
}

func (r ApiSitesTermStoresSetsChildrenRelationsUpdateRefSetRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.SitesTermStoresSetsChildrenRelationsUpdateRefSetExecute(r)
}

/*
SitesTermStoresSetsChildrenRelationsUpdateRefSet Update the ref of navigation property set in sites

The [set] in which the relation is relevant.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param siteId key: id of site
 @param storeId key: id of store
 @param setId key: id of set
 @param termId key: id of term
 @param relationId key: id of relation
 @return ApiSitesTermStoresSetsChildrenRelationsUpdateRefSetRequest
*/
func (a *SitesStoreApiService) SitesTermStoresSetsChildrenRelationsUpdateRefSet(ctx _context.Context, siteId string, storeId string, setId string, termId string, relationId string) ApiSitesTermStoresSetsChildrenRelationsUpdateRefSetRequest {
	return ApiSitesTermStoresSetsChildrenRelationsUpdateRefSetRequest{
		ApiService: a,
		ctx: ctx,
		siteId: siteId,
		storeId: storeId,
		setId: setId,
		termId: termId,
		relationId: relationId,
	}
}

// Execute executes the request
func (a *SitesStoreApiService) SitesTermStoresSetsChildrenRelationsUpdateRefSetExecute(r ApiSitesTermStoresSetsChildrenRelationsUpdateRefSetRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPut
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SitesStoreApiService.SitesTermStoresSetsChildrenRelationsUpdateRefSet")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sites/{site-id}/termStores/{store-id}/sets/{set-id}/children/{term-id}/relations/{relation-id}/set/$ref"
	localVarPath = strings.Replace(localVarPath, "{"+"site-id"+"}", _neturl.PathEscape(parameterToString(r.siteId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"store-id"+"}", _neturl.PathEscape(parameterToString(r.storeId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"set-id"+"}", _neturl.PathEscape(parameterToString(r.setId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"term-id"+"}", _neturl.PathEscape(parameterToString(r.termId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"relation-id"+"}", _neturl.PathEscape(parameterToString(r.relationId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.requestBody == nil {
		return nil, reportError("requestBody is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.requestBody
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiSitesTermStoresSetsChildrenRelationsUpdateRefToTermRequest struct {
	ctx _context.Context
	ApiService *SitesStoreApiService
	siteId string
	storeId string
	setId string
	termId string
	relationId string
	requestBody *map[string]map[string]interface{}
}

// New navigation property ref values
func (r ApiSitesTermStoresSetsChildrenRelationsUpdateRefToTermRequest) RequestBody(requestBody map[string]map[string]interface{}) ApiSitesTermStoresSetsChildrenRelationsUpdateRefToTermRequest {
	r.requestBody = &requestBody
	return r
}

func (r ApiSitesTermStoresSetsChildrenRelationsUpdateRefToTermRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.SitesTermStoresSetsChildrenRelationsUpdateRefToTermExecute(r)
}

/*
SitesTermStoresSetsChildrenRelationsUpdateRefToTerm Update the ref of navigation property toTerm in sites

The to [term] of the relation. The term to which the relationship is defined.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param siteId key: id of site
 @param storeId key: id of store
 @param setId key: id of set
 @param termId key: id of term
 @param relationId key: id of relation
 @return ApiSitesTermStoresSetsChildrenRelationsUpdateRefToTermRequest
*/
func (a *SitesStoreApiService) SitesTermStoresSetsChildrenRelationsUpdateRefToTerm(ctx _context.Context, siteId string, storeId string, setId string, termId string, relationId string) ApiSitesTermStoresSetsChildrenRelationsUpdateRefToTermRequest {
	return ApiSitesTermStoresSetsChildrenRelationsUpdateRefToTermRequest{
		ApiService: a,
		ctx: ctx,
		siteId: siteId,
		storeId: storeId,
		setId: setId,
		termId: termId,
		relationId: relationId,
	}
}

// Execute executes the request
func (a *SitesStoreApiService) SitesTermStoresSetsChildrenRelationsUpdateRefToTermExecute(r ApiSitesTermStoresSetsChildrenRelationsUpdateRefToTermRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPut
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SitesStoreApiService.SitesTermStoresSetsChildrenRelationsUpdateRefToTerm")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sites/{site-id}/termStores/{store-id}/sets/{set-id}/children/{term-id}/relations/{relation-id}/toTerm/$ref"
	localVarPath = strings.Replace(localVarPath, "{"+"site-id"+"}", _neturl.PathEscape(parameterToString(r.siteId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"store-id"+"}", _neturl.PathEscape(parameterToString(r.storeId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"set-id"+"}", _neturl.PathEscape(parameterToString(r.setId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"term-id"+"}", _neturl.PathEscape(parameterToString(r.termId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"relation-id"+"}", _neturl.PathEscape(parameterToString(r.relationId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.requestBody == nil {
		return nil, reportError("requestBody is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.requestBody
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiSitesTermStoresSetsChildrenUpdateChildrenRequest struct {
	ctx _context.Context
	ApiService *SitesStoreApiService
	siteId string
	storeId string
	setId string
	termId string
	termId1 string
	microsoftGraphTermStoreTerm *MicrosoftGraphTermStoreTerm
}

// New navigation property values
func (r ApiSitesTermStoresSetsChildrenUpdateChildrenRequest) MicrosoftGraphTermStoreTerm(microsoftGraphTermStoreTerm MicrosoftGraphTermStoreTerm) ApiSitesTermStoresSetsChildrenUpdateChildrenRequest {
	r.microsoftGraphTermStoreTerm = &microsoftGraphTermStoreTerm
	return r
}

func (r ApiSitesTermStoresSetsChildrenUpdateChildrenRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.SitesTermStoresSetsChildrenUpdateChildrenExecute(r)
}

/*
SitesTermStoresSetsChildrenUpdateChildren Update the navigation property children in sites

Children of current term.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param siteId key: id of site
 @param storeId key: id of store
 @param setId key: id of set
 @param termId key: id of term
 @param termId1 key: id of term
 @return ApiSitesTermStoresSetsChildrenUpdateChildrenRequest
*/
func (a *SitesStoreApiService) SitesTermStoresSetsChildrenUpdateChildren(ctx _context.Context, siteId string, storeId string, setId string, termId string, termId1 string) ApiSitesTermStoresSetsChildrenUpdateChildrenRequest {
	return ApiSitesTermStoresSetsChildrenUpdateChildrenRequest{
		ApiService: a,
		ctx: ctx,
		siteId: siteId,
		storeId: storeId,
		setId: setId,
		termId: termId,
		termId1: termId1,
	}
}

// Execute executes the request
func (a *SitesStoreApiService) SitesTermStoresSetsChildrenUpdateChildrenExecute(r ApiSitesTermStoresSetsChildrenUpdateChildrenRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPatch
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SitesStoreApiService.SitesTermStoresSetsChildrenUpdateChildren")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sites/{site-id}/termStores/{store-id}/sets/{set-id}/children/{term-id}/children/{term-id1}"
	localVarPath = strings.Replace(localVarPath, "{"+"site-id"+"}", _neturl.PathEscape(parameterToString(r.siteId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"store-id"+"}", _neturl.PathEscape(parameterToString(r.storeId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"set-id"+"}", _neturl.PathEscape(parameterToString(r.setId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"term-id"+"}", _neturl.PathEscape(parameterToString(r.termId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"term-id1"+"}", _neturl.PathEscape(parameterToString(r.termId1, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphTermStoreTerm == nil {
		return nil, reportError("microsoftGraphTermStoreTerm is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphTermStoreTerm
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiSitesTermStoresSetsChildrenUpdateRefSetRequest struct {
	ctx _context.Context
	ApiService *SitesStoreApiService
	siteId string
	storeId string
	setId string
	termId string
	requestBody *map[string]map[string]interface{}
}

// New navigation property ref values
func (r ApiSitesTermStoresSetsChildrenUpdateRefSetRequest) RequestBody(requestBody map[string]map[string]interface{}) ApiSitesTermStoresSetsChildrenUpdateRefSetRequest {
	r.requestBody = &requestBody
	return r
}

func (r ApiSitesTermStoresSetsChildrenUpdateRefSetRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.SitesTermStoresSetsChildrenUpdateRefSetExecute(r)
}

/*
SitesTermStoresSetsChildrenUpdateRefSet Update the ref of navigation property set in sites

The [set] in which the term is created.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param siteId key: id of site
 @param storeId key: id of store
 @param setId key: id of set
 @param termId key: id of term
 @return ApiSitesTermStoresSetsChildrenUpdateRefSetRequest
*/
func (a *SitesStoreApiService) SitesTermStoresSetsChildrenUpdateRefSet(ctx _context.Context, siteId string, storeId string, setId string, termId string) ApiSitesTermStoresSetsChildrenUpdateRefSetRequest {
	return ApiSitesTermStoresSetsChildrenUpdateRefSetRequest{
		ApiService: a,
		ctx: ctx,
		siteId: siteId,
		storeId: storeId,
		setId: setId,
		termId: termId,
	}
}

// Execute executes the request
func (a *SitesStoreApiService) SitesTermStoresSetsChildrenUpdateRefSetExecute(r ApiSitesTermStoresSetsChildrenUpdateRefSetRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPut
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SitesStoreApiService.SitesTermStoresSetsChildrenUpdateRefSet")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sites/{site-id}/termStores/{store-id}/sets/{set-id}/children/{term-id}/set/$ref"
	localVarPath = strings.Replace(localVarPath, "{"+"site-id"+"}", _neturl.PathEscape(parameterToString(r.siteId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"store-id"+"}", _neturl.PathEscape(parameterToString(r.storeId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"set-id"+"}", _neturl.PathEscape(parameterToString(r.setId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"term-id"+"}", _neturl.PathEscape(parameterToString(r.termId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.requestBody == nil {
		return nil, reportError("requestBody is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.requestBody
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiSitesTermStoresSetsChildrenUpdateRelationsRequest struct {
	ctx _context.Context
	ApiService *SitesStoreApiService
	siteId string
	storeId string
	setId string
	termId string
	relationId string
	microsoftGraphTermStoreRelation *MicrosoftGraphTermStoreRelation
}

// New navigation property values
func (r ApiSitesTermStoresSetsChildrenUpdateRelationsRequest) MicrosoftGraphTermStoreRelation(microsoftGraphTermStoreRelation MicrosoftGraphTermStoreRelation) ApiSitesTermStoresSetsChildrenUpdateRelationsRequest {
	r.microsoftGraphTermStoreRelation = &microsoftGraphTermStoreRelation
	return r
}

func (r ApiSitesTermStoresSetsChildrenUpdateRelationsRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.SitesTermStoresSetsChildrenUpdateRelationsExecute(r)
}

/*
SitesTermStoresSetsChildrenUpdateRelations Update the navigation property relations in sites

To indicate which terms are related to the current term as either pinned or reused.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param siteId key: id of site
 @param storeId key: id of store
 @param setId key: id of set
 @param termId key: id of term
 @param relationId key: id of relation
 @return ApiSitesTermStoresSetsChildrenUpdateRelationsRequest
*/
func (a *SitesStoreApiService) SitesTermStoresSetsChildrenUpdateRelations(ctx _context.Context, siteId string, storeId string, setId string, termId string, relationId string) ApiSitesTermStoresSetsChildrenUpdateRelationsRequest {
	return ApiSitesTermStoresSetsChildrenUpdateRelationsRequest{
		ApiService: a,
		ctx: ctx,
		siteId: siteId,
		storeId: storeId,
		setId: setId,
		termId: termId,
		relationId: relationId,
	}
}

// Execute executes the request
func (a *SitesStoreApiService) SitesTermStoresSetsChildrenUpdateRelationsExecute(r ApiSitesTermStoresSetsChildrenUpdateRelationsRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPatch
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SitesStoreApiService.SitesTermStoresSetsChildrenUpdateRelations")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sites/{site-id}/termStores/{store-id}/sets/{set-id}/children/{term-id}/relations/{relation-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"site-id"+"}", _neturl.PathEscape(parameterToString(r.siteId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"store-id"+"}", _neturl.PathEscape(parameterToString(r.storeId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"set-id"+"}", _neturl.PathEscape(parameterToString(r.setId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"term-id"+"}", _neturl.PathEscape(parameterToString(r.termId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"relation-id"+"}", _neturl.PathEscape(parameterToString(r.relationId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphTermStoreRelation == nil {
		return nil, reportError("microsoftGraphTermStoreRelation is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphTermStoreRelation
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiSitesTermStoresSetsCreateChildrenRequest struct {
	ctx _context.Context
	ApiService *SitesStoreApiService
	siteId string
	storeId string
	setId string
	microsoftGraphTermStoreTerm *MicrosoftGraphTermStoreTerm
}

// New navigation property
func (r ApiSitesTermStoresSetsCreateChildrenRequest) MicrosoftGraphTermStoreTerm(microsoftGraphTermStoreTerm MicrosoftGraphTermStoreTerm) ApiSitesTermStoresSetsCreateChildrenRequest {
	r.microsoftGraphTermStoreTerm = &microsoftGraphTermStoreTerm
	return r
}

func (r ApiSitesTermStoresSetsCreateChildrenRequest) Execute() (MicrosoftGraphTermStoreTerm, *_nethttp.Response, error) {
	return r.ApiService.SitesTermStoresSetsCreateChildrenExecute(r)
}

/*
SitesTermStoresSetsCreateChildren Create new navigation property to children for sites

Children terms of set in term [store].

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param siteId key: id of site
 @param storeId key: id of store
 @param setId key: id of set
 @return ApiSitesTermStoresSetsCreateChildrenRequest
*/
func (a *SitesStoreApiService) SitesTermStoresSetsCreateChildren(ctx _context.Context, siteId string, storeId string, setId string) ApiSitesTermStoresSetsCreateChildrenRequest {
	return ApiSitesTermStoresSetsCreateChildrenRequest{
		ApiService: a,
		ctx: ctx,
		siteId: siteId,
		storeId: storeId,
		setId: setId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphTermStoreTerm
func (a *SitesStoreApiService) SitesTermStoresSetsCreateChildrenExecute(r ApiSitesTermStoresSetsCreateChildrenRequest) (MicrosoftGraphTermStoreTerm, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphTermStoreTerm
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SitesStoreApiService.SitesTermStoresSetsCreateChildren")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sites/{site-id}/termStores/{store-id}/sets/{set-id}/children"
	localVarPath = strings.Replace(localVarPath, "{"+"site-id"+"}", _neturl.PathEscape(parameterToString(r.siteId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"store-id"+"}", _neturl.PathEscape(parameterToString(r.storeId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"set-id"+"}", _neturl.PathEscape(parameterToString(r.setId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphTermStoreTerm == nil {
		return localVarReturnValue, nil, reportError("microsoftGraphTermStoreTerm is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphTermStoreTerm
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSitesTermStoresSetsCreateRelationsRequest struct {
	ctx _context.Context
	ApiService *SitesStoreApiService
	siteId string
	storeId string
	setId string
	microsoftGraphTermStoreRelation *MicrosoftGraphTermStoreRelation
}

// New navigation property
func (r ApiSitesTermStoresSetsCreateRelationsRequest) MicrosoftGraphTermStoreRelation(microsoftGraphTermStoreRelation MicrosoftGraphTermStoreRelation) ApiSitesTermStoresSetsCreateRelationsRequest {
	r.microsoftGraphTermStoreRelation = &microsoftGraphTermStoreRelation
	return r
}

func (r ApiSitesTermStoresSetsCreateRelationsRequest) Execute() (MicrosoftGraphTermStoreRelation, *_nethttp.Response, error) {
	return r.ApiService.SitesTermStoresSetsCreateRelationsExecute(r)
}

/*
SitesTermStoresSetsCreateRelations Create new navigation property to relations for sites

Indicates which terms have been pinned or reused directly under the set.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param siteId key: id of site
 @param storeId key: id of store
 @param setId key: id of set
 @return ApiSitesTermStoresSetsCreateRelationsRequest
*/
func (a *SitesStoreApiService) SitesTermStoresSetsCreateRelations(ctx _context.Context, siteId string, storeId string, setId string) ApiSitesTermStoresSetsCreateRelationsRequest {
	return ApiSitesTermStoresSetsCreateRelationsRequest{
		ApiService: a,
		ctx: ctx,
		siteId: siteId,
		storeId: storeId,
		setId: setId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphTermStoreRelation
func (a *SitesStoreApiService) SitesTermStoresSetsCreateRelationsExecute(r ApiSitesTermStoresSetsCreateRelationsRequest) (MicrosoftGraphTermStoreRelation, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphTermStoreRelation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SitesStoreApiService.SitesTermStoresSetsCreateRelations")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sites/{site-id}/termStores/{store-id}/sets/{set-id}/relations"
	localVarPath = strings.Replace(localVarPath, "{"+"site-id"+"}", _neturl.PathEscape(parameterToString(r.siteId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"store-id"+"}", _neturl.PathEscape(parameterToString(r.storeId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"set-id"+"}", _neturl.PathEscape(parameterToString(r.setId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphTermStoreRelation == nil {
		return localVarReturnValue, nil, reportError("microsoftGraphTermStoreRelation is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphTermStoreRelation
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSitesTermStoresSetsCreateTermsRequest struct {
	ctx _context.Context
	ApiService *SitesStoreApiService
	siteId string
	storeId string
	setId string
	microsoftGraphTermStoreTerm *MicrosoftGraphTermStoreTerm
}

// New navigation property
func (r ApiSitesTermStoresSetsCreateTermsRequest) MicrosoftGraphTermStoreTerm(microsoftGraphTermStoreTerm MicrosoftGraphTermStoreTerm) ApiSitesTermStoresSetsCreateTermsRequest {
	r.microsoftGraphTermStoreTerm = &microsoftGraphTermStoreTerm
	return r
}

func (r ApiSitesTermStoresSetsCreateTermsRequest) Execute() (MicrosoftGraphTermStoreTerm, *_nethttp.Response, error) {
	return r.ApiService.SitesTermStoresSetsCreateTermsExecute(r)
}

/*
SitesTermStoresSetsCreateTerms Create new navigation property to terms for sites

All the terms under the set.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param siteId key: id of site
 @param storeId key: id of store
 @param setId key: id of set
 @return ApiSitesTermStoresSetsCreateTermsRequest
*/
func (a *SitesStoreApiService) SitesTermStoresSetsCreateTerms(ctx _context.Context, siteId string, storeId string, setId string) ApiSitesTermStoresSetsCreateTermsRequest {
	return ApiSitesTermStoresSetsCreateTermsRequest{
		ApiService: a,
		ctx: ctx,
		siteId: siteId,
		storeId: storeId,
		setId: setId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphTermStoreTerm
func (a *SitesStoreApiService) SitesTermStoresSetsCreateTermsExecute(r ApiSitesTermStoresSetsCreateTermsRequest) (MicrosoftGraphTermStoreTerm, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphTermStoreTerm
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SitesStoreApiService.SitesTermStoresSetsCreateTerms")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sites/{site-id}/termStores/{store-id}/sets/{set-id}/terms"
	localVarPath = strings.Replace(localVarPath, "{"+"site-id"+"}", _neturl.PathEscape(parameterToString(r.siteId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"store-id"+"}", _neturl.PathEscape(parameterToString(r.storeId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"set-id"+"}", _neturl.PathEscape(parameterToString(r.setId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphTermStoreTerm == nil {
		return localVarReturnValue, nil, reportError("microsoftGraphTermStoreTerm is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphTermStoreTerm
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSitesTermStoresSetsDeleteChildrenRequest struct {
	ctx _context.Context
	ApiService *SitesStoreApiService
	siteId string
	storeId string
	setId string
	termId string
	ifMatch *string
}

// ETag
func (r ApiSitesTermStoresSetsDeleteChildrenRequest) IfMatch(ifMatch string) ApiSitesTermStoresSetsDeleteChildrenRequest {
	r.ifMatch = &ifMatch
	return r
}

func (r ApiSitesTermStoresSetsDeleteChildrenRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.SitesTermStoresSetsDeleteChildrenExecute(r)
}

/*
SitesTermStoresSetsDeleteChildren Delete navigation property children for sites

Children terms of set in term [store].

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param siteId key: id of site
 @param storeId key: id of store
 @param setId key: id of set
 @param termId key: id of term
 @return ApiSitesTermStoresSetsDeleteChildrenRequest
*/
func (a *SitesStoreApiService) SitesTermStoresSetsDeleteChildren(ctx _context.Context, siteId string, storeId string, setId string, termId string) ApiSitesTermStoresSetsDeleteChildrenRequest {
	return ApiSitesTermStoresSetsDeleteChildrenRequest{
		ApiService: a,
		ctx: ctx,
		siteId: siteId,
		storeId: storeId,
		setId: setId,
		termId: termId,
	}
}

// Execute executes the request
func (a *SitesStoreApiService) SitesTermStoresSetsDeleteChildrenExecute(r ApiSitesTermStoresSetsDeleteChildrenRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SitesStoreApiService.SitesTermStoresSetsDeleteChildren")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sites/{site-id}/termStores/{store-id}/sets/{set-id}/children/{term-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"site-id"+"}", _neturl.PathEscape(parameterToString(r.siteId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"store-id"+"}", _neturl.PathEscape(parameterToString(r.storeId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"set-id"+"}", _neturl.PathEscape(parameterToString(r.setId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"term-id"+"}", _neturl.PathEscape(parameterToString(r.termId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ifMatch != nil {
		localVarHeaderParams["If-Match"] = parameterToString(*r.ifMatch, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiSitesTermStoresSetsDeleteParentGroupRequest struct {
	ctx _context.Context
	ApiService *SitesStoreApiService
	siteId string
	storeId string
	setId string
	ifMatch *string
}

// ETag
func (r ApiSitesTermStoresSetsDeleteParentGroupRequest) IfMatch(ifMatch string) ApiSitesTermStoresSetsDeleteParentGroupRequest {
	r.ifMatch = &ifMatch
	return r
}

func (r ApiSitesTermStoresSetsDeleteParentGroupRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.SitesTermStoresSetsDeleteParentGroupExecute(r)
}

/*
SitesTermStoresSetsDeleteParentGroup Delete navigation property parentGroup for sites

The parent [group] that contains the set.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param siteId key: id of site
 @param storeId key: id of store
 @param setId key: id of set
 @return ApiSitesTermStoresSetsDeleteParentGroupRequest
*/
func (a *SitesStoreApiService) SitesTermStoresSetsDeleteParentGroup(ctx _context.Context, siteId string, storeId string, setId string) ApiSitesTermStoresSetsDeleteParentGroupRequest {
	return ApiSitesTermStoresSetsDeleteParentGroupRequest{
		ApiService: a,
		ctx: ctx,
		siteId: siteId,
		storeId: storeId,
		setId: setId,
	}
}

// Execute executes the request
func (a *SitesStoreApiService) SitesTermStoresSetsDeleteParentGroupExecute(r ApiSitesTermStoresSetsDeleteParentGroupRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SitesStoreApiService.SitesTermStoresSetsDeleteParentGroup")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sites/{site-id}/termStores/{store-id}/sets/{set-id}/parentGroup"
	localVarPath = strings.Replace(localVarPath, "{"+"site-id"+"}", _neturl.PathEscape(parameterToString(r.siteId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"store-id"+"}", _neturl.PathEscape(parameterToString(r.storeId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"set-id"+"}", _neturl.PathEscape(parameterToString(r.setId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ifMatch != nil {
		localVarHeaderParams["If-Match"] = parameterToString(*r.ifMatch, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiSitesTermStoresSetsDeleteRelationsRequest struct {
	ctx _context.Context
	ApiService *SitesStoreApiService
	siteId string
	storeId string
	setId string
	relationId string
	ifMatch *string
}

// ETag
func (r ApiSitesTermStoresSetsDeleteRelationsRequest) IfMatch(ifMatch string) ApiSitesTermStoresSetsDeleteRelationsRequest {
	r.ifMatch = &ifMatch
	return r
}

func (r ApiSitesTermStoresSetsDeleteRelationsRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.SitesTermStoresSetsDeleteRelationsExecute(r)
}

/*
SitesTermStoresSetsDeleteRelations Delete navigation property relations for sites

Indicates which terms have been pinned or reused directly under the set.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param siteId key: id of site
 @param storeId key: id of store
 @param setId key: id of set
 @param relationId key: id of relation
 @return ApiSitesTermStoresSetsDeleteRelationsRequest
*/
func (a *SitesStoreApiService) SitesTermStoresSetsDeleteRelations(ctx _context.Context, siteId string, storeId string, setId string, relationId string) ApiSitesTermStoresSetsDeleteRelationsRequest {
	return ApiSitesTermStoresSetsDeleteRelationsRequest{
		ApiService: a,
		ctx: ctx,
		siteId: siteId,
		storeId: storeId,
		setId: setId,
		relationId: relationId,
	}
}

// Execute executes the request
func (a *SitesStoreApiService) SitesTermStoresSetsDeleteRelationsExecute(r ApiSitesTermStoresSetsDeleteRelationsRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SitesStoreApiService.SitesTermStoresSetsDeleteRelations")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sites/{site-id}/termStores/{store-id}/sets/{set-id}/relations/{relation-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"site-id"+"}", _neturl.PathEscape(parameterToString(r.siteId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"store-id"+"}", _neturl.PathEscape(parameterToString(r.storeId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"set-id"+"}", _neturl.PathEscape(parameterToString(r.setId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"relation-id"+"}", _neturl.PathEscape(parameterToString(r.relationId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ifMatch != nil {
		localVarHeaderParams["If-Match"] = parameterToString(*r.ifMatch, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiSitesTermStoresSetsDeleteTermsRequest struct {
	ctx _context.Context
	ApiService *SitesStoreApiService
	siteId string
	storeId string
	setId string
	termId string
	ifMatch *string
}

// ETag
func (r ApiSitesTermStoresSetsDeleteTermsRequest) IfMatch(ifMatch string) ApiSitesTermStoresSetsDeleteTermsRequest {
	r.ifMatch = &ifMatch
	return r
}

func (r ApiSitesTermStoresSetsDeleteTermsRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.SitesTermStoresSetsDeleteTermsExecute(r)
}

/*
SitesTermStoresSetsDeleteTerms Delete navigation property terms for sites

All the terms under the set.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param siteId key: id of site
 @param storeId key: id of store
 @param setId key: id of set
 @param termId key: id of term
 @return ApiSitesTermStoresSetsDeleteTermsRequest
*/
func (a *SitesStoreApiService) SitesTermStoresSetsDeleteTerms(ctx _context.Context, siteId string, storeId string, setId string, termId string) ApiSitesTermStoresSetsDeleteTermsRequest {
	return ApiSitesTermStoresSetsDeleteTermsRequest{
		ApiService: a,
		ctx: ctx,
		siteId: siteId,
		storeId: storeId,
		setId: setId,
		termId: termId,
	}
}

// Execute executes the request
func (a *SitesStoreApiService) SitesTermStoresSetsDeleteTermsExecute(r ApiSitesTermStoresSetsDeleteTermsRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SitesStoreApiService.SitesTermStoresSetsDeleteTerms")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sites/{site-id}/termStores/{store-id}/sets/{set-id}/terms/{term-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"site-id"+"}", _neturl.PathEscape(parameterToString(r.siteId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"store-id"+"}", _neturl.PathEscape(parameterToString(r.storeId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"set-id"+"}", _neturl.PathEscape(parameterToString(r.setId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"term-id"+"}", _neturl.PathEscape(parameterToString(r.termId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ifMatch != nil {
		localVarHeaderParams["If-Match"] = parameterToString(*r.ifMatch, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiSitesTermStoresSetsGetChildrenRequest struct {
	ctx _context.Context
	ApiService *SitesStoreApiService
	siteId string
	storeId string
	setId string
	termId string
	select_ *[]string
	expand *[]string
}

// Select properties to be returned
func (r ApiSitesTermStoresSetsGetChildrenRequest) Select_(select_ []string) ApiSitesTermStoresSetsGetChildrenRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiSitesTermStoresSetsGetChildrenRequest) Expand(expand []string) ApiSitesTermStoresSetsGetChildrenRequest {
	r.expand = &expand
	return r
}

func (r ApiSitesTermStoresSetsGetChildrenRequest) Execute() (MicrosoftGraphTermStoreTerm, *_nethttp.Response, error) {
	return r.ApiService.SitesTermStoresSetsGetChildrenExecute(r)
}

/*
SitesTermStoresSetsGetChildren Get children from sites

Children terms of set in term [store].

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param siteId key: id of site
 @param storeId key: id of store
 @param setId key: id of set
 @param termId key: id of term
 @return ApiSitesTermStoresSetsGetChildrenRequest
*/
func (a *SitesStoreApiService) SitesTermStoresSetsGetChildren(ctx _context.Context, siteId string, storeId string, setId string, termId string) ApiSitesTermStoresSetsGetChildrenRequest {
	return ApiSitesTermStoresSetsGetChildrenRequest{
		ApiService: a,
		ctx: ctx,
		siteId: siteId,
		storeId: storeId,
		setId: setId,
		termId: termId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphTermStoreTerm
func (a *SitesStoreApiService) SitesTermStoresSetsGetChildrenExecute(r ApiSitesTermStoresSetsGetChildrenRequest) (MicrosoftGraphTermStoreTerm, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphTermStoreTerm
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SitesStoreApiService.SitesTermStoresSetsGetChildren")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sites/{site-id}/termStores/{store-id}/sets/{set-id}/children/{term-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"site-id"+"}", _neturl.PathEscape(parameterToString(r.siteId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"store-id"+"}", _neturl.PathEscape(parameterToString(r.storeId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"set-id"+"}", _neturl.PathEscape(parameterToString(r.setId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"term-id"+"}", _neturl.PathEscape(parameterToString(r.termId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSitesTermStoresSetsGetParentGroupRequest struct {
	ctx _context.Context
	ApiService *SitesStoreApiService
	siteId string
	storeId string
	setId string
	select_ *[]string
	expand *[]string
}

// Select properties to be returned
func (r ApiSitesTermStoresSetsGetParentGroupRequest) Select_(select_ []string) ApiSitesTermStoresSetsGetParentGroupRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiSitesTermStoresSetsGetParentGroupRequest) Expand(expand []string) ApiSitesTermStoresSetsGetParentGroupRequest {
	r.expand = &expand
	return r
}

func (r ApiSitesTermStoresSetsGetParentGroupRequest) Execute() (MicrosoftGraphTermStoreGroup, *_nethttp.Response, error) {
	return r.ApiService.SitesTermStoresSetsGetParentGroupExecute(r)
}

/*
SitesTermStoresSetsGetParentGroup Get parentGroup from sites

The parent [group] that contains the set.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param siteId key: id of site
 @param storeId key: id of store
 @param setId key: id of set
 @return ApiSitesTermStoresSetsGetParentGroupRequest
*/
func (a *SitesStoreApiService) SitesTermStoresSetsGetParentGroup(ctx _context.Context, siteId string, storeId string, setId string) ApiSitesTermStoresSetsGetParentGroupRequest {
	return ApiSitesTermStoresSetsGetParentGroupRequest{
		ApiService: a,
		ctx: ctx,
		siteId: siteId,
		storeId: storeId,
		setId: setId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphTermStoreGroup
func (a *SitesStoreApiService) SitesTermStoresSetsGetParentGroupExecute(r ApiSitesTermStoresSetsGetParentGroupRequest) (MicrosoftGraphTermStoreGroup, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphTermStoreGroup
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SitesStoreApiService.SitesTermStoresSetsGetParentGroup")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sites/{site-id}/termStores/{store-id}/sets/{set-id}/parentGroup"
	localVarPath = strings.Replace(localVarPath, "{"+"site-id"+"}", _neturl.PathEscape(parameterToString(r.siteId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"store-id"+"}", _neturl.PathEscape(parameterToString(r.storeId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"set-id"+"}", _neturl.PathEscape(parameterToString(r.setId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSitesTermStoresSetsGetRelationsRequest struct {
	ctx _context.Context
	ApiService *SitesStoreApiService
	siteId string
	storeId string
	setId string
	relationId string
	select_ *[]string
	expand *[]string
}

// Select properties to be returned
func (r ApiSitesTermStoresSetsGetRelationsRequest) Select_(select_ []string) ApiSitesTermStoresSetsGetRelationsRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiSitesTermStoresSetsGetRelationsRequest) Expand(expand []string) ApiSitesTermStoresSetsGetRelationsRequest {
	r.expand = &expand
	return r
}

func (r ApiSitesTermStoresSetsGetRelationsRequest) Execute() (MicrosoftGraphTermStoreRelation, *_nethttp.Response, error) {
	return r.ApiService.SitesTermStoresSetsGetRelationsExecute(r)
}

/*
SitesTermStoresSetsGetRelations Get relations from sites

Indicates which terms have been pinned or reused directly under the set.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param siteId key: id of site
 @param storeId key: id of store
 @param setId key: id of set
 @param relationId key: id of relation
 @return ApiSitesTermStoresSetsGetRelationsRequest
*/
func (a *SitesStoreApiService) SitesTermStoresSetsGetRelations(ctx _context.Context, siteId string, storeId string, setId string, relationId string) ApiSitesTermStoresSetsGetRelationsRequest {
	return ApiSitesTermStoresSetsGetRelationsRequest{
		ApiService: a,
		ctx: ctx,
		siteId: siteId,
		storeId: storeId,
		setId: setId,
		relationId: relationId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphTermStoreRelation
func (a *SitesStoreApiService) SitesTermStoresSetsGetRelationsExecute(r ApiSitesTermStoresSetsGetRelationsRequest) (MicrosoftGraphTermStoreRelation, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphTermStoreRelation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SitesStoreApiService.SitesTermStoresSetsGetRelations")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sites/{site-id}/termStores/{store-id}/sets/{set-id}/relations/{relation-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"site-id"+"}", _neturl.PathEscape(parameterToString(r.siteId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"store-id"+"}", _neturl.PathEscape(parameterToString(r.storeId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"set-id"+"}", _neturl.PathEscape(parameterToString(r.setId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"relation-id"+"}", _neturl.PathEscape(parameterToString(r.relationId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSitesTermStoresSetsGetTermsRequest struct {
	ctx _context.Context
	ApiService *SitesStoreApiService
	siteId string
	storeId string
	setId string
	termId string
	select_ *[]string
	expand *[]string
}

// Select properties to be returned
func (r ApiSitesTermStoresSetsGetTermsRequest) Select_(select_ []string) ApiSitesTermStoresSetsGetTermsRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiSitesTermStoresSetsGetTermsRequest) Expand(expand []string) ApiSitesTermStoresSetsGetTermsRequest {
	r.expand = &expand
	return r
}

func (r ApiSitesTermStoresSetsGetTermsRequest) Execute() (MicrosoftGraphTermStoreTerm, *_nethttp.Response, error) {
	return r.ApiService.SitesTermStoresSetsGetTermsExecute(r)
}

/*
SitesTermStoresSetsGetTerms Get terms from sites

All the terms under the set.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param siteId key: id of site
 @param storeId key: id of store
 @param setId key: id of set
 @param termId key: id of term
 @return ApiSitesTermStoresSetsGetTermsRequest
*/
func (a *SitesStoreApiService) SitesTermStoresSetsGetTerms(ctx _context.Context, siteId string, storeId string, setId string, termId string) ApiSitesTermStoresSetsGetTermsRequest {
	return ApiSitesTermStoresSetsGetTermsRequest{
		ApiService: a,
		ctx: ctx,
		siteId: siteId,
		storeId: storeId,
		setId: setId,
		termId: termId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphTermStoreTerm
func (a *SitesStoreApiService) SitesTermStoresSetsGetTermsExecute(r ApiSitesTermStoresSetsGetTermsRequest) (MicrosoftGraphTermStoreTerm, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphTermStoreTerm
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SitesStoreApiService.SitesTermStoresSetsGetTerms")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sites/{site-id}/termStores/{store-id}/sets/{set-id}/terms/{term-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"site-id"+"}", _neturl.PathEscape(parameterToString(r.siteId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"store-id"+"}", _neturl.PathEscape(parameterToString(r.storeId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"set-id"+"}", _neturl.PathEscape(parameterToString(r.setId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"term-id"+"}", _neturl.PathEscape(parameterToString(r.termId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSitesTermStoresSetsListChildrenRequest struct {
	ctx _context.Context
	ApiService *SitesStoreApiService
	siteId string
	storeId string
	setId string
	top *int32
	skip *int32
	search *string
	filter *string
	count *bool
	orderby *[]string
	select_ *[]string
	expand *[]string
}

// Show only the first n items
func (r ApiSitesTermStoresSetsListChildrenRequest) Top(top int32) ApiSitesTermStoresSetsListChildrenRequest {
	r.top = &top
	return r
}
// Skip the first n items
func (r ApiSitesTermStoresSetsListChildrenRequest) Skip(skip int32) ApiSitesTermStoresSetsListChildrenRequest {
	r.skip = &skip
	return r
}
// Search items by search phrases
func (r ApiSitesTermStoresSetsListChildrenRequest) Search(search string) ApiSitesTermStoresSetsListChildrenRequest {
	r.search = &search
	return r
}
// Filter items by property values
func (r ApiSitesTermStoresSetsListChildrenRequest) Filter(filter string) ApiSitesTermStoresSetsListChildrenRequest {
	r.filter = &filter
	return r
}
// Include count of items
func (r ApiSitesTermStoresSetsListChildrenRequest) Count(count bool) ApiSitesTermStoresSetsListChildrenRequest {
	r.count = &count
	return r
}
// Order items by property values
func (r ApiSitesTermStoresSetsListChildrenRequest) Orderby(orderby []string) ApiSitesTermStoresSetsListChildrenRequest {
	r.orderby = &orderby
	return r
}
// Select properties to be returned
func (r ApiSitesTermStoresSetsListChildrenRequest) Select_(select_ []string) ApiSitesTermStoresSetsListChildrenRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiSitesTermStoresSetsListChildrenRequest) Expand(expand []string) ApiSitesTermStoresSetsListChildrenRequest {
	r.expand = &expand
	return r
}

func (r ApiSitesTermStoresSetsListChildrenRequest) Execute() (CollectionOfTerm, *_nethttp.Response, error) {
	return r.ApiService.SitesTermStoresSetsListChildrenExecute(r)
}

/*
SitesTermStoresSetsListChildren Get children from sites

Children terms of set in term [store].

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param siteId key: id of site
 @param storeId key: id of store
 @param setId key: id of set
 @return ApiSitesTermStoresSetsListChildrenRequest
*/
func (a *SitesStoreApiService) SitesTermStoresSetsListChildren(ctx _context.Context, siteId string, storeId string, setId string) ApiSitesTermStoresSetsListChildrenRequest {
	return ApiSitesTermStoresSetsListChildrenRequest{
		ApiService: a,
		ctx: ctx,
		siteId: siteId,
		storeId: storeId,
		setId: setId,
	}
}

// Execute executes the request
//  @return CollectionOfTerm
func (a *SitesStoreApiService) SitesTermStoresSetsListChildrenExecute(r ApiSitesTermStoresSetsListChildrenRequest) (CollectionOfTerm, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  CollectionOfTerm
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SitesStoreApiService.SitesTermStoresSetsListChildren")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sites/{site-id}/termStores/{store-id}/sets/{set-id}/children"
	localVarPath = strings.Replace(localVarPath, "{"+"site-id"+"}", _neturl.PathEscape(parameterToString(r.siteId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"store-id"+"}", _neturl.PathEscape(parameterToString(r.storeId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"set-id"+"}", _neturl.PathEscape(parameterToString(r.setId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.top != nil {
		localVarQueryParams.Add("$top", parameterToString(*r.top, ""))
	}
	if r.skip != nil {
		localVarQueryParams.Add("$skip", parameterToString(*r.skip, ""))
	}
	if r.search != nil {
		localVarQueryParams.Add("$search", parameterToString(*r.search, ""))
	}
	if r.filter != nil {
		localVarQueryParams.Add("$filter", parameterToString(*r.filter, ""))
	}
	if r.count != nil {
		localVarQueryParams.Add("$count", parameterToString(*r.count, ""))
	}
	if r.orderby != nil {
		localVarQueryParams.Add("$orderby", parameterToString(*r.orderby, "csv"))
	}
	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSitesTermStoresSetsListRelationsRequest struct {
	ctx _context.Context
	ApiService *SitesStoreApiService
	siteId string
	storeId string
	setId string
	top *int32
	skip *int32
	search *string
	filter *string
	count *bool
	orderby *[]string
	select_ *[]string
	expand *[]string
}

// Show only the first n items
func (r ApiSitesTermStoresSetsListRelationsRequest) Top(top int32) ApiSitesTermStoresSetsListRelationsRequest {
	r.top = &top
	return r
}
// Skip the first n items
func (r ApiSitesTermStoresSetsListRelationsRequest) Skip(skip int32) ApiSitesTermStoresSetsListRelationsRequest {
	r.skip = &skip
	return r
}
// Search items by search phrases
func (r ApiSitesTermStoresSetsListRelationsRequest) Search(search string) ApiSitesTermStoresSetsListRelationsRequest {
	r.search = &search
	return r
}
// Filter items by property values
func (r ApiSitesTermStoresSetsListRelationsRequest) Filter(filter string) ApiSitesTermStoresSetsListRelationsRequest {
	r.filter = &filter
	return r
}
// Include count of items
func (r ApiSitesTermStoresSetsListRelationsRequest) Count(count bool) ApiSitesTermStoresSetsListRelationsRequest {
	r.count = &count
	return r
}
// Order items by property values
func (r ApiSitesTermStoresSetsListRelationsRequest) Orderby(orderby []string) ApiSitesTermStoresSetsListRelationsRequest {
	r.orderby = &orderby
	return r
}
// Select properties to be returned
func (r ApiSitesTermStoresSetsListRelationsRequest) Select_(select_ []string) ApiSitesTermStoresSetsListRelationsRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiSitesTermStoresSetsListRelationsRequest) Expand(expand []string) ApiSitesTermStoresSetsListRelationsRequest {
	r.expand = &expand
	return r
}

func (r ApiSitesTermStoresSetsListRelationsRequest) Execute() (CollectionOfRelation, *_nethttp.Response, error) {
	return r.ApiService.SitesTermStoresSetsListRelationsExecute(r)
}

/*
SitesTermStoresSetsListRelations Get relations from sites

Indicates which terms have been pinned or reused directly under the set.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param siteId key: id of site
 @param storeId key: id of store
 @param setId key: id of set
 @return ApiSitesTermStoresSetsListRelationsRequest
*/
func (a *SitesStoreApiService) SitesTermStoresSetsListRelations(ctx _context.Context, siteId string, storeId string, setId string) ApiSitesTermStoresSetsListRelationsRequest {
	return ApiSitesTermStoresSetsListRelationsRequest{
		ApiService: a,
		ctx: ctx,
		siteId: siteId,
		storeId: storeId,
		setId: setId,
	}
}

// Execute executes the request
//  @return CollectionOfRelation
func (a *SitesStoreApiService) SitesTermStoresSetsListRelationsExecute(r ApiSitesTermStoresSetsListRelationsRequest) (CollectionOfRelation, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  CollectionOfRelation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SitesStoreApiService.SitesTermStoresSetsListRelations")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sites/{site-id}/termStores/{store-id}/sets/{set-id}/relations"
	localVarPath = strings.Replace(localVarPath, "{"+"site-id"+"}", _neturl.PathEscape(parameterToString(r.siteId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"store-id"+"}", _neturl.PathEscape(parameterToString(r.storeId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"set-id"+"}", _neturl.PathEscape(parameterToString(r.setId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.top != nil {
		localVarQueryParams.Add("$top", parameterToString(*r.top, ""))
	}
	if r.skip != nil {
		localVarQueryParams.Add("$skip", parameterToString(*r.skip, ""))
	}
	if r.search != nil {
		localVarQueryParams.Add("$search", parameterToString(*r.search, ""))
	}
	if r.filter != nil {
		localVarQueryParams.Add("$filter", parameterToString(*r.filter, ""))
	}
	if r.count != nil {
		localVarQueryParams.Add("$count", parameterToString(*r.count, ""))
	}
	if r.orderby != nil {
		localVarQueryParams.Add("$orderby", parameterToString(*r.orderby, "csv"))
	}
	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSitesTermStoresSetsListTermsRequest struct {
	ctx _context.Context
	ApiService *SitesStoreApiService
	siteId string
	storeId string
	setId string
	top *int32
	skip *int32
	search *string
	filter *string
	count *bool
	orderby *[]string
	select_ *[]string
	expand *[]string
}

// Show only the first n items
func (r ApiSitesTermStoresSetsListTermsRequest) Top(top int32) ApiSitesTermStoresSetsListTermsRequest {
	r.top = &top
	return r
}
// Skip the first n items
func (r ApiSitesTermStoresSetsListTermsRequest) Skip(skip int32) ApiSitesTermStoresSetsListTermsRequest {
	r.skip = &skip
	return r
}
// Search items by search phrases
func (r ApiSitesTermStoresSetsListTermsRequest) Search(search string) ApiSitesTermStoresSetsListTermsRequest {
	r.search = &search
	return r
}
// Filter items by property values
func (r ApiSitesTermStoresSetsListTermsRequest) Filter(filter string) ApiSitesTermStoresSetsListTermsRequest {
	r.filter = &filter
	return r
}
// Include count of items
func (r ApiSitesTermStoresSetsListTermsRequest) Count(count bool) ApiSitesTermStoresSetsListTermsRequest {
	r.count = &count
	return r
}
// Order items by property values
func (r ApiSitesTermStoresSetsListTermsRequest) Orderby(orderby []string) ApiSitesTermStoresSetsListTermsRequest {
	r.orderby = &orderby
	return r
}
// Select properties to be returned
func (r ApiSitesTermStoresSetsListTermsRequest) Select_(select_ []string) ApiSitesTermStoresSetsListTermsRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiSitesTermStoresSetsListTermsRequest) Expand(expand []string) ApiSitesTermStoresSetsListTermsRequest {
	r.expand = &expand
	return r
}

func (r ApiSitesTermStoresSetsListTermsRequest) Execute() (CollectionOfTerm, *_nethttp.Response, error) {
	return r.ApiService.SitesTermStoresSetsListTermsExecute(r)
}

/*
SitesTermStoresSetsListTerms Get terms from sites

All the terms under the set.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param siteId key: id of site
 @param storeId key: id of store
 @param setId key: id of set
 @return ApiSitesTermStoresSetsListTermsRequest
*/
func (a *SitesStoreApiService) SitesTermStoresSetsListTerms(ctx _context.Context, siteId string, storeId string, setId string) ApiSitesTermStoresSetsListTermsRequest {
	return ApiSitesTermStoresSetsListTermsRequest{
		ApiService: a,
		ctx: ctx,
		siteId: siteId,
		storeId: storeId,
		setId: setId,
	}
}

// Execute executes the request
//  @return CollectionOfTerm
func (a *SitesStoreApiService) SitesTermStoresSetsListTermsExecute(r ApiSitesTermStoresSetsListTermsRequest) (CollectionOfTerm, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  CollectionOfTerm
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SitesStoreApiService.SitesTermStoresSetsListTerms")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sites/{site-id}/termStores/{store-id}/sets/{set-id}/terms"
	localVarPath = strings.Replace(localVarPath, "{"+"site-id"+"}", _neturl.PathEscape(parameterToString(r.siteId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"store-id"+"}", _neturl.PathEscape(parameterToString(r.storeId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"set-id"+"}", _neturl.PathEscape(parameterToString(r.setId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.top != nil {
		localVarQueryParams.Add("$top", parameterToString(*r.top, ""))
	}
	if r.skip != nil {
		localVarQueryParams.Add("$skip", parameterToString(*r.skip, ""))
	}
	if r.search != nil {
		localVarQueryParams.Add("$search", parameterToString(*r.search, ""))
	}
	if r.filter != nil {
		localVarQueryParams.Add("$filter", parameterToString(*r.filter, ""))
	}
	if r.count != nil {
		localVarQueryParams.Add("$count", parameterToString(*r.count, ""))
	}
	if r.orderby != nil {
		localVarQueryParams.Add("$orderby", parameterToString(*r.orderby, "csv"))
	}
	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSitesTermStoresSetsParentGroupCreateSetsRequest struct {
	ctx _context.Context
	ApiService *SitesStoreApiService
	siteId string
	storeId string
	setId string
	microsoftGraphTermStoreSet *MicrosoftGraphTermStoreSet
}

// New navigation property
func (r ApiSitesTermStoresSetsParentGroupCreateSetsRequest) MicrosoftGraphTermStoreSet(microsoftGraphTermStoreSet MicrosoftGraphTermStoreSet) ApiSitesTermStoresSetsParentGroupCreateSetsRequest {
	r.microsoftGraphTermStoreSet = &microsoftGraphTermStoreSet
	return r
}

func (r ApiSitesTermStoresSetsParentGroupCreateSetsRequest) Execute() (MicrosoftGraphTermStoreSet, *_nethttp.Response, error) {
	return r.ApiService.SitesTermStoresSetsParentGroupCreateSetsExecute(r)
}

/*
SitesTermStoresSetsParentGroupCreateSets Create new navigation property to sets for sites

All sets under the group in a term [store].

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param siteId key: id of site
 @param storeId key: id of store
 @param setId key: id of set
 @return ApiSitesTermStoresSetsParentGroupCreateSetsRequest
*/
func (a *SitesStoreApiService) SitesTermStoresSetsParentGroupCreateSets(ctx _context.Context, siteId string, storeId string, setId string) ApiSitesTermStoresSetsParentGroupCreateSetsRequest {
	return ApiSitesTermStoresSetsParentGroupCreateSetsRequest{
		ApiService: a,
		ctx: ctx,
		siteId: siteId,
		storeId: storeId,
		setId: setId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphTermStoreSet
func (a *SitesStoreApiService) SitesTermStoresSetsParentGroupCreateSetsExecute(r ApiSitesTermStoresSetsParentGroupCreateSetsRequest) (MicrosoftGraphTermStoreSet, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphTermStoreSet
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SitesStoreApiService.SitesTermStoresSetsParentGroupCreateSets")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sites/{site-id}/termStores/{store-id}/sets/{set-id}/parentGroup/sets"
	localVarPath = strings.Replace(localVarPath, "{"+"site-id"+"}", _neturl.PathEscape(parameterToString(r.siteId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"store-id"+"}", _neturl.PathEscape(parameterToString(r.storeId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"set-id"+"}", _neturl.PathEscape(parameterToString(r.setId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphTermStoreSet == nil {
		return localVarReturnValue, nil, reportError("microsoftGraphTermStoreSet is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphTermStoreSet
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSitesTermStoresSetsParentGroupDeleteSetsRequest struct {
	ctx _context.Context
	ApiService *SitesStoreApiService
	siteId string
	storeId string
	setId string
	setId1 string
	ifMatch *string
}

// ETag
func (r ApiSitesTermStoresSetsParentGroupDeleteSetsRequest) IfMatch(ifMatch string) ApiSitesTermStoresSetsParentGroupDeleteSetsRequest {
	r.ifMatch = &ifMatch
	return r
}

func (r ApiSitesTermStoresSetsParentGroupDeleteSetsRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.SitesTermStoresSetsParentGroupDeleteSetsExecute(r)
}

/*
SitesTermStoresSetsParentGroupDeleteSets Delete navigation property sets for sites

All sets under the group in a term [store].

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param siteId key: id of site
 @param storeId key: id of store
 @param setId key: id of set
 @param setId1 key: id of set
 @return ApiSitesTermStoresSetsParentGroupDeleteSetsRequest
*/
func (a *SitesStoreApiService) SitesTermStoresSetsParentGroupDeleteSets(ctx _context.Context, siteId string, storeId string, setId string, setId1 string) ApiSitesTermStoresSetsParentGroupDeleteSetsRequest {
	return ApiSitesTermStoresSetsParentGroupDeleteSetsRequest{
		ApiService: a,
		ctx: ctx,
		siteId: siteId,
		storeId: storeId,
		setId: setId,
		setId1: setId1,
	}
}

// Execute executes the request
func (a *SitesStoreApiService) SitesTermStoresSetsParentGroupDeleteSetsExecute(r ApiSitesTermStoresSetsParentGroupDeleteSetsRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SitesStoreApiService.SitesTermStoresSetsParentGroupDeleteSets")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sites/{site-id}/termStores/{store-id}/sets/{set-id}/parentGroup/sets/{set-id1}"
	localVarPath = strings.Replace(localVarPath, "{"+"site-id"+"}", _neturl.PathEscape(parameterToString(r.siteId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"store-id"+"}", _neturl.PathEscape(parameterToString(r.storeId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"set-id"+"}", _neturl.PathEscape(parameterToString(r.setId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"set-id1"+"}", _neturl.PathEscape(parameterToString(r.setId1, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ifMatch != nil {
		localVarHeaderParams["If-Match"] = parameterToString(*r.ifMatch, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiSitesTermStoresSetsParentGroupGetSetsRequest struct {
	ctx _context.Context
	ApiService *SitesStoreApiService
	siteId string
	storeId string
	setId string
	setId1 string
	select_ *[]string
	expand *[]string
}

// Select properties to be returned
func (r ApiSitesTermStoresSetsParentGroupGetSetsRequest) Select_(select_ []string) ApiSitesTermStoresSetsParentGroupGetSetsRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiSitesTermStoresSetsParentGroupGetSetsRequest) Expand(expand []string) ApiSitesTermStoresSetsParentGroupGetSetsRequest {
	r.expand = &expand
	return r
}

func (r ApiSitesTermStoresSetsParentGroupGetSetsRequest) Execute() (MicrosoftGraphTermStoreSet, *_nethttp.Response, error) {
	return r.ApiService.SitesTermStoresSetsParentGroupGetSetsExecute(r)
}

/*
SitesTermStoresSetsParentGroupGetSets Get sets from sites

All sets under the group in a term [store].

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param siteId key: id of site
 @param storeId key: id of store
 @param setId key: id of set
 @param setId1 key: id of set
 @return ApiSitesTermStoresSetsParentGroupGetSetsRequest
*/
func (a *SitesStoreApiService) SitesTermStoresSetsParentGroupGetSets(ctx _context.Context, siteId string, storeId string, setId string, setId1 string) ApiSitesTermStoresSetsParentGroupGetSetsRequest {
	return ApiSitesTermStoresSetsParentGroupGetSetsRequest{
		ApiService: a,
		ctx: ctx,
		siteId: siteId,
		storeId: storeId,
		setId: setId,
		setId1: setId1,
	}
}

// Execute executes the request
//  @return MicrosoftGraphTermStoreSet
func (a *SitesStoreApiService) SitesTermStoresSetsParentGroupGetSetsExecute(r ApiSitesTermStoresSetsParentGroupGetSetsRequest) (MicrosoftGraphTermStoreSet, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphTermStoreSet
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SitesStoreApiService.SitesTermStoresSetsParentGroupGetSets")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sites/{site-id}/termStores/{store-id}/sets/{set-id}/parentGroup/sets/{set-id1}"
	localVarPath = strings.Replace(localVarPath, "{"+"site-id"+"}", _neturl.PathEscape(parameterToString(r.siteId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"store-id"+"}", _neturl.PathEscape(parameterToString(r.storeId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"set-id"+"}", _neturl.PathEscape(parameterToString(r.setId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"set-id1"+"}", _neturl.PathEscape(parameterToString(r.setId1, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSitesTermStoresSetsParentGroupListSetsRequest struct {
	ctx _context.Context
	ApiService *SitesStoreApiService
	siteId string
	storeId string
	setId string
	top *int32
	skip *int32
	search *string
	filter *string
	count *bool
	orderby *[]string
	select_ *[]string
	expand *[]string
}

// Show only the first n items
func (r ApiSitesTermStoresSetsParentGroupListSetsRequest) Top(top int32) ApiSitesTermStoresSetsParentGroupListSetsRequest {
	r.top = &top
	return r
}
// Skip the first n items
func (r ApiSitesTermStoresSetsParentGroupListSetsRequest) Skip(skip int32) ApiSitesTermStoresSetsParentGroupListSetsRequest {
	r.skip = &skip
	return r
}
// Search items by search phrases
func (r ApiSitesTermStoresSetsParentGroupListSetsRequest) Search(search string) ApiSitesTermStoresSetsParentGroupListSetsRequest {
	r.search = &search
	return r
}
// Filter items by property values
func (r ApiSitesTermStoresSetsParentGroupListSetsRequest) Filter(filter string) ApiSitesTermStoresSetsParentGroupListSetsRequest {
	r.filter = &filter
	return r
}
// Include count of items
func (r ApiSitesTermStoresSetsParentGroupListSetsRequest) Count(count bool) ApiSitesTermStoresSetsParentGroupListSetsRequest {
	r.count = &count
	return r
}
// Order items by property values
func (r ApiSitesTermStoresSetsParentGroupListSetsRequest) Orderby(orderby []string) ApiSitesTermStoresSetsParentGroupListSetsRequest {
	r.orderby = &orderby
	return r
}
// Select properties to be returned
func (r ApiSitesTermStoresSetsParentGroupListSetsRequest) Select_(select_ []string) ApiSitesTermStoresSetsParentGroupListSetsRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiSitesTermStoresSetsParentGroupListSetsRequest) Expand(expand []string) ApiSitesTermStoresSetsParentGroupListSetsRequest {
	r.expand = &expand
	return r
}

func (r ApiSitesTermStoresSetsParentGroupListSetsRequest) Execute() (CollectionOfSet, *_nethttp.Response, error) {
	return r.ApiService.SitesTermStoresSetsParentGroupListSetsExecute(r)
}

/*
SitesTermStoresSetsParentGroupListSets Get sets from sites

All sets under the group in a term [store].

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param siteId key: id of site
 @param storeId key: id of store
 @param setId key: id of set
 @return ApiSitesTermStoresSetsParentGroupListSetsRequest
*/
func (a *SitesStoreApiService) SitesTermStoresSetsParentGroupListSets(ctx _context.Context, siteId string, storeId string, setId string) ApiSitesTermStoresSetsParentGroupListSetsRequest {
	return ApiSitesTermStoresSetsParentGroupListSetsRequest{
		ApiService: a,
		ctx: ctx,
		siteId: siteId,
		storeId: storeId,
		setId: setId,
	}
}

// Execute executes the request
//  @return CollectionOfSet
func (a *SitesStoreApiService) SitesTermStoresSetsParentGroupListSetsExecute(r ApiSitesTermStoresSetsParentGroupListSetsRequest) (CollectionOfSet, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  CollectionOfSet
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SitesStoreApiService.SitesTermStoresSetsParentGroupListSets")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sites/{site-id}/termStores/{store-id}/sets/{set-id}/parentGroup/sets"
	localVarPath = strings.Replace(localVarPath, "{"+"site-id"+"}", _neturl.PathEscape(parameterToString(r.siteId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"store-id"+"}", _neturl.PathEscape(parameterToString(r.storeId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"set-id"+"}", _neturl.PathEscape(parameterToString(r.setId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.top != nil {
		localVarQueryParams.Add("$top", parameterToString(*r.top, ""))
	}
	if r.skip != nil {
		localVarQueryParams.Add("$skip", parameterToString(*r.skip, ""))
	}
	if r.search != nil {
		localVarQueryParams.Add("$search", parameterToString(*r.search, ""))
	}
	if r.filter != nil {
		localVarQueryParams.Add("$filter", parameterToString(*r.filter, ""))
	}
	if r.count != nil {
		localVarQueryParams.Add("$count", parameterToString(*r.count, ""))
	}
	if r.orderby != nil {
		localVarQueryParams.Add("$orderby", parameterToString(*r.orderby, "csv"))
	}
	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSitesTermStoresSetsParentGroupUpdateSetsRequest struct {
	ctx _context.Context
	ApiService *SitesStoreApiService
	siteId string
	storeId string
	setId string
	setId1 string
	microsoftGraphTermStoreSet *MicrosoftGraphTermStoreSet
}

// New navigation property values
func (r ApiSitesTermStoresSetsParentGroupUpdateSetsRequest) MicrosoftGraphTermStoreSet(microsoftGraphTermStoreSet MicrosoftGraphTermStoreSet) ApiSitesTermStoresSetsParentGroupUpdateSetsRequest {
	r.microsoftGraphTermStoreSet = &microsoftGraphTermStoreSet
	return r
}

func (r ApiSitesTermStoresSetsParentGroupUpdateSetsRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.SitesTermStoresSetsParentGroupUpdateSetsExecute(r)
}

/*
SitesTermStoresSetsParentGroupUpdateSets Update the navigation property sets in sites

All sets under the group in a term [store].

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param siteId key: id of site
 @param storeId key: id of store
 @param setId key: id of set
 @param setId1 key: id of set
 @return ApiSitesTermStoresSetsParentGroupUpdateSetsRequest
*/
func (a *SitesStoreApiService) SitesTermStoresSetsParentGroupUpdateSets(ctx _context.Context, siteId string, storeId string, setId string, setId1 string) ApiSitesTermStoresSetsParentGroupUpdateSetsRequest {
	return ApiSitesTermStoresSetsParentGroupUpdateSetsRequest{
		ApiService: a,
		ctx: ctx,
		siteId: siteId,
		storeId: storeId,
		setId: setId,
		setId1: setId1,
	}
}

// Execute executes the request
func (a *SitesStoreApiService) SitesTermStoresSetsParentGroupUpdateSetsExecute(r ApiSitesTermStoresSetsParentGroupUpdateSetsRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPatch
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SitesStoreApiService.SitesTermStoresSetsParentGroupUpdateSets")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sites/{site-id}/termStores/{store-id}/sets/{set-id}/parentGroup/sets/{set-id1}"
	localVarPath = strings.Replace(localVarPath, "{"+"site-id"+"}", _neturl.PathEscape(parameterToString(r.siteId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"store-id"+"}", _neturl.PathEscape(parameterToString(r.storeId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"set-id"+"}", _neturl.PathEscape(parameterToString(r.setId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"set-id1"+"}", _neturl.PathEscape(parameterToString(r.setId1, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphTermStoreSet == nil {
		return nil, reportError("microsoftGraphTermStoreSet is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphTermStoreSet
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiSitesTermStoresSetsRelationsDeleteRefFromTermRequest struct {
	ctx _context.Context
	ApiService *SitesStoreApiService
	siteId string
	storeId string
	setId string
	relationId string
	ifMatch *string
}

// ETag
func (r ApiSitesTermStoresSetsRelationsDeleteRefFromTermRequest) IfMatch(ifMatch string) ApiSitesTermStoresSetsRelationsDeleteRefFromTermRequest {
	r.ifMatch = &ifMatch
	return r
}

func (r ApiSitesTermStoresSetsRelationsDeleteRefFromTermRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.SitesTermStoresSetsRelationsDeleteRefFromTermExecute(r)
}

/*
SitesTermStoresSetsRelationsDeleteRefFromTerm Delete ref of navigation property fromTerm for sites

The from [term] of the relation. The term from which the relationship is defined. A null value would indicate the relation is directly with the [set].

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param siteId key: id of site
 @param storeId key: id of store
 @param setId key: id of set
 @param relationId key: id of relation
 @return ApiSitesTermStoresSetsRelationsDeleteRefFromTermRequest
*/
func (a *SitesStoreApiService) SitesTermStoresSetsRelationsDeleteRefFromTerm(ctx _context.Context, siteId string, storeId string, setId string, relationId string) ApiSitesTermStoresSetsRelationsDeleteRefFromTermRequest {
	return ApiSitesTermStoresSetsRelationsDeleteRefFromTermRequest{
		ApiService: a,
		ctx: ctx,
		siteId: siteId,
		storeId: storeId,
		setId: setId,
		relationId: relationId,
	}
}

// Execute executes the request
func (a *SitesStoreApiService) SitesTermStoresSetsRelationsDeleteRefFromTermExecute(r ApiSitesTermStoresSetsRelationsDeleteRefFromTermRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SitesStoreApiService.SitesTermStoresSetsRelationsDeleteRefFromTerm")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sites/{site-id}/termStores/{store-id}/sets/{set-id}/relations/{relation-id}/fromTerm/$ref"
	localVarPath = strings.Replace(localVarPath, "{"+"site-id"+"}", _neturl.PathEscape(parameterToString(r.siteId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"store-id"+"}", _neturl.PathEscape(parameterToString(r.storeId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"set-id"+"}", _neturl.PathEscape(parameterToString(r.setId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"relation-id"+"}", _neturl.PathEscape(parameterToString(r.relationId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ifMatch != nil {
		localVarHeaderParams["If-Match"] = parameterToString(*r.ifMatch, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiSitesTermStoresSetsRelationsDeleteRefSetRequest struct {
	ctx _context.Context
	ApiService *SitesStoreApiService
	siteId string
	storeId string
	setId string
	relationId string
	ifMatch *string
}

// ETag
func (r ApiSitesTermStoresSetsRelationsDeleteRefSetRequest) IfMatch(ifMatch string) ApiSitesTermStoresSetsRelationsDeleteRefSetRequest {
	r.ifMatch = &ifMatch
	return r
}

func (r ApiSitesTermStoresSetsRelationsDeleteRefSetRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.SitesTermStoresSetsRelationsDeleteRefSetExecute(r)
}

/*
SitesTermStoresSetsRelationsDeleteRefSet Delete ref of navigation property set for sites

The [set] in which the relation is relevant.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param siteId key: id of site
 @param storeId key: id of store
 @param setId key: id of set
 @param relationId key: id of relation
 @return ApiSitesTermStoresSetsRelationsDeleteRefSetRequest
*/
func (a *SitesStoreApiService) SitesTermStoresSetsRelationsDeleteRefSet(ctx _context.Context, siteId string, storeId string, setId string, relationId string) ApiSitesTermStoresSetsRelationsDeleteRefSetRequest {
	return ApiSitesTermStoresSetsRelationsDeleteRefSetRequest{
		ApiService: a,
		ctx: ctx,
		siteId: siteId,
		storeId: storeId,
		setId: setId,
		relationId: relationId,
	}
}

// Execute executes the request
func (a *SitesStoreApiService) SitesTermStoresSetsRelationsDeleteRefSetExecute(r ApiSitesTermStoresSetsRelationsDeleteRefSetRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SitesStoreApiService.SitesTermStoresSetsRelationsDeleteRefSet")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sites/{site-id}/termStores/{store-id}/sets/{set-id}/relations/{relation-id}/set/$ref"
	localVarPath = strings.Replace(localVarPath, "{"+"site-id"+"}", _neturl.PathEscape(parameterToString(r.siteId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"store-id"+"}", _neturl.PathEscape(parameterToString(r.storeId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"set-id"+"}", _neturl.PathEscape(parameterToString(r.setId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"relation-id"+"}", _neturl.PathEscape(parameterToString(r.relationId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ifMatch != nil {
		localVarHeaderParams["If-Match"] = parameterToString(*r.ifMatch, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiSitesTermStoresSetsRelationsDeleteRefToTermRequest struct {
	ctx _context.Context
	ApiService *SitesStoreApiService
	siteId string
	storeId string
	setId string
	relationId string
	ifMatch *string
}

// ETag
func (r ApiSitesTermStoresSetsRelationsDeleteRefToTermRequest) IfMatch(ifMatch string) ApiSitesTermStoresSetsRelationsDeleteRefToTermRequest {
	r.ifMatch = &ifMatch
	return r
}

func (r ApiSitesTermStoresSetsRelationsDeleteRefToTermRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.SitesTermStoresSetsRelationsDeleteRefToTermExecute(r)
}

/*
SitesTermStoresSetsRelationsDeleteRefToTerm Delete ref of navigation property toTerm for sites

The to [term] of the relation. The term to which the relationship is defined.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param siteId key: id of site
 @param storeId key: id of store
 @param setId key: id of set
 @param relationId key: id of relation
 @return ApiSitesTermStoresSetsRelationsDeleteRefToTermRequest
*/
func (a *SitesStoreApiService) SitesTermStoresSetsRelationsDeleteRefToTerm(ctx _context.Context, siteId string, storeId string, setId string, relationId string) ApiSitesTermStoresSetsRelationsDeleteRefToTermRequest {
	return ApiSitesTermStoresSetsRelationsDeleteRefToTermRequest{
		ApiService: a,
		ctx: ctx,
		siteId: siteId,
		storeId: storeId,
		setId: setId,
		relationId: relationId,
	}
}

// Execute executes the request
func (a *SitesStoreApiService) SitesTermStoresSetsRelationsDeleteRefToTermExecute(r ApiSitesTermStoresSetsRelationsDeleteRefToTermRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SitesStoreApiService.SitesTermStoresSetsRelationsDeleteRefToTerm")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sites/{site-id}/termStores/{store-id}/sets/{set-id}/relations/{relation-id}/toTerm/$ref"
	localVarPath = strings.Replace(localVarPath, "{"+"site-id"+"}", _neturl.PathEscape(parameterToString(r.siteId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"store-id"+"}", _neturl.PathEscape(parameterToString(r.storeId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"set-id"+"}", _neturl.PathEscape(parameterToString(r.setId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"relation-id"+"}", _neturl.PathEscape(parameterToString(r.relationId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ifMatch != nil {
		localVarHeaderParams["If-Match"] = parameterToString(*r.ifMatch, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiSitesTermStoresSetsRelationsGetFromTermRequest struct {
	ctx _context.Context
	ApiService *SitesStoreApiService
	siteId string
	storeId string
	setId string
	relationId string
	select_ *[]string
	expand *[]string
}

// Select properties to be returned
func (r ApiSitesTermStoresSetsRelationsGetFromTermRequest) Select_(select_ []string) ApiSitesTermStoresSetsRelationsGetFromTermRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiSitesTermStoresSetsRelationsGetFromTermRequest) Expand(expand []string) ApiSitesTermStoresSetsRelationsGetFromTermRequest {
	r.expand = &expand
	return r
}

func (r ApiSitesTermStoresSetsRelationsGetFromTermRequest) Execute() (MicrosoftGraphTermStoreTerm, *_nethttp.Response, error) {
	return r.ApiService.SitesTermStoresSetsRelationsGetFromTermExecute(r)
}

/*
SitesTermStoresSetsRelationsGetFromTerm Get fromTerm from sites

The from [term] of the relation. The term from which the relationship is defined. A null value would indicate the relation is directly with the [set].

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param siteId key: id of site
 @param storeId key: id of store
 @param setId key: id of set
 @param relationId key: id of relation
 @return ApiSitesTermStoresSetsRelationsGetFromTermRequest
*/
func (a *SitesStoreApiService) SitesTermStoresSetsRelationsGetFromTerm(ctx _context.Context, siteId string, storeId string, setId string, relationId string) ApiSitesTermStoresSetsRelationsGetFromTermRequest {
	return ApiSitesTermStoresSetsRelationsGetFromTermRequest{
		ApiService: a,
		ctx: ctx,
		siteId: siteId,
		storeId: storeId,
		setId: setId,
		relationId: relationId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphTermStoreTerm
func (a *SitesStoreApiService) SitesTermStoresSetsRelationsGetFromTermExecute(r ApiSitesTermStoresSetsRelationsGetFromTermRequest) (MicrosoftGraphTermStoreTerm, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphTermStoreTerm
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SitesStoreApiService.SitesTermStoresSetsRelationsGetFromTerm")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sites/{site-id}/termStores/{store-id}/sets/{set-id}/relations/{relation-id}/fromTerm"
	localVarPath = strings.Replace(localVarPath, "{"+"site-id"+"}", _neturl.PathEscape(parameterToString(r.siteId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"store-id"+"}", _neturl.PathEscape(parameterToString(r.storeId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"set-id"+"}", _neturl.PathEscape(parameterToString(r.setId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"relation-id"+"}", _neturl.PathEscape(parameterToString(r.relationId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSitesTermStoresSetsRelationsGetRefFromTermRequest struct {
	ctx _context.Context
	ApiService *SitesStoreApiService
	siteId string
	storeId string
	setId string
	relationId string
}


func (r ApiSitesTermStoresSetsRelationsGetRefFromTermRequest) Execute() (string, *_nethttp.Response, error) {
	return r.ApiService.SitesTermStoresSetsRelationsGetRefFromTermExecute(r)
}

/*
SitesTermStoresSetsRelationsGetRefFromTerm Get ref of fromTerm from sites

The from [term] of the relation. The term from which the relationship is defined. A null value would indicate the relation is directly with the [set].

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param siteId key: id of site
 @param storeId key: id of store
 @param setId key: id of set
 @param relationId key: id of relation
 @return ApiSitesTermStoresSetsRelationsGetRefFromTermRequest
*/
func (a *SitesStoreApiService) SitesTermStoresSetsRelationsGetRefFromTerm(ctx _context.Context, siteId string, storeId string, setId string, relationId string) ApiSitesTermStoresSetsRelationsGetRefFromTermRequest {
	return ApiSitesTermStoresSetsRelationsGetRefFromTermRequest{
		ApiService: a,
		ctx: ctx,
		siteId: siteId,
		storeId: storeId,
		setId: setId,
		relationId: relationId,
	}
}

// Execute executes the request
//  @return string
func (a *SitesStoreApiService) SitesTermStoresSetsRelationsGetRefFromTermExecute(r ApiSitesTermStoresSetsRelationsGetRefFromTermRequest) (string, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  string
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SitesStoreApiService.SitesTermStoresSetsRelationsGetRefFromTerm")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sites/{site-id}/termStores/{store-id}/sets/{set-id}/relations/{relation-id}/fromTerm/$ref"
	localVarPath = strings.Replace(localVarPath, "{"+"site-id"+"}", _neturl.PathEscape(parameterToString(r.siteId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"store-id"+"}", _neturl.PathEscape(parameterToString(r.storeId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"set-id"+"}", _neturl.PathEscape(parameterToString(r.setId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"relation-id"+"}", _neturl.PathEscape(parameterToString(r.relationId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSitesTermStoresSetsRelationsGetRefSetRequest struct {
	ctx _context.Context
	ApiService *SitesStoreApiService
	siteId string
	storeId string
	setId string
	relationId string
}


func (r ApiSitesTermStoresSetsRelationsGetRefSetRequest) Execute() (string, *_nethttp.Response, error) {
	return r.ApiService.SitesTermStoresSetsRelationsGetRefSetExecute(r)
}

/*
SitesTermStoresSetsRelationsGetRefSet Get ref of set from sites

The [set] in which the relation is relevant.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param siteId key: id of site
 @param storeId key: id of store
 @param setId key: id of set
 @param relationId key: id of relation
 @return ApiSitesTermStoresSetsRelationsGetRefSetRequest
*/
func (a *SitesStoreApiService) SitesTermStoresSetsRelationsGetRefSet(ctx _context.Context, siteId string, storeId string, setId string, relationId string) ApiSitesTermStoresSetsRelationsGetRefSetRequest {
	return ApiSitesTermStoresSetsRelationsGetRefSetRequest{
		ApiService: a,
		ctx: ctx,
		siteId: siteId,
		storeId: storeId,
		setId: setId,
		relationId: relationId,
	}
}

// Execute executes the request
//  @return string
func (a *SitesStoreApiService) SitesTermStoresSetsRelationsGetRefSetExecute(r ApiSitesTermStoresSetsRelationsGetRefSetRequest) (string, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  string
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SitesStoreApiService.SitesTermStoresSetsRelationsGetRefSet")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sites/{site-id}/termStores/{store-id}/sets/{set-id}/relations/{relation-id}/set/$ref"
	localVarPath = strings.Replace(localVarPath, "{"+"site-id"+"}", _neturl.PathEscape(parameterToString(r.siteId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"store-id"+"}", _neturl.PathEscape(parameterToString(r.storeId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"set-id"+"}", _neturl.PathEscape(parameterToString(r.setId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"relation-id"+"}", _neturl.PathEscape(parameterToString(r.relationId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSitesTermStoresSetsRelationsGetRefToTermRequest struct {
	ctx _context.Context
	ApiService *SitesStoreApiService
	siteId string
	storeId string
	setId string
	relationId string
}


func (r ApiSitesTermStoresSetsRelationsGetRefToTermRequest) Execute() (string, *_nethttp.Response, error) {
	return r.ApiService.SitesTermStoresSetsRelationsGetRefToTermExecute(r)
}

/*
SitesTermStoresSetsRelationsGetRefToTerm Get ref of toTerm from sites

The to [term] of the relation. The term to which the relationship is defined.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param siteId key: id of site
 @param storeId key: id of store
 @param setId key: id of set
 @param relationId key: id of relation
 @return ApiSitesTermStoresSetsRelationsGetRefToTermRequest
*/
func (a *SitesStoreApiService) SitesTermStoresSetsRelationsGetRefToTerm(ctx _context.Context, siteId string, storeId string, setId string, relationId string) ApiSitesTermStoresSetsRelationsGetRefToTermRequest {
	return ApiSitesTermStoresSetsRelationsGetRefToTermRequest{
		ApiService: a,
		ctx: ctx,
		siteId: siteId,
		storeId: storeId,
		setId: setId,
		relationId: relationId,
	}
}

// Execute executes the request
//  @return string
func (a *SitesStoreApiService) SitesTermStoresSetsRelationsGetRefToTermExecute(r ApiSitesTermStoresSetsRelationsGetRefToTermRequest) (string, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  string
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SitesStoreApiService.SitesTermStoresSetsRelationsGetRefToTerm")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sites/{site-id}/termStores/{store-id}/sets/{set-id}/relations/{relation-id}/toTerm/$ref"
	localVarPath = strings.Replace(localVarPath, "{"+"site-id"+"}", _neturl.PathEscape(parameterToString(r.siteId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"store-id"+"}", _neturl.PathEscape(parameterToString(r.storeId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"set-id"+"}", _neturl.PathEscape(parameterToString(r.setId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"relation-id"+"}", _neturl.PathEscape(parameterToString(r.relationId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSitesTermStoresSetsRelationsGetSetRequest struct {
	ctx _context.Context
	ApiService *SitesStoreApiService
	siteId string
	storeId string
	setId string
	relationId string
	select_ *[]string
	expand *[]string
}

// Select properties to be returned
func (r ApiSitesTermStoresSetsRelationsGetSetRequest) Select_(select_ []string) ApiSitesTermStoresSetsRelationsGetSetRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiSitesTermStoresSetsRelationsGetSetRequest) Expand(expand []string) ApiSitesTermStoresSetsRelationsGetSetRequest {
	r.expand = &expand
	return r
}

func (r ApiSitesTermStoresSetsRelationsGetSetRequest) Execute() (MicrosoftGraphTermStoreSet, *_nethttp.Response, error) {
	return r.ApiService.SitesTermStoresSetsRelationsGetSetExecute(r)
}

/*
SitesTermStoresSetsRelationsGetSet Get set from sites

The [set] in which the relation is relevant.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param siteId key: id of site
 @param storeId key: id of store
 @param setId key: id of set
 @param relationId key: id of relation
 @return ApiSitesTermStoresSetsRelationsGetSetRequest
*/
func (a *SitesStoreApiService) SitesTermStoresSetsRelationsGetSet(ctx _context.Context, siteId string, storeId string, setId string, relationId string) ApiSitesTermStoresSetsRelationsGetSetRequest {
	return ApiSitesTermStoresSetsRelationsGetSetRequest{
		ApiService: a,
		ctx: ctx,
		siteId: siteId,
		storeId: storeId,
		setId: setId,
		relationId: relationId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphTermStoreSet
func (a *SitesStoreApiService) SitesTermStoresSetsRelationsGetSetExecute(r ApiSitesTermStoresSetsRelationsGetSetRequest) (MicrosoftGraphTermStoreSet, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphTermStoreSet
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SitesStoreApiService.SitesTermStoresSetsRelationsGetSet")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sites/{site-id}/termStores/{store-id}/sets/{set-id}/relations/{relation-id}/set"
	localVarPath = strings.Replace(localVarPath, "{"+"site-id"+"}", _neturl.PathEscape(parameterToString(r.siteId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"store-id"+"}", _neturl.PathEscape(parameterToString(r.storeId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"set-id"+"}", _neturl.PathEscape(parameterToString(r.setId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"relation-id"+"}", _neturl.PathEscape(parameterToString(r.relationId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSitesTermStoresSetsRelationsGetToTermRequest struct {
	ctx _context.Context
	ApiService *SitesStoreApiService
	siteId string
	storeId string
	setId string
	relationId string
	select_ *[]string
	expand *[]string
}

// Select properties to be returned
func (r ApiSitesTermStoresSetsRelationsGetToTermRequest) Select_(select_ []string) ApiSitesTermStoresSetsRelationsGetToTermRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiSitesTermStoresSetsRelationsGetToTermRequest) Expand(expand []string) ApiSitesTermStoresSetsRelationsGetToTermRequest {
	r.expand = &expand
	return r
}

func (r ApiSitesTermStoresSetsRelationsGetToTermRequest) Execute() (MicrosoftGraphTermStoreTerm, *_nethttp.Response, error) {
	return r.ApiService.SitesTermStoresSetsRelationsGetToTermExecute(r)
}

/*
SitesTermStoresSetsRelationsGetToTerm Get toTerm from sites

The to [term] of the relation. The term to which the relationship is defined.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param siteId key: id of site
 @param storeId key: id of store
 @param setId key: id of set
 @param relationId key: id of relation
 @return ApiSitesTermStoresSetsRelationsGetToTermRequest
*/
func (a *SitesStoreApiService) SitesTermStoresSetsRelationsGetToTerm(ctx _context.Context, siteId string, storeId string, setId string, relationId string) ApiSitesTermStoresSetsRelationsGetToTermRequest {
	return ApiSitesTermStoresSetsRelationsGetToTermRequest{
		ApiService: a,
		ctx: ctx,
		siteId: siteId,
		storeId: storeId,
		setId: setId,
		relationId: relationId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphTermStoreTerm
func (a *SitesStoreApiService) SitesTermStoresSetsRelationsGetToTermExecute(r ApiSitesTermStoresSetsRelationsGetToTermRequest) (MicrosoftGraphTermStoreTerm, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphTermStoreTerm
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SitesStoreApiService.SitesTermStoresSetsRelationsGetToTerm")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sites/{site-id}/termStores/{store-id}/sets/{set-id}/relations/{relation-id}/toTerm"
	localVarPath = strings.Replace(localVarPath, "{"+"site-id"+"}", _neturl.PathEscape(parameterToString(r.siteId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"store-id"+"}", _neturl.PathEscape(parameterToString(r.storeId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"set-id"+"}", _neturl.PathEscape(parameterToString(r.setId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"relation-id"+"}", _neturl.PathEscape(parameterToString(r.relationId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSitesTermStoresSetsRelationsUpdateRefFromTermRequest struct {
	ctx _context.Context
	ApiService *SitesStoreApiService
	siteId string
	storeId string
	setId string
	relationId string
	requestBody *map[string]map[string]interface{}
}

// New navigation property ref values
func (r ApiSitesTermStoresSetsRelationsUpdateRefFromTermRequest) RequestBody(requestBody map[string]map[string]interface{}) ApiSitesTermStoresSetsRelationsUpdateRefFromTermRequest {
	r.requestBody = &requestBody
	return r
}

func (r ApiSitesTermStoresSetsRelationsUpdateRefFromTermRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.SitesTermStoresSetsRelationsUpdateRefFromTermExecute(r)
}

/*
SitesTermStoresSetsRelationsUpdateRefFromTerm Update the ref of navigation property fromTerm in sites

The from [term] of the relation. The term from which the relationship is defined. A null value would indicate the relation is directly with the [set].

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param siteId key: id of site
 @param storeId key: id of store
 @param setId key: id of set
 @param relationId key: id of relation
 @return ApiSitesTermStoresSetsRelationsUpdateRefFromTermRequest
*/
func (a *SitesStoreApiService) SitesTermStoresSetsRelationsUpdateRefFromTerm(ctx _context.Context, siteId string, storeId string, setId string, relationId string) ApiSitesTermStoresSetsRelationsUpdateRefFromTermRequest {
	return ApiSitesTermStoresSetsRelationsUpdateRefFromTermRequest{
		ApiService: a,
		ctx: ctx,
		siteId: siteId,
		storeId: storeId,
		setId: setId,
		relationId: relationId,
	}
}

// Execute executes the request
func (a *SitesStoreApiService) SitesTermStoresSetsRelationsUpdateRefFromTermExecute(r ApiSitesTermStoresSetsRelationsUpdateRefFromTermRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPut
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SitesStoreApiService.SitesTermStoresSetsRelationsUpdateRefFromTerm")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sites/{site-id}/termStores/{store-id}/sets/{set-id}/relations/{relation-id}/fromTerm/$ref"
	localVarPath = strings.Replace(localVarPath, "{"+"site-id"+"}", _neturl.PathEscape(parameterToString(r.siteId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"store-id"+"}", _neturl.PathEscape(parameterToString(r.storeId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"set-id"+"}", _neturl.PathEscape(parameterToString(r.setId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"relation-id"+"}", _neturl.PathEscape(parameterToString(r.relationId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.requestBody == nil {
		return nil, reportError("requestBody is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.requestBody
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiSitesTermStoresSetsRelationsUpdateRefSetRequest struct {
	ctx _context.Context
	ApiService *SitesStoreApiService
	siteId string
	storeId string
	setId string
	relationId string
	requestBody *map[string]map[string]interface{}
}

// New navigation property ref values
func (r ApiSitesTermStoresSetsRelationsUpdateRefSetRequest) RequestBody(requestBody map[string]map[string]interface{}) ApiSitesTermStoresSetsRelationsUpdateRefSetRequest {
	r.requestBody = &requestBody
	return r
}

func (r ApiSitesTermStoresSetsRelationsUpdateRefSetRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.SitesTermStoresSetsRelationsUpdateRefSetExecute(r)
}

/*
SitesTermStoresSetsRelationsUpdateRefSet Update the ref of navigation property set in sites

The [set] in which the relation is relevant.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param siteId key: id of site
 @param storeId key: id of store
 @param setId key: id of set
 @param relationId key: id of relation
 @return ApiSitesTermStoresSetsRelationsUpdateRefSetRequest
*/
func (a *SitesStoreApiService) SitesTermStoresSetsRelationsUpdateRefSet(ctx _context.Context, siteId string, storeId string, setId string, relationId string) ApiSitesTermStoresSetsRelationsUpdateRefSetRequest {
	return ApiSitesTermStoresSetsRelationsUpdateRefSetRequest{
		ApiService: a,
		ctx: ctx,
		siteId: siteId,
		storeId: storeId,
		setId: setId,
		relationId: relationId,
	}
}

// Execute executes the request
func (a *SitesStoreApiService) SitesTermStoresSetsRelationsUpdateRefSetExecute(r ApiSitesTermStoresSetsRelationsUpdateRefSetRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPut
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SitesStoreApiService.SitesTermStoresSetsRelationsUpdateRefSet")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sites/{site-id}/termStores/{store-id}/sets/{set-id}/relations/{relation-id}/set/$ref"
	localVarPath = strings.Replace(localVarPath, "{"+"site-id"+"}", _neturl.PathEscape(parameterToString(r.siteId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"store-id"+"}", _neturl.PathEscape(parameterToString(r.storeId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"set-id"+"}", _neturl.PathEscape(parameterToString(r.setId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"relation-id"+"}", _neturl.PathEscape(parameterToString(r.relationId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.requestBody == nil {
		return nil, reportError("requestBody is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.requestBody
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiSitesTermStoresSetsRelationsUpdateRefToTermRequest struct {
	ctx _context.Context
	ApiService *SitesStoreApiService
	siteId string
	storeId string
	setId string
	relationId string
	requestBody *map[string]map[string]interface{}
}

// New navigation property ref values
func (r ApiSitesTermStoresSetsRelationsUpdateRefToTermRequest) RequestBody(requestBody map[string]map[string]interface{}) ApiSitesTermStoresSetsRelationsUpdateRefToTermRequest {
	r.requestBody = &requestBody
	return r
}

func (r ApiSitesTermStoresSetsRelationsUpdateRefToTermRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.SitesTermStoresSetsRelationsUpdateRefToTermExecute(r)
}

/*
SitesTermStoresSetsRelationsUpdateRefToTerm Update the ref of navigation property toTerm in sites

The to [term] of the relation. The term to which the relationship is defined.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param siteId key: id of site
 @param storeId key: id of store
 @param setId key: id of set
 @param relationId key: id of relation
 @return ApiSitesTermStoresSetsRelationsUpdateRefToTermRequest
*/
func (a *SitesStoreApiService) SitesTermStoresSetsRelationsUpdateRefToTerm(ctx _context.Context, siteId string, storeId string, setId string, relationId string) ApiSitesTermStoresSetsRelationsUpdateRefToTermRequest {
	return ApiSitesTermStoresSetsRelationsUpdateRefToTermRequest{
		ApiService: a,
		ctx: ctx,
		siteId: siteId,
		storeId: storeId,
		setId: setId,
		relationId: relationId,
	}
}

// Execute executes the request
func (a *SitesStoreApiService) SitesTermStoresSetsRelationsUpdateRefToTermExecute(r ApiSitesTermStoresSetsRelationsUpdateRefToTermRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPut
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SitesStoreApiService.SitesTermStoresSetsRelationsUpdateRefToTerm")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sites/{site-id}/termStores/{store-id}/sets/{set-id}/relations/{relation-id}/toTerm/$ref"
	localVarPath = strings.Replace(localVarPath, "{"+"site-id"+"}", _neturl.PathEscape(parameterToString(r.siteId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"store-id"+"}", _neturl.PathEscape(parameterToString(r.storeId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"set-id"+"}", _neturl.PathEscape(parameterToString(r.setId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"relation-id"+"}", _neturl.PathEscape(parameterToString(r.relationId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.requestBody == nil {
		return nil, reportError("requestBody is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.requestBody
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiSitesTermStoresSetsTermsCreateChildrenRequest struct {
	ctx _context.Context
	ApiService *SitesStoreApiService
	siteId string
	storeId string
	setId string
	termId string
	microsoftGraphTermStoreTerm *MicrosoftGraphTermStoreTerm
}

// New navigation property
func (r ApiSitesTermStoresSetsTermsCreateChildrenRequest) MicrosoftGraphTermStoreTerm(microsoftGraphTermStoreTerm MicrosoftGraphTermStoreTerm) ApiSitesTermStoresSetsTermsCreateChildrenRequest {
	r.microsoftGraphTermStoreTerm = &microsoftGraphTermStoreTerm
	return r
}

func (r ApiSitesTermStoresSetsTermsCreateChildrenRequest) Execute() (MicrosoftGraphTermStoreTerm, *_nethttp.Response, error) {
	return r.ApiService.SitesTermStoresSetsTermsCreateChildrenExecute(r)
}

/*
SitesTermStoresSetsTermsCreateChildren Create new navigation property to children for sites

Children of current term.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param siteId key: id of site
 @param storeId key: id of store
 @param setId key: id of set
 @param termId key: id of term
 @return ApiSitesTermStoresSetsTermsCreateChildrenRequest
*/
func (a *SitesStoreApiService) SitesTermStoresSetsTermsCreateChildren(ctx _context.Context, siteId string, storeId string, setId string, termId string) ApiSitesTermStoresSetsTermsCreateChildrenRequest {
	return ApiSitesTermStoresSetsTermsCreateChildrenRequest{
		ApiService: a,
		ctx: ctx,
		siteId: siteId,
		storeId: storeId,
		setId: setId,
		termId: termId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphTermStoreTerm
func (a *SitesStoreApiService) SitesTermStoresSetsTermsCreateChildrenExecute(r ApiSitesTermStoresSetsTermsCreateChildrenRequest) (MicrosoftGraphTermStoreTerm, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphTermStoreTerm
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SitesStoreApiService.SitesTermStoresSetsTermsCreateChildren")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sites/{site-id}/termStores/{store-id}/sets/{set-id}/terms/{term-id}/children"
	localVarPath = strings.Replace(localVarPath, "{"+"site-id"+"}", _neturl.PathEscape(parameterToString(r.siteId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"store-id"+"}", _neturl.PathEscape(parameterToString(r.storeId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"set-id"+"}", _neturl.PathEscape(parameterToString(r.setId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"term-id"+"}", _neturl.PathEscape(parameterToString(r.termId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphTermStoreTerm == nil {
		return localVarReturnValue, nil, reportError("microsoftGraphTermStoreTerm is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphTermStoreTerm
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSitesTermStoresSetsTermsCreateRelationsRequest struct {
	ctx _context.Context
	ApiService *SitesStoreApiService
	siteId string
	storeId string
	setId string
	termId string
	microsoftGraphTermStoreRelation *MicrosoftGraphTermStoreRelation
}

// New navigation property
func (r ApiSitesTermStoresSetsTermsCreateRelationsRequest) MicrosoftGraphTermStoreRelation(microsoftGraphTermStoreRelation MicrosoftGraphTermStoreRelation) ApiSitesTermStoresSetsTermsCreateRelationsRequest {
	r.microsoftGraphTermStoreRelation = &microsoftGraphTermStoreRelation
	return r
}

func (r ApiSitesTermStoresSetsTermsCreateRelationsRequest) Execute() (MicrosoftGraphTermStoreRelation, *_nethttp.Response, error) {
	return r.ApiService.SitesTermStoresSetsTermsCreateRelationsExecute(r)
}

/*
SitesTermStoresSetsTermsCreateRelations Create new navigation property to relations for sites

To indicate which terms are related to the current term as either pinned or reused.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param siteId key: id of site
 @param storeId key: id of store
 @param setId key: id of set
 @param termId key: id of term
 @return ApiSitesTermStoresSetsTermsCreateRelationsRequest
*/
func (a *SitesStoreApiService) SitesTermStoresSetsTermsCreateRelations(ctx _context.Context, siteId string, storeId string, setId string, termId string) ApiSitesTermStoresSetsTermsCreateRelationsRequest {
	return ApiSitesTermStoresSetsTermsCreateRelationsRequest{
		ApiService: a,
		ctx: ctx,
		siteId: siteId,
		storeId: storeId,
		setId: setId,
		termId: termId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphTermStoreRelation
func (a *SitesStoreApiService) SitesTermStoresSetsTermsCreateRelationsExecute(r ApiSitesTermStoresSetsTermsCreateRelationsRequest) (MicrosoftGraphTermStoreRelation, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphTermStoreRelation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SitesStoreApiService.SitesTermStoresSetsTermsCreateRelations")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sites/{site-id}/termStores/{store-id}/sets/{set-id}/terms/{term-id}/relations"
	localVarPath = strings.Replace(localVarPath, "{"+"site-id"+"}", _neturl.PathEscape(parameterToString(r.siteId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"store-id"+"}", _neturl.PathEscape(parameterToString(r.storeId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"set-id"+"}", _neturl.PathEscape(parameterToString(r.setId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"term-id"+"}", _neturl.PathEscape(parameterToString(r.termId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphTermStoreRelation == nil {
		return localVarReturnValue, nil, reportError("microsoftGraphTermStoreRelation is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphTermStoreRelation
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSitesTermStoresSetsTermsDeleteChildrenRequest struct {
	ctx _context.Context
	ApiService *SitesStoreApiService
	siteId string
	storeId string
	setId string
	termId string
	termId1 string
	ifMatch *string
}

// ETag
func (r ApiSitesTermStoresSetsTermsDeleteChildrenRequest) IfMatch(ifMatch string) ApiSitesTermStoresSetsTermsDeleteChildrenRequest {
	r.ifMatch = &ifMatch
	return r
}

func (r ApiSitesTermStoresSetsTermsDeleteChildrenRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.SitesTermStoresSetsTermsDeleteChildrenExecute(r)
}

/*
SitesTermStoresSetsTermsDeleteChildren Delete navigation property children for sites

Children of current term.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param siteId key: id of site
 @param storeId key: id of store
 @param setId key: id of set
 @param termId key: id of term
 @param termId1 key: id of term
 @return ApiSitesTermStoresSetsTermsDeleteChildrenRequest
*/
func (a *SitesStoreApiService) SitesTermStoresSetsTermsDeleteChildren(ctx _context.Context, siteId string, storeId string, setId string, termId string, termId1 string) ApiSitesTermStoresSetsTermsDeleteChildrenRequest {
	return ApiSitesTermStoresSetsTermsDeleteChildrenRequest{
		ApiService: a,
		ctx: ctx,
		siteId: siteId,
		storeId: storeId,
		setId: setId,
		termId: termId,
		termId1: termId1,
	}
}

// Execute executes the request
func (a *SitesStoreApiService) SitesTermStoresSetsTermsDeleteChildrenExecute(r ApiSitesTermStoresSetsTermsDeleteChildrenRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SitesStoreApiService.SitesTermStoresSetsTermsDeleteChildren")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sites/{site-id}/termStores/{store-id}/sets/{set-id}/terms/{term-id}/children/{term-id1}"
	localVarPath = strings.Replace(localVarPath, "{"+"site-id"+"}", _neturl.PathEscape(parameterToString(r.siteId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"store-id"+"}", _neturl.PathEscape(parameterToString(r.storeId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"set-id"+"}", _neturl.PathEscape(parameterToString(r.setId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"term-id"+"}", _neturl.PathEscape(parameterToString(r.termId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"term-id1"+"}", _neturl.PathEscape(parameterToString(r.termId1, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ifMatch != nil {
		localVarHeaderParams["If-Match"] = parameterToString(*r.ifMatch, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiSitesTermStoresSetsTermsDeleteRefSetRequest struct {
	ctx _context.Context
	ApiService *SitesStoreApiService
	siteId string
	storeId string
	setId string
	termId string
	ifMatch *string
}

// ETag
func (r ApiSitesTermStoresSetsTermsDeleteRefSetRequest) IfMatch(ifMatch string) ApiSitesTermStoresSetsTermsDeleteRefSetRequest {
	r.ifMatch = &ifMatch
	return r
}

func (r ApiSitesTermStoresSetsTermsDeleteRefSetRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.SitesTermStoresSetsTermsDeleteRefSetExecute(r)
}

/*
SitesTermStoresSetsTermsDeleteRefSet Delete ref of navigation property set for sites

The [set] in which the term is created.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param siteId key: id of site
 @param storeId key: id of store
 @param setId key: id of set
 @param termId key: id of term
 @return ApiSitesTermStoresSetsTermsDeleteRefSetRequest
*/
func (a *SitesStoreApiService) SitesTermStoresSetsTermsDeleteRefSet(ctx _context.Context, siteId string, storeId string, setId string, termId string) ApiSitesTermStoresSetsTermsDeleteRefSetRequest {
	return ApiSitesTermStoresSetsTermsDeleteRefSetRequest{
		ApiService: a,
		ctx: ctx,
		siteId: siteId,
		storeId: storeId,
		setId: setId,
		termId: termId,
	}
}

// Execute executes the request
func (a *SitesStoreApiService) SitesTermStoresSetsTermsDeleteRefSetExecute(r ApiSitesTermStoresSetsTermsDeleteRefSetRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SitesStoreApiService.SitesTermStoresSetsTermsDeleteRefSet")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sites/{site-id}/termStores/{store-id}/sets/{set-id}/terms/{term-id}/set/$ref"
	localVarPath = strings.Replace(localVarPath, "{"+"site-id"+"}", _neturl.PathEscape(parameterToString(r.siteId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"store-id"+"}", _neturl.PathEscape(parameterToString(r.storeId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"set-id"+"}", _neturl.PathEscape(parameterToString(r.setId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"term-id"+"}", _neturl.PathEscape(parameterToString(r.termId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ifMatch != nil {
		localVarHeaderParams["If-Match"] = parameterToString(*r.ifMatch, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiSitesTermStoresSetsTermsDeleteRelationsRequest struct {
	ctx _context.Context
	ApiService *SitesStoreApiService
	siteId string
	storeId string
	setId string
	termId string
	relationId string
	ifMatch *string
}

// ETag
func (r ApiSitesTermStoresSetsTermsDeleteRelationsRequest) IfMatch(ifMatch string) ApiSitesTermStoresSetsTermsDeleteRelationsRequest {
	r.ifMatch = &ifMatch
	return r
}

func (r ApiSitesTermStoresSetsTermsDeleteRelationsRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.SitesTermStoresSetsTermsDeleteRelationsExecute(r)
}

/*
SitesTermStoresSetsTermsDeleteRelations Delete navigation property relations for sites

To indicate which terms are related to the current term as either pinned or reused.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param siteId key: id of site
 @param storeId key: id of store
 @param setId key: id of set
 @param termId key: id of term
 @param relationId key: id of relation
 @return ApiSitesTermStoresSetsTermsDeleteRelationsRequest
*/
func (a *SitesStoreApiService) SitesTermStoresSetsTermsDeleteRelations(ctx _context.Context, siteId string, storeId string, setId string, termId string, relationId string) ApiSitesTermStoresSetsTermsDeleteRelationsRequest {
	return ApiSitesTermStoresSetsTermsDeleteRelationsRequest{
		ApiService: a,
		ctx: ctx,
		siteId: siteId,
		storeId: storeId,
		setId: setId,
		termId: termId,
		relationId: relationId,
	}
}

// Execute executes the request
func (a *SitesStoreApiService) SitesTermStoresSetsTermsDeleteRelationsExecute(r ApiSitesTermStoresSetsTermsDeleteRelationsRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SitesStoreApiService.SitesTermStoresSetsTermsDeleteRelations")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sites/{site-id}/termStores/{store-id}/sets/{set-id}/terms/{term-id}/relations/{relation-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"site-id"+"}", _neturl.PathEscape(parameterToString(r.siteId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"store-id"+"}", _neturl.PathEscape(parameterToString(r.storeId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"set-id"+"}", _neturl.PathEscape(parameterToString(r.setId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"term-id"+"}", _neturl.PathEscape(parameterToString(r.termId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"relation-id"+"}", _neturl.PathEscape(parameterToString(r.relationId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ifMatch != nil {
		localVarHeaderParams["If-Match"] = parameterToString(*r.ifMatch, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiSitesTermStoresSetsTermsGetChildrenRequest struct {
	ctx _context.Context
	ApiService *SitesStoreApiService
	siteId string
	storeId string
	setId string
	termId string
	termId1 string
	select_ *[]string
	expand *[]string
}

// Select properties to be returned
func (r ApiSitesTermStoresSetsTermsGetChildrenRequest) Select_(select_ []string) ApiSitesTermStoresSetsTermsGetChildrenRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiSitesTermStoresSetsTermsGetChildrenRequest) Expand(expand []string) ApiSitesTermStoresSetsTermsGetChildrenRequest {
	r.expand = &expand
	return r
}

func (r ApiSitesTermStoresSetsTermsGetChildrenRequest) Execute() (MicrosoftGraphTermStoreTerm, *_nethttp.Response, error) {
	return r.ApiService.SitesTermStoresSetsTermsGetChildrenExecute(r)
}

/*
SitesTermStoresSetsTermsGetChildren Get children from sites

Children of current term.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param siteId key: id of site
 @param storeId key: id of store
 @param setId key: id of set
 @param termId key: id of term
 @param termId1 key: id of term
 @return ApiSitesTermStoresSetsTermsGetChildrenRequest
*/
func (a *SitesStoreApiService) SitesTermStoresSetsTermsGetChildren(ctx _context.Context, siteId string, storeId string, setId string, termId string, termId1 string) ApiSitesTermStoresSetsTermsGetChildrenRequest {
	return ApiSitesTermStoresSetsTermsGetChildrenRequest{
		ApiService: a,
		ctx: ctx,
		siteId: siteId,
		storeId: storeId,
		setId: setId,
		termId: termId,
		termId1: termId1,
	}
}

// Execute executes the request
//  @return MicrosoftGraphTermStoreTerm
func (a *SitesStoreApiService) SitesTermStoresSetsTermsGetChildrenExecute(r ApiSitesTermStoresSetsTermsGetChildrenRequest) (MicrosoftGraphTermStoreTerm, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphTermStoreTerm
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SitesStoreApiService.SitesTermStoresSetsTermsGetChildren")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sites/{site-id}/termStores/{store-id}/sets/{set-id}/terms/{term-id}/children/{term-id1}"
	localVarPath = strings.Replace(localVarPath, "{"+"site-id"+"}", _neturl.PathEscape(parameterToString(r.siteId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"store-id"+"}", _neturl.PathEscape(parameterToString(r.storeId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"set-id"+"}", _neturl.PathEscape(parameterToString(r.setId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"term-id"+"}", _neturl.PathEscape(parameterToString(r.termId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"term-id1"+"}", _neturl.PathEscape(parameterToString(r.termId1, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSitesTermStoresSetsTermsGetRefSetRequest struct {
	ctx _context.Context
	ApiService *SitesStoreApiService
	siteId string
	storeId string
	setId string
	termId string
}


func (r ApiSitesTermStoresSetsTermsGetRefSetRequest) Execute() (string, *_nethttp.Response, error) {
	return r.ApiService.SitesTermStoresSetsTermsGetRefSetExecute(r)
}

/*
SitesTermStoresSetsTermsGetRefSet Get ref of set from sites

The [set] in which the term is created.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param siteId key: id of site
 @param storeId key: id of store
 @param setId key: id of set
 @param termId key: id of term
 @return ApiSitesTermStoresSetsTermsGetRefSetRequest
*/
func (a *SitesStoreApiService) SitesTermStoresSetsTermsGetRefSet(ctx _context.Context, siteId string, storeId string, setId string, termId string) ApiSitesTermStoresSetsTermsGetRefSetRequest {
	return ApiSitesTermStoresSetsTermsGetRefSetRequest{
		ApiService: a,
		ctx: ctx,
		siteId: siteId,
		storeId: storeId,
		setId: setId,
		termId: termId,
	}
}

// Execute executes the request
//  @return string
func (a *SitesStoreApiService) SitesTermStoresSetsTermsGetRefSetExecute(r ApiSitesTermStoresSetsTermsGetRefSetRequest) (string, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  string
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SitesStoreApiService.SitesTermStoresSetsTermsGetRefSet")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sites/{site-id}/termStores/{store-id}/sets/{set-id}/terms/{term-id}/set/$ref"
	localVarPath = strings.Replace(localVarPath, "{"+"site-id"+"}", _neturl.PathEscape(parameterToString(r.siteId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"store-id"+"}", _neturl.PathEscape(parameterToString(r.storeId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"set-id"+"}", _neturl.PathEscape(parameterToString(r.setId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"term-id"+"}", _neturl.PathEscape(parameterToString(r.termId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSitesTermStoresSetsTermsGetRelationsRequest struct {
	ctx _context.Context
	ApiService *SitesStoreApiService
	siteId string
	storeId string
	setId string
	termId string
	relationId string
	select_ *[]string
	expand *[]string
}

// Select properties to be returned
func (r ApiSitesTermStoresSetsTermsGetRelationsRequest) Select_(select_ []string) ApiSitesTermStoresSetsTermsGetRelationsRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiSitesTermStoresSetsTermsGetRelationsRequest) Expand(expand []string) ApiSitesTermStoresSetsTermsGetRelationsRequest {
	r.expand = &expand
	return r
}

func (r ApiSitesTermStoresSetsTermsGetRelationsRequest) Execute() (MicrosoftGraphTermStoreRelation, *_nethttp.Response, error) {
	return r.ApiService.SitesTermStoresSetsTermsGetRelationsExecute(r)
}

/*
SitesTermStoresSetsTermsGetRelations Get relations from sites

To indicate which terms are related to the current term as either pinned or reused.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param siteId key: id of site
 @param storeId key: id of store
 @param setId key: id of set
 @param termId key: id of term
 @param relationId key: id of relation
 @return ApiSitesTermStoresSetsTermsGetRelationsRequest
*/
func (a *SitesStoreApiService) SitesTermStoresSetsTermsGetRelations(ctx _context.Context, siteId string, storeId string, setId string, termId string, relationId string) ApiSitesTermStoresSetsTermsGetRelationsRequest {
	return ApiSitesTermStoresSetsTermsGetRelationsRequest{
		ApiService: a,
		ctx: ctx,
		siteId: siteId,
		storeId: storeId,
		setId: setId,
		termId: termId,
		relationId: relationId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphTermStoreRelation
func (a *SitesStoreApiService) SitesTermStoresSetsTermsGetRelationsExecute(r ApiSitesTermStoresSetsTermsGetRelationsRequest) (MicrosoftGraphTermStoreRelation, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphTermStoreRelation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SitesStoreApiService.SitesTermStoresSetsTermsGetRelations")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sites/{site-id}/termStores/{store-id}/sets/{set-id}/terms/{term-id}/relations/{relation-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"site-id"+"}", _neturl.PathEscape(parameterToString(r.siteId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"store-id"+"}", _neturl.PathEscape(parameterToString(r.storeId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"set-id"+"}", _neturl.PathEscape(parameterToString(r.setId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"term-id"+"}", _neturl.PathEscape(parameterToString(r.termId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"relation-id"+"}", _neturl.PathEscape(parameterToString(r.relationId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSitesTermStoresSetsTermsGetSetRequest struct {
	ctx _context.Context
	ApiService *SitesStoreApiService
	siteId string
	storeId string
	setId string
	termId string
	select_ *[]string
	expand *[]string
}

// Select properties to be returned
func (r ApiSitesTermStoresSetsTermsGetSetRequest) Select_(select_ []string) ApiSitesTermStoresSetsTermsGetSetRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiSitesTermStoresSetsTermsGetSetRequest) Expand(expand []string) ApiSitesTermStoresSetsTermsGetSetRequest {
	r.expand = &expand
	return r
}

func (r ApiSitesTermStoresSetsTermsGetSetRequest) Execute() (MicrosoftGraphTermStoreSet, *_nethttp.Response, error) {
	return r.ApiService.SitesTermStoresSetsTermsGetSetExecute(r)
}

/*
SitesTermStoresSetsTermsGetSet Get set from sites

The [set] in which the term is created.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param siteId key: id of site
 @param storeId key: id of store
 @param setId key: id of set
 @param termId key: id of term
 @return ApiSitesTermStoresSetsTermsGetSetRequest
*/
func (a *SitesStoreApiService) SitesTermStoresSetsTermsGetSet(ctx _context.Context, siteId string, storeId string, setId string, termId string) ApiSitesTermStoresSetsTermsGetSetRequest {
	return ApiSitesTermStoresSetsTermsGetSetRequest{
		ApiService: a,
		ctx: ctx,
		siteId: siteId,
		storeId: storeId,
		setId: setId,
		termId: termId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphTermStoreSet
func (a *SitesStoreApiService) SitesTermStoresSetsTermsGetSetExecute(r ApiSitesTermStoresSetsTermsGetSetRequest) (MicrosoftGraphTermStoreSet, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphTermStoreSet
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SitesStoreApiService.SitesTermStoresSetsTermsGetSet")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sites/{site-id}/termStores/{store-id}/sets/{set-id}/terms/{term-id}/set"
	localVarPath = strings.Replace(localVarPath, "{"+"site-id"+"}", _neturl.PathEscape(parameterToString(r.siteId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"store-id"+"}", _neturl.PathEscape(parameterToString(r.storeId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"set-id"+"}", _neturl.PathEscape(parameterToString(r.setId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"term-id"+"}", _neturl.PathEscape(parameterToString(r.termId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSitesTermStoresSetsTermsListChildrenRequest struct {
	ctx _context.Context
	ApiService *SitesStoreApiService
	siteId string
	storeId string
	setId string
	termId string
	top *int32
	skip *int32
	search *string
	filter *string
	count *bool
	orderby *[]string
	select_ *[]string
	expand *[]string
}

// Show only the first n items
func (r ApiSitesTermStoresSetsTermsListChildrenRequest) Top(top int32) ApiSitesTermStoresSetsTermsListChildrenRequest {
	r.top = &top
	return r
}
// Skip the first n items
func (r ApiSitesTermStoresSetsTermsListChildrenRequest) Skip(skip int32) ApiSitesTermStoresSetsTermsListChildrenRequest {
	r.skip = &skip
	return r
}
// Search items by search phrases
func (r ApiSitesTermStoresSetsTermsListChildrenRequest) Search(search string) ApiSitesTermStoresSetsTermsListChildrenRequest {
	r.search = &search
	return r
}
// Filter items by property values
func (r ApiSitesTermStoresSetsTermsListChildrenRequest) Filter(filter string) ApiSitesTermStoresSetsTermsListChildrenRequest {
	r.filter = &filter
	return r
}
// Include count of items
func (r ApiSitesTermStoresSetsTermsListChildrenRequest) Count(count bool) ApiSitesTermStoresSetsTermsListChildrenRequest {
	r.count = &count
	return r
}
// Order items by property values
func (r ApiSitesTermStoresSetsTermsListChildrenRequest) Orderby(orderby []string) ApiSitesTermStoresSetsTermsListChildrenRequest {
	r.orderby = &orderby
	return r
}
// Select properties to be returned
func (r ApiSitesTermStoresSetsTermsListChildrenRequest) Select_(select_ []string) ApiSitesTermStoresSetsTermsListChildrenRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiSitesTermStoresSetsTermsListChildrenRequest) Expand(expand []string) ApiSitesTermStoresSetsTermsListChildrenRequest {
	r.expand = &expand
	return r
}

func (r ApiSitesTermStoresSetsTermsListChildrenRequest) Execute() (CollectionOfTerm, *_nethttp.Response, error) {
	return r.ApiService.SitesTermStoresSetsTermsListChildrenExecute(r)
}

/*
SitesTermStoresSetsTermsListChildren Get children from sites

Children of current term.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param siteId key: id of site
 @param storeId key: id of store
 @param setId key: id of set
 @param termId key: id of term
 @return ApiSitesTermStoresSetsTermsListChildrenRequest
*/
func (a *SitesStoreApiService) SitesTermStoresSetsTermsListChildren(ctx _context.Context, siteId string, storeId string, setId string, termId string) ApiSitesTermStoresSetsTermsListChildrenRequest {
	return ApiSitesTermStoresSetsTermsListChildrenRequest{
		ApiService: a,
		ctx: ctx,
		siteId: siteId,
		storeId: storeId,
		setId: setId,
		termId: termId,
	}
}

// Execute executes the request
//  @return CollectionOfTerm
func (a *SitesStoreApiService) SitesTermStoresSetsTermsListChildrenExecute(r ApiSitesTermStoresSetsTermsListChildrenRequest) (CollectionOfTerm, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  CollectionOfTerm
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SitesStoreApiService.SitesTermStoresSetsTermsListChildren")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sites/{site-id}/termStores/{store-id}/sets/{set-id}/terms/{term-id}/children"
	localVarPath = strings.Replace(localVarPath, "{"+"site-id"+"}", _neturl.PathEscape(parameterToString(r.siteId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"store-id"+"}", _neturl.PathEscape(parameterToString(r.storeId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"set-id"+"}", _neturl.PathEscape(parameterToString(r.setId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"term-id"+"}", _neturl.PathEscape(parameterToString(r.termId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.top != nil {
		localVarQueryParams.Add("$top", parameterToString(*r.top, ""))
	}
	if r.skip != nil {
		localVarQueryParams.Add("$skip", parameterToString(*r.skip, ""))
	}
	if r.search != nil {
		localVarQueryParams.Add("$search", parameterToString(*r.search, ""))
	}
	if r.filter != nil {
		localVarQueryParams.Add("$filter", parameterToString(*r.filter, ""))
	}
	if r.count != nil {
		localVarQueryParams.Add("$count", parameterToString(*r.count, ""))
	}
	if r.orderby != nil {
		localVarQueryParams.Add("$orderby", parameterToString(*r.orderby, "csv"))
	}
	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSitesTermStoresSetsTermsListRelationsRequest struct {
	ctx _context.Context
	ApiService *SitesStoreApiService
	siteId string
	storeId string
	setId string
	termId string
	top *int32
	skip *int32
	search *string
	filter *string
	count *bool
	orderby *[]string
	select_ *[]string
	expand *[]string
}

// Show only the first n items
func (r ApiSitesTermStoresSetsTermsListRelationsRequest) Top(top int32) ApiSitesTermStoresSetsTermsListRelationsRequest {
	r.top = &top
	return r
}
// Skip the first n items
func (r ApiSitesTermStoresSetsTermsListRelationsRequest) Skip(skip int32) ApiSitesTermStoresSetsTermsListRelationsRequest {
	r.skip = &skip
	return r
}
// Search items by search phrases
func (r ApiSitesTermStoresSetsTermsListRelationsRequest) Search(search string) ApiSitesTermStoresSetsTermsListRelationsRequest {
	r.search = &search
	return r
}
// Filter items by property values
func (r ApiSitesTermStoresSetsTermsListRelationsRequest) Filter(filter string) ApiSitesTermStoresSetsTermsListRelationsRequest {
	r.filter = &filter
	return r
}
// Include count of items
func (r ApiSitesTermStoresSetsTermsListRelationsRequest) Count(count bool) ApiSitesTermStoresSetsTermsListRelationsRequest {
	r.count = &count
	return r
}
// Order items by property values
func (r ApiSitesTermStoresSetsTermsListRelationsRequest) Orderby(orderby []string) ApiSitesTermStoresSetsTermsListRelationsRequest {
	r.orderby = &orderby
	return r
}
// Select properties to be returned
func (r ApiSitesTermStoresSetsTermsListRelationsRequest) Select_(select_ []string) ApiSitesTermStoresSetsTermsListRelationsRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiSitesTermStoresSetsTermsListRelationsRequest) Expand(expand []string) ApiSitesTermStoresSetsTermsListRelationsRequest {
	r.expand = &expand
	return r
}

func (r ApiSitesTermStoresSetsTermsListRelationsRequest) Execute() (CollectionOfRelation, *_nethttp.Response, error) {
	return r.ApiService.SitesTermStoresSetsTermsListRelationsExecute(r)
}

/*
SitesTermStoresSetsTermsListRelations Get relations from sites

To indicate which terms are related to the current term as either pinned or reused.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param siteId key: id of site
 @param storeId key: id of store
 @param setId key: id of set
 @param termId key: id of term
 @return ApiSitesTermStoresSetsTermsListRelationsRequest
*/
func (a *SitesStoreApiService) SitesTermStoresSetsTermsListRelations(ctx _context.Context, siteId string, storeId string, setId string, termId string) ApiSitesTermStoresSetsTermsListRelationsRequest {
	return ApiSitesTermStoresSetsTermsListRelationsRequest{
		ApiService: a,
		ctx: ctx,
		siteId: siteId,
		storeId: storeId,
		setId: setId,
		termId: termId,
	}
}

// Execute executes the request
//  @return CollectionOfRelation
func (a *SitesStoreApiService) SitesTermStoresSetsTermsListRelationsExecute(r ApiSitesTermStoresSetsTermsListRelationsRequest) (CollectionOfRelation, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  CollectionOfRelation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SitesStoreApiService.SitesTermStoresSetsTermsListRelations")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sites/{site-id}/termStores/{store-id}/sets/{set-id}/terms/{term-id}/relations"
	localVarPath = strings.Replace(localVarPath, "{"+"site-id"+"}", _neturl.PathEscape(parameterToString(r.siteId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"store-id"+"}", _neturl.PathEscape(parameterToString(r.storeId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"set-id"+"}", _neturl.PathEscape(parameterToString(r.setId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"term-id"+"}", _neturl.PathEscape(parameterToString(r.termId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.top != nil {
		localVarQueryParams.Add("$top", parameterToString(*r.top, ""))
	}
	if r.skip != nil {
		localVarQueryParams.Add("$skip", parameterToString(*r.skip, ""))
	}
	if r.search != nil {
		localVarQueryParams.Add("$search", parameterToString(*r.search, ""))
	}
	if r.filter != nil {
		localVarQueryParams.Add("$filter", parameterToString(*r.filter, ""))
	}
	if r.count != nil {
		localVarQueryParams.Add("$count", parameterToString(*r.count, ""))
	}
	if r.orderby != nil {
		localVarQueryParams.Add("$orderby", parameterToString(*r.orderby, "csv"))
	}
	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSitesTermStoresSetsTermsRelationsDeleteRefFromTermRequest struct {
	ctx _context.Context
	ApiService *SitesStoreApiService
	siteId string
	storeId string
	setId string
	termId string
	relationId string
	ifMatch *string
}

// ETag
func (r ApiSitesTermStoresSetsTermsRelationsDeleteRefFromTermRequest) IfMatch(ifMatch string) ApiSitesTermStoresSetsTermsRelationsDeleteRefFromTermRequest {
	r.ifMatch = &ifMatch
	return r
}

func (r ApiSitesTermStoresSetsTermsRelationsDeleteRefFromTermRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.SitesTermStoresSetsTermsRelationsDeleteRefFromTermExecute(r)
}

/*
SitesTermStoresSetsTermsRelationsDeleteRefFromTerm Delete ref of navigation property fromTerm for sites

The from [term] of the relation. The term from which the relationship is defined. A null value would indicate the relation is directly with the [set].

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param siteId key: id of site
 @param storeId key: id of store
 @param setId key: id of set
 @param termId key: id of term
 @param relationId key: id of relation
 @return ApiSitesTermStoresSetsTermsRelationsDeleteRefFromTermRequest
*/
func (a *SitesStoreApiService) SitesTermStoresSetsTermsRelationsDeleteRefFromTerm(ctx _context.Context, siteId string, storeId string, setId string, termId string, relationId string) ApiSitesTermStoresSetsTermsRelationsDeleteRefFromTermRequest {
	return ApiSitesTermStoresSetsTermsRelationsDeleteRefFromTermRequest{
		ApiService: a,
		ctx: ctx,
		siteId: siteId,
		storeId: storeId,
		setId: setId,
		termId: termId,
		relationId: relationId,
	}
}

// Execute executes the request
func (a *SitesStoreApiService) SitesTermStoresSetsTermsRelationsDeleteRefFromTermExecute(r ApiSitesTermStoresSetsTermsRelationsDeleteRefFromTermRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SitesStoreApiService.SitesTermStoresSetsTermsRelationsDeleteRefFromTerm")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sites/{site-id}/termStores/{store-id}/sets/{set-id}/terms/{term-id}/relations/{relation-id}/fromTerm/$ref"
	localVarPath = strings.Replace(localVarPath, "{"+"site-id"+"}", _neturl.PathEscape(parameterToString(r.siteId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"store-id"+"}", _neturl.PathEscape(parameterToString(r.storeId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"set-id"+"}", _neturl.PathEscape(parameterToString(r.setId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"term-id"+"}", _neturl.PathEscape(parameterToString(r.termId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"relation-id"+"}", _neturl.PathEscape(parameterToString(r.relationId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ifMatch != nil {
		localVarHeaderParams["If-Match"] = parameterToString(*r.ifMatch, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiSitesTermStoresSetsTermsRelationsDeleteRefSetRequest struct {
	ctx _context.Context
	ApiService *SitesStoreApiService
	siteId string
	storeId string
	setId string
	termId string
	relationId string
	ifMatch *string
}

// ETag
func (r ApiSitesTermStoresSetsTermsRelationsDeleteRefSetRequest) IfMatch(ifMatch string) ApiSitesTermStoresSetsTermsRelationsDeleteRefSetRequest {
	r.ifMatch = &ifMatch
	return r
}

func (r ApiSitesTermStoresSetsTermsRelationsDeleteRefSetRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.SitesTermStoresSetsTermsRelationsDeleteRefSetExecute(r)
}

/*
SitesTermStoresSetsTermsRelationsDeleteRefSet Delete ref of navigation property set for sites

The [set] in which the relation is relevant.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param siteId key: id of site
 @param storeId key: id of store
 @param setId key: id of set
 @param termId key: id of term
 @param relationId key: id of relation
 @return ApiSitesTermStoresSetsTermsRelationsDeleteRefSetRequest
*/
func (a *SitesStoreApiService) SitesTermStoresSetsTermsRelationsDeleteRefSet(ctx _context.Context, siteId string, storeId string, setId string, termId string, relationId string) ApiSitesTermStoresSetsTermsRelationsDeleteRefSetRequest {
	return ApiSitesTermStoresSetsTermsRelationsDeleteRefSetRequest{
		ApiService: a,
		ctx: ctx,
		siteId: siteId,
		storeId: storeId,
		setId: setId,
		termId: termId,
		relationId: relationId,
	}
}

// Execute executes the request
func (a *SitesStoreApiService) SitesTermStoresSetsTermsRelationsDeleteRefSetExecute(r ApiSitesTermStoresSetsTermsRelationsDeleteRefSetRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SitesStoreApiService.SitesTermStoresSetsTermsRelationsDeleteRefSet")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sites/{site-id}/termStores/{store-id}/sets/{set-id}/terms/{term-id}/relations/{relation-id}/set/$ref"
	localVarPath = strings.Replace(localVarPath, "{"+"site-id"+"}", _neturl.PathEscape(parameterToString(r.siteId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"store-id"+"}", _neturl.PathEscape(parameterToString(r.storeId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"set-id"+"}", _neturl.PathEscape(parameterToString(r.setId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"term-id"+"}", _neturl.PathEscape(parameterToString(r.termId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"relation-id"+"}", _neturl.PathEscape(parameterToString(r.relationId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ifMatch != nil {
		localVarHeaderParams["If-Match"] = parameterToString(*r.ifMatch, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiSitesTermStoresSetsTermsRelationsDeleteRefToTermRequest struct {
	ctx _context.Context
	ApiService *SitesStoreApiService
	siteId string
	storeId string
	setId string
	termId string
	relationId string
	ifMatch *string
}

// ETag
func (r ApiSitesTermStoresSetsTermsRelationsDeleteRefToTermRequest) IfMatch(ifMatch string) ApiSitesTermStoresSetsTermsRelationsDeleteRefToTermRequest {
	r.ifMatch = &ifMatch
	return r
}

func (r ApiSitesTermStoresSetsTermsRelationsDeleteRefToTermRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.SitesTermStoresSetsTermsRelationsDeleteRefToTermExecute(r)
}

/*
SitesTermStoresSetsTermsRelationsDeleteRefToTerm Delete ref of navigation property toTerm for sites

The to [term] of the relation. The term to which the relationship is defined.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param siteId key: id of site
 @param storeId key: id of store
 @param setId key: id of set
 @param termId key: id of term
 @param relationId key: id of relation
 @return ApiSitesTermStoresSetsTermsRelationsDeleteRefToTermRequest
*/
func (a *SitesStoreApiService) SitesTermStoresSetsTermsRelationsDeleteRefToTerm(ctx _context.Context, siteId string, storeId string, setId string, termId string, relationId string) ApiSitesTermStoresSetsTermsRelationsDeleteRefToTermRequest {
	return ApiSitesTermStoresSetsTermsRelationsDeleteRefToTermRequest{
		ApiService: a,
		ctx: ctx,
		siteId: siteId,
		storeId: storeId,
		setId: setId,
		termId: termId,
		relationId: relationId,
	}
}

// Execute executes the request
func (a *SitesStoreApiService) SitesTermStoresSetsTermsRelationsDeleteRefToTermExecute(r ApiSitesTermStoresSetsTermsRelationsDeleteRefToTermRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SitesStoreApiService.SitesTermStoresSetsTermsRelationsDeleteRefToTerm")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sites/{site-id}/termStores/{store-id}/sets/{set-id}/terms/{term-id}/relations/{relation-id}/toTerm/$ref"
	localVarPath = strings.Replace(localVarPath, "{"+"site-id"+"}", _neturl.PathEscape(parameterToString(r.siteId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"store-id"+"}", _neturl.PathEscape(parameterToString(r.storeId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"set-id"+"}", _neturl.PathEscape(parameterToString(r.setId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"term-id"+"}", _neturl.PathEscape(parameterToString(r.termId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"relation-id"+"}", _neturl.PathEscape(parameterToString(r.relationId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ifMatch != nil {
		localVarHeaderParams["If-Match"] = parameterToString(*r.ifMatch, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiSitesTermStoresSetsTermsRelationsGetFromTermRequest struct {
	ctx _context.Context
	ApiService *SitesStoreApiService
	siteId string
	storeId string
	setId string
	termId string
	relationId string
	select_ *[]string
	expand *[]string
}

// Select properties to be returned
func (r ApiSitesTermStoresSetsTermsRelationsGetFromTermRequest) Select_(select_ []string) ApiSitesTermStoresSetsTermsRelationsGetFromTermRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiSitesTermStoresSetsTermsRelationsGetFromTermRequest) Expand(expand []string) ApiSitesTermStoresSetsTermsRelationsGetFromTermRequest {
	r.expand = &expand
	return r
}

func (r ApiSitesTermStoresSetsTermsRelationsGetFromTermRequest) Execute() (MicrosoftGraphTermStoreTerm, *_nethttp.Response, error) {
	return r.ApiService.SitesTermStoresSetsTermsRelationsGetFromTermExecute(r)
}

/*
SitesTermStoresSetsTermsRelationsGetFromTerm Get fromTerm from sites

The from [term] of the relation. The term from which the relationship is defined. A null value would indicate the relation is directly with the [set].

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param siteId key: id of site
 @param storeId key: id of store
 @param setId key: id of set
 @param termId key: id of term
 @param relationId key: id of relation
 @return ApiSitesTermStoresSetsTermsRelationsGetFromTermRequest
*/
func (a *SitesStoreApiService) SitesTermStoresSetsTermsRelationsGetFromTerm(ctx _context.Context, siteId string, storeId string, setId string, termId string, relationId string) ApiSitesTermStoresSetsTermsRelationsGetFromTermRequest {
	return ApiSitesTermStoresSetsTermsRelationsGetFromTermRequest{
		ApiService: a,
		ctx: ctx,
		siteId: siteId,
		storeId: storeId,
		setId: setId,
		termId: termId,
		relationId: relationId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphTermStoreTerm
func (a *SitesStoreApiService) SitesTermStoresSetsTermsRelationsGetFromTermExecute(r ApiSitesTermStoresSetsTermsRelationsGetFromTermRequest) (MicrosoftGraphTermStoreTerm, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphTermStoreTerm
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SitesStoreApiService.SitesTermStoresSetsTermsRelationsGetFromTerm")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sites/{site-id}/termStores/{store-id}/sets/{set-id}/terms/{term-id}/relations/{relation-id}/fromTerm"
	localVarPath = strings.Replace(localVarPath, "{"+"site-id"+"}", _neturl.PathEscape(parameterToString(r.siteId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"store-id"+"}", _neturl.PathEscape(parameterToString(r.storeId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"set-id"+"}", _neturl.PathEscape(parameterToString(r.setId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"term-id"+"}", _neturl.PathEscape(parameterToString(r.termId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"relation-id"+"}", _neturl.PathEscape(parameterToString(r.relationId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSitesTermStoresSetsTermsRelationsGetRefFromTermRequest struct {
	ctx _context.Context
	ApiService *SitesStoreApiService
	siteId string
	storeId string
	setId string
	termId string
	relationId string
}


func (r ApiSitesTermStoresSetsTermsRelationsGetRefFromTermRequest) Execute() (string, *_nethttp.Response, error) {
	return r.ApiService.SitesTermStoresSetsTermsRelationsGetRefFromTermExecute(r)
}

/*
SitesTermStoresSetsTermsRelationsGetRefFromTerm Get ref of fromTerm from sites

The from [term] of the relation. The term from which the relationship is defined. A null value would indicate the relation is directly with the [set].

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param siteId key: id of site
 @param storeId key: id of store
 @param setId key: id of set
 @param termId key: id of term
 @param relationId key: id of relation
 @return ApiSitesTermStoresSetsTermsRelationsGetRefFromTermRequest
*/
func (a *SitesStoreApiService) SitesTermStoresSetsTermsRelationsGetRefFromTerm(ctx _context.Context, siteId string, storeId string, setId string, termId string, relationId string) ApiSitesTermStoresSetsTermsRelationsGetRefFromTermRequest {
	return ApiSitesTermStoresSetsTermsRelationsGetRefFromTermRequest{
		ApiService: a,
		ctx: ctx,
		siteId: siteId,
		storeId: storeId,
		setId: setId,
		termId: termId,
		relationId: relationId,
	}
}

// Execute executes the request
//  @return string
func (a *SitesStoreApiService) SitesTermStoresSetsTermsRelationsGetRefFromTermExecute(r ApiSitesTermStoresSetsTermsRelationsGetRefFromTermRequest) (string, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  string
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SitesStoreApiService.SitesTermStoresSetsTermsRelationsGetRefFromTerm")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sites/{site-id}/termStores/{store-id}/sets/{set-id}/terms/{term-id}/relations/{relation-id}/fromTerm/$ref"
	localVarPath = strings.Replace(localVarPath, "{"+"site-id"+"}", _neturl.PathEscape(parameterToString(r.siteId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"store-id"+"}", _neturl.PathEscape(parameterToString(r.storeId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"set-id"+"}", _neturl.PathEscape(parameterToString(r.setId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"term-id"+"}", _neturl.PathEscape(parameterToString(r.termId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"relation-id"+"}", _neturl.PathEscape(parameterToString(r.relationId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSitesTermStoresSetsTermsRelationsGetRefSetRequest struct {
	ctx _context.Context
	ApiService *SitesStoreApiService
	siteId string
	storeId string
	setId string
	termId string
	relationId string
}


func (r ApiSitesTermStoresSetsTermsRelationsGetRefSetRequest) Execute() (string, *_nethttp.Response, error) {
	return r.ApiService.SitesTermStoresSetsTermsRelationsGetRefSetExecute(r)
}

/*
SitesTermStoresSetsTermsRelationsGetRefSet Get ref of set from sites

The [set] in which the relation is relevant.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param siteId key: id of site
 @param storeId key: id of store
 @param setId key: id of set
 @param termId key: id of term
 @param relationId key: id of relation
 @return ApiSitesTermStoresSetsTermsRelationsGetRefSetRequest
*/
func (a *SitesStoreApiService) SitesTermStoresSetsTermsRelationsGetRefSet(ctx _context.Context, siteId string, storeId string, setId string, termId string, relationId string) ApiSitesTermStoresSetsTermsRelationsGetRefSetRequest {
	return ApiSitesTermStoresSetsTermsRelationsGetRefSetRequest{
		ApiService: a,
		ctx: ctx,
		siteId: siteId,
		storeId: storeId,
		setId: setId,
		termId: termId,
		relationId: relationId,
	}
}

// Execute executes the request
//  @return string
func (a *SitesStoreApiService) SitesTermStoresSetsTermsRelationsGetRefSetExecute(r ApiSitesTermStoresSetsTermsRelationsGetRefSetRequest) (string, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  string
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SitesStoreApiService.SitesTermStoresSetsTermsRelationsGetRefSet")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sites/{site-id}/termStores/{store-id}/sets/{set-id}/terms/{term-id}/relations/{relation-id}/set/$ref"
	localVarPath = strings.Replace(localVarPath, "{"+"site-id"+"}", _neturl.PathEscape(parameterToString(r.siteId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"store-id"+"}", _neturl.PathEscape(parameterToString(r.storeId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"set-id"+"}", _neturl.PathEscape(parameterToString(r.setId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"term-id"+"}", _neturl.PathEscape(parameterToString(r.termId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"relation-id"+"}", _neturl.PathEscape(parameterToString(r.relationId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSitesTermStoresSetsTermsRelationsGetRefToTermRequest struct {
	ctx _context.Context
	ApiService *SitesStoreApiService
	siteId string
	storeId string
	setId string
	termId string
	relationId string
}


func (r ApiSitesTermStoresSetsTermsRelationsGetRefToTermRequest) Execute() (string, *_nethttp.Response, error) {
	return r.ApiService.SitesTermStoresSetsTermsRelationsGetRefToTermExecute(r)
}

/*
SitesTermStoresSetsTermsRelationsGetRefToTerm Get ref of toTerm from sites

The to [term] of the relation. The term to which the relationship is defined.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param siteId key: id of site
 @param storeId key: id of store
 @param setId key: id of set
 @param termId key: id of term
 @param relationId key: id of relation
 @return ApiSitesTermStoresSetsTermsRelationsGetRefToTermRequest
*/
func (a *SitesStoreApiService) SitesTermStoresSetsTermsRelationsGetRefToTerm(ctx _context.Context, siteId string, storeId string, setId string, termId string, relationId string) ApiSitesTermStoresSetsTermsRelationsGetRefToTermRequest {
	return ApiSitesTermStoresSetsTermsRelationsGetRefToTermRequest{
		ApiService: a,
		ctx: ctx,
		siteId: siteId,
		storeId: storeId,
		setId: setId,
		termId: termId,
		relationId: relationId,
	}
}

// Execute executes the request
//  @return string
func (a *SitesStoreApiService) SitesTermStoresSetsTermsRelationsGetRefToTermExecute(r ApiSitesTermStoresSetsTermsRelationsGetRefToTermRequest) (string, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  string
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SitesStoreApiService.SitesTermStoresSetsTermsRelationsGetRefToTerm")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sites/{site-id}/termStores/{store-id}/sets/{set-id}/terms/{term-id}/relations/{relation-id}/toTerm/$ref"
	localVarPath = strings.Replace(localVarPath, "{"+"site-id"+"}", _neturl.PathEscape(parameterToString(r.siteId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"store-id"+"}", _neturl.PathEscape(parameterToString(r.storeId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"set-id"+"}", _neturl.PathEscape(parameterToString(r.setId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"term-id"+"}", _neturl.PathEscape(parameterToString(r.termId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"relation-id"+"}", _neturl.PathEscape(parameterToString(r.relationId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSitesTermStoresSetsTermsRelationsGetSetRequest struct {
	ctx _context.Context
	ApiService *SitesStoreApiService
	siteId string
	storeId string
	setId string
	termId string
	relationId string
	select_ *[]string
	expand *[]string
}

// Select properties to be returned
func (r ApiSitesTermStoresSetsTermsRelationsGetSetRequest) Select_(select_ []string) ApiSitesTermStoresSetsTermsRelationsGetSetRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiSitesTermStoresSetsTermsRelationsGetSetRequest) Expand(expand []string) ApiSitesTermStoresSetsTermsRelationsGetSetRequest {
	r.expand = &expand
	return r
}

func (r ApiSitesTermStoresSetsTermsRelationsGetSetRequest) Execute() (MicrosoftGraphTermStoreSet, *_nethttp.Response, error) {
	return r.ApiService.SitesTermStoresSetsTermsRelationsGetSetExecute(r)
}

/*
SitesTermStoresSetsTermsRelationsGetSet Get set from sites

The [set] in which the relation is relevant.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param siteId key: id of site
 @param storeId key: id of store
 @param setId key: id of set
 @param termId key: id of term
 @param relationId key: id of relation
 @return ApiSitesTermStoresSetsTermsRelationsGetSetRequest
*/
func (a *SitesStoreApiService) SitesTermStoresSetsTermsRelationsGetSet(ctx _context.Context, siteId string, storeId string, setId string, termId string, relationId string) ApiSitesTermStoresSetsTermsRelationsGetSetRequest {
	return ApiSitesTermStoresSetsTermsRelationsGetSetRequest{
		ApiService: a,
		ctx: ctx,
		siteId: siteId,
		storeId: storeId,
		setId: setId,
		termId: termId,
		relationId: relationId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphTermStoreSet
func (a *SitesStoreApiService) SitesTermStoresSetsTermsRelationsGetSetExecute(r ApiSitesTermStoresSetsTermsRelationsGetSetRequest) (MicrosoftGraphTermStoreSet, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphTermStoreSet
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SitesStoreApiService.SitesTermStoresSetsTermsRelationsGetSet")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sites/{site-id}/termStores/{store-id}/sets/{set-id}/terms/{term-id}/relations/{relation-id}/set"
	localVarPath = strings.Replace(localVarPath, "{"+"site-id"+"}", _neturl.PathEscape(parameterToString(r.siteId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"store-id"+"}", _neturl.PathEscape(parameterToString(r.storeId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"set-id"+"}", _neturl.PathEscape(parameterToString(r.setId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"term-id"+"}", _neturl.PathEscape(parameterToString(r.termId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"relation-id"+"}", _neturl.PathEscape(parameterToString(r.relationId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSitesTermStoresSetsTermsRelationsGetToTermRequest struct {
	ctx _context.Context
	ApiService *SitesStoreApiService
	siteId string
	storeId string
	setId string
	termId string
	relationId string
	select_ *[]string
	expand *[]string
}

// Select properties to be returned
func (r ApiSitesTermStoresSetsTermsRelationsGetToTermRequest) Select_(select_ []string) ApiSitesTermStoresSetsTermsRelationsGetToTermRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiSitesTermStoresSetsTermsRelationsGetToTermRequest) Expand(expand []string) ApiSitesTermStoresSetsTermsRelationsGetToTermRequest {
	r.expand = &expand
	return r
}

func (r ApiSitesTermStoresSetsTermsRelationsGetToTermRequest) Execute() (MicrosoftGraphTermStoreTerm, *_nethttp.Response, error) {
	return r.ApiService.SitesTermStoresSetsTermsRelationsGetToTermExecute(r)
}

/*
SitesTermStoresSetsTermsRelationsGetToTerm Get toTerm from sites

The to [term] of the relation. The term to which the relationship is defined.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param siteId key: id of site
 @param storeId key: id of store
 @param setId key: id of set
 @param termId key: id of term
 @param relationId key: id of relation
 @return ApiSitesTermStoresSetsTermsRelationsGetToTermRequest
*/
func (a *SitesStoreApiService) SitesTermStoresSetsTermsRelationsGetToTerm(ctx _context.Context, siteId string, storeId string, setId string, termId string, relationId string) ApiSitesTermStoresSetsTermsRelationsGetToTermRequest {
	return ApiSitesTermStoresSetsTermsRelationsGetToTermRequest{
		ApiService: a,
		ctx: ctx,
		siteId: siteId,
		storeId: storeId,
		setId: setId,
		termId: termId,
		relationId: relationId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphTermStoreTerm
func (a *SitesStoreApiService) SitesTermStoresSetsTermsRelationsGetToTermExecute(r ApiSitesTermStoresSetsTermsRelationsGetToTermRequest) (MicrosoftGraphTermStoreTerm, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphTermStoreTerm
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SitesStoreApiService.SitesTermStoresSetsTermsRelationsGetToTerm")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sites/{site-id}/termStores/{store-id}/sets/{set-id}/terms/{term-id}/relations/{relation-id}/toTerm"
	localVarPath = strings.Replace(localVarPath, "{"+"site-id"+"}", _neturl.PathEscape(parameterToString(r.siteId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"store-id"+"}", _neturl.PathEscape(parameterToString(r.storeId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"set-id"+"}", _neturl.PathEscape(parameterToString(r.setId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"term-id"+"}", _neturl.PathEscape(parameterToString(r.termId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"relation-id"+"}", _neturl.PathEscape(parameterToString(r.relationId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSitesTermStoresSetsTermsRelationsUpdateRefFromTermRequest struct {
	ctx _context.Context
	ApiService *SitesStoreApiService
	siteId string
	storeId string
	setId string
	termId string
	relationId string
	requestBody *map[string]map[string]interface{}
}

// New navigation property ref values
func (r ApiSitesTermStoresSetsTermsRelationsUpdateRefFromTermRequest) RequestBody(requestBody map[string]map[string]interface{}) ApiSitesTermStoresSetsTermsRelationsUpdateRefFromTermRequest {
	r.requestBody = &requestBody
	return r
}

func (r ApiSitesTermStoresSetsTermsRelationsUpdateRefFromTermRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.SitesTermStoresSetsTermsRelationsUpdateRefFromTermExecute(r)
}

/*
SitesTermStoresSetsTermsRelationsUpdateRefFromTerm Update the ref of navigation property fromTerm in sites

The from [term] of the relation. The term from which the relationship is defined. A null value would indicate the relation is directly with the [set].

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param siteId key: id of site
 @param storeId key: id of store
 @param setId key: id of set
 @param termId key: id of term
 @param relationId key: id of relation
 @return ApiSitesTermStoresSetsTermsRelationsUpdateRefFromTermRequest
*/
func (a *SitesStoreApiService) SitesTermStoresSetsTermsRelationsUpdateRefFromTerm(ctx _context.Context, siteId string, storeId string, setId string, termId string, relationId string) ApiSitesTermStoresSetsTermsRelationsUpdateRefFromTermRequest {
	return ApiSitesTermStoresSetsTermsRelationsUpdateRefFromTermRequest{
		ApiService: a,
		ctx: ctx,
		siteId: siteId,
		storeId: storeId,
		setId: setId,
		termId: termId,
		relationId: relationId,
	}
}

// Execute executes the request
func (a *SitesStoreApiService) SitesTermStoresSetsTermsRelationsUpdateRefFromTermExecute(r ApiSitesTermStoresSetsTermsRelationsUpdateRefFromTermRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPut
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SitesStoreApiService.SitesTermStoresSetsTermsRelationsUpdateRefFromTerm")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sites/{site-id}/termStores/{store-id}/sets/{set-id}/terms/{term-id}/relations/{relation-id}/fromTerm/$ref"
	localVarPath = strings.Replace(localVarPath, "{"+"site-id"+"}", _neturl.PathEscape(parameterToString(r.siteId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"store-id"+"}", _neturl.PathEscape(parameterToString(r.storeId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"set-id"+"}", _neturl.PathEscape(parameterToString(r.setId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"term-id"+"}", _neturl.PathEscape(parameterToString(r.termId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"relation-id"+"}", _neturl.PathEscape(parameterToString(r.relationId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.requestBody == nil {
		return nil, reportError("requestBody is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.requestBody
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiSitesTermStoresSetsTermsRelationsUpdateRefSetRequest struct {
	ctx _context.Context
	ApiService *SitesStoreApiService
	siteId string
	storeId string
	setId string
	termId string
	relationId string
	requestBody *map[string]map[string]interface{}
}

// New navigation property ref values
func (r ApiSitesTermStoresSetsTermsRelationsUpdateRefSetRequest) RequestBody(requestBody map[string]map[string]interface{}) ApiSitesTermStoresSetsTermsRelationsUpdateRefSetRequest {
	r.requestBody = &requestBody
	return r
}

func (r ApiSitesTermStoresSetsTermsRelationsUpdateRefSetRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.SitesTermStoresSetsTermsRelationsUpdateRefSetExecute(r)
}

/*
SitesTermStoresSetsTermsRelationsUpdateRefSet Update the ref of navigation property set in sites

The [set] in which the relation is relevant.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param siteId key: id of site
 @param storeId key: id of store
 @param setId key: id of set
 @param termId key: id of term
 @param relationId key: id of relation
 @return ApiSitesTermStoresSetsTermsRelationsUpdateRefSetRequest
*/
func (a *SitesStoreApiService) SitesTermStoresSetsTermsRelationsUpdateRefSet(ctx _context.Context, siteId string, storeId string, setId string, termId string, relationId string) ApiSitesTermStoresSetsTermsRelationsUpdateRefSetRequest {
	return ApiSitesTermStoresSetsTermsRelationsUpdateRefSetRequest{
		ApiService: a,
		ctx: ctx,
		siteId: siteId,
		storeId: storeId,
		setId: setId,
		termId: termId,
		relationId: relationId,
	}
}

// Execute executes the request
func (a *SitesStoreApiService) SitesTermStoresSetsTermsRelationsUpdateRefSetExecute(r ApiSitesTermStoresSetsTermsRelationsUpdateRefSetRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPut
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SitesStoreApiService.SitesTermStoresSetsTermsRelationsUpdateRefSet")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sites/{site-id}/termStores/{store-id}/sets/{set-id}/terms/{term-id}/relations/{relation-id}/set/$ref"
	localVarPath = strings.Replace(localVarPath, "{"+"site-id"+"}", _neturl.PathEscape(parameterToString(r.siteId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"store-id"+"}", _neturl.PathEscape(parameterToString(r.storeId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"set-id"+"}", _neturl.PathEscape(parameterToString(r.setId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"term-id"+"}", _neturl.PathEscape(parameterToString(r.termId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"relation-id"+"}", _neturl.PathEscape(parameterToString(r.relationId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.requestBody == nil {
		return nil, reportError("requestBody is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.requestBody
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiSitesTermStoresSetsTermsRelationsUpdateRefToTermRequest struct {
	ctx _context.Context
	ApiService *SitesStoreApiService
	siteId string
	storeId string
	setId string
	termId string
	relationId string
	requestBody *map[string]map[string]interface{}
}

// New navigation property ref values
func (r ApiSitesTermStoresSetsTermsRelationsUpdateRefToTermRequest) RequestBody(requestBody map[string]map[string]interface{}) ApiSitesTermStoresSetsTermsRelationsUpdateRefToTermRequest {
	r.requestBody = &requestBody
	return r
}

func (r ApiSitesTermStoresSetsTermsRelationsUpdateRefToTermRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.SitesTermStoresSetsTermsRelationsUpdateRefToTermExecute(r)
}

/*
SitesTermStoresSetsTermsRelationsUpdateRefToTerm Update the ref of navigation property toTerm in sites

The to [term] of the relation. The term to which the relationship is defined.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param siteId key: id of site
 @param storeId key: id of store
 @param setId key: id of set
 @param termId key: id of term
 @param relationId key: id of relation
 @return ApiSitesTermStoresSetsTermsRelationsUpdateRefToTermRequest
*/
func (a *SitesStoreApiService) SitesTermStoresSetsTermsRelationsUpdateRefToTerm(ctx _context.Context, siteId string, storeId string, setId string, termId string, relationId string) ApiSitesTermStoresSetsTermsRelationsUpdateRefToTermRequest {
	return ApiSitesTermStoresSetsTermsRelationsUpdateRefToTermRequest{
		ApiService: a,
		ctx: ctx,
		siteId: siteId,
		storeId: storeId,
		setId: setId,
		termId: termId,
		relationId: relationId,
	}
}

// Execute executes the request
func (a *SitesStoreApiService) SitesTermStoresSetsTermsRelationsUpdateRefToTermExecute(r ApiSitesTermStoresSetsTermsRelationsUpdateRefToTermRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPut
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SitesStoreApiService.SitesTermStoresSetsTermsRelationsUpdateRefToTerm")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sites/{site-id}/termStores/{store-id}/sets/{set-id}/terms/{term-id}/relations/{relation-id}/toTerm/$ref"
	localVarPath = strings.Replace(localVarPath, "{"+"site-id"+"}", _neturl.PathEscape(parameterToString(r.siteId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"store-id"+"}", _neturl.PathEscape(parameterToString(r.storeId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"set-id"+"}", _neturl.PathEscape(parameterToString(r.setId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"term-id"+"}", _neturl.PathEscape(parameterToString(r.termId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"relation-id"+"}", _neturl.PathEscape(parameterToString(r.relationId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.requestBody == nil {
		return nil, reportError("requestBody is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.requestBody
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiSitesTermStoresSetsTermsUpdateChildrenRequest struct {
	ctx _context.Context
	ApiService *SitesStoreApiService
	siteId string
	storeId string
	setId string
	termId string
	termId1 string
	microsoftGraphTermStoreTerm *MicrosoftGraphTermStoreTerm
}

// New navigation property values
func (r ApiSitesTermStoresSetsTermsUpdateChildrenRequest) MicrosoftGraphTermStoreTerm(microsoftGraphTermStoreTerm MicrosoftGraphTermStoreTerm) ApiSitesTermStoresSetsTermsUpdateChildrenRequest {
	r.microsoftGraphTermStoreTerm = &microsoftGraphTermStoreTerm
	return r
}

func (r ApiSitesTermStoresSetsTermsUpdateChildrenRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.SitesTermStoresSetsTermsUpdateChildrenExecute(r)
}

/*
SitesTermStoresSetsTermsUpdateChildren Update the navigation property children in sites

Children of current term.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param siteId key: id of site
 @param storeId key: id of store
 @param setId key: id of set
 @param termId key: id of term
 @param termId1 key: id of term
 @return ApiSitesTermStoresSetsTermsUpdateChildrenRequest
*/
func (a *SitesStoreApiService) SitesTermStoresSetsTermsUpdateChildren(ctx _context.Context, siteId string, storeId string, setId string, termId string, termId1 string) ApiSitesTermStoresSetsTermsUpdateChildrenRequest {
	return ApiSitesTermStoresSetsTermsUpdateChildrenRequest{
		ApiService: a,
		ctx: ctx,
		siteId: siteId,
		storeId: storeId,
		setId: setId,
		termId: termId,
		termId1: termId1,
	}
}

// Execute executes the request
func (a *SitesStoreApiService) SitesTermStoresSetsTermsUpdateChildrenExecute(r ApiSitesTermStoresSetsTermsUpdateChildrenRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPatch
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SitesStoreApiService.SitesTermStoresSetsTermsUpdateChildren")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sites/{site-id}/termStores/{store-id}/sets/{set-id}/terms/{term-id}/children/{term-id1}"
	localVarPath = strings.Replace(localVarPath, "{"+"site-id"+"}", _neturl.PathEscape(parameterToString(r.siteId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"store-id"+"}", _neturl.PathEscape(parameterToString(r.storeId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"set-id"+"}", _neturl.PathEscape(parameterToString(r.setId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"term-id"+"}", _neturl.PathEscape(parameterToString(r.termId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"term-id1"+"}", _neturl.PathEscape(parameterToString(r.termId1, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphTermStoreTerm == nil {
		return nil, reportError("microsoftGraphTermStoreTerm is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphTermStoreTerm
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiSitesTermStoresSetsTermsUpdateRefSetRequest struct {
	ctx _context.Context
	ApiService *SitesStoreApiService
	siteId string
	storeId string
	setId string
	termId string
	requestBody *map[string]map[string]interface{}
}

// New navigation property ref values
func (r ApiSitesTermStoresSetsTermsUpdateRefSetRequest) RequestBody(requestBody map[string]map[string]interface{}) ApiSitesTermStoresSetsTermsUpdateRefSetRequest {
	r.requestBody = &requestBody
	return r
}

func (r ApiSitesTermStoresSetsTermsUpdateRefSetRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.SitesTermStoresSetsTermsUpdateRefSetExecute(r)
}

/*
SitesTermStoresSetsTermsUpdateRefSet Update the ref of navigation property set in sites

The [set] in which the term is created.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param siteId key: id of site
 @param storeId key: id of store
 @param setId key: id of set
 @param termId key: id of term
 @return ApiSitesTermStoresSetsTermsUpdateRefSetRequest
*/
func (a *SitesStoreApiService) SitesTermStoresSetsTermsUpdateRefSet(ctx _context.Context, siteId string, storeId string, setId string, termId string) ApiSitesTermStoresSetsTermsUpdateRefSetRequest {
	return ApiSitesTermStoresSetsTermsUpdateRefSetRequest{
		ApiService: a,
		ctx: ctx,
		siteId: siteId,
		storeId: storeId,
		setId: setId,
		termId: termId,
	}
}

// Execute executes the request
func (a *SitesStoreApiService) SitesTermStoresSetsTermsUpdateRefSetExecute(r ApiSitesTermStoresSetsTermsUpdateRefSetRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPut
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SitesStoreApiService.SitesTermStoresSetsTermsUpdateRefSet")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sites/{site-id}/termStores/{store-id}/sets/{set-id}/terms/{term-id}/set/$ref"
	localVarPath = strings.Replace(localVarPath, "{"+"site-id"+"}", _neturl.PathEscape(parameterToString(r.siteId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"store-id"+"}", _neturl.PathEscape(parameterToString(r.storeId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"set-id"+"}", _neturl.PathEscape(parameterToString(r.setId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"term-id"+"}", _neturl.PathEscape(parameterToString(r.termId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.requestBody == nil {
		return nil, reportError("requestBody is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.requestBody
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiSitesTermStoresSetsTermsUpdateRelationsRequest struct {
	ctx _context.Context
	ApiService *SitesStoreApiService
	siteId string
	storeId string
	setId string
	termId string
	relationId string
	microsoftGraphTermStoreRelation *MicrosoftGraphTermStoreRelation
}

// New navigation property values
func (r ApiSitesTermStoresSetsTermsUpdateRelationsRequest) MicrosoftGraphTermStoreRelation(microsoftGraphTermStoreRelation MicrosoftGraphTermStoreRelation) ApiSitesTermStoresSetsTermsUpdateRelationsRequest {
	r.microsoftGraphTermStoreRelation = &microsoftGraphTermStoreRelation
	return r
}

func (r ApiSitesTermStoresSetsTermsUpdateRelationsRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.SitesTermStoresSetsTermsUpdateRelationsExecute(r)
}

/*
SitesTermStoresSetsTermsUpdateRelations Update the navigation property relations in sites

To indicate which terms are related to the current term as either pinned or reused.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param siteId key: id of site
 @param storeId key: id of store
 @param setId key: id of set
 @param termId key: id of term
 @param relationId key: id of relation
 @return ApiSitesTermStoresSetsTermsUpdateRelationsRequest
*/
func (a *SitesStoreApiService) SitesTermStoresSetsTermsUpdateRelations(ctx _context.Context, siteId string, storeId string, setId string, termId string, relationId string) ApiSitesTermStoresSetsTermsUpdateRelationsRequest {
	return ApiSitesTermStoresSetsTermsUpdateRelationsRequest{
		ApiService: a,
		ctx: ctx,
		siteId: siteId,
		storeId: storeId,
		setId: setId,
		termId: termId,
		relationId: relationId,
	}
}

// Execute executes the request
func (a *SitesStoreApiService) SitesTermStoresSetsTermsUpdateRelationsExecute(r ApiSitesTermStoresSetsTermsUpdateRelationsRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPatch
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SitesStoreApiService.SitesTermStoresSetsTermsUpdateRelations")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sites/{site-id}/termStores/{store-id}/sets/{set-id}/terms/{term-id}/relations/{relation-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"site-id"+"}", _neturl.PathEscape(parameterToString(r.siteId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"store-id"+"}", _neturl.PathEscape(parameterToString(r.storeId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"set-id"+"}", _neturl.PathEscape(parameterToString(r.setId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"term-id"+"}", _neturl.PathEscape(parameterToString(r.termId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"relation-id"+"}", _neturl.PathEscape(parameterToString(r.relationId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphTermStoreRelation == nil {
		return nil, reportError("microsoftGraphTermStoreRelation is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphTermStoreRelation
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiSitesTermStoresSetsUpdateChildrenRequest struct {
	ctx _context.Context
	ApiService *SitesStoreApiService
	siteId string
	storeId string
	setId string
	termId string
	microsoftGraphTermStoreTerm *MicrosoftGraphTermStoreTerm
}

// New navigation property values
func (r ApiSitesTermStoresSetsUpdateChildrenRequest) MicrosoftGraphTermStoreTerm(microsoftGraphTermStoreTerm MicrosoftGraphTermStoreTerm) ApiSitesTermStoresSetsUpdateChildrenRequest {
	r.microsoftGraphTermStoreTerm = &microsoftGraphTermStoreTerm
	return r
}

func (r ApiSitesTermStoresSetsUpdateChildrenRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.SitesTermStoresSetsUpdateChildrenExecute(r)
}

/*
SitesTermStoresSetsUpdateChildren Update the navigation property children in sites

Children terms of set in term [store].

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param siteId key: id of site
 @param storeId key: id of store
 @param setId key: id of set
 @param termId key: id of term
 @return ApiSitesTermStoresSetsUpdateChildrenRequest
*/
func (a *SitesStoreApiService) SitesTermStoresSetsUpdateChildren(ctx _context.Context, siteId string, storeId string, setId string, termId string) ApiSitesTermStoresSetsUpdateChildrenRequest {
	return ApiSitesTermStoresSetsUpdateChildrenRequest{
		ApiService: a,
		ctx: ctx,
		siteId: siteId,
		storeId: storeId,
		setId: setId,
		termId: termId,
	}
}

// Execute executes the request
func (a *SitesStoreApiService) SitesTermStoresSetsUpdateChildrenExecute(r ApiSitesTermStoresSetsUpdateChildrenRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPatch
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SitesStoreApiService.SitesTermStoresSetsUpdateChildren")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sites/{site-id}/termStores/{store-id}/sets/{set-id}/children/{term-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"site-id"+"}", _neturl.PathEscape(parameterToString(r.siteId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"store-id"+"}", _neturl.PathEscape(parameterToString(r.storeId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"set-id"+"}", _neturl.PathEscape(parameterToString(r.setId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"term-id"+"}", _neturl.PathEscape(parameterToString(r.termId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphTermStoreTerm == nil {
		return nil, reportError("microsoftGraphTermStoreTerm is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphTermStoreTerm
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiSitesTermStoresSetsUpdateParentGroupRequest struct {
	ctx _context.Context
	ApiService *SitesStoreApiService
	siteId string
	storeId string
	setId string
	microsoftGraphTermStoreGroup *MicrosoftGraphTermStoreGroup
}

// New navigation property values
func (r ApiSitesTermStoresSetsUpdateParentGroupRequest) MicrosoftGraphTermStoreGroup(microsoftGraphTermStoreGroup MicrosoftGraphTermStoreGroup) ApiSitesTermStoresSetsUpdateParentGroupRequest {
	r.microsoftGraphTermStoreGroup = &microsoftGraphTermStoreGroup
	return r
}

func (r ApiSitesTermStoresSetsUpdateParentGroupRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.SitesTermStoresSetsUpdateParentGroupExecute(r)
}

/*
SitesTermStoresSetsUpdateParentGroup Update the navigation property parentGroup in sites

The parent [group] that contains the set.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param siteId key: id of site
 @param storeId key: id of store
 @param setId key: id of set
 @return ApiSitesTermStoresSetsUpdateParentGroupRequest
*/
func (a *SitesStoreApiService) SitesTermStoresSetsUpdateParentGroup(ctx _context.Context, siteId string, storeId string, setId string) ApiSitesTermStoresSetsUpdateParentGroupRequest {
	return ApiSitesTermStoresSetsUpdateParentGroupRequest{
		ApiService: a,
		ctx: ctx,
		siteId: siteId,
		storeId: storeId,
		setId: setId,
	}
}

// Execute executes the request
func (a *SitesStoreApiService) SitesTermStoresSetsUpdateParentGroupExecute(r ApiSitesTermStoresSetsUpdateParentGroupRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPatch
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SitesStoreApiService.SitesTermStoresSetsUpdateParentGroup")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sites/{site-id}/termStores/{store-id}/sets/{set-id}/parentGroup"
	localVarPath = strings.Replace(localVarPath, "{"+"site-id"+"}", _neturl.PathEscape(parameterToString(r.siteId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"store-id"+"}", _neturl.PathEscape(parameterToString(r.storeId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"set-id"+"}", _neturl.PathEscape(parameterToString(r.setId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphTermStoreGroup == nil {
		return nil, reportError("microsoftGraphTermStoreGroup is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphTermStoreGroup
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiSitesTermStoresSetsUpdateRelationsRequest struct {
	ctx _context.Context
	ApiService *SitesStoreApiService
	siteId string
	storeId string
	setId string
	relationId string
	microsoftGraphTermStoreRelation *MicrosoftGraphTermStoreRelation
}

// New navigation property values
func (r ApiSitesTermStoresSetsUpdateRelationsRequest) MicrosoftGraphTermStoreRelation(microsoftGraphTermStoreRelation MicrosoftGraphTermStoreRelation) ApiSitesTermStoresSetsUpdateRelationsRequest {
	r.microsoftGraphTermStoreRelation = &microsoftGraphTermStoreRelation
	return r
}

func (r ApiSitesTermStoresSetsUpdateRelationsRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.SitesTermStoresSetsUpdateRelationsExecute(r)
}

/*
SitesTermStoresSetsUpdateRelations Update the navigation property relations in sites

Indicates which terms have been pinned or reused directly under the set.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param siteId key: id of site
 @param storeId key: id of store
 @param setId key: id of set
 @param relationId key: id of relation
 @return ApiSitesTermStoresSetsUpdateRelationsRequest
*/
func (a *SitesStoreApiService) SitesTermStoresSetsUpdateRelations(ctx _context.Context, siteId string, storeId string, setId string, relationId string) ApiSitesTermStoresSetsUpdateRelationsRequest {
	return ApiSitesTermStoresSetsUpdateRelationsRequest{
		ApiService: a,
		ctx: ctx,
		siteId: siteId,
		storeId: storeId,
		setId: setId,
		relationId: relationId,
	}
}

// Execute executes the request
func (a *SitesStoreApiService) SitesTermStoresSetsUpdateRelationsExecute(r ApiSitesTermStoresSetsUpdateRelationsRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPatch
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SitesStoreApiService.SitesTermStoresSetsUpdateRelations")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sites/{site-id}/termStores/{store-id}/sets/{set-id}/relations/{relation-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"site-id"+"}", _neturl.PathEscape(parameterToString(r.siteId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"store-id"+"}", _neturl.PathEscape(parameterToString(r.storeId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"set-id"+"}", _neturl.PathEscape(parameterToString(r.setId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"relation-id"+"}", _neturl.PathEscape(parameterToString(r.relationId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphTermStoreRelation == nil {
		return nil, reportError("microsoftGraphTermStoreRelation is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphTermStoreRelation
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiSitesTermStoresSetsUpdateTermsRequest struct {
	ctx _context.Context
	ApiService *SitesStoreApiService
	siteId string
	storeId string
	setId string
	termId string
	microsoftGraphTermStoreTerm *MicrosoftGraphTermStoreTerm
}

// New navigation property values
func (r ApiSitesTermStoresSetsUpdateTermsRequest) MicrosoftGraphTermStoreTerm(microsoftGraphTermStoreTerm MicrosoftGraphTermStoreTerm) ApiSitesTermStoresSetsUpdateTermsRequest {
	r.microsoftGraphTermStoreTerm = &microsoftGraphTermStoreTerm
	return r
}

func (r ApiSitesTermStoresSetsUpdateTermsRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.SitesTermStoresSetsUpdateTermsExecute(r)
}

/*
SitesTermStoresSetsUpdateTerms Update the navigation property terms in sites

All the terms under the set.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param siteId key: id of site
 @param storeId key: id of store
 @param setId key: id of set
 @param termId key: id of term
 @return ApiSitesTermStoresSetsUpdateTermsRequest
*/
func (a *SitesStoreApiService) SitesTermStoresSetsUpdateTerms(ctx _context.Context, siteId string, storeId string, setId string, termId string) ApiSitesTermStoresSetsUpdateTermsRequest {
	return ApiSitesTermStoresSetsUpdateTermsRequest{
		ApiService: a,
		ctx: ctx,
		siteId: siteId,
		storeId: storeId,
		setId: setId,
		termId: termId,
	}
}

// Execute executes the request
func (a *SitesStoreApiService) SitesTermStoresSetsUpdateTermsExecute(r ApiSitesTermStoresSetsUpdateTermsRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPatch
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SitesStoreApiService.SitesTermStoresSetsUpdateTerms")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sites/{site-id}/termStores/{store-id}/sets/{set-id}/terms/{term-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"site-id"+"}", _neturl.PathEscape(parameterToString(r.siteId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"store-id"+"}", _neturl.PathEscape(parameterToString(r.storeId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"set-id"+"}", _neturl.PathEscape(parameterToString(r.setId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"term-id"+"}", _neturl.PathEscape(parameterToString(r.termId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphTermStoreTerm == nil {
		return nil, reportError("microsoftGraphTermStoreTerm is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphTermStoreTerm
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiSitesTermStoresUpdateGroupsRequest struct {
	ctx _context.Context
	ApiService *SitesStoreApiService
	siteId string
	storeId string
	groupId string
	microsoftGraphTermStoreGroup *MicrosoftGraphTermStoreGroup
}

// New navigation property values
func (r ApiSitesTermStoresUpdateGroupsRequest) MicrosoftGraphTermStoreGroup(microsoftGraphTermStoreGroup MicrosoftGraphTermStoreGroup) ApiSitesTermStoresUpdateGroupsRequest {
	r.microsoftGraphTermStoreGroup = &microsoftGraphTermStoreGroup
	return r
}

func (r ApiSitesTermStoresUpdateGroupsRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.SitesTermStoresUpdateGroupsExecute(r)
}

/*
SitesTermStoresUpdateGroups Update the navigation property groups in sites

Collection of all groups available in the term store.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param siteId key: id of site
 @param storeId key: id of store
 @param groupId key: id of group
 @return ApiSitesTermStoresUpdateGroupsRequest
*/
func (a *SitesStoreApiService) SitesTermStoresUpdateGroups(ctx _context.Context, siteId string, storeId string, groupId string) ApiSitesTermStoresUpdateGroupsRequest {
	return ApiSitesTermStoresUpdateGroupsRequest{
		ApiService: a,
		ctx: ctx,
		siteId: siteId,
		storeId: storeId,
		groupId: groupId,
	}
}

// Execute executes the request
func (a *SitesStoreApiService) SitesTermStoresUpdateGroupsExecute(r ApiSitesTermStoresUpdateGroupsRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPatch
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SitesStoreApiService.SitesTermStoresUpdateGroups")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sites/{site-id}/termStores/{store-id}/groups/{group-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"site-id"+"}", _neturl.PathEscape(parameterToString(r.siteId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"store-id"+"}", _neturl.PathEscape(parameterToString(r.storeId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphTermStoreGroup == nil {
		return nil, reportError("microsoftGraphTermStoreGroup is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphTermStoreGroup
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiSitesTermStoresUpdateSetsRequest struct {
	ctx _context.Context
	ApiService *SitesStoreApiService
	siteId string
	storeId string
	setId string
	microsoftGraphTermStoreSet *MicrosoftGraphTermStoreSet
}

// New navigation property values
func (r ApiSitesTermStoresUpdateSetsRequest) MicrosoftGraphTermStoreSet(microsoftGraphTermStoreSet MicrosoftGraphTermStoreSet) ApiSitesTermStoresUpdateSetsRequest {
	r.microsoftGraphTermStoreSet = &microsoftGraphTermStoreSet
	return r
}

func (r ApiSitesTermStoresUpdateSetsRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.SitesTermStoresUpdateSetsExecute(r)
}

/*
SitesTermStoresUpdateSets Update the navigation property sets in sites

Collection of all sets available in the term store.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param siteId key: id of site
 @param storeId key: id of store
 @param setId key: id of set
 @return ApiSitesTermStoresUpdateSetsRequest
*/
func (a *SitesStoreApiService) SitesTermStoresUpdateSets(ctx _context.Context, siteId string, storeId string, setId string) ApiSitesTermStoresUpdateSetsRequest {
	return ApiSitesTermStoresUpdateSetsRequest{
		ApiService: a,
		ctx: ctx,
		siteId: siteId,
		storeId: storeId,
		setId: setId,
	}
}

// Execute executes the request
func (a *SitesStoreApiService) SitesTermStoresUpdateSetsExecute(r ApiSitesTermStoresUpdateSetsRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPatch
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SitesStoreApiService.SitesTermStoresUpdateSets")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sites/{site-id}/termStores/{store-id}/sets/{set-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"site-id"+"}", _neturl.PathEscape(parameterToString(r.siteId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"store-id"+"}", _neturl.PathEscape(parameterToString(r.storeId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"set-id"+"}", _neturl.PathEscape(parameterToString(r.setId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphTermStoreSet == nil {
		return nil, reportError("microsoftGraphTermStoreSet is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphTermStoreSet
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiSitesUpdateTermStoreRequest struct {
	ctx _context.Context
	ApiService *SitesStoreApiService
	siteId string
	microsoftGraphTermStoreStore *MicrosoftGraphTermStoreStore
}

// New navigation property values
func (r ApiSitesUpdateTermStoreRequest) MicrosoftGraphTermStoreStore(microsoftGraphTermStoreStore MicrosoftGraphTermStoreStore) ApiSitesUpdateTermStoreRequest {
	r.microsoftGraphTermStoreStore = &microsoftGraphTermStoreStore
	return r
}

func (r ApiSitesUpdateTermStoreRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.SitesUpdateTermStoreExecute(r)
}

/*
SitesUpdateTermStore Update the navigation property termStore in sites

The default termStore under this site.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param siteId key: id of site
 @return ApiSitesUpdateTermStoreRequest
*/
func (a *SitesStoreApiService) SitesUpdateTermStore(ctx _context.Context, siteId string) ApiSitesUpdateTermStoreRequest {
	return ApiSitesUpdateTermStoreRequest{
		ApiService: a,
		ctx: ctx,
		siteId: siteId,
	}
}

// Execute executes the request
func (a *SitesStoreApiService) SitesUpdateTermStoreExecute(r ApiSitesUpdateTermStoreRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPatch
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SitesStoreApiService.SitesUpdateTermStore")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sites/{site-id}/termStore"
	localVarPath = strings.Replace(localVarPath, "{"+"site-id"+"}", _neturl.PathEscape(parameterToString(r.siteId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphTermStoreStore == nil {
		return nil, reportError("microsoftGraphTermStoreStore is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphTermStoreStore
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiSitesUpdateTermStoresRequest struct {
	ctx _context.Context
	ApiService *SitesStoreApiService
	siteId string
	storeId string
	microsoftGraphTermStoreStore *MicrosoftGraphTermStoreStore
}

// New navigation property values
func (r ApiSitesUpdateTermStoresRequest) MicrosoftGraphTermStoreStore(microsoftGraphTermStoreStore MicrosoftGraphTermStoreStore) ApiSitesUpdateTermStoresRequest {
	r.microsoftGraphTermStoreStore = &microsoftGraphTermStoreStore
	return r
}

func (r ApiSitesUpdateTermStoresRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.SitesUpdateTermStoresExecute(r)
}

/*
SitesUpdateTermStores Update the navigation property termStores in sites

The collection of termStores under this site.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param siteId key: id of site
 @param storeId key: id of store
 @return ApiSitesUpdateTermStoresRequest
*/
func (a *SitesStoreApiService) SitesUpdateTermStores(ctx _context.Context, siteId string, storeId string) ApiSitesUpdateTermStoresRequest {
	return ApiSitesUpdateTermStoresRequest{
		ApiService: a,
		ctx: ctx,
		siteId: siteId,
		storeId: storeId,
	}
}

// Execute executes the request
func (a *SitesStoreApiService) SitesUpdateTermStoresExecute(r ApiSitesUpdateTermStoresRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPatch
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SitesStoreApiService.SitesUpdateTermStores")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sites/{site-id}/termStores/{store-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"site-id"+"}", _neturl.PathEscape(parameterToString(r.siteId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"store-id"+"}", _neturl.PathEscape(parameterToString(r.storeId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphTermStoreStore == nil {
		return nil, reportError("microsoftGraphTermStoreStore is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphTermStoreStore
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}
