/*
Partial Graph API

No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

API version: v1.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package openapi

import (
	"bytes"
	_context "context"
	_ioutil "io/ioutil"
	_nethttp "net/http"
	_neturl "net/url"
	"strings"
)

// Linger please
var (
	_ _context.Context
)

// CommunicationsActionsApiService CommunicationsActionsApi service
type CommunicationsActionsApiService service

type ApiCommunicationsCallsCallAnswerRequest struct {
	ctx _context.Context
	ApiService *CommunicationsActionsApiService
	callId string
	inlineObject21 *InlineObject21
}

func (r ApiCommunicationsCallsCallAnswerRequest) InlineObject21(inlineObject21 InlineObject21) ApiCommunicationsCallsCallAnswerRequest {
	r.inlineObject21 = &inlineObject21
	return r
}

func (r ApiCommunicationsCallsCallAnswerRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.CommunicationsCallsCallAnswerExecute(r)
}

/*
CommunicationsCallsCallAnswer Invoke action answer

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param callId key: id of call
 @return ApiCommunicationsCallsCallAnswerRequest
*/
func (a *CommunicationsActionsApiService) CommunicationsCallsCallAnswer(ctx _context.Context, callId string) ApiCommunicationsCallsCallAnswerRequest {
	return ApiCommunicationsCallsCallAnswerRequest{
		ApiService: a,
		ctx: ctx,
		callId: callId,
	}
}

// Execute executes the request
func (a *CommunicationsActionsApiService) CommunicationsCallsCallAnswerExecute(r ApiCommunicationsCallsCallAnswerRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CommunicationsActionsApiService.CommunicationsCallsCallAnswer")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/communications/calls/{call-id}/microsoft.graph.answer"
	localVarPath = strings.Replace(localVarPath, "{"+"call-id"+"}", _neturl.PathEscape(parameterToString(r.callId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject21 == nil {
		return nil, reportError("inlineObject21 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject21
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiCommunicationsCallsCallCancelMediaProcessingRequest struct {
	ctx _context.Context
	ApiService *CommunicationsActionsApiService
	callId string
	inlineObject22 *InlineObject22
}

func (r ApiCommunicationsCallsCallCancelMediaProcessingRequest) InlineObject22(inlineObject22 InlineObject22) ApiCommunicationsCallsCallCancelMediaProcessingRequest {
	r.inlineObject22 = &inlineObject22
	return r
}

func (r ApiCommunicationsCallsCallCancelMediaProcessingRequest) Execute() (AnyOfmicrosoftGraphCancelMediaProcessingOperation, *_nethttp.Response, error) {
	return r.ApiService.CommunicationsCallsCallCancelMediaProcessingExecute(r)
}

/*
CommunicationsCallsCallCancelMediaProcessing Invoke action cancelMediaProcessing

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param callId key: id of call
 @return ApiCommunicationsCallsCallCancelMediaProcessingRequest
*/
func (a *CommunicationsActionsApiService) CommunicationsCallsCallCancelMediaProcessing(ctx _context.Context, callId string) ApiCommunicationsCallsCallCancelMediaProcessingRequest {
	return ApiCommunicationsCallsCallCancelMediaProcessingRequest{
		ApiService: a,
		ctx: ctx,
		callId: callId,
	}
}

// Execute executes the request
//  @return AnyOfmicrosoftGraphCancelMediaProcessingOperation
func (a *CommunicationsActionsApiService) CommunicationsCallsCallCancelMediaProcessingExecute(r ApiCommunicationsCallsCallCancelMediaProcessingRequest) (AnyOfmicrosoftGraphCancelMediaProcessingOperation, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  AnyOfmicrosoftGraphCancelMediaProcessingOperation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CommunicationsActionsApiService.CommunicationsCallsCallCancelMediaProcessing")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/communications/calls/{call-id}/microsoft.graph.cancelMediaProcessing"
	localVarPath = strings.Replace(localVarPath, "{"+"call-id"+"}", _neturl.PathEscape(parameterToString(r.callId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject22 == nil {
		return localVarReturnValue, nil, reportError("inlineObject22 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject22
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCommunicationsCallsCallChangeScreenSharingRoleRequest struct {
	ctx _context.Context
	ApiService *CommunicationsActionsApiService
	callId string
	inlineObject23 *InlineObject23
}

func (r ApiCommunicationsCallsCallChangeScreenSharingRoleRequest) InlineObject23(inlineObject23 InlineObject23) ApiCommunicationsCallsCallChangeScreenSharingRoleRequest {
	r.inlineObject23 = &inlineObject23
	return r
}

func (r ApiCommunicationsCallsCallChangeScreenSharingRoleRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.CommunicationsCallsCallChangeScreenSharingRoleExecute(r)
}

/*
CommunicationsCallsCallChangeScreenSharingRole Invoke action changeScreenSharingRole

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param callId key: id of call
 @return ApiCommunicationsCallsCallChangeScreenSharingRoleRequest
*/
func (a *CommunicationsActionsApiService) CommunicationsCallsCallChangeScreenSharingRole(ctx _context.Context, callId string) ApiCommunicationsCallsCallChangeScreenSharingRoleRequest {
	return ApiCommunicationsCallsCallChangeScreenSharingRoleRequest{
		ApiService: a,
		ctx: ctx,
		callId: callId,
	}
}

// Execute executes the request
func (a *CommunicationsActionsApiService) CommunicationsCallsCallChangeScreenSharingRoleExecute(r ApiCommunicationsCallsCallChangeScreenSharingRoleRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CommunicationsActionsApiService.CommunicationsCallsCallChangeScreenSharingRole")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/communications/calls/{call-id}/microsoft.graph.changeScreenSharingRole"
	localVarPath = strings.Replace(localVarPath, "{"+"call-id"+"}", _neturl.PathEscape(parameterToString(r.callId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject23 == nil {
		return nil, reportError("inlineObject23 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject23
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiCommunicationsCallsCallKeepAliveRequest struct {
	ctx _context.Context
	ApiService *CommunicationsActionsApiService
	callId string
}


func (r ApiCommunicationsCallsCallKeepAliveRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.CommunicationsCallsCallKeepAliveExecute(r)
}

/*
CommunicationsCallsCallKeepAlive Invoke action keepAlive

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param callId key: id of call
 @return ApiCommunicationsCallsCallKeepAliveRequest
*/
func (a *CommunicationsActionsApiService) CommunicationsCallsCallKeepAlive(ctx _context.Context, callId string) ApiCommunicationsCallsCallKeepAliveRequest {
	return ApiCommunicationsCallsCallKeepAliveRequest{
		ApiService: a,
		ctx: ctx,
		callId: callId,
	}
}

// Execute executes the request
func (a *CommunicationsActionsApiService) CommunicationsCallsCallKeepAliveExecute(r ApiCommunicationsCallsCallKeepAliveRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CommunicationsActionsApiService.CommunicationsCallsCallKeepAlive")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/communications/calls/{call-id}/microsoft.graph.keepAlive"
	localVarPath = strings.Replace(localVarPath, "{"+"call-id"+"}", _neturl.PathEscape(parameterToString(r.callId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiCommunicationsCallsCallMuteRequest struct {
	ctx _context.Context
	ApiService *CommunicationsActionsApiService
	callId string
	inlineObject24 *InlineObject24
}

func (r ApiCommunicationsCallsCallMuteRequest) InlineObject24(inlineObject24 InlineObject24) ApiCommunicationsCallsCallMuteRequest {
	r.inlineObject24 = &inlineObject24
	return r
}

func (r ApiCommunicationsCallsCallMuteRequest) Execute() (AnyOfmicrosoftGraphMuteParticipantOperation, *_nethttp.Response, error) {
	return r.ApiService.CommunicationsCallsCallMuteExecute(r)
}

/*
CommunicationsCallsCallMute Invoke action mute

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param callId key: id of call
 @return ApiCommunicationsCallsCallMuteRequest
*/
func (a *CommunicationsActionsApiService) CommunicationsCallsCallMute(ctx _context.Context, callId string) ApiCommunicationsCallsCallMuteRequest {
	return ApiCommunicationsCallsCallMuteRequest{
		ApiService: a,
		ctx: ctx,
		callId: callId,
	}
}

// Execute executes the request
//  @return AnyOfmicrosoftGraphMuteParticipantOperation
func (a *CommunicationsActionsApiService) CommunicationsCallsCallMuteExecute(r ApiCommunicationsCallsCallMuteRequest) (AnyOfmicrosoftGraphMuteParticipantOperation, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  AnyOfmicrosoftGraphMuteParticipantOperation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CommunicationsActionsApiService.CommunicationsCallsCallMute")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/communications/calls/{call-id}/microsoft.graph.mute"
	localVarPath = strings.Replace(localVarPath, "{"+"call-id"+"}", _neturl.PathEscape(parameterToString(r.callId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject24 == nil {
		return localVarReturnValue, nil, reportError("inlineObject24 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject24
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCommunicationsCallsCallParticipantsInviteRequest struct {
	ctx _context.Context
	ApiService *CommunicationsActionsApiService
	callId string
	inlineObject36 *InlineObject36
}

func (r ApiCommunicationsCallsCallParticipantsInviteRequest) InlineObject36(inlineObject36 InlineObject36) ApiCommunicationsCallsCallParticipantsInviteRequest {
	r.inlineObject36 = &inlineObject36
	return r
}

func (r ApiCommunicationsCallsCallParticipantsInviteRequest) Execute() (AnyOfmicrosoftGraphInviteParticipantsOperation, *_nethttp.Response, error) {
	return r.ApiService.CommunicationsCallsCallParticipantsInviteExecute(r)
}

/*
CommunicationsCallsCallParticipantsInvite Invoke action invite

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param callId key: id of call
 @return ApiCommunicationsCallsCallParticipantsInviteRequest
*/
func (a *CommunicationsActionsApiService) CommunicationsCallsCallParticipantsInvite(ctx _context.Context, callId string) ApiCommunicationsCallsCallParticipantsInviteRequest {
	return ApiCommunicationsCallsCallParticipantsInviteRequest{
		ApiService: a,
		ctx: ctx,
		callId: callId,
	}
}

// Execute executes the request
//  @return AnyOfmicrosoftGraphInviteParticipantsOperation
func (a *CommunicationsActionsApiService) CommunicationsCallsCallParticipantsInviteExecute(r ApiCommunicationsCallsCallParticipantsInviteRequest) (AnyOfmicrosoftGraphInviteParticipantsOperation, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  AnyOfmicrosoftGraphInviteParticipantsOperation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CommunicationsActionsApiService.CommunicationsCallsCallParticipantsInvite")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/communications/calls/{call-id}/participants/microsoft.graph.invite"
	localVarPath = strings.Replace(localVarPath, "{"+"call-id"+"}", _neturl.PathEscape(parameterToString(r.callId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject36 == nil {
		return localVarReturnValue, nil, reportError("inlineObject36 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject36
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCommunicationsCallsCallParticipantsParticipantMuteRequest struct {
	ctx _context.Context
	ApiService *CommunicationsActionsApiService
	callId string
	participantId string
	inlineObject33 *InlineObject33
}

func (r ApiCommunicationsCallsCallParticipantsParticipantMuteRequest) InlineObject33(inlineObject33 InlineObject33) ApiCommunicationsCallsCallParticipantsParticipantMuteRequest {
	r.inlineObject33 = &inlineObject33
	return r
}

func (r ApiCommunicationsCallsCallParticipantsParticipantMuteRequest) Execute() (AnyOfmicrosoftGraphMuteParticipantOperation, *_nethttp.Response, error) {
	return r.ApiService.CommunicationsCallsCallParticipantsParticipantMuteExecute(r)
}

/*
CommunicationsCallsCallParticipantsParticipantMute Invoke action mute

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param callId key: id of call
 @param participantId key: id of participant
 @return ApiCommunicationsCallsCallParticipantsParticipantMuteRequest
*/
func (a *CommunicationsActionsApiService) CommunicationsCallsCallParticipantsParticipantMute(ctx _context.Context, callId string, participantId string) ApiCommunicationsCallsCallParticipantsParticipantMuteRequest {
	return ApiCommunicationsCallsCallParticipantsParticipantMuteRequest{
		ApiService: a,
		ctx: ctx,
		callId: callId,
		participantId: participantId,
	}
}

// Execute executes the request
//  @return AnyOfmicrosoftGraphMuteParticipantOperation
func (a *CommunicationsActionsApiService) CommunicationsCallsCallParticipantsParticipantMuteExecute(r ApiCommunicationsCallsCallParticipantsParticipantMuteRequest) (AnyOfmicrosoftGraphMuteParticipantOperation, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  AnyOfmicrosoftGraphMuteParticipantOperation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CommunicationsActionsApiService.CommunicationsCallsCallParticipantsParticipantMute")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/communications/calls/{call-id}/participants/{participant-id}/microsoft.graph.mute"
	localVarPath = strings.Replace(localVarPath, "{"+"call-id"+"}", _neturl.PathEscape(parameterToString(r.callId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"participant-id"+"}", _neturl.PathEscape(parameterToString(r.participantId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject33 == nil {
		return localVarReturnValue, nil, reportError("inlineObject33 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject33
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCommunicationsCallsCallParticipantsParticipantStartHoldMusicRequest struct {
	ctx _context.Context
	ApiService *CommunicationsActionsApiService
	callId string
	participantId string
	inlineObject34 *InlineObject34
}

func (r ApiCommunicationsCallsCallParticipantsParticipantStartHoldMusicRequest) InlineObject34(inlineObject34 InlineObject34) ApiCommunicationsCallsCallParticipantsParticipantStartHoldMusicRequest {
	r.inlineObject34 = &inlineObject34
	return r
}

func (r ApiCommunicationsCallsCallParticipantsParticipantStartHoldMusicRequest) Execute() (AnyOfmicrosoftGraphStartHoldMusicOperation, *_nethttp.Response, error) {
	return r.ApiService.CommunicationsCallsCallParticipantsParticipantStartHoldMusicExecute(r)
}

/*
CommunicationsCallsCallParticipantsParticipantStartHoldMusic Invoke action startHoldMusic

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param callId key: id of call
 @param participantId key: id of participant
 @return ApiCommunicationsCallsCallParticipantsParticipantStartHoldMusicRequest
*/
func (a *CommunicationsActionsApiService) CommunicationsCallsCallParticipantsParticipantStartHoldMusic(ctx _context.Context, callId string, participantId string) ApiCommunicationsCallsCallParticipantsParticipantStartHoldMusicRequest {
	return ApiCommunicationsCallsCallParticipantsParticipantStartHoldMusicRequest{
		ApiService: a,
		ctx: ctx,
		callId: callId,
		participantId: participantId,
	}
}

// Execute executes the request
//  @return AnyOfmicrosoftGraphStartHoldMusicOperation
func (a *CommunicationsActionsApiService) CommunicationsCallsCallParticipantsParticipantStartHoldMusicExecute(r ApiCommunicationsCallsCallParticipantsParticipantStartHoldMusicRequest) (AnyOfmicrosoftGraphStartHoldMusicOperation, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  AnyOfmicrosoftGraphStartHoldMusicOperation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CommunicationsActionsApiService.CommunicationsCallsCallParticipantsParticipantStartHoldMusic")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/communications/calls/{call-id}/participants/{participant-id}/microsoft.graph.startHoldMusic"
	localVarPath = strings.Replace(localVarPath, "{"+"call-id"+"}", _neturl.PathEscape(parameterToString(r.callId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"participant-id"+"}", _neturl.PathEscape(parameterToString(r.participantId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject34 == nil {
		return localVarReturnValue, nil, reportError("inlineObject34 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject34
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCommunicationsCallsCallParticipantsParticipantStopHoldMusicRequest struct {
	ctx _context.Context
	ApiService *CommunicationsActionsApiService
	callId string
	participantId string
	inlineObject35 *InlineObject35
}

func (r ApiCommunicationsCallsCallParticipantsParticipantStopHoldMusicRequest) InlineObject35(inlineObject35 InlineObject35) ApiCommunicationsCallsCallParticipantsParticipantStopHoldMusicRequest {
	r.inlineObject35 = &inlineObject35
	return r
}

func (r ApiCommunicationsCallsCallParticipantsParticipantStopHoldMusicRequest) Execute() (AnyOfmicrosoftGraphStopHoldMusicOperation, *_nethttp.Response, error) {
	return r.ApiService.CommunicationsCallsCallParticipantsParticipantStopHoldMusicExecute(r)
}

/*
CommunicationsCallsCallParticipantsParticipantStopHoldMusic Invoke action stopHoldMusic

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param callId key: id of call
 @param participantId key: id of participant
 @return ApiCommunicationsCallsCallParticipantsParticipantStopHoldMusicRequest
*/
func (a *CommunicationsActionsApiService) CommunicationsCallsCallParticipantsParticipantStopHoldMusic(ctx _context.Context, callId string, participantId string) ApiCommunicationsCallsCallParticipantsParticipantStopHoldMusicRequest {
	return ApiCommunicationsCallsCallParticipantsParticipantStopHoldMusicRequest{
		ApiService: a,
		ctx: ctx,
		callId: callId,
		participantId: participantId,
	}
}

// Execute executes the request
//  @return AnyOfmicrosoftGraphStopHoldMusicOperation
func (a *CommunicationsActionsApiService) CommunicationsCallsCallParticipantsParticipantStopHoldMusicExecute(r ApiCommunicationsCallsCallParticipantsParticipantStopHoldMusicRequest) (AnyOfmicrosoftGraphStopHoldMusicOperation, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  AnyOfmicrosoftGraphStopHoldMusicOperation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CommunicationsActionsApiService.CommunicationsCallsCallParticipantsParticipantStopHoldMusic")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/communications/calls/{call-id}/participants/{participant-id}/microsoft.graph.stopHoldMusic"
	localVarPath = strings.Replace(localVarPath, "{"+"call-id"+"}", _neturl.PathEscape(parameterToString(r.callId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"participant-id"+"}", _neturl.PathEscape(parameterToString(r.participantId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject35 == nil {
		return localVarReturnValue, nil, reportError("inlineObject35 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject35
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCommunicationsCallsCallPlayPromptRequest struct {
	ctx _context.Context
	ApiService *CommunicationsActionsApiService
	callId string
	inlineObject25 *InlineObject25
}

func (r ApiCommunicationsCallsCallPlayPromptRequest) InlineObject25(inlineObject25 InlineObject25) ApiCommunicationsCallsCallPlayPromptRequest {
	r.inlineObject25 = &inlineObject25
	return r
}

func (r ApiCommunicationsCallsCallPlayPromptRequest) Execute() (AnyOfmicrosoftGraphPlayPromptOperation, *_nethttp.Response, error) {
	return r.ApiService.CommunicationsCallsCallPlayPromptExecute(r)
}

/*
CommunicationsCallsCallPlayPrompt Invoke action playPrompt

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param callId key: id of call
 @return ApiCommunicationsCallsCallPlayPromptRequest
*/
func (a *CommunicationsActionsApiService) CommunicationsCallsCallPlayPrompt(ctx _context.Context, callId string) ApiCommunicationsCallsCallPlayPromptRequest {
	return ApiCommunicationsCallsCallPlayPromptRequest{
		ApiService: a,
		ctx: ctx,
		callId: callId,
	}
}

// Execute executes the request
//  @return AnyOfmicrosoftGraphPlayPromptOperation
func (a *CommunicationsActionsApiService) CommunicationsCallsCallPlayPromptExecute(r ApiCommunicationsCallsCallPlayPromptRequest) (AnyOfmicrosoftGraphPlayPromptOperation, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  AnyOfmicrosoftGraphPlayPromptOperation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CommunicationsActionsApiService.CommunicationsCallsCallPlayPrompt")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/communications/calls/{call-id}/microsoft.graph.playPrompt"
	localVarPath = strings.Replace(localVarPath, "{"+"call-id"+"}", _neturl.PathEscape(parameterToString(r.callId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject25 == nil {
		return localVarReturnValue, nil, reportError("inlineObject25 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject25
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCommunicationsCallsCallRecordResponseRequest struct {
	ctx _context.Context
	ApiService *CommunicationsActionsApiService
	callId string
	inlineObject26 *InlineObject26
}

func (r ApiCommunicationsCallsCallRecordResponseRequest) InlineObject26(inlineObject26 InlineObject26) ApiCommunicationsCallsCallRecordResponseRequest {
	r.inlineObject26 = &inlineObject26
	return r
}

func (r ApiCommunicationsCallsCallRecordResponseRequest) Execute() (AnyOfmicrosoftGraphRecordOperation, *_nethttp.Response, error) {
	return r.ApiService.CommunicationsCallsCallRecordResponseExecute(r)
}

/*
CommunicationsCallsCallRecordResponse Invoke action recordResponse

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param callId key: id of call
 @return ApiCommunicationsCallsCallRecordResponseRequest
*/
func (a *CommunicationsActionsApiService) CommunicationsCallsCallRecordResponse(ctx _context.Context, callId string) ApiCommunicationsCallsCallRecordResponseRequest {
	return ApiCommunicationsCallsCallRecordResponseRequest{
		ApiService: a,
		ctx: ctx,
		callId: callId,
	}
}

// Execute executes the request
//  @return AnyOfmicrosoftGraphRecordOperation
func (a *CommunicationsActionsApiService) CommunicationsCallsCallRecordResponseExecute(r ApiCommunicationsCallsCallRecordResponseRequest) (AnyOfmicrosoftGraphRecordOperation, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  AnyOfmicrosoftGraphRecordOperation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CommunicationsActionsApiService.CommunicationsCallsCallRecordResponse")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/communications/calls/{call-id}/microsoft.graph.recordResponse"
	localVarPath = strings.Replace(localVarPath, "{"+"call-id"+"}", _neturl.PathEscape(parameterToString(r.callId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject26 == nil {
		return localVarReturnValue, nil, reportError("inlineObject26 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject26
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCommunicationsCallsCallRedirectRequest struct {
	ctx _context.Context
	ApiService *CommunicationsActionsApiService
	callId string
	inlineObject27 *InlineObject27
}

func (r ApiCommunicationsCallsCallRedirectRequest) InlineObject27(inlineObject27 InlineObject27) ApiCommunicationsCallsCallRedirectRequest {
	r.inlineObject27 = &inlineObject27
	return r
}

func (r ApiCommunicationsCallsCallRedirectRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.CommunicationsCallsCallRedirectExecute(r)
}

/*
CommunicationsCallsCallRedirect Invoke action redirect

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param callId key: id of call
 @return ApiCommunicationsCallsCallRedirectRequest
*/
func (a *CommunicationsActionsApiService) CommunicationsCallsCallRedirect(ctx _context.Context, callId string) ApiCommunicationsCallsCallRedirectRequest {
	return ApiCommunicationsCallsCallRedirectRequest{
		ApiService: a,
		ctx: ctx,
		callId: callId,
	}
}

// Execute executes the request
func (a *CommunicationsActionsApiService) CommunicationsCallsCallRedirectExecute(r ApiCommunicationsCallsCallRedirectRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CommunicationsActionsApiService.CommunicationsCallsCallRedirect")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/communications/calls/{call-id}/microsoft.graph.redirect"
	localVarPath = strings.Replace(localVarPath, "{"+"call-id"+"}", _neturl.PathEscape(parameterToString(r.callId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject27 == nil {
		return nil, reportError("inlineObject27 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject27
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiCommunicationsCallsCallRejectRequest struct {
	ctx _context.Context
	ApiService *CommunicationsActionsApiService
	callId string
	inlineObject28 *InlineObject28
}

func (r ApiCommunicationsCallsCallRejectRequest) InlineObject28(inlineObject28 InlineObject28) ApiCommunicationsCallsCallRejectRequest {
	r.inlineObject28 = &inlineObject28
	return r
}

func (r ApiCommunicationsCallsCallRejectRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.CommunicationsCallsCallRejectExecute(r)
}

/*
CommunicationsCallsCallReject Invoke action reject

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param callId key: id of call
 @return ApiCommunicationsCallsCallRejectRequest
*/
func (a *CommunicationsActionsApiService) CommunicationsCallsCallReject(ctx _context.Context, callId string) ApiCommunicationsCallsCallRejectRequest {
	return ApiCommunicationsCallsCallRejectRequest{
		ApiService: a,
		ctx: ctx,
		callId: callId,
	}
}

// Execute executes the request
func (a *CommunicationsActionsApiService) CommunicationsCallsCallRejectExecute(r ApiCommunicationsCallsCallRejectRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CommunicationsActionsApiService.CommunicationsCallsCallReject")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/communications/calls/{call-id}/microsoft.graph.reject"
	localVarPath = strings.Replace(localVarPath, "{"+"call-id"+"}", _neturl.PathEscape(parameterToString(r.callId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject28 == nil {
		return nil, reportError("inlineObject28 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject28
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiCommunicationsCallsCallSubscribeToToneRequest struct {
	ctx _context.Context
	ApiService *CommunicationsActionsApiService
	callId string
	inlineObject29 *InlineObject29
}

func (r ApiCommunicationsCallsCallSubscribeToToneRequest) InlineObject29(inlineObject29 InlineObject29) ApiCommunicationsCallsCallSubscribeToToneRequest {
	r.inlineObject29 = &inlineObject29
	return r
}

func (r ApiCommunicationsCallsCallSubscribeToToneRequest) Execute() (AnyOfmicrosoftGraphSubscribeToToneOperation, *_nethttp.Response, error) {
	return r.ApiService.CommunicationsCallsCallSubscribeToToneExecute(r)
}

/*
CommunicationsCallsCallSubscribeToTone Invoke action subscribeToTone

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param callId key: id of call
 @return ApiCommunicationsCallsCallSubscribeToToneRequest
*/
func (a *CommunicationsActionsApiService) CommunicationsCallsCallSubscribeToTone(ctx _context.Context, callId string) ApiCommunicationsCallsCallSubscribeToToneRequest {
	return ApiCommunicationsCallsCallSubscribeToToneRequest{
		ApiService: a,
		ctx: ctx,
		callId: callId,
	}
}

// Execute executes the request
//  @return AnyOfmicrosoftGraphSubscribeToToneOperation
func (a *CommunicationsActionsApiService) CommunicationsCallsCallSubscribeToToneExecute(r ApiCommunicationsCallsCallSubscribeToToneRequest) (AnyOfmicrosoftGraphSubscribeToToneOperation, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  AnyOfmicrosoftGraphSubscribeToToneOperation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CommunicationsActionsApiService.CommunicationsCallsCallSubscribeToTone")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/communications/calls/{call-id}/microsoft.graph.subscribeToTone"
	localVarPath = strings.Replace(localVarPath, "{"+"call-id"+"}", _neturl.PathEscape(parameterToString(r.callId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject29 == nil {
		return localVarReturnValue, nil, reportError("inlineObject29 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject29
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCommunicationsCallsCallTransferRequest struct {
	ctx _context.Context
	ApiService *CommunicationsActionsApiService
	callId string
	inlineObject30 *InlineObject30
}

func (r ApiCommunicationsCallsCallTransferRequest) InlineObject30(inlineObject30 InlineObject30) ApiCommunicationsCallsCallTransferRequest {
	r.inlineObject30 = &inlineObject30
	return r
}

func (r ApiCommunicationsCallsCallTransferRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.CommunicationsCallsCallTransferExecute(r)
}

/*
CommunicationsCallsCallTransfer Invoke action transfer

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param callId key: id of call
 @return ApiCommunicationsCallsCallTransferRequest
*/
func (a *CommunicationsActionsApiService) CommunicationsCallsCallTransfer(ctx _context.Context, callId string) ApiCommunicationsCallsCallTransferRequest {
	return ApiCommunicationsCallsCallTransferRequest{
		ApiService: a,
		ctx: ctx,
		callId: callId,
	}
}

// Execute executes the request
func (a *CommunicationsActionsApiService) CommunicationsCallsCallTransferExecute(r ApiCommunicationsCallsCallTransferRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CommunicationsActionsApiService.CommunicationsCallsCallTransfer")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/communications/calls/{call-id}/microsoft.graph.transfer"
	localVarPath = strings.Replace(localVarPath, "{"+"call-id"+"}", _neturl.PathEscape(parameterToString(r.callId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject30 == nil {
		return nil, reportError("inlineObject30 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject30
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiCommunicationsCallsCallUnmuteRequest struct {
	ctx _context.Context
	ApiService *CommunicationsActionsApiService
	callId string
	inlineObject31 *InlineObject31
}

func (r ApiCommunicationsCallsCallUnmuteRequest) InlineObject31(inlineObject31 InlineObject31) ApiCommunicationsCallsCallUnmuteRequest {
	r.inlineObject31 = &inlineObject31
	return r
}

func (r ApiCommunicationsCallsCallUnmuteRequest) Execute() (AnyOfmicrosoftGraphUnmuteParticipantOperation, *_nethttp.Response, error) {
	return r.ApiService.CommunicationsCallsCallUnmuteExecute(r)
}

/*
CommunicationsCallsCallUnmute Invoke action unmute

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param callId key: id of call
 @return ApiCommunicationsCallsCallUnmuteRequest
*/
func (a *CommunicationsActionsApiService) CommunicationsCallsCallUnmute(ctx _context.Context, callId string) ApiCommunicationsCallsCallUnmuteRequest {
	return ApiCommunicationsCallsCallUnmuteRequest{
		ApiService: a,
		ctx: ctx,
		callId: callId,
	}
}

// Execute executes the request
//  @return AnyOfmicrosoftGraphUnmuteParticipantOperation
func (a *CommunicationsActionsApiService) CommunicationsCallsCallUnmuteExecute(r ApiCommunicationsCallsCallUnmuteRequest) (AnyOfmicrosoftGraphUnmuteParticipantOperation, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  AnyOfmicrosoftGraphUnmuteParticipantOperation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CommunicationsActionsApiService.CommunicationsCallsCallUnmute")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/communications/calls/{call-id}/microsoft.graph.unmute"
	localVarPath = strings.Replace(localVarPath, "{"+"call-id"+"}", _neturl.PathEscape(parameterToString(r.callId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject31 == nil {
		return localVarReturnValue, nil, reportError("inlineObject31 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject31
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCommunicationsCallsCallUpdateRecordingStatusRequest struct {
	ctx _context.Context
	ApiService *CommunicationsActionsApiService
	callId string
	inlineObject32 *InlineObject32
}

func (r ApiCommunicationsCallsCallUpdateRecordingStatusRequest) InlineObject32(inlineObject32 InlineObject32) ApiCommunicationsCallsCallUpdateRecordingStatusRequest {
	r.inlineObject32 = &inlineObject32
	return r
}

func (r ApiCommunicationsCallsCallUpdateRecordingStatusRequest) Execute() (AnyOfmicrosoftGraphUpdateRecordingStatusOperation, *_nethttp.Response, error) {
	return r.ApiService.CommunicationsCallsCallUpdateRecordingStatusExecute(r)
}

/*
CommunicationsCallsCallUpdateRecordingStatus Invoke action updateRecordingStatus

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param callId key: id of call
 @return ApiCommunicationsCallsCallUpdateRecordingStatusRequest
*/
func (a *CommunicationsActionsApiService) CommunicationsCallsCallUpdateRecordingStatus(ctx _context.Context, callId string) ApiCommunicationsCallsCallUpdateRecordingStatusRequest {
	return ApiCommunicationsCallsCallUpdateRecordingStatusRequest{
		ApiService: a,
		ctx: ctx,
		callId: callId,
	}
}

// Execute executes the request
//  @return AnyOfmicrosoftGraphUpdateRecordingStatusOperation
func (a *CommunicationsActionsApiService) CommunicationsCallsCallUpdateRecordingStatusExecute(r ApiCommunicationsCallsCallUpdateRecordingStatusRequest) (AnyOfmicrosoftGraphUpdateRecordingStatusOperation, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  AnyOfmicrosoftGraphUpdateRecordingStatusOperation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CommunicationsActionsApiService.CommunicationsCallsCallUpdateRecordingStatus")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/communications/calls/{call-id}/microsoft.graph.updateRecordingStatus"
	localVarPath = strings.Replace(localVarPath, "{"+"call-id"+"}", _neturl.PathEscape(parameterToString(r.callId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject32 == nil {
		return localVarReturnValue, nil, reportError("inlineObject32 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject32
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCommunicationsCallsLogTeleconferenceDeviceQualityRequest struct {
	ctx _context.Context
	ApiService *CommunicationsActionsApiService
	inlineObject37 *InlineObject37
}

func (r ApiCommunicationsCallsLogTeleconferenceDeviceQualityRequest) InlineObject37(inlineObject37 InlineObject37) ApiCommunicationsCallsLogTeleconferenceDeviceQualityRequest {
	r.inlineObject37 = &inlineObject37
	return r
}

func (r ApiCommunicationsCallsLogTeleconferenceDeviceQualityRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.CommunicationsCallsLogTeleconferenceDeviceQualityExecute(r)
}

/*
CommunicationsCallsLogTeleconferenceDeviceQuality Invoke action logTeleconferenceDeviceQuality

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCommunicationsCallsLogTeleconferenceDeviceQualityRequest
*/
func (a *CommunicationsActionsApiService) CommunicationsCallsLogTeleconferenceDeviceQuality(ctx _context.Context) ApiCommunicationsCallsLogTeleconferenceDeviceQualityRequest {
	return ApiCommunicationsCallsLogTeleconferenceDeviceQualityRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *CommunicationsActionsApiService) CommunicationsCallsLogTeleconferenceDeviceQualityExecute(r ApiCommunicationsCallsLogTeleconferenceDeviceQualityRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CommunicationsActionsApiService.CommunicationsCallsLogTeleconferenceDeviceQuality")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/communications/calls/microsoft.graph.logTeleconferenceDeviceQuality"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject37 == nil {
		return nil, reportError("inlineObject37 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject37
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiCommunicationsGetPresencesByUserIdRequest struct {
	ctx _context.Context
	ApiService *CommunicationsActionsApiService
	inlineObject38 *InlineObject38
}

func (r ApiCommunicationsGetPresencesByUserIdRequest) InlineObject38(inlineObject38 InlineObject38) ApiCommunicationsGetPresencesByUserIdRequest {
	r.inlineObject38 = &inlineObject38
	return r
}

func (r ApiCommunicationsGetPresencesByUserIdRequest) Execute() ([]*AnyOfmicrosoftGraphPresence, *_nethttp.Response, error) {
	return r.ApiService.CommunicationsGetPresencesByUserIdExecute(r)
}

/*
CommunicationsGetPresencesByUserId Invoke action getPresencesByUserId

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCommunicationsGetPresencesByUserIdRequest
*/
func (a *CommunicationsActionsApiService) CommunicationsGetPresencesByUserId(ctx _context.Context) ApiCommunicationsGetPresencesByUserIdRequest {
	return ApiCommunicationsGetPresencesByUserIdRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []*AnyOfmicrosoftGraphPresence
func (a *CommunicationsActionsApiService) CommunicationsGetPresencesByUserIdExecute(r ApiCommunicationsGetPresencesByUserIdRequest) ([]*AnyOfmicrosoftGraphPresence, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  []*AnyOfmicrosoftGraphPresence
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CommunicationsActionsApiService.CommunicationsGetPresencesByUserId")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/communications/microsoft.graph.getPresencesByUserId"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject38 == nil {
		return localVarReturnValue, nil, reportError("inlineObject38 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject38
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCommunicationsOnlineMeetingsCreateOrGetRequest struct {
	ctx _context.Context
	ApiService *CommunicationsActionsApiService
	inlineObject39 *InlineObject39
}

func (r ApiCommunicationsOnlineMeetingsCreateOrGetRequest) InlineObject39(inlineObject39 InlineObject39) ApiCommunicationsOnlineMeetingsCreateOrGetRequest {
	r.inlineObject39 = &inlineObject39
	return r
}

func (r ApiCommunicationsOnlineMeetingsCreateOrGetRequest) Execute() (AnyOfmicrosoftGraphOnlineMeeting, *_nethttp.Response, error) {
	return r.ApiService.CommunicationsOnlineMeetingsCreateOrGetExecute(r)
}

/*
CommunicationsOnlineMeetingsCreateOrGet Invoke action createOrGet

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCommunicationsOnlineMeetingsCreateOrGetRequest
*/
func (a *CommunicationsActionsApiService) CommunicationsOnlineMeetingsCreateOrGet(ctx _context.Context) ApiCommunicationsOnlineMeetingsCreateOrGetRequest {
	return ApiCommunicationsOnlineMeetingsCreateOrGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return AnyOfmicrosoftGraphOnlineMeeting
func (a *CommunicationsActionsApiService) CommunicationsOnlineMeetingsCreateOrGetExecute(r ApiCommunicationsOnlineMeetingsCreateOrGetRequest) (AnyOfmicrosoftGraphOnlineMeeting, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  AnyOfmicrosoftGraphOnlineMeeting
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CommunicationsActionsApiService.CommunicationsOnlineMeetingsCreateOrGet")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/communications/onlineMeetings/microsoft.graph.createOrGet"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject39 == nil {
		return localVarReturnValue, nil, reportError("inlineObject39 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject39
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCommunicationsPresencesPresenceClearPresenceRequest struct {
	ctx _context.Context
	ApiService *CommunicationsActionsApiService
	presenceId string
	inlineObject40 *InlineObject40
}

func (r ApiCommunicationsPresencesPresenceClearPresenceRequest) InlineObject40(inlineObject40 InlineObject40) ApiCommunicationsPresencesPresenceClearPresenceRequest {
	r.inlineObject40 = &inlineObject40
	return r
}

func (r ApiCommunicationsPresencesPresenceClearPresenceRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.CommunicationsPresencesPresenceClearPresenceExecute(r)
}

/*
CommunicationsPresencesPresenceClearPresence Invoke action clearPresence

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param presenceId key: id of presence
 @return ApiCommunicationsPresencesPresenceClearPresenceRequest
*/
func (a *CommunicationsActionsApiService) CommunicationsPresencesPresenceClearPresence(ctx _context.Context, presenceId string) ApiCommunicationsPresencesPresenceClearPresenceRequest {
	return ApiCommunicationsPresencesPresenceClearPresenceRequest{
		ApiService: a,
		ctx: ctx,
		presenceId: presenceId,
	}
}

// Execute executes the request
func (a *CommunicationsActionsApiService) CommunicationsPresencesPresenceClearPresenceExecute(r ApiCommunicationsPresencesPresenceClearPresenceRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CommunicationsActionsApiService.CommunicationsPresencesPresenceClearPresence")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/communications/presences/{presence-id}/microsoft.graph.clearPresence"
	localVarPath = strings.Replace(localVarPath, "{"+"presence-id"+"}", _neturl.PathEscape(parameterToString(r.presenceId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject40 == nil {
		return nil, reportError("inlineObject40 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject40
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiCommunicationsPresencesPresenceSetPresenceRequest struct {
	ctx _context.Context
	ApiService *CommunicationsActionsApiService
	presenceId string
	inlineObject41 *InlineObject41
}

func (r ApiCommunicationsPresencesPresenceSetPresenceRequest) InlineObject41(inlineObject41 InlineObject41) ApiCommunicationsPresencesPresenceSetPresenceRequest {
	r.inlineObject41 = &inlineObject41
	return r
}

func (r ApiCommunicationsPresencesPresenceSetPresenceRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.CommunicationsPresencesPresenceSetPresenceExecute(r)
}

/*
CommunicationsPresencesPresenceSetPresence Invoke action setPresence

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param presenceId key: id of presence
 @return ApiCommunicationsPresencesPresenceSetPresenceRequest
*/
func (a *CommunicationsActionsApiService) CommunicationsPresencesPresenceSetPresence(ctx _context.Context, presenceId string) ApiCommunicationsPresencesPresenceSetPresenceRequest {
	return ApiCommunicationsPresencesPresenceSetPresenceRequest{
		ApiService: a,
		ctx: ctx,
		presenceId: presenceId,
	}
}

// Execute executes the request
func (a *CommunicationsActionsApiService) CommunicationsPresencesPresenceSetPresenceExecute(r ApiCommunicationsPresencesPresenceSetPresenceRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CommunicationsActionsApiService.CommunicationsPresencesPresenceSetPresence")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/communications/presences/{presence-id}/microsoft.graph.setPresence"
	localVarPath = strings.Replace(localVarPath, "{"+"presence-id"+"}", _neturl.PathEscape(parameterToString(r.presenceId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject41 == nil {
		return nil, reportError("inlineObject41 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject41
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}
