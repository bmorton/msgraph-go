/*
Partial Graph API

No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

API version: v1.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package msgraph

import (
	"bytes"
	_context "context"
	_ioutil "io/ioutil"
	_nethttp "net/http"
	_neturl "net/url"
	"strings"
	"os"
)

// Linger please
var (
	_ _context.Context
)

// DrivesDriveItemApiService DrivesDriveItemApi service
type DrivesDriveItemApiService service

type ApiDrivesCreateBundlesRequest struct {
	ctx _context.Context
	ApiService *DrivesDriveItemApiService
	driveId string
	microsoftGraphDriveItem *MicrosoftGraphDriveItem
}

// New navigation property
func (r ApiDrivesCreateBundlesRequest) MicrosoftGraphDriveItem(microsoftGraphDriveItem MicrosoftGraphDriveItem) ApiDrivesCreateBundlesRequest {
	r.microsoftGraphDriveItem = &microsoftGraphDriveItem
	return r
}

func (r ApiDrivesCreateBundlesRequest) Execute() (MicrosoftGraphDriveItem, *_nethttp.Response, error) {
	return r.ApiService.DrivesCreateBundlesExecute(r)
}

/*
DrivesCreateBundles Create new navigation property to bundles for drives

Collection of [bundles][bundle] (albums and multi-select-shared sets of items). Only in personal OneDrive.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param driveId key: id of drive
 @return ApiDrivesCreateBundlesRequest
*/
func (a *DrivesDriveItemApiService) DrivesCreateBundles(ctx _context.Context, driveId string) ApiDrivesCreateBundlesRequest {
	return ApiDrivesCreateBundlesRequest{
		ApiService: a,
		ctx: ctx,
		driveId: driveId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphDriveItem
func (a *DrivesDriveItemApiService) DrivesCreateBundlesExecute(r ApiDrivesCreateBundlesRequest) (MicrosoftGraphDriveItem, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphDriveItem
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DrivesDriveItemApiService.DrivesCreateBundles")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/drives/{drive-id}/bundles"
	localVarPath = strings.Replace(localVarPath, "{"+"drive-id"+"}", _neturl.PathEscape(parameterToString(r.driveId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphDriveItem == nil {
		return localVarReturnValue, nil, reportError("microsoftGraphDriveItem is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphDriveItem
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDrivesCreateFollowingRequest struct {
	ctx _context.Context
	ApiService *DrivesDriveItemApiService
	driveId string
	microsoftGraphDriveItem *MicrosoftGraphDriveItem
}

// New navigation property
func (r ApiDrivesCreateFollowingRequest) MicrosoftGraphDriveItem(microsoftGraphDriveItem MicrosoftGraphDriveItem) ApiDrivesCreateFollowingRequest {
	r.microsoftGraphDriveItem = &microsoftGraphDriveItem
	return r
}

func (r ApiDrivesCreateFollowingRequest) Execute() (MicrosoftGraphDriveItem, *_nethttp.Response, error) {
	return r.ApiService.DrivesCreateFollowingExecute(r)
}

/*
DrivesCreateFollowing Create new navigation property to following for drives

The list of items the user is following. Only in OneDrive for Business.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param driveId key: id of drive
 @return ApiDrivesCreateFollowingRequest
*/
func (a *DrivesDriveItemApiService) DrivesCreateFollowing(ctx _context.Context, driveId string) ApiDrivesCreateFollowingRequest {
	return ApiDrivesCreateFollowingRequest{
		ApiService: a,
		ctx: ctx,
		driveId: driveId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphDriveItem
func (a *DrivesDriveItemApiService) DrivesCreateFollowingExecute(r ApiDrivesCreateFollowingRequest) (MicrosoftGraphDriveItem, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphDriveItem
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DrivesDriveItemApiService.DrivesCreateFollowing")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/drives/{drive-id}/following"
	localVarPath = strings.Replace(localVarPath, "{"+"drive-id"+"}", _neturl.PathEscape(parameterToString(r.driveId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphDriveItem == nil {
		return localVarReturnValue, nil, reportError("microsoftGraphDriveItem is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphDriveItem
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDrivesCreateItemsRequest struct {
	ctx _context.Context
	ApiService *DrivesDriveItemApiService
	driveId string
	microsoftGraphDriveItem *MicrosoftGraphDriveItem
}

// New navigation property
func (r ApiDrivesCreateItemsRequest) MicrosoftGraphDriveItem(microsoftGraphDriveItem MicrosoftGraphDriveItem) ApiDrivesCreateItemsRequest {
	r.microsoftGraphDriveItem = &microsoftGraphDriveItem
	return r
}

func (r ApiDrivesCreateItemsRequest) Execute() (MicrosoftGraphDriveItem, *_nethttp.Response, error) {
	return r.ApiService.DrivesCreateItemsExecute(r)
}

/*
DrivesCreateItems Create new navigation property to items for drives

All items contained in the drive. Read-only. Nullable.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param driveId key: id of drive
 @return ApiDrivesCreateItemsRequest
*/
func (a *DrivesDriveItemApiService) DrivesCreateItems(ctx _context.Context, driveId string) ApiDrivesCreateItemsRequest {
	return ApiDrivesCreateItemsRequest{
		ApiService: a,
		ctx: ctx,
		driveId: driveId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphDriveItem
func (a *DrivesDriveItemApiService) DrivesCreateItemsExecute(r ApiDrivesCreateItemsRequest) (MicrosoftGraphDriveItem, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphDriveItem
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DrivesDriveItemApiService.DrivesCreateItems")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/drives/{drive-id}/items"
	localVarPath = strings.Replace(localVarPath, "{"+"drive-id"+"}", _neturl.PathEscape(parameterToString(r.driveId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphDriveItem == nil {
		return localVarReturnValue, nil, reportError("microsoftGraphDriveItem is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphDriveItem
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDrivesCreateSpecialRequest struct {
	ctx _context.Context
	ApiService *DrivesDriveItemApiService
	driveId string
	microsoftGraphDriveItem *MicrosoftGraphDriveItem
}

// New navigation property
func (r ApiDrivesCreateSpecialRequest) MicrosoftGraphDriveItem(microsoftGraphDriveItem MicrosoftGraphDriveItem) ApiDrivesCreateSpecialRequest {
	r.microsoftGraphDriveItem = &microsoftGraphDriveItem
	return r
}

func (r ApiDrivesCreateSpecialRequest) Execute() (MicrosoftGraphDriveItem, *_nethttp.Response, error) {
	return r.ApiService.DrivesCreateSpecialExecute(r)
}

/*
DrivesCreateSpecial Create new navigation property to special for drives

Collection of common folders available in OneDrive. Read-only. Nullable.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param driveId key: id of drive
 @return ApiDrivesCreateSpecialRequest
*/
func (a *DrivesDriveItemApiService) DrivesCreateSpecial(ctx _context.Context, driveId string) ApiDrivesCreateSpecialRequest {
	return ApiDrivesCreateSpecialRequest{
		ApiService: a,
		ctx: ctx,
		driveId: driveId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphDriveItem
func (a *DrivesDriveItemApiService) DrivesCreateSpecialExecute(r ApiDrivesCreateSpecialRequest) (MicrosoftGraphDriveItem, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphDriveItem
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DrivesDriveItemApiService.DrivesCreateSpecial")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/drives/{drive-id}/special"
	localVarPath = strings.Replace(localVarPath, "{"+"drive-id"+"}", _neturl.PathEscape(parameterToString(r.driveId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphDriveItem == nil {
		return localVarReturnValue, nil, reportError("microsoftGraphDriveItem is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphDriveItem
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDrivesDeleteBundlesRequest struct {
	ctx _context.Context
	ApiService *DrivesDriveItemApiService
	driveId string
	driveItemId string
	ifMatch *string
}

// ETag
func (r ApiDrivesDeleteBundlesRequest) IfMatch(ifMatch string) ApiDrivesDeleteBundlesRequest {
	r.ifMatch = &ifMatch
	return r
}

func (r ApiDrivesDeleteBundlesRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.DrivesDeleteBundlesExecute(r)
}

/*
DrivesDeleteBundles Delete navigation property bundles for drives

Collection of [bundles][bundle] (albums and multi-select-shared sets of items). Only in personal OneDrive.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param driveId key: id of drive
 @param driveItemId key: id of driveItem
 @return ApiDrivesDeleteBundlesRequest
*/
func (a *DrivesDriveItemApiService) DrivesDeleteBundles(ctx _context.Context, driveId string, driveItemId string) ApiDrivesDeleteBundlesRequest {
	return ApiDrivesDeleteBundlesRequest{
		ApiService: a,
		ctx: ctx,
		driveId: driveId,
		driveItemId: driveItemId,
	}
}

// Execute executes the request
func (a *DrivesDriveItemApiService) DrivesDeleteBundlesExecute(r ApiDrivesDeleteBundlesRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DrivesDriveItemApiService.DrivesDeleteBundles")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/drives/{drive-id}/bundles/{driveItem-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"drive-id"+"}", _neturl.PathEscape(parameterToString(r.driveId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"driveItem-id"+"}", _neturl.PathEscape(parameterToString(r.driveItemId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ifMatch != nil {
		localVarHeaderParams["If-Match"] = parameterToString(*r.ifMatch, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDrivesDeleteFollowingRequest struct {
	ctx _context.Context
	ApiService *DrivesDriveItemApiService
	driveId string
	driveItemId string
	ifMatch *string
}

// ETag
func (r ApiDrivesDeleteFollowingRequest) IfMatch(ifMatch string) ApiDrivesDeleteFollowingRequest {
	r.ifMatch = &ifMatch
	return r
}

func (r ApiDrivesDeleteFollowingRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.DrivesDeleteFollowingExecute(r)
}

/*
DrivesDeleteFollowing Delete navigation property following for drives

The list of items the user is following. Only in OneDrive for Business.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param driveId key: id of drive
 @param driveItemId key: id of driveItem
 @return ApiDrivesDeleteFollowingRequest
*/
func (a *DrivesDriveItemApiService) DrivesDeleteFollowing(ctx _context.Context, driveId string, driveItemId string) ApiDrivesDeleteFollowingRequest {
	return ApiDrivesDeleteFollowingRequest{
		ApiService: a,
		ctx: ctx,
		driveId: driveId,
		driveItemId: driveItemId,
	}
}

// Execute executes the request
func (a *DrivesDriveItemApiService) DrivesDeleteFollowingExecute(r ApiDrivesDeleteFollowingRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DrivesDriveItemApiService.DrivesDeleteFollowing")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/drives/{drive-id}/following/{driveItem-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"drive-id"+"}", _neturl.PathEscape(parameterToString(r.driveId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"driveItem-id"+"}", _neturl.PathEscape(parameterToString(r.driveItemId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ifMatch != nil {
		localVarHeaderParams["If-Match"] = parameterToString(*r.ifMatch, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDrivesDeleteItemsRequest struct {
	ctx _context.Context
	ApiService *DrivesDriveItemApiService
	driveId string
	driveItemId string
	ifMatch *string
}

// ETag
func (r ApiDrivesDeleteItemsRequest) IfMatch(ifMatch string) ApiDrivesDeleteItemsRequest {
	r.ifMatch = &ifMatch
	return r
}

func (r ApiDrivesDeleteItemsRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.DrivesDeleteItemsExecute(r)
}

/*
DrivesDeleteItems Delete navigation property items for drives

All items contained in the drive. Read-only. Nullable.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param driveId key: id of drive
 @param driveItemId key: id of driveItem
 @return ApiDrivesDeleteItemsRequest
*/
func (a *DrivesDriveItemApiService) DrivesDeleteItems(ctx _context.Context, driveId string, driveItemId string) ApiDrivesDeleteItemsRequest {
	return ApiDrivesDeleteItemsRequest{
		ApiService: a,
		ctx: ctx,
		driveId: driveId,
		driveItemId: driveItemId,
	}
}

// Execute executes the request
func (a *DrivesDriveItemApiService) DrivesDeleteItemsExecute(r ApiDrivesDeleteItemsRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DrivesDriveItemApiService.DrivesDeleteItems")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/drives/{drive-id}/items/{driveItem-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"drive-id"+"}", _neturl.PathEscape(parameterToString(r.driveId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"driveItem-id"+"}", _neturl.PathEscape(parameterToString(r.driveItemId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ifMatch != nil {
		localVarHeaderParams["If-Match"] = parameterToString(*r.ifMatch, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDrivesDeleteRootRequest struct {
	ctx _context.Context
	ApiService *DrivesDriveItemApiService
	driveId string
	ifMatch *string
}

// ETag
func (r ApiDrivesDeleteRootRequest) IfMatch(ifMatch string) ApiDrivesDeleteRootRequest {
	r.ifMatch = &ifMatch
	return r
}

func (r ApiDrivesDeleteRootRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.DrivesDeleteRootExecute(r)
}

/*
DrivesDeleteRoot Delete navigation property root for drives

The root folder of the drive. Read-only.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param driveId key: id of drive
 @return ApiDrivesDeleteRootRequest
*/
func (a *DrivesDriveItemApiService) DrivesDeleteRoot(ctx _context.Context, driveId string) ApiDrivesDeleteRootRequest {
	return ApiDrivesDeleteRootRequest{
		ApiService: a,
		ctx: ctx,
		driveId: driveId,
	}
}

// Execute executes the request
func (a *DrivesDriveItemApiService) DrivesDeleteRootExecute(r ApiDrivesDeleteRootRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DrivesDriveItemApiService.DrivesDeleteRoot")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/drives/{drive-id}/root"
	localVarPath = strings.Replace(localVarPath, "{"+"drive-id"+"}", _neturl.PathEscape(parameterToString(r.driveId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ifMatch != nil {
		localVarHeaderParams["If-Match"] = parameterToString(*r.ifMatch, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDrivesDeleteSpecialRequest struct {
	ctx _context.Context
	ApiService *DrivesDriveItemApiService
	driveId string
	driveItemId string
	ifMatch *string
}

// ETag
func (r ApiDrivesDeleteSpecialRequest) IfMatch(ifMatch string) ApiDrivesDeleteSpecialRequest {
	r.ifMatch = &ifMatch
	return r
}

func (r ApiDrivesDeleteSpecialRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.DrivesDeleteSpecialExecute(r)
}

/*
DrivesDeleteSpecial Delete navigation property special for drives

Collection of common folders available in OneDrive. Read-only. Nullable.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param driveId key: id of drive
 @param driveItemId key: id of driveItem
 @return ApiDrivesDeleteSpecialRequest
*/
func (a *DrivesDriveItemApiService) DrivesDeleteSpecial(ctx _context.Context, driveId string, driveItemId string) ApiDrivesDeleteSpecialRequest {
	return ApiDrivesDeleteSpecialRequest{
		ApiService: a,
		ctx: ctx,
		driveId: driveId,
		driveItemId: driveItemId,
	}
}

// Execute executes the request
func (a *DrivesDriveItemApiService) DrivesDeleteSpecialExecute(r ApiDrivesDeleteSpecialRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DrivesDriveItemApiService.DrivesDeleteSpecial")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/drives/{drive-id}/special/{driveItem-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"drive-id"+"}", _neturl.PathEscape(parameterToString(r.driveId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"driveItem-id"+"}", _neturl.PathEscape(parameterToString(r.driveItemId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ifMatch != nil {
		localVarHeaderParams["If-Match"] = parameterToString(*r.ifMatch, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDrivesGetBundlesRequest struct {
	ctx _context.Context
	ApiService *DrivesDriveItemApiService
	driveId string
	driveItemId string
	select_ *[]string
	expand *[]string
}

// Select properties to be returned
func (r ApiDrivesGetBundlesRequest) Select_(select_ []string) ApiDrivesGetBundlesRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiDrivesGetBundlesRequest) Expand(expand []string) ApiDrivesGetBundlesRequest {
	r.expand = &expand
	return r
}

func (r ApiDrivesGetBundlesRequest) Execute() (MicrosoftGraphDriveItem, *_nethttp.Response, error) {
	return r.ApiService.DrivesGetBundlesExecute(r)
}

/*
DrivesGetBundles Get bundles from drives

Collection of [bundles][bundle] (albums and multi-select-shared sets of items). Only in personal OneDrive.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param driveId key: id of drive
 @param driveItemId key: id of driveItem
 @return ApiDrivesGetBundlesRequest
*/
func (a *DrivesDriveItemApiService) DrivesGetBundles(ctx _context.Context, driveId string, driveItemId string) ApiDrivesGetBundlesRequest {
	return ApiDrivesGetBundlesRequest{
		ApiService: a,
		ctx: ctx,
		driveId: driveId,
		driveItemId: driveItemId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphDriveItem
func (a *DrivesDriveItemApiService) DrivesGetBundlesExecute(r ApiDrivesGetBundlesRequest) (MicrosoftGraphDriveItem, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphDriveItem
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DrivesDriveItemApiService.DrivesGetBundles")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/drives/{drive-id}/bundles/{driveItem-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"drive-id"+"}", _neturl.PathEscape(parameterToString(r.driveId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"driveItem-id"+"}", _neturl.PathEscape(parameterToString(r.driveItemId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDrivesGetBundlesContentRequest struct {
	ctx _context.Context
	ApiService *DrivesDriveItemApiService
	driveId string
	driveItemId string
}


func (r ApiDrivesGetBundlesContentRequest) Execute() (*os.File, *_nethttp.Response, error) {
	return r.ApiService.DrivesGetBundlesContentExecute(r)
}

/*
DrivesGetBundlesContent Get media content for the navigation property bundles from drives

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param driveId key: id of drive
 @param driveItemId key: id of driveItem
 @return ApiDrivesGetBundlesContentRequest
*/
func (a *DrivesDriveItemApiService) DrivesGetBundlesContent(ctx _context.Context, driveId string, driveItemId string) ApiDrivesGetBundlesContentRequest {
	return ApiDrivesGetBundlesContentRequest{
		ApiService: a,
		ctx: ctx,
		driveId: driveId,
		driveItemId: driveItemId,
	}
}

// Execute executes the request
//  @return *os.File
func (a *DrivesDriveItemApiService) DrivesGetBundlesContentExecute(r ApiDrivesGetBundlesContentRequest) (*os.File, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  *os.File
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DrivesDriveItemApiService.DrivesGetBundlesContent")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/drives/{drive-id}/bundles/{driveItem-id}/content"
	localVarPath = strings.Replace(localVarPath, "{"+"drive-id"+"}", _neturl.PathEscape(parameterToString(r.driveId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"driveItem-id"+"}", _neturl.PathEscape(parameterToString(r.driveItemId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/octet-stream", "application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDrivesGetFollowingRequest struct {
	ctx _context.Context
	ApiService *DrivesDriveItemApiService
	driveId string
	driveItemId string
	select_ *[]string
	expand *[]string
}

// Select properties to be returned
func (r ApiDrivesGetFollowingRequest) Select_(select_ []string) ApiDrivesGetFollowingRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiDrivesGetFollowingRequest) Expand(expand []string) ApiDrivesGetFollowingRequest {
	r.expand = &expand
	return r
}

func (r ApiDrivesGetFollowingRequest) Execute() (MicrosoftGraphDriveItem, *_nethttp.Response, error) {
	return r.ApiService.DrivesGetFollowingExecute(r)
}

/*
DrivesGetFollowing Get following from drives

The list of items the user is following. Only in OneDrive for Business.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param driveId key: id of drive
 @param driveItemId key: id of driveItem
 @return ApiDrivesGetFollowingRequest
*/
func (a *DrivesDriveItemApiService) DrivesGetFollowing(ctx _context.Context, driveId string, driveItemId string) ApiDrivesGetFollowingRequest {
	return ApiDrivesGetFollowingRequest{
		ApiService: a,
		ctx: ctx,
		driveId: driveId,
		driveItemId: driveItemId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphDriveItem
func (a *DrivesDriveItemApiService) DrivesGetFollowingExecute(r ApiDrivesGetFollowingRequest) (MicrosoftGraphDriveItem, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphDriveItem
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DrivesDriveItemApiService.DrivesGetFollowing")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/drives/{drive-id}/following/{driveItem-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"drive-id"+"}", _neturl.PathEscape(parameterToString(r.driveId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"driveItem-id"+"}", _neturl.PathEscape(parameterToString(r.driveItemId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDrivesGetFollowingContentRequest struct {
	ctx _context.Context
	ApiService *DrivesDriveItemApiService
	driveId string
	driveItemId string
}


func (r ApiDrivesGetFollowingContentRequest) Execute() (*os.File, *_nethttp.Response, error) {
	return r.ApiService.DrivesGetFollowingContentExecute(r)
}

/*
DrivesGetFollowingContent Get media content for the navigation property following from drives

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param driveId key: id of drive
 @param driveItemId key: id of driveItem
 @return ApiDrivesGetFollowingContentRequest
*/
func (a *DrivesDriveItemApiService) DrivesGetFollowingContent(ctx _context.Context, driveId string, driveItemId string) ApiDrivesGetFollowingContentRequest {
	return ApiDrivesGetFollowingContentRequest{
		ApiService: a,
		ctx: ctx,
		driveId: driveId,
		driveItemId: driveItemId,
	}
}

// Execute executes the request
//  @return *os.File
func (a *DrivesDriveItemApiService) DrivesGetFollowingContentExecute(r ApiDrivesGetFollowingContentRequest) (*os.File, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  *os.File
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DrivesDriveItemApiService.DrivesGetFollowingContent")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/drives/{drive-id}/following/{driveItem-id}/content"
	localVarPath = strings.Replace(localVarPath, "{"+"drive-id"+"}", _neturl.PathEscape(parameterToString(r.driveId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"driveItem-id"+"}", _neturl.PathEscape(parameterToString(r.driveItemId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/octet-stream", "application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDrivesGetItemsRequest struct {
	ctx _context.Context
	ApiService *DrivesDriveItemApiService
	driveId string
	driveItemId string
	select_ *[]string
	expand *[]string
}

// Select properties to be returned
func (r ApiDrivesGetItemsRequest) Select_(select_ []string) ApiDrivesGetItemsRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiDrivesGetItemsRequest) Expand(expand []string) ApiDrivesGetItemsRequest {
	r.expand = &expand
	return r
}

func (r ApiDrivesGetItemsRequest) Execute() (MicrosoftGraphDriveItem, *_nethttp.Response, error) {
	return r.ApiService.DrivesGetItemsExecute(r)
}

/*
DrivesGetItems Get items from drives

All items contained in the drive. Read-only. Nullable.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param driveId key: id of drive
 @param driveItemId key: id of driveItem
 @return ApiDrivesGetItemsRequest
*/
func (a *DrivesDriveItemApiService) DrivesGetItems(ctx _context.Context, driveId string, driveItemId string) ApiDrivesGetItemsRequest {
	return ApiDrivesGetItemsRequest{
		ApiService: a,
		ctx: ctx,
		driveId: driveId,
		driveItemId: driveItemId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphDriveItem
func (a *DrivesDriveItemApiService) DrivesGetItemsExecute(r ApiDrivesGetItemsRequest) (MicrosoftGraphDriveItem, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphDriveItem
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DrivesDriveItemApiService.DrivesGetItems")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/drives/{drive-id}/items/{driveItem-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"drive-id"+"}", _neturl.PathEscape(parameterToString(r.driveId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"driveItem-id"+"}", _neturl.PathEscape(parameterToString(r.driveItemId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDrivesGetItemsContentRequest struct {
	ctx _context.Context
	ApiService *DrivesDriveItemApiService
	driveId string
	driveItemId string
}


func (r ApiDrivesGetItemsContentRequest) Execute() (*os.File, *_nethttp.Response, error) {
	return r.ApiService.DrivesGetItemsContentExecute(r)
}

/*
DrivesGetItemsContent Get media content for the navigation property items from drives

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param driveId key: id of drive
 @param driveItemId key: id of driveItem
 @return ApiDrivesGetItemsContentRequest
*/
func (a *DrivesDriveItemApiService) DrivesGetItemsContent(ctx _context.Context, driveId string, driveItemId string) ApiDrivesGetItemsContentRequest {
	return ApiDrivesGetItemsContentRequest{
		ApiService: a,
		ctx: ctx,
		driveId: driveId,
		driveItemId: driveItemId,
	}
}

// Execute executes the request
//  @return *os.File
func (a *DrivesDriveItemApiService) DrivesGetItemsContentExecute(r ApiDrivesGetItemsContentRequest) (*os.File, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  *os.File
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DrivesDriveItemApiService.DrivesGetItemsContent")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/drives/{drive-id}/items/{driveItem-id}/content"
	localVarPath = strings.Replace(localVarPath, "{"+"drive-id"+"}", _neturl.PathEscape(parameterToString(r.driveId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"driveItem-id"+"}", _neturl.PathEscape(parameterToString(r.driveItemId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/octet-stream", "application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDrivesGetRootRequest struct {
	ctx _context.Context
	ApiService *DrivesDriveItemApiService
	driveId string
	select_ *[]string
	expand *[]string
}

// Select properties to be returned
func (r ApiDrivesGetRootRequest) Select_(select_ []string) ApiDrivesGetRootRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiDrivesGetRootRequest) Expand(expand []string) ApiDrivesGetRootRequest {
	r.expand = &expand
	return r
}

func (r ApiDrivesGetRootRequest) Execute() (MicrosoftGraphDriveItem, *_nethttp.Response, error) {
	return r.ApiService.DrivesGetRootExecute(r)
}

/*
DrivesGetRoot Get root from drives

The root folder of the drive. Read-only.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param driveId key: id of drive
 @return ApiDrivesGetRootRequest
*/
func (a *DrivesDriveItemApiService) DrivesGetRoot(ctx _context.Context, driveId string) ApiDrivesGetRootRequest {
	return ApiDrivesGetRootRequest{
		ApiService: a,
		ctx: ctx,
		driveId: driveId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphDriveItem
func (a *DrivesDriveItemApiService) DrivesGetRootExecute(r ApiDrivesGetRootRequest) (MicrosoftGraphDriveItem, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphDriveItem
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DrivesDriveItemApiService.DrivesGetRoot")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/drives/{drive-id}/root"
	localVarPath = strings.Replace(localVarPath, "{"+"drive-id"+"}", _neturl.PathEscape(parameterToString(r.driveId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDrivesGetRootContentRequest struct {
	ctx _context.Context
	ApiService *DrivesDriveItemApiService
	driveId string
}


func (r ApiDrivesGetRootContentRequest) Execute() (*os.File, *_nethttp.Response, error) {
	return r.ApiService.DrivesGetRootContentExecute(r)
}

/*
DrivesGetRootContent Get media content for the navigation property root from drives

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param driveId key: id of drive
 @return ApiDrivesGetRootContentRequest
*/
func (a *DrivesDriveItemApiService) DrivesGetRootContent(ctx _context.Context, driveId string) ApiDrivesGetRootContentRequest {
	return ApiDrivesGetRootContentRequest{
		ApiService: a,
		ctx: ctx,
		driveId: driveId,
	}
}

// Execute executes the request
//  @return *os.File
func (a *DrivesDriveItemApiService) DrivesGetRootContentExecute(r ApiDrivesGetRootContentRequest) (*os.File, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  *os.File
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DrivesDriveItemApiService.DrivesGetRootContent")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/drives/{drive-id}/root/content"
	localVarPath = strings.Replace(localVarPath, "{"+"drive-id"+"}", _neturl.PathEscape(parameterToString(r.driveId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/octet-stream", "application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDrivesGetSpecialRequest struct {
	ctx _context.Context
	ApiService *DrivesDriveItemApiService
	driveId string
	driveItemId string
	select_ *[]string
	expand *[]string
}

// Select properties to be returned
func (r ApiDrivesGetSpecialRequest) Select_(select_ []string) ApiDrivesGetSpecialRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiDrivesGetSpecialRequest) Expand(expand []string) ApiDrivesGetSpecialRequest {
	r.expand = &expand
	return r
}

func (r ApiDrivesGetSpecialRequest) Execute() (MicrosoftGraphDriveItem, *_nethttp.Response, error) {
	return r.ApiService.DrivesGetSpecialExecute(r)
}

/*
DrivesGetSpecial Get special from drives

Collection of common folders available in OneDrive. Read-only. Nullable.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param driveId key: id of drive
 @param driveItemId key: id of driveItem
 @return ApiDrivesGetSpecialRequest
*/
func (a *DrivesDriveItemApiService) DrivesGetSpecial(ctx _context.Context, driveId string, driveItemId string) ApiDrivesGetSpecialRequest {
	return ApiDrivesGetSpecialRequest{
		ApiService: a,
		ctx: ctx,
		driveId: driveId,
		driveItemId: driveItemId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphDriveItem
func (a *DrivesDriveItemApiService) DrivesGetSpecialExecute(r ApiDrivesGetSpecialRequest) (MicrosoftGraphDriveItem, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphDriveItem
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DrivesDriveItemApiService.DrivesGetSpecial")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/drives/{drive-id}/special/{driveItem-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"drive-id"+"}", _neturl.PathEscape(parameterToString(r.driveId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"driveItem-id"+"}", _neturl.PathEscape(parameterToString(r.driveItemId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDrivesGetSpecialContentRequest struct {
	ctx _context.Context
	ApiService *DrivesDriveItemApiService
	driveId string
	driveItemId string
}


func (r ApiDrivesGetSpecialContentRequest) Execute() (*os.File, *_nethttp.Response, error) {
	return r.ApiService.DrivesGetSpecialContentExecute(r)
}

/*
DrivesGetSpecialContent Get media content for the navigation property special from drives

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param driveId key: id of drive
 @param driveItemId key: id of driveItem
 @return ApiDrivesGetSpecialContentRequest
*/
func (a *DrivesDriveItemApiService) DrivesGetSpecialContent(ctx _context.Context, driveId string, driveItemId string) ApiDrivesGetSpecialContentRequest {
	return ApiDrivesGetSpecialContentRequest{
		ApiService: a,
		ctx: ctx,
		driveId: driveId,
		driveItemId: driveItemId,
	}
}

// Execute executes the request
//  @return *os.File
func (a *DrivesDriveItemApiService) DrivesGetSpecialContentExecute(r ApiDrivesGetSpecialContentRequest) (*os.File, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  *os.File
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DrivesDriveItemApiService.DrivesGetSpecialContent")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/drives/{drive-id}/special/{driveItem-id}/content"
	localVarPath = strings.Replace(localVarPath, "{"+"drive-id"+"}", _neturl.PathEscape(parameterToString(r.driveId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"driveItem-id"+"}", _neturl.PathEscape(parameterToString(r.driveItemId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/octet-stream", "application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDrivesListBundlesRequest struct {
	ctx _context.Context
	ApiService *DrivesDriveItemApiService
	driveId string
	top *int32
	skip *int32
	search *string
	filter *string
	count *bool
	orderby *[]string
	select_ *[]string
	expand *[]string
}

// Show only the first n items
func (r ApiDrivesListBundlesRequest) Top(top int32) ApiDrivesListBundlesRequest {
	r.top = &top
	return r
}
// Skip the first n items
func (r ApiDrivesListBundlesRequest) Skip(skip int32) ApiDrivesListBundlesRequest {
	r.skip = &skip
	return r
}
// Search items by search phrases
func (r ApiDrivesListBundlesRequest) Search(search string) ApiDrivesListBundlesRequest {
	r.search = &search
	return r
}
// Filter items by property values
func (r ApiDrivesListBundlesRequest) Filter(filter string) ApiDrivesListBundlesRequest {
	r.filter = &filter
	return r
}
// Include count of items
func (r ApiDrivesListBundlesRequest) Count(count bool) ApiDrivesListBundlesRequest {
	r.count = &count
	return r
}
// Order items by property values
func (r ApiDrivesListBundlesRequest) Orderby(orderby []string) ApiDrivesListBundlesRequest {
	r.orderby = &orderby
	return r
}
// Select properties to be returned
func (r ApiDrivesListBundlesRequest) Select_(select_ []string) ApiDrivesListBundlesRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiDrivesListBundlesRequest) Expand(expand []string) ApiDrivesListBundlesRequest {
	r.expand = &expand
	return r
}

func (r ApiDrivesListBundlesRequest) Execute() (CollectionOfDriveItem, *_nethttp.Response, error) {
	return r.ApiService.DrivesListBundlesExecute(r)
}

/*
DrivesListBundles Get bundles from drives

Collection of [bundles][bundle] (albums and multi-select-shared sets of items). Only in personal OneDrive.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param driveId key: id of drive
 @return ApiDrivesListBundlesRequest
*/
func (a *DrivesDriveItemApiService) DrivesListBundles(ctx _context.Context, driveId string) ApiDrivesListBundlesRequest {
	return ApiDrivesListBundlesRequest{
		ApiService: a,
		ctx: ctx,
		driveId: driveId,
	}
}

// Execute executes the request
//  @return CollectionOfDriveItem
func (a *DrivesDriveItemApiService) DrivesListBundlesExecute(r ApiDrivesListBundlesRequest) (CollectionOfDriveItem, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  CollectionOfDriveItem
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DrivesDriveItemApiService.DrivesListBundles")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/drives/{drive-id}/bundles"
	localVarPath = strings.Replace(localVarPath, "{"+"drive-id"+"}", _neturl.PathEscape(parameterToString(r.driveId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.top != nil {
		localVarQueryParams.Add("$top", parameterToString(*r.top, ""))
	}
	if r.skip != nil {
		localVarQueryParams.Add("$skip", parameterToString(*r.skip, ""))
	}
	if r.search != nil {
		localVarQueryParams.Add("$search", parameterToString(*r.search, ""))
	}
	if r.filter != nil {
		localVarQueryParams.Add("$filter", parameterToString(*r.filter, ""))
	}
	if r.count != nil {
		localVarQueryParams.Add("$count", parameterToString(*r.count, ""))
	}
	if r.orderby != nil {
		localVarQueryParams.Add("$orderby", parameterToString(*r.orderby, "csv"))
	}
	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDrivesListFollowingRequest struct {
	ctx _context.Context
	ApiService *DrivesDriveItemApiService
	driveId string
	top *int32
	skip *int32
	search *string
	filter *string
	count *bool
	orderby *[]string
	select_ *[]string
	expand *[]string
}

// Show only the first n items
func (r ApiDrivesListFollowingRequest) Top(top int32) ApiDrivesListFollowingRequest {
	r.top = &top
	return r
}
// Skip the first n items
func (r ApiDrivesListFollowingRequest) Skip(skip int32) ApiDrivesListFollowingRequest {
	r.skip = &skip
	return r
}
// Search items by search phrases
func (r ApiDrivesListFollowingRequest) Search(search string) ApiDrivesListFollowingRequest {
	r.search = &search
	return r
}
// Filter items by property values
func (r ApiDrivesListFollowingRequest) Filter(filter string) ApiDrivesListFollowingRequest {
	r.filter = &filter
	return r
}
// Include count of items
func (r ApiDrivesListFollowingRequest) Count(count bool) ApiDrivesListFollowingRequest {
	r.count = &count
	return r
}
// Order items by property values
func (r ApiDrivesListFollowingRequest) Orderby(orderby []string) ApiDrivesListFollowingRequest {
	r.orderby = &orderby
	return r
}
// Select properties to be returned
func (r ApiDrivesListFollowingRequest) Select_(select_ []string) ApiDrivesListFollowingRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiDrivesListFollowingRequest) Expand(expand []string) ApiDrivesListFollowingRequest {
	r.expand = &expand
	return r
}

func (r ApiDrivesListFollowingRequest) Execute() (CollectionOfDriveItem, *_nethttp.Response, error) {
	return r.ApiService.DrivesListFollowingExecute(r)
}

/*
DrivesListFollowing Get following from drives

The list of items the user is following. Only in OneDrive for Business.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param driveId key: id of drive
 @return ApiDrivesListFollowingRequest
*/
func (a *DrivesDriveItemApiService) DrivesListFollowing(ctx _context.Context, driveId string) ApiDrivesListFollowingRequest {
	return ApiDrivesListFollowingRequest{
		ApiService: a,
		ctx: ctx,
		driveId: driveId,
	}
}

// Execute executes the request
//  @return CollectionOfDriveItem
func (a *DrivesDriveItemApiService) DrivesListFollowingExecute(r ApiDrivesListFollowingRequest) (CollectionOfDriveItem, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  CollectionOfDriveItem
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DrivesDriveItemApiService.DrivesListFollowing")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/drives/{drive-id}/following"
	localVarPath = strings.Replace(localVarPath, "{"+"drive-id"+"}", _neturl.PathEscape(parameterToString(r.driveId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.top != nil {
		localVarQueryParams.Add("$top", parameterToString(*r.top, ""))
	}
	if r.skip != nil {
		localVarQueryParams.Add("$skip", parameterToString(*r.skip, ""))
	}
	if r.search != nil {
		localVarQueryParams.Add("$search", parameterToString(*r.search, ""))
	}
	if r.filter != nil {
		localVarQueryParams.Add("$filter", parameterToString(*r.filter, ""))
	}
	if r.count != nil {
		localVarQueryParams.Add("$count", parameterToString(*r.count, ""))
	}
	if r.orderby != nil {
		localVarQueryParams.Add("$orderby", parameterToString(*r.orderby, "csv"))
	}
	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDrivesListItemsRequest struct {
	ctx _context.Context
	ApiService *DrivesDriveItemApiService
	driveId string
	top *int32
	skip *int32
	search *string
	filter *string
	count *bool
	orderby *[]string
	select_ *[]string
	expand *[]string
}

// Show only the first n items
func (r ApiDrivesListItemsRequest) Top(top int32) ApiDrivesListItemsRequest {
	r.top = &top
	return r
}
// Skip the first n items
func (r ApiDrivesListItemsRequest) Skip(skip int32) ApiDrivesListItemsRequest {
	r.skip = &skip
	return r
}
// Search items by search phrases
func (r ApiDrivesListItemsRequest) Search(search string) ApiDrivesListItemsRequest {
	r.search = &search
	return r
}
// Filter items by property values
func (r ApiDrivesListItemsRequest) Filter(filter string) ApiDrivesListItemsRequest {
	r.filter = &filter
	return r
}
// Include count of items
func (r ApiDrivesListItemsRequest) Count(count bool) ApiDrivesListItemsRequest {
	r.count = &count
	return r
}
// Order items by property values
func (r ApiDrivesListItemsRequest) Orderby(orderby []string) ApiDrivesListItemsRequest {
	r.orderby = &orderby
	return r
}
// Select properties to be returned
func (r ApiDrivesListItemsRequest) Select_(select_ []string) ApiDrivesListItemsRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiDrivesListItemsRequest) Expand(expand []string) ApiDrivesListItemsRequest {
	r.expand = &expand
	return r
}

func (r ApiDrivesListItemsRequest) Execute() (CollectionOfDriveItem, *_nethttp.Response, error) {
	return r.ApiService.DrivesListItemsExecute(r)
}

/*
DrivesListItems Get items from drives

All items contained in the drive. Read-only. Nullable.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param driveId key: id of drive
 @return ApiDrivesListItemsRequest
*/
func (a *DrivesDriveItemApiService) DrivesListItems(ctx _context.Context, driveId string) ApiDrivesListItemsRequest {
	return ApiDrivesListItemsRequest{
		ApiService: a,
		ctx: ctx,
		driveId: driveId,
	}
}

// Execute executes the request
//  @return CollectionOfDriveItem
func (a *DrivesDriveItemApiService) DrivesListItemsExecute(r ApiDrivesListItemsRequest) (CollectionOfDriveItem, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  CollectionOfDriveItem
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DrivesDriveItemApiService.DrivesListItems")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/drives/{drive-id}/items"
	localVarPath = strings.Replace(localVarPath, "{"+"drive-id"+"}", _neturl.PathEscape(parameterToString(r.driveId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.top != nil {
		localVarQueryParams.Add("$top", parameterToString(*r.top, ""))
	}
	if r.skip != nil {
		localVarQueryParams.Add("$skip", parameterToString(*r.skip, ""))
	}
	if r.search != nil {
		localVarQueryParams.Add("$search", parameterToString(*r.search, ""))
	}
	if r.filter != nil {
		localVarQueryParams.Add("$filter", parameterToString(*r.filter, ""))
	}
	if r.count != nil {
		localVarQueryParams.Add("$count", parameterToString(*r.count, ""))
	}
	if r.orderby != nil {
		localVarQueryParams.Add("$orderby", parameterToString(*r.orderby, "csv"))
	}
	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDrivesListSpecialRequest struct {
	ctx _context.Context
	ApiService *DrivesDriveItemApiService
	driveId string
	top *int32
	skip *int32
	search *string
	filter *string
	count *bool
	orderby *[]string
	select_ *[]string
	expand *[]string
}

// Show only the first n items
func (r ApiDrivesListSpecialRequest) Top(top int32) ApiDrivesListSpecialRequest {
	r.top = &top
	return r
}
// Skip the first n items
func (r ApiDrivesListSpecialRequest) Skip(skip int32) ApiDrivesListSpecialRequest {
	r.skip = &skip
	return r
}
// Search items by search phrases
func (r ApiDrivesListSpecialRequest) Search(search string) ApiDrivesListSpecialRequest {
	r.search = &search
	return r
}
// Filter items by property values
func (r ApiDrivesListSpecialRequest) Filter(filter string) ApiDrivesListSpecialRequest {
	r.filter = &filter
	return r
}
// Include count of items
func (r ApiDrivesListSpecialRequest) Count(count bool) ApiDrivesListSpecialRequest {
	r.count = &count
	return r
}
// Order items by property values
func (r ApiDrivesListSpecialRequest) Orderby(orderby []string) ApiDrivesListSpecialRequest {
	r.orderby = &orderby
	return r
}
// Select properties to be returned
func (r ApiDrivesListSpecialRequest) Select_(select_ []string) ApiDrivesListSpecialRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiDrivesListSpecialRequest) Expand(expand []string) ApiDrivesListSpecialRequest {
	r.expand = &expand
	return r
}

func (r ApiDrivesListSpecialRequest) Execute() (CollectionOfDriveItem, *_nethttp.Response, error) {
	return r.ApiService.DrivesListSpecialExecute(r)
}

/*
DrivesListSpecial Get special from drives

Collection of common folders available in OneDrive. Read-only. Nullable.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param driveId key: id of drive
 @return ApiDrivesListSpecialRequest
*/
func (a *DrivesDriveItemApiService) DrivesListSpecial(ctx _context.Context, driveId string) ApiDrivesListSpecialRequest {
	return ApiDrivesListSpecialRequest{
		ApiService: a,
		ctx: ctx,
		driveId: driveId,
	}
}

// Execute executes the request
//  @return CollectionOfDriveItem
func (a *DrivesDriveItemApiService) DrivesListSpecialExecute(r ApiDrivesListSpecialRequest) (CollectionOfDriveItem, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  CollectionOfDriveItem
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DrivesDriveItemApiService.DrivesListSpecial")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/drives/{drive-id}/special"
	localVarPath = strings.Replace(localVarPath, "{"+"drive-id"+"}", _neturl.PathEscape(parameterToString(r.driveId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.top != nil {
		localVarQueryParams.Add("$top", parameterToString(*r.top, ""))
	}
	if r.skip != nil {
		localVarQueryParams.Add("$skip", parameterToString(*r.skip, ""))
	}
	if r.search != nil {
		localVarQueryParams.Add("$search", parameterToString(*r.search, ""))
	}
	if r.filter != nil {
		localVarQueryParams.Add("$filter", parameterToString(*r.filter, ""))
	}
	if r.count != nil {
		localVarQueryParams.Add("$count", parameterToString(*r.count, ""))
	}
	if r.orderby != nil {
		localVarQueryParams.Add("$orderby", parameterToString(*r.orderby, "csv"))
	}
	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDrivesUpdateBundlesRequest struct {
	ctx _context.Context
	ApiService *DrivesDriveItemApiService
	driveId string
	driveItemId string
	microsoftGraphDriveItem *MicrosoftGraphDriveItem
}

// New navigation property values
func (r ApiDrivesUpdateBundlesRequest) MicrosoftGraphDriveItem(microsoftGraphDriveItem MicrosoftGraphDriveItem) ApiDrivesUpdateBundlesRequest {
	r.microsoftGraphDriveItem = &microsoftGraphDriveItem
	return r
}

func (r ApiDrivesUpdateBundlesRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.DrivesUpdateBundlesExecute(r)
}

/*
DrivesUpdateBundles Update the navigation property bundles in drives

Collection of [bundles][bundle] (albums and multi-select-shared sets of items). Only in personal OneDrive.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param driveId key: id of drive
 @param driveItemId key: id of driveItem
 @return ApiDrivesUpdateBundlesRequest
*/
func (a *DrivesDriveItemApiService) DrivesUpdateBundles(ctx _context.Context, driveId string, driveItemId string) ApiDrivesUpdateBundlesRequest {
	return ApiDrivesUpdateBundlesRequest{
		ApiService: a,
		ctx: ctx,
		driveId: driveId,
		driveItemId: driveItemId,
	}
}

// Execute executes the request
func (a *DrivesDriveItemApiService) DrivesUpdateBundlesExecute(r ApiDrivesUpdateBundlesRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPatch
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DrivesDriveItemApiService.DrivesUpdateBundles")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/drives/{drive-id}/bundles/{driveItem-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"drive-id"+"}", _neturl.PathEscape(parameterToString(r.driveId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"driveItem-id"+"}", _neturl.PathEscape(parameterToString(r.driveItemId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphDriveItem == nil {
		return nil, reportError("microsoftGraphDriveItem is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphDriveItem
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDrivesUpdateBundlesContentRequest struct {
	ctx _context.Context
	ApiService *DrivesDriveItemApiService
	driveId string
	driveItemId string
	body **os.File
}

// New media content.
func (r ApiDrivesUpdateBundlesContentRequest) Body(body *os.File) ApiDrivesUpdateBundlesContentRequest {
	r.body = &body
	return r
}

func (r ApiDrivesUpdateBundlesContentRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.DrivesUpdateBundlesContentExecute(r)
}

/*
DrivesUpdateBundlesContent Update media content for the navigation property bundles in drives

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param driveId key: id of drive
 @param driveItemId key: id of driveItem
 @return ApiDrivesUpdateBundlesContentRequest
*/
func (a *DrivesDriveItemApiService) DrivesUpdateBundlesContent(ctx _context.Context, driveId string, driveItemId string) ApiDrivesUpdateBundlesContentRequest {
	return ApiDrivesUpdateBundlesContentRequest{
		ApiService: a,
		ctx: ctx,
		driveId: driveId,
		driveItemId: driveItemId,
	}
}

// Execute executes the request
func (a *DrivesDriveItemApiService) DrivesUpdateBundlesContentExecute(r ApiDrivesUpdateBundlesContentRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPut
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DrivesDriveItemApiService.DrivesUpdateBundlesContent")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/drives/{drive-id}/bundles/{driveItem-id}/content"
	localVarPath = strings.Replace(localVarPath, "{"+"drive-id"+"}", _neturl.PathEscape(parameterToString(r.driveId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"driveItem-id"+"}", _neturl.PathEscape(parameterToString(r.driveItemId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.body == nil {
		return nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/octet-stream"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDrivesUpdateFollowingRequest struct {
	ctx _context.Context
	ApiService *DrivesDriveItemApiService
	driveId string
	driveItemId string
	microsoftGraphDriveItem *MicrosoftGraphDriveItem
}

// New navigation property values
func (r ApiDrivesUpdateFollowingRequest) MicrosoftGraphDriveItem(microsoftGraphDriveItem MicrosoftGraphDriveItem) ApiDrivesUpdateFollowingRequest {
	r.microsoftGraphDriveItem = &microsoftGraphDriveItem
	return r
}

func (r ApiDrivesUpdateFollowingRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.DrivesUpdateFollowingExecute(r)
}

/*
DrivesUpdateFollowing Update the navigation property following in drives

The list of items the user is following. Only in OneDrive for Business.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param driveId key: id of drive
 @param driveItemId key: id of driveItem
 @return ApiDrivesUpdateFollowingRequest
*/
func (a *DrivesDriveItemApiService) DrivesUpdateFollowing(ctx _context.Context, driveId string, driveItemId string) ApiDrivesUpdateFollowingRequest {
	return ApiDrivesUpdateFollowingRequest{
		ApiService: a,
		ctx: ctx,
		driveId: driveId,
		driveItemId: driveItemId,
	}
}

// Execute executes the request
func (a *DrivesDriveItemApiService) DrivesUpdateFollowingExecute(r ApiDrivesUpdateFollowingRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPatch
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DrivesDriveItemApiService.DrivesUpdateFollowing")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/drives/{drive-id}/following/{driveItem-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"drive-id"+"}", _neturl.PathEscape(parameterToString(r.driveId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"driveItem-id"+"}", _neturl.PathEscape(parameterToString(r.driveItemId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphDriveItem == nil {
		return nil, reportError("microsoftGraphDriveItem is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphDriveItem
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDrivesUpdateFollowingContentRequest struct {
	ctx _context.Context
	ApiService *DrivesDriveItemApiService
	driveId string
	driveItemId string
	body **os.File
}

// New media content.
func (r ApiDrivesUpdateFollowingContentRequest) Body(body *os.File) ApiDrivesUpdateFollowingContentRequest {
	r.body = &body
	return r
}

func (r ApiDrivesUpdateFollowingContentRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.DrivesUpdateFollowingContentExecute(r)
}

/*
DrivesUpdateFollowingContent Update media content for the navigation property following in drives

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param driveId key: id of drive
 @param driveItemId key: id of driveItem
 @return ApiDrivesUpdateFollowingContentRequest
*/
func (a *DrivesDriveItemApiService) DrivesUpdateFollowingContent(ctx _context.Context, driveId string, driveItemId string) ApiDrivesUpdateFollowingContentRequest {
	return ApiDrivesUpdateFollowingContentRequest{
		ApiService: a,
		ctx: ctx,
		driveId: driveId,
		driveItemId: driveItemId,
	}
}

// Execute executes the request
func (a *DrivesDriveItemApiService) DrivesUpdateFollowingContentExecute(r ApiDrivesUpdateFollowingContentRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPut
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DrivesDriveItemApiService.DrivesUpdateFollowingContent")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/drives/{drive-id}/following/{driveItem-id}/content"
	localVarPath = strings.Replace(localVarPath, "{"+"drive-id"+"}", _neturl.PathEscape(parameterToString(r.driveId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"driveItem-id"+"}", _neturl.PathEscape(parameterToString(r.driveItemId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.body == nil {
		return nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/octet-stream"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDrivesUpdateItemsRequest struct {
	ctx _context.Context
	ApiService *DrivesDriveItemApiService
	driveId string
	driveItemId string
	microsoftGraphDriveItem *MicrosoftGraphDriveItem
}

// New navigation property values
func (r ApiDrivesUpdateItemsRequest) MicrosoftGraphDriveItem(microsoftGraphDriveItem MicrosoftGraphDriveItem) ApiDrivesUpdateItemsRequest {
	r.microsoftGraphDriveItem = &microsoftGraphDriveItem
	return r
}

func (r ApiDrivesUpdateItemsRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.DrivesUpdateItemsExecute(r)
}

/*
DrivesUpdateItems Update the navigation property items in drives

All items contained in the drive. Read-only. Nullable.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param driveId key: id of drive
 @param driveItemId key: id of driveItem
 @return ApiDrivesUpdateItemsRequest
*/
func (a *DrivesDriveItemApiService) DrivesUpdateItems(ctx _context.Context, driveId string, driveItemId string) ApiDrivesUpdateItemsRequest {
	return ApiDrivesUpdateItemsRequest{
		ApiService: a,
		ctx: ctx,
		driveId: driveId,
		driveItemId: driveItemId,
	}
}

// Execute executes the request
func (a *DrivesDriveItemApiService) DrivesUpdateItemsExecute(r ApiDrivesUpdateItemsRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPatch
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DrivesDriveItemApiService.DrivesUpdateItems")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/drives/{drive-id}/items/{driveItem-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"drive-id"+"}", _neturl.PathEscape(parameterToString(r.driveId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"driveItem-id"+"}", _neturl.PathEscape(parameterToString(r.driveItemId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphDriveItem == nil {
		return nil, reportError("microsoftGraphDriveItem is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphDriveItem
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDrivesUpdateItemsContentRequest struct {
	ctx _context.Context
	ApiService *DrivesDriveItemApiService
	driveId string
	driveItemId string
	body **os.File
}

// New media content.
func (r ApiDrivesUpdateItemsContentRequest) Body(body *os.File) ApiDrivesUpdateItemsContentRequest {
	r.body = &body
	return r
}

func (r ApiDrivesUpdateItemsContentRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.DrivesUpdateItemsContentExecute(r)
}

/*
DrivesUpdateItemsContent Update media content for the navigation property items in drives

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param driveId key: id of drive
 @param driveItemId key: id of driveItem
 @return ApiDrivesUpdateItemsContentRequest
*/
func (a *DrivesDriveItemApiService) DrivesUpdateItemsContent(ctx _context.Context, driveId string, driveItemId string) ApiDrivesUpdateItemsContentRequest {
	return ApiDrivesUpdateItemsContentRequest{
		ApiService: a,
		ctx: ctx,
		driveId: driveId,
		driveItemId: driveItemId,
	}
}

// Execute executes the request
func (a *DrivesDriveItemApiService) DrivesUpdateItemsContentExecute(r ApiDrivesUpdateItemsContentRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPut
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DrivesDriveItemApiService.DrivesUpdateItemsContent")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/drives/{drive-id}/items/{driveItem-id}/content"
	localVarPath = strings.Replace(localVarPath, "{"+"drive-id"+"}", _neturl.PathEscape(parameterToString(r.driveId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"driveItem-id"+"}", _neturl.PathEscape(parameterToString(r.driveItemId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.body == nil {
		return nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/octet-stream"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDrivesUpdateRootRequest struct {
	ctx _context.Context
	ApiService *DrivesDriveItemApiService
	driveId string
	microsoftGraphDriveItem *MicrosoftGraphDriveItem
}

// New navigation property values
func (r ApiDrivesUpdateRootRequest) MicrosoftGraphDriveItem(microsoftGraphDriveItem MicrosoftGraphDriveItem) ApiDrivesUpdateRootRequest {
	r.microsoftGraphDriveItem = &microsoftGraphDriveItem
	return r
}

func (r ApiDrivesUpdateRootRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.DrivesUpdateRootExecute(r)
}

/*
DrivesUpdateRoot Update the navigation property root in drives

The root folder of the drive. Read-only.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param driveId key: id of drive
 @return ApiDrivesUpdateRootRequest
*/
func (a *DrivesDriveItemApiService) DrivesUpdateRoot(ctx _context.Context, driveId string) ApiDrivesUpdateRootRequest {
	return ApiDrivesUpdateRootRequest{
		ApiService: a,
		ctx: ctx,
		driveId: driveId,
	}
}

// Execute executes the request
func (a *DrivesDriveItemApiService) DrivesUpdateRootExecute(r ApiDrivesUpdateRootRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPatch
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DrivesDriveItemApiService.DrivesUpdateRoot")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/drives/{drive-id}/root"
	localVarPath = strings.Replace(localVarPath, "{"+"drive-id"+"}", _neturl.PathEscape(parameterToString(r.driveId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphDriveItem == nil {
		return nil, reportError("microsoftGraphDriveItem is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphDriveItem
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDrivesUpdateRootContentRequest struct {
	ctx _context.Context
	ApiService *DrivesDriveItemApiService
	driveId string
	body **os.File
}

// New media content.
func (r ApiDrivesUpdateRootContentRequest) Body(body *os.File) ApiDrivesUpdateRootContentRequest {
	r.body = &body
	return r
}

func (r ApiDrivesUpdateRootContentRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.DrivesUpdateRootContentExecute(r)
}

/*
DrivesUpdateRootContent Update media content for the navigation property root in drives

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param driveId key: id of drive
 @return ApiDrivesUpdateRootContentRequest
*/
func (a *DrivesDriveItemApiService) DrivesUpdateRootContent(ctx _context.Context, driveId string) ApiDrivesUpdateRootContentRequest {
	return ApiDrivesUpdateRootContentRequest{
		ApiService: a,
		ctx: ctx,
		driveId: driveId,
	}
}

// Execute executes the request
func (a *DrivesDriveItemApiService) DrivesUpdateRootContentExecute(r ApiDrivesUpdateRootContentRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPut
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DrivesDriveItemApiService.DrivesUpdateRootContent")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/drives/{drive-id}/root/content"
	localVarPath = strings.Replace(localVarPath, "{"+"drive-id"+"}", _neturl.PathEscape(parameterToString(r.driveId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.body == nil {
		return nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/octet-stream"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDrivesUpdateSpecialRequest struct {
	ctx _context.Context
	ApiService *DrivesDriveItemApiService
	driveId string
	driveItemId string
	microsoftGraphDriveItem *MicrosoftGraphDriveItem
}

// New navigation property values
func (r ApiDrivesUpdateSpecialRequest) MicrosoftGraphDriveItem(microsoftGraphDriveItem MicrosoftGraphDriveItem) ApiDrivesUpdateSpecialRequest {
	r.microsoftGraphDriveItem = &microsoftGraphDriveItem
	return r
}

func (r ApiDrivesUpdateSpecialRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.DrivesUpdateSpecialExecute(r)
}

/*
DrivesUpdateSpecial Update the navigation property special in drives

Collection of common folders available in OneDrive. Read-only. Nullable.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param driveId key: id of drive
 @param driveItemId key: id of driveItem
 @return ApiDrivesUpdateSpecialRequest
*/
func (a *DrivesDriveItemApiService) DrivesUpdateSpecial(ctx _context.Context, driveId string, driveItemId string) ApiDrivesUpdateSpecialRequest {
	return ApiDrivesUpdateSpecialRequest{
		ApiService: a,
		ctx: ctx,
		driveId: driveId,
		driveItemId: driveItemId,
	}
}

// Execute executes the request
func (a *DrivesDriveItemApiService) DrivesUpdateSpecialExecute(r ApiDrivesUpdateSpecialRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPatch
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DrivesDriveItemApiService.DrivesUpdateSpecial")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/drives/{drive-id}/special/{driveItem-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"drive-id"+"}", _neturl.PathEscape(parameterToString(r.driveId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"driveItem-id"+"}", _neturl.PathEscape(parameterToString(r.driveItemId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphDriveItem == nil {
		return nil, reportError("microsoftGraphDriveItem is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphDriveItem
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDrivesUpdateSpecialContentRequest struct {
	ctx _context.Context
	ApiService *DrivesDriveItemApiService
	driveId string
	driveItemId string
	body **os.File
}

// New media content.
func (r ApiDrivesUpdateSpecialContentRequest) Body(body *os.File) ApiDrivesUpdateSpecialContentRequest {
	r.body = &body
	return r
}

func (r ApiDrivesUpdateSpecialContentRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.DrivesUpdateSpecialContentExecute(r)
}

/*
DrivesUpdateSpecialContent Update media content for the navigation property special in drives

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param driveId key: id of drive
 @param driveItemId key: id of driveItem
 @return ApiDrivesUpdateSpecialContentRequest
*/
func (a *DrivesDriveItemApiService) DrivesUpdateSpecialContent(ctx _context.Context, driveId string, driveItemId string) ApiDrivesUpdateSpecialContentRequest {
	return ApiDrivesUpdateSpecialContentRequest{
		ApiService: a,
		ctx: ctx,
		driveId: driveId,
		driveItemId: driveItemId,
	}
}

// Execute executes the request
func (a *DrivesDriveItemApiService) DrivesUpdateSpecialContentExecute(r ApiDrivesUpdateSpecialContentRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPut
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DrivesDriveItemApiService.DrivesUpdateSpecialContent")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/drives/{drive-id}/special/{driveItem-id}/content"
	localVarPath = strings.Replace(localVarPath, "{"+"drive-id"+"}", _neturl.PathEscape(parameterToString(r.driveId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"driveItem-id"+"}", _neturl.PathEscape(parameterToString(r.driveItemId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.body == nil {
		return nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/octet-stream"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}
