/*
Partial Graph API

No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

API version: v1.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package msgraph

import (
	"bytes"
	_context "context"
	_ioutil "io/ioutil"
	_nethttp "net/http"
	_neturl "net/url"
	"strings"
	"os"
)

// Linger please
var (
	_ _context.Context
)

// TeamsChannelApiService TeamsChannelApi service
type TeamsChannelApiService service

type ApiTeamsChannelsCreateMembersRequest struct {
	ctx _context.Context
	ApiService *TeamsChannelApiService
	teamId string
	channelId string
	microsoftGraphConversationMember *MicrosoftGraphConversationMember
}

// New navigation property
func (r ApiTeamsChannelsCreateMembersRequest) MicrosoftGraphConversationMember(microsoftGraphConversationMember MicrosoftGraphConversationMember) ApiTeamsChannelsCreateMembersRequest {
	r.microsoftGraphConversationMember = &microsoftGraphConversationMember
	return r
}

func (r ApiTeamsChannelsCreateMembersRequest) Execute() (MicrosoftGraphConversationMember, *_nethttp.Response, error) {
	return r.ApiService.TeamsChannelsCreateMembersExecute(r)
}

/*
TeamsChannelsCreateMembers Create new navigation property to members for teams

A collection of membership records associated with the channel.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param teamId key: id of team
 @param channelId key: id of channel
 @return ApiTeamsChannelsCreateMembersRequest
*/
func (a *TeamsChannelApiService) TeamsChannelsCreateMembers(ctx _context.Context, teamId string, channelId string) ApiTeamsChannelsCreateMembersRequest {
	return ApiTeamsChannelsCreateMembersRequest{
		ApiService: a,
		ctx: ctx,
		teamId: teamId,
		channelId: channelId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphConversationMember
func (a *TeamsChannelApiService) TeamsChannelsCreateMembersExecute(r ApiTeamsChannelsCreateMembersRequest) (MicrosoftGraphConversationMember, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphConversationMember
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TeamsChannelApiService.TeamsChannelsCreateMembers")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/teams/{team-id}/channels/{channel-id}/members"
	localVarPath = strings.Replace(localVarPath, "{"+"team-id"+"}", _neturl.PathEscape(parameterToString(r.teamId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"channel-id"+"}", _neturl.PathEscape(parameterToString(r.channelId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphConversationMember == nil {
		return localVarReturnValue, nil, reportError("microsoftGraphConversationMember is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphConversationMember
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiTeamsChannelsCreateMessagesRequest struct {
	ctx _context.Context
	ApiService *TeamsChannelApiService
	teamId string
	channelId string
	microsoftGraphChatMessage *MicrosoftGraphChatMessage
}

// New navigation property
func (r ApiTeamsChannelsCreateMessagesRequest) MicrosoftGraphChatMessage(microsoftGraphChatMessage MicrosoftGraphChatMessage) ApiTeamsChannelsCreateMessagesRequest {
	r.microsoftGraphChatMessage = &microsoftGraphChatMessage
	return r
}

func (r ApiTeamsChannelsCreateMessagesRequest) Execute() (MicrosoftGraphChatMessage, *_nethttp.Response, error) {
	return r.ApiService.TeamsChannelsCreateMessagesExecute(r)
}

/*
TeamsChannelsCreateMessages Create new navigation property to messages for teams

A collection of all the messages in the channel. A navigation property. Nullable.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param teamId key: id of team
 @param channelId key: id of channel
 @return ApiTeamsChannelsCreateMessagesRequest
*/
func (a *TeamsChannelApiService) TeamsChannelsCreateMessages(ctx _context.Context, teamId string, channelId string) ApiTeamsChannelsCreateMessagesRequest {
	return ApiTeamsChannelsCreateMessagesRequest{
		ApiService: a,
		ctx: ctx,
		teamId: teamId,
		channelId: channelId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphChatMessage
func (a *TeamsChannelApiService) TeamsChannelsCreateMessagesExecute(r ApiTeamsChannelsCreateMessagesRequest) (MicrosoftGraphChatMessage, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphChatMessage
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TeamsChannelApiService.TeamsChannelsCreateMessages")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/teams/{team-id}/channels/{channel-id}/messages"
	localVarPath = strings.Replace(localVarPath, "{"+"team-id"+"}", _neturl.PathEscape(parameterToString(r.teamId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"channel-id"+"}", _neturl.PathEscape(parameterToString(r.channelId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphChatMessage == nil {
		return localVarReturnValue, nil, reportError("microsoftGraphChatMessage is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphChatMessage
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiTeamsChannelsCreateTabsRequest struct {
	ctx _context.Context
	ApiService *TeamsChannelApiService
	teamId string
	channelId string
	microsoftGraphTeamsTab *MicrosoftGraphTeamsTab
}

// New navigation property
func (r ApiTeamsChannelsCreateTabsRequest) MicrosoftGraphTeamsTab(microsoftGraphTeamsTab MicrosoftGraphTeamsTab) ApiTeamsChannelsCreateTabsRequest {
	r.microsoftGraphTeamsTab = &microsoftGraphTeamsTab
	return r
}

func (r ApiTeamsChannelsCreateTabsRequest) Execute() (MicrosoftGraphTeamsTab, *_nethttp.Response, error) {
	return r.ApiService.TeamsChannelsCreateTabsExecute(r)
}

/*
TeamsChannelsCreateTabs Create new navigation property to tabs for teams

A collection of all the tabs in the channel. A navigation property.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param teamId key: id of team
 @param channelId key: id of channel
 @return ApiTeamsChannelsCreateTabsRequest
*/
func (a *TeamsChannelApiService) TeamsChannelsCreateTabs(ctx _context.Context, teamId string, channelId string) ApiTeamsChannelsCreateTabsRequest {
	return ApiTeamsChannelsCreateTabsRequest{
		ApiService: a,
		ctx: ctx,
		teamId: teamId,
		channelId: channelId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphTeamsTab
func (a *TeamsChannelApiService) TeamsChannelsCreateTabsExecute(r ApiTeamsChannelsCreateTabsRequest) (MicrosoftGraphTeamsTab, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphTeamsTab
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TeamsChannelApiService.TeamsChannelsCreateTabs")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/teams/{team-id}/channels/{channel-id}/tabs"
	localVarPath = strings.Replace(localVarPath, "{"+"team-id"+"}", _neturl.PathEscape(parameterToString(r.teamId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"channel-id"+"}", _neturl.PathEscape(parameterToString(r.channelId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphTeamsTab == nil {
		return localVarReturnValue, nil, reportError("microsoftGraphTeamsTab is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphTeamsTab
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiTeamsChannelsDeleteFilesFolderRequest struct {
	ctx _context.Context
	ApiService *TeamsChannelApiService
	teamId string
	channelId string
	ifMatch *string
}

// ETag
func (r ApiTeamsChannelsDeleteFilesFolderRequest) IfMatch(ifMatch string) ApiTeamsChannelsDeleteFilesFolderRequest {
	r.ifMatch = &ifMatch
	return r
}

func (r ApiTeamsChannelsDeleteFilesFolderRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.TeamsChannelsDeleteFilesFolderExecute(r)
}

/*
TeamsChannelsDeleteFilesFolder Delete navigation property filesFolder for teams

Metadata for the location where the channel's files are stored.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param teamId key: id of team
 @param channelId key: id of channel
 @return ApiTeamsChannelsDeleteFilesFolderRequest
*/
func (a *TeamsChannelApiService) TeamsChannelsDeleteFilesFolder(ctx _context.Context, teamId string, channelId string) ApiTeamsChannelsDeleteFilesFolderRequest {
	return ApiTeamsChannelsDeleteFilesFolderRequest{
		ApiService: a,
		ctx: ctx,
		teamId: teamId,
		channelId: channelId,
	}
}

// Execute executes the request
func (a *TeamsChannelApiService) TeamsChannelsDeleteFilesFolderExecute(r ApiTeamsChannelsDeleteFilesFolderRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TeamsChannelApiService.TeamsChannelsDeleteFilesFolder")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/teams/{team-id}/channels/{channel-id}/filesFolder"
	localVarPath = strings.Replace(localVarPath, "{"+"team-id"+"}", _neturl.PathEscape(parameterToString(r.teamId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"channel-id"+"}", _neturl.PathEscape(parameterToString(r.channelId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ifMatch != nil {
		localVarHeaderParams["If-Match"] = parameterToString(*r.ifMatch, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiTeamsChannelsDeleteMembersRequest struct {
	ctx _context.Context
	ApiService *TeamsChannelApiService
	teamId string
	channelId string
	conversationMemberId string
	ifMatch *string
}

// ETag
func (r ApiTeamsChannelsDeleteMembersRequest) IfMatch(ifMatch string) ApiTeamsChannelsDeleteMembersRequest {
	r.ifMatch = &ifMatch
	return r
}

func (r ApiTeamsChannelsDeleteMembersRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.TeamsChannelsDeleteMembersExecute(r)
}

/*
TeamsChannelsDeleteMembers Delete navigation property members for teams

A collection of membership records associated with the channel.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param teamId key: id of team
 @param channelId key: id of channel
 @param conversationMemberId key: id of conversationMember
 @return ApiTeamsChannelsDeleteMembersRequest
*/
func (a *TeamsChannelApiService) TeamsChannelsDeleteMembers(ctx _context.Context, teamId string, channelId string, conversationMemberId string) ApiTeamsChannelsDeleteMembersRequest {
	return ApiTeamsChannelsDeleteMembersRequest{
		ApiService: a,
		ctx: ctx,
		teamId: teamId,
		channelId: channelId,
		conversationMemberId: conversationMemberId,
	}
}

// Execute executes the request
func (a *TeamsChannelApiService) TeamsChannelsDeleteMembersExecute(r ApiTeamsChannelsDeleteMembersRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TeamsChannelApiService.TeamsChannelsDeleteMembers")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/teams/{team-id}/channels/{channel-id}/members/{conversationMember-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"team-id"+"}", _neturl.PathEscape(parameterToString(r.teamId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"channel-id"+"}", _neturl.PathEscape(parameterToString(r.channelId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"conversationMember-id"+"}", _neturl.PathEscape(parameterToString(r.conversationMemberId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ifMatch != nil {
		localVarHeaderParams["If-Match"] = parameterToString(*r.ifMatch, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiTeamsChannelsDeleteMessagesRequest struct {
	ctx _context.Context
	ApiService *TeamsChannelApiService
	teamId string
	channelId string
	chatMessageId string
	ifMatch *string
}

// ETag
func (r ApiTeamsChannelsDeleteMessagesRequest) IfMatch(ifMatch string) ApiTeamsChannelsDeleteMessagesRequest {
	r.ifMatch = &ifMatch
	return r
}

func (r ApiTeamsChannelsDeleteMessagesRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.TeamsChannelsDeleteMessagesExecute(r)
}

/*
TeamsChannelsDeleteMessages Delete navigation property messages for teams

A collection of all the messages in the channel. A navigation property. Nullable.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param teamId key: id of team
 @param channelId key: id of channel
 @param chatMessageId key: id of chatMessage
 @return ApiTeamsChannelsDeleteMessagesRequest
*/
func (a *TeamsChannelApiService) TeamsChannelsDeleteMessages(ctx _context.Context, teamId string, channelId string, chatMessageId string) ApiTeamsChannelsDeleteMessagesRequest {
	return ApiTeamsChannelsDeleteMessagesRequest{
		ApiService: a,
		ctx: ctx,
		teamId: teamId,
		channelId: channelId,
		chatMessageId: chatMessageId,
	}
}

// Execute executes the request
func (a *TeamsChannelApiService) TeamsChannelsDeleteMessagesExecute(r ApiTeamsChannelsDeleteMessagesRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TeamsChannelApiService.TeamsChannelsDeleteMessages")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/teams/{team-id}/channels/{channel-id}/messages/{chatMessage-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"team-id"+"}", _neturl.PathEscape(parameterToString(r.teamId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"channel-id"+"}", _neturl.PathEscape(parameterToString(r.channelId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"chatMessage-id"+"}", _neturl.PathEscape(parameterToString(r.chatMessageId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ifMatch != nil {
		localVarHeaderParams["If-Match"] = parameterToString(*r.ifMatch, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiTeamsChannelsDeleteTabsRequest struct {
	ctx _context.Context
	ApiService *TeamsChannelApiService
	teamId string
	channelId string
	teamsTabId string
	ifMatch *string
}

// ETag
func (r ApiTeamsChannelsDeleteTabsRequest) IfMatch(ifMatch string) ApiTeamsChannelsDeleteTabsRequest {
	r.ifMatch = &ifMatch
	return r
}

func (r ApiTeamsChannelsDeleteTabsRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.TeamsChannelsDeleteTabsExecute(r)
}

/*
TeamsChannelsDeleteTabs Delete navigation property tabs for teams

A collection of all the tabs in the channel. A navigation property.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param teamId key: id of team
 @param channelId key: id of channel
 @param teamsTabId key: id of teamsTab
 @return ApiTeamsChannelsDeleteTabsRequest
*/
func (a *TeamsChannelApiService) TeamsChannelsDeleteTabs(ctx _context.Context, teamId string, channelId string, teamsTabId string) ApiTeamsChannelsDeleteTabsRequest {
	return ApiTeamsChannelsDeleteTabsRequest{
		ApiService: a,
		ctx: ctx,
		teamId: teamId,
		channelId: channelId,
		teamsTabId: teamsTabId,
	}
}

// Execute executes the request
func (a *TeamsChannelApiService) TeamsChannelsDeleteTabsExecute(r ApiTeamsChannelsDeleteTabsRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TeamsChannelApiService.TeamsChannelsDeleteTabs")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/teams/{team-id}/channels/{channel-id}/tabs/{teamsTab-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"team-id"+"}", _neturl.PathEscape(parameterToString(r.teamId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"channel-id"+"}", _neturl.PathEscape(parameterToString(r.channelId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"teamsTab-id"+"}", _neturl.PathEscape(parameterToString(r.teamsTabId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ifMatch != nil {
		localVarHeaderParams["If-Match"] = parameterToString(*r.ifMatch, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiTeamsChannelsGetFilesFolderRequest struct {
	ctx _context.Context
	ApiService *TeamsChannelApiService
	teamId string
	channelId string
	select_ *[]string
	expand *[]string
}

// Select properties to be returned
func (r ApiTeamsChannelsGetFilesFolderRequest) Select_(select_ []string) ApiTeamsChannelsGetFilesFolderRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiTeamsChannelsGetFilesFolderRequest) Expand(expand []string) ApiTeamsChannelsGetFilesFolderRequest {
	r.expand = &expand
	return r
}

func (r ApiTeamsChannelsGetFilesFolderRequest) Execute() (MicrosoftGraphDriveItem, *_nethttp.Response, error) {
	return r.ApiService.TeamsChannelsGetFilesFolderExecute(r)
}

/*
TeamsChannelsGetFilesFolder Get filesFolder from teams

Metadata for the location where the channel's files are stored.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param teamId key: id of team
 @param channelId key: id of channel
 @return ApiTeamsChannelsGetFilesFolderRequest
*/
func (a *TeamsChannelApiService) TeamsChannelsGetFilesFolder(ctx _context.Context, teamId string, channelId string) ApiTeamsChannelsGetFilesFolderRequest {
	return ApiTeamsChannelsGetFilesFolderRequest{
		ApiService: a,
		ctx: ctx,
		teamId: teamId,
		channelId: channelId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphDriveItem
func (a *TeamsChannelApiService) TeamsChannelsGetFilesFolderExecute(r ApiTeamsChannelsGetFilesFolderRequest) (MicrosoftGraphDriveItem, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphDriveItem
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TeamsChannelApiService.TeamsChannelsGetFilesFolder")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/teams/{team-id}/channels/{channel-id}/filesFolder"
	localVarPath = strings.Replace(localVarPath, "{"+"team-id"+"}", _neturl.PathEscape(parameterToString(r.teamId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"channel-id"+"}", _neturl.PathEscape(parameterToString(r.channelId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiTeamsChannelsGetFilesFolderContentRequest struct {
	ctx _context.Context
	ApiService *TeamsChannelApiService
	teamId string
	channelId string
}


func (r ApiTeamsChannelsGetFilesFolderContentRequest) Execute() (*os.File, *_nethttp.Response, error) {
	return r.ApiService.TeamsChannelsGetFilesFolderContentExecute(r)
}

/*
TeamsChannelsGetFilesFolderContent Get media content for the navigation property filesFolder from teams

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param teamId key: id of team
 @param channelId key: id of channel
 @return ApiTeamsChannelsGetFilesFolderContentRequest
*/
func (a *TeamsChannelApiService) TeamsChannelsGetFilesFolderContent(ctx _context.Context, teamId string, channelId string) ApiTeamsChannelsGetFilesFolderContentRequest {
	return ApiTeamsChannelsGetFilesFolderContentRequest{
		ApiService: a,
		ctx: ctx,
		teamId: teamId,
		channelId: channelId,
	}
}

// Execute executes the request
//  @return *os.File
func (a *TeamsChannelApiService) TeamsChannelsGetFilesFolderContentExecute(r ApiTeamsChannelsGetFilesFolderContentRequest) (*os.File, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  *os.File
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TeamsChannelApiService.TeamsChannelsGetFilesFolderContent")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/teams/{team-id}/channels/{channel-id}/filesFolder/content"
	localVarPath = strings.Replace(localVarPath, "{"+"team-id"+"}", _neturl.PathEscape(parameterToString(r.teamId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"channel-id"+"}", _neturl.PathEscape(parameterToString(r.channelId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/octet-stream", "application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiTeamsChannelsGetMembersRequest struct {
	ctx _context.Context
	ApiService *TeamsChannelApiService
	teamId string
	channelId string
	conversationMemberId string
	select_ *[]string
	expand *[]string
}

// Select properties to be returned
func (r ApiTeamsChannelsGetMembersRequest) Select_(select_ []string) ApiTeamsChannelsGetMembersRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiTeamsChannelsGetMembersRequest) Expand(expand []string) ApiTeamsChannelsGetMembersRequest {
	r.expand = &expand
	return r
}

func (r ApiTeamsChannelsGetMembersRequest) Execute() (MicrosoftGraphConversationMember, *_nethttp.Response, error) {
	return r.ApiService.TeamsChannelsGetMembersExecute(r)
}

/*
TeamsChannelsGetMembers Get members from teams

A collection of membership records associated with the channel.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param teamId key: id of team
 @param channelId key: id of channel
 @param conversationMemberId key: id of conversationMember
 @return ApiTeamsChannelsGetMembersRequest
*/
func (a *TeamsChannelApiService) TeamsChannelsGetMembers(ctx _context.Context, teamId string, channelId string, conversationMemberId string) ApiTeamsChannelsGetMembersRequest {
	return ApiTeamsChannelsGetMembersRequest{
		ApiService: a,
		ctx: ctx,
		teamId: teamId,
		channelId: channelId,
		conversationMemberId: conversationMemberId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphConversationMember
func (a *TeamsChannelApiService) TeamsChannelsGetMembersExecute(r ApiTeamsChannelsGetMembersRequest) (MicrosoftGraphConversationMember, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphConversationMember
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TeamsChannelApiService.TeamsChannelsGetMembers")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/teams/{team-id}/channels/{channel-id}/members/{conversationMember-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"team-id"+"}", _neturl.PathEscape(parameterToString(r.teamId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"channel-id"+"}", _neturl.PathEscape(parameterToString(r.channelId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"conversationMember-id"+"}", _neturl.PathEscape(parameterToString(r.conversationMemberId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiTeamsChannelsGetMessagesRequest struct {
	ctx _context.Context
	ApiService *TeamsChannelApiService
	teamId string
	channelId string
	chatMessageId string
	select_ *[]string
	expand *[]string
}

// Select properties to be returned
func (r ApiTeamsChannelsGetMessagesRequest) Select_(select_ []string) ApiTeamsChannelsGetMessagesRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiTeamsChannelsGetMessagesRequest) Expand(expand []string) ApiTeamsChannelsGetMessagesRequest {
	r.expand = &expand
	return r
}

func (r ApiTeamsChannelsGetMessagesRequest) Execute() (MicrosoftGraphChatMessage, *_nethttp.Response, error) {
	return r.ApiService.TeamsChannelsGetMessagesExecute(r)
}

/*
TeamsChannelsGetMessages Get messages from teams

A collection of all the messages in the channel. A navigation property. Nullable.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param teamId key: id of team
 @param channelId key: id of channel
 @param chatMessageId key: id of chatMessage
 @return ApiTeamsChannelsGetMessagesRequest
*/
func (a *TeamsChannelApiService) TeamsChannelsGetMessages(ctx _context.Context, teamId string, channelId string, chatMessageId string) ApiTeamsChannelsGetMessagesRequest {
	return ApiTeamsChannelsGetMessagesRequest{
		ApiService: a,
		ctx: ctx,
		teamId: teamId,
		channelId: channelId,
		chatMessageId: chatMessageId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphChatMessage
func (a *TeamsChannelApiService) TeamsChannelsGetMessagesExecute(r ApiTeamsChannelsGetMessagesRequest) (MicrosoftGraphChatMessage, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphChatMessage
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TeamsChannelApiService.TeamsChannelsGetMessages")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/teams/{team-id}/channels/{channel-id}/messages/{chatMessage-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"team-id"+"}", _neturl.PathEscape(parameterToString(r.teamId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"channel-id"+"}", _neturl.PathEscape(parameterToString(r.channelId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"chatMessage-id"+"}", _neturl.PathEscape(parameterToString(r.chatMessageId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiTeamsChannelsGetTabsRequest struct {
	ctx _context.Context
	ApiService *TeamsChannelApiService
	teamId string
	channelId string
	teamsTabId string
	select_ *[]string
	expand *[]string
}

// Select properties to be returned
func (r ApiTeamsChannelsGetTabsRequest) Select_(select_ []string) ApiTeamsChannelsGetTabsRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiTeamsChannelsGetTabsRequest) Expand(expand []string) ApiTeamsChannelsGetTabsRequest {
	r.expand = &expand
	return r
}

func (r ApiTeamsChannelsGetTabsRequest) Execute() (MicrosoftGraphTeamsTab, *_nethttp.Response, error) {
	return r.ApiService.TeamsChannelsGetTabsExecute(r)
}

/*
TeamsChannelsGetTabs Get tabs from teams

A collection of all the tabs in the channel. A navigation property.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param teamId key: id of team
 @param channelId key: id of channel
 @param teamsTabId key: id of teamsTab
 @return ApiTeamsChannelsGetTabsRequest
*/
func (a *TeamsChannelApiService) TeamsChannelsGetTabs(ctx _context.Context, teamId string, channelId string, teamsTabId string) ApiTeamsChannelsGetTabsRequest {
	return ApiTeamsChannelsGetTabsRequest{
		ApiService: a,
		ctx: ctx,
		teamId: teamId,
		channelId: channelId,
		teamsTabId: teamsTabId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphTeamsTab
func (a *TeamsChannelApiService) TeamsChannelsGetTabsExecute(r ApiTeamsChannelsGetTabsRequest) (MicrosoftGraphTeamsTab, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphTeamsTab
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TeamsChannelApiService.TeamsChannelsGetTabs")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/teams/{team-id}/channels/{channel-id}/tabs/{teamsTab-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"team-id"+"}", _neturl.PathEscape(parameterToString(r.teamId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"channel-id"+"}", _neturl.PathEscape(parameterToString(r.channelId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"teamsTab-id"+"}", _neturl.PathEscape(parameterToString(r.teamsTabId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiTeamsChannelsListMembersRequest struct {
	ctx _context.Context
	ApiService *TeamsChannelApiService
	teamId string
	channelId string
	top *int32
	skip *int32
	search *string
	filter *string
	count *bool
	orderby *[]string
	select_ *[]string
	expand *[]string
}

// Show only the first n items
func (r ApiTeamsChannelsListMembersRequest) Top(top int32) ApiTeamsChannelsListMembersRequest {
	r.top = &top
	return r
}
// Skip the first n items
func (r ApiTeamsChannelsListMembersRequest) Skip(skip int32) ApiTeamsChannelsListMembersRequest {
	r.skip = &skip
	return r
}
// Search items by search phrases
func (r ApiTeamsChannelsListMembersRequest) Search(search string) ApiTeamsChannelsListMembersRequest {
	r.search = &search
	return r
}
// Filter items by property values
func (r ApiTeamsChannelsListMembersRequest) Filter(filter string) ApiTeamsChannelsListMembersRequest {
	r.filter = &filter
	return r
}
// Include count of items
func (r ApiTeamsChannelsListMembersRequest) Count(count bool) ApiTeamsChannelsListMembersRequest {
	r.count = &count
	return r
}
// Order items by property values
func (r ApiTeamsChannelsListMembersRequest) Orderby(orderby []string) ApiTeamsChannelsListMembersRequest {
	r.orderby = &orderby
	return r
}
// Select properties to be returned
func (r ApiTeamsChannelsListMembersRequest) Select_(select_ []string) ApiTeamsChannelsListMembersRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiTeamsChannelsListMembersRequest) Expand(expand []string) ApiTeamsChannelsListMembersRequest {
	r.expand = &expand
	return r
}

func (r ApiTeamsChannelsListMembersRequest) Execute() (CollectionOfConversationMember, *_nethttp.Response, error) {
	return r.ApiService.TeamsChannelsListMembersExecute(r)
}

/*
TeamsChannelsListMembers Get members from teams

A collection of membership records associated with the channel.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param teamId key: id of team
 @param channelId key: id of channel
 @return ApiTeamsChannelsListMembersRequest
*/
func (a *TeamsChannelApiService) TeamsChannelsListMembers(ctx _context.Context, teamId string, channelId string) ApiTeamsChannelsListMembersRequest {
	return ApiTeamsChannelsListMembersRequest{
		ApiService: a,
		ctx: ctx,
		teamId: teamId,
		channelId: channelId,
	}
}

// Execute executes the request
//  @return CollectionOfConversationMember
func (a *TeamsChannelApiService) TeamsChannelsListMembersExecute(r ApiTeamsChannelsListMembersRequest) (CollectionOfConversationMember, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  CollectionOfConversationMember
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TeamsChannelApiService.TeamsChannelsListMembers")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/teams/{team-id}/channels/{channel-id}/members"
	localVarPath = strings.Replace(localVarPath, "{"+"team-id"+"}", _neturl.PathEscape(parameterToString(r.teamId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"channel-id"+"}", _neturl.PathEscape(parameterToString(r.channelId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.top != nil {
		localVarQueryParams.Add("$top", parameterToString(*r.top, ""))
	}
	if r.skip != nil {
		localVarQueryParams.Add("$skip", parameterToString(*r.skip, ""))
	}
	if r.search != nil {
		localVarQueryParams.Add("$search", parameterToString(*r.search, ""))
	}
	if r.filter != nil {
		localVarQueryParams.Add("$filter", parameterToString(*r.filter, ""))
	}
	if r.count != nil {
		localVarQueryParams.Add("$count", parameterToString(*r.count, ""))
	}
	if r.orderby != nil {
		localVarQueryParams.Add("$orderby", parameterToString(*r.orderby, "csv"))
	}
	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiTeamsChannelsListMessagesRequest struct {
	ctx _context.Context
	ApiService *TeamsChannelApiService
	teamId string
	channelId string
	top *int32
	skip *int32
	search *string
	filter *string
	count *bool
	orderby *[]string
	select_ *[]string
	expand *[]string
}

// Show only the first n items
func (r ApiTeamsChannelsListMessagesRequest) Top(top int32) ApiTeamsChannelsListMessagesRequest {
	r.top = &top
	return r
}
// Skip the first n items
func (r ApiTeamsChannelsListMessagesRequest) Skip(skip int32) ApiTeamsChannelsListMessagesRequest {
	r.skip = &skip
	return r
}
// Search items by search phrases
func (r ApiTeamsChannelsListMessagesRequest) Search(search string) ApiTeamsChannelsListMessagesRequest {
	r.search = &search
	return r
}
// Filter items by property values
func (r ApiTeamsChannelsListMessagesRequest) Filter(filter string) ApiTeamsChannelsListMessagesRequest {
	r.filter = &filter
	return r
}
// Include count of items
func (r ApiTeamsChannelsListMessagesRequest) Count(count bool) ApiTeamsChannelsListMessagesRequest {
	r.count = &count
	return r
}
// Order items by property values
func (r ApiTeamsChannelsListMessagesRequest) Orderby(orderby []string) ApiTeamsChannelsListMessagesRequest {
	r.orderby = &orderby
	return r
}
// Select properties to be returned
func (r ApiTeamsChannelsListMessagesRequest) Select_(select_ []string) ApiTeamsChannelsListMessagesRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiTeamsChannelsListMessagesRequest) Expand(expand []string) ApiTeamsChannelsListMessagesRequest {
	r.expand = &expand
	return r
}

func (r ApiTeamsChannelsListMessagesRequest) Execute() (CollectionOfChatMessage, *_nethttp.Response, error) {
	return r.ApiService.TeamsChannelsListMessagesExecute(r)
}

/*
TeamsChannelsListMessages Get messages from teams

A collection of all the messages in the channel. A navigation property. Nullable.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param teamId key: id of team
 @param channelId key: id of channel
 @return ApiTeamsChannelsListMessagesRequest
*/
func (a *TeamsChannelApiService) TeamsChannelsListMessages(ctx _context.Context, teamId string, channelId string) ApiTeamsChannelsListMessagesRequest {
	return ApiTeamsChannelsListMessagesRequest{
		ApiService: a,
		ctx: ctx,
		teamId: teamId,
		channelId: channelId,
	}
}

// Execute executes the request
//  @return CollectionOfChatMessage
func (a *TeamsChannelApiService) TeamsChannelsListMessagesExecute(r ApiTeamsChannelsListMessagesRequest) (CollectionOfChatMessage, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  CollectionOfChatMessage
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TeamsChannelApiService.TeamsChannelsListMessages")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/teams/{team-id}/channels/{channel-id}/messages"
	localVarPath = strings.Replace(localVarPath, "{"+"team-id"+"}", _neturl.PathEscape(parameterToString(r.teamId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"channel-id"+"}", _neturl.PathEscape(parameterToString(r.channelId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.top != nil {
		localVarQueryParams.Add("$top", parameterToString(*r.top, ""))
	}
	if r.skip != nil {
		localVarQueryParams.Add("$skip", parameterToString(*r.skip, ""))
	}
	if r.search != nil {
		localVarQueryParams.Add("$search", parameterToString(*r.search, ""))
	}
	if r.filter != nil {
		localVarQueryParams.Add("$filter", parameterToString(*r.filter, ""))
	}
	if r.count != nil {
		localVarQueryParams.Add("$count", parameterToString(*r.count, ""))
	}
	if r.orderby != nil {
		localVarQueryParams.Add("$orderby", parameterToString(*r.orderby, "csv"))
	}
	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiTeamsChannelsListTabsRequest struct {
	ctx _context.Context
	ApiService *TeamsChannelApiService
	teamId string
	channelId string
	top *int32
	skip *int32
	search *string
	filter *string
	count *bool
	orderby *[]string
	select_ *[]string
	expand *[]string
}

// Show only the first n items
func (r ApiTeamsChannelsListTabsRequest) Top(top int32) ApiTeamsChannelsListTabsRequest {
	r.top = &top
	return r
}
// Skip the first n items
func (r ApiTeamsChannelsListTabsRequest) Skip(skip int32) ApiTeamsChannelsListTabsRequest {
	r.skip = &skip
	return r
}
// Search items by search phrases
func (r ApiTeamsChannelsListTabsRequest) Search(search string) ApiTeamsChannelsListTabsRequest {
	r.search = &search
	return r
}
// Filter items by property values
func (r ApiTeamsChannelsListTabsRequest) Filter(filter string) ApiTeamsChannelsListTabsRequest {
	r.filter = &filter
	return r
}
// Include count of items
func (r ApiTeamsChannelsListTabsRequest) Count(count bool) ApiTeamsChannelsListTabsRequest {
	r.count = &count
	return r
}
// Order items by property values
func (r ApiTeamsChannelsListTabsRequest) Orderby(orderby []string) ApiTeamsChannelsListTabsRequest {
	r.orderby = &orderby
	return r
}
// Select properties to be returned
func (r ApiTeamsChannelsListTabsRequest) Select_(select_ []string) ApiTeamsChannelsListTabsRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiTeamsChannelsListTabsRequest) Expand(expand []string) ApiTeamsChannelsListTabsRequest {
	r.expand = &expand
	return r
}

func (r ApiTeamsChannelsListTabsRequest) Execute() (CollectionOfTeamsTab, *_nethttp.Response, error) {
	return r.ApiService.TeamsChannelsListTabsExecute(r)
}

/*
TeamsChannelsListTabs Get tabs from teams

A collection of all the tabs in the channel. A navigation property.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param teamId key: id of team
 @param channelId key: id of channel
 @return ApiTeamsChannelsListTabsRequest
*/
func (a *TeamsChannelApiService) TeamsChannelsListTabs(ctx _context.Context, teamId string, channelId string) ApiTeamsChannelsListTabsRequest {
	return ApiTeamsChannelsListTabsRequest{
		ApiService: a,
		ctx: ctx,
		teamId: teamId,
		channelId: channelId,
	}
}

// Execute executes the request
//  @return CollectionOfTeamsTab
func (a *TeamsChannelApiService) TeamsChannelsListTabsExecute(r ApiTeamsChannelsListTabsRequest) (CollectionOfTeamsTab, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  CollectionOfTeamsTab
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TeamsChannelApiService.TeamsChannelsListTabs")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/teams/{team-id}/channels/{channel-id}/tabs"
	localVarPath = strings.Replace(localVarPath, "{"+"team-id"+"}", _neturl.PathEscape(parameterToString(r.teamId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"channel-id"+"}", _neturl.PathEscape(parameterToString(r.channelId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.top != nil {
		localVarQueryParams.Add("$top", parameterToString(*r.top, ""))
	}
	if r.skip != nil {
		localVarQueryParams.Add("$skip", parameterToString(*r.skip, ""))
	}
	if r.search != nil {
		localVarQueryParams.Add("$search", parameterToString(*r.search, ""))
	}
	if r.filter != nil {
		localVarQueryParams.Add("$filter", parameterToString(*r.filter, ""))
	}
	if r.count != nil {
		localVarQueryParams.Add("$count", parameterToString(*r.count, ""))
	}
	if r.orderby != nil {
		localVarQueryParams.Add("$orderby", parameterToString(*r.orderby, "csv"))
	}
	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiTeamsChannelsMessagesCreateHostedContentsRequest struct {
	ctx _context.Context
	ApiService *TeamsChannelApiService
	teamId string
	channelId string
	chatMessageId string
	microsoftGraphChatMessageHostedContent *MicrosoftGraphChatMessageHostedContent
}

// New navigation property
func (r ApiTeamsChannelsMessagesCreateHostedContentsRequest) MicrosoftGraphChatMessageHostedContent(microsoftGraphChatMessageHostedContent MicrosoftGraphChatMessageHostedContent) ApiTeamsChannelsMessagesCreateHostedContentsRequest {
	r.microsoftGraphChatMessageHostedContent = &microsoftGraphChatMessageHostedContent
	return r
}

func (r ApiTeamsChannelsMessagesCreateHostedContentsRequest) Execute() (MicrosoftGraphChatMessageHostedContent, *_nethttp.Response, error) {
	return r.ApiService.TeamsChannelsMessagesCreateHostedContentsExecute(r)
}

/*
TeamsChannelsMessagesCreateHostedContents Create new navigation property to hostedContents for teams

Content in a message hosted by Microsoft Teams - for example, images or code snippets.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param teamId key: id of team
 @param channelId key: id of channel
 @param chatMessageId key: id of chatMessage
 @return ApiTeamsChannelsMessagesCreateHostedContentsRequest
*/
func (a *TeamsChannelApiService) TeamsChannelsMessagesCreateHostedContents(ctx _context.Context, teamId string, channelId string, chatMessageId string) ApiTeamsChannelsMessagesCreateHostedContentsRequest {
	return ApiTeamsChannelsMessagesCreateHostedContentsRequest{
		ApiService: a,
		ctx: ctx,
		teamId: teamId,
		channelId: channelId,
		chatMessageId: chatMessageId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphChatMessageHostedContent
func (a *TeamsChannelApiService) TeamsChannelsMessagesCreateHostedContentsExecute(r ApiTeamsChannelsMessagesCreateHostedContentsRequest) (MicrosoftGraphChatMessageHostedContent, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphChatMessageHostedContent
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TeamsChannelApiService.TeamsChannelsMessagesCreateHostedContents")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/teams/{team-id}/channels/{channel-id}/messages/{chatMessage-id}/hostedContents"
	localVarPath = strings.Replace(localVarPath, "{"+"team-id"+"}", _neturl.PathEscape(parameterToString(r.teamId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"channel-id"+"}", _neturl.PathEscape(parameterToString(r.channelId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"chatMessage-id"+"}", _neturl.PathEscape(parameterToString(r.chatMessageId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphChatMessageHostedContent == nil {
		return localVarReturnValue, nil, reportError("microsoftGraphChatMessageHostedContent is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphChatMessageHostedContent
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiTeamsChannelsMessagesCreateRepliesRequest struct {
	ctx _context.Context
	ApiService *TeamsChannelApiService
	teamId string
	channelId string
	chatMessageId string
	microsoftGraphChatMessage *MicrosoftGraphChatMessage
}

// New navigation property
func (r ApiTeamsChannelsMessagesCreateRepliesRequest) MicrosoftGraphChatMessage(microsoftGraphChatMessage MicrosoftGraphChatMessage) ApiTeamsChannelsMessagesCreateRepliesRequest {
	r.microsoftGraphChatMessage = &microsoftGraphChatMessage
	return r
}

func (r ApiTeamsChannelsMessagesCreateRepliesRequest) Execute() (MicrosoftGraphChatMessage, *_nethttp.Response, error) {
	return r.ApiService.TeamsChannelsMessagesCreateRepliesExecute(r)
}

/*
TeamsChannelsMessagesCreateReplies Create new navigation property to replies for teams

Replies for a specified message.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param teamId key: id of team
 @param channelId key: id of channel
 @param chatMessageId key: id of chatMessage
 @return ApiTeamsChannelsMessagesCreateRepliesRequest
*/
func (a *TeamsChannelApiService) TeamsChannelsMessagesCreateReplies(ctx _context.Context, teamId string, channelId string, chatMessageId string) ApiTeamsChannelsMessagesCreateRepliesRequest {
	return ApiTeamsChannelsMessagesCreateRepliesRequest{
		ApiService: a,
		ctx: ctx,
		teamId: teamId,
		channelId: channelId,
		chatMessageId: chatMessageId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphChatMessage
func (a *TeamsChannelApiService) TeamsChannelsMessagesCreateRepliesExecute(r ApiTeamsChannelsMessagesCreateRepliesRequest) (MicrosoftGraphChatMessage, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphChatMessage
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TeamsChannelApiService.TeamsChannelsMessagesCreateReplies")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/teams/{team-id}/channels/{channel-id}/messages/{chatMessage-id}/replies"
	localVarPath = strings.Replace(localVarPath, "{"+"team-id"+"}", _neturl.PathEscape(parameterToString(r.teamId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"channel-id"+"}", _neturl.PathEscape(parameterToString(r.channelId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"chatMessage-id"+"}", _neturl.PathEscape(parameterToString(r.chatMessageId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphChatMessage == nil {
		return localVarReturnValue, nil, reportError("microsoftGraphChatMessage is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphChatMessage
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiTeamsChannelsMessagesDeleteHostedContentsRequest struct {
	ctx _context.Context
	ApiService *TeamsChannelApiService
	teamId string
	channelId string
	chatMessageId string
	chatMessageHostedContentId string
	ifMatch *string
}

// ETag
func (r ApiTeamsChannelsMessagesDeleteHostedContentsRequest) IfMatch(ifMatch string) ApiTeamsChannelsMessagesDeleteHostedContentsRequest {
	r.ifMatch = &ifMatch
	return r
}

func (r ApiTeamsChannelsMessagesDeleteHostedContentsRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.TeamsChannelsMessagesDeleteHostedContentsExecute(r)
}

/*
TeamsChannelsMessagesDeleteHostedContents Delete navigation property hostedContents for teams

Content in a message hosted by Microsoft Teams - for example, images or code snippets.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param teamId key: id of team
 @param channelId key: id of channel
 @param chatMessageId key: id of chatMessage
 @param chatMessageHostedContentId key: id of chatMessageHostedContent
 @return ApiTeamsChannelsMessagesDeleteHostedContentsRequest
*/
func (a *TeamsChannelApiService) TeamsChannelsMessagesDeleteHostedContents(ctx _context.Context, teamId string, channelId string, chatMessageId string, chatMessageHostedContentId string) ApiTeamsChannelsMessagesDeleteHostedContentsRequest {
	return ApiTeamsChannelsMessagesDeleteHostedContentsRequest{
		ApiService: a,
		ctx: ctx,
		teamId: teamId,
		channelId: channelId,
		chatMessageId: chatMessageId,
		chatMessageHostedContentId: chatMessageHostedContentId,
	}
}

// Execute executes the request
func (a *TeamsChannelApiService) TeamsChannelsMessagesDeleteHostedContentsExecute(r ApiTeamsChannelsMessagesDeleteHostedContentsRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TeamsChannelApiService.TeamsChannelsMessagesDeleteHostedContents")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/teams/{team-id}/channels/{channel-id}/messages/{chatMessage-id}/hostedContents/{chatMessageHostedContent-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"team-id"+"}", _neturl.PathEscape(parameterToString(r.teamId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"channel-id"+"}", _neturl.PathEscape(parameterToString(r.channelId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"chatMessage-id"+"}", _neturl.PathEscape(parameterToString(r.chatMessageId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"chatMessageHostedContent-id"+"}", _neturl.PathEscape(parameterToString(r.chatMessageHostedContentId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ifMatch != nil {
		localVarHeaderParams["If-Match"] = parameterToString(*r.ifMatch, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiTeamsChannelsMessagesDeleteRepliesRequest struct {
	ctx _context.Context
	ApiService *TeamsChannelApiService
	teamId string
	channelId string
	chatMessageId string
	chatMessageId1 string
	ifMatch *string
}

// ETag
func (r ApiTeamsChannelsMessagesDeleteRepliesRequest) IfMatch(ifMatch string) ApiTeamsChannelsMessagesDeleteRepliesRequest {
	r.ifMatch = &ifMatch
	return r
}

func (r ApiTeamsChannelsMessagesDeleteRepliesRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.TeamsChannelsMessagesDeleteRepliesExecute(r)
}

/*
TeamsChannelsMessagesDeleteReplies Delete navigation property replies for teams

Replies for a specified message.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param teamId key: id of team
 @param channelId key: id of channel
 @param chatMessageId key: id of chatMessage
 @param chatMessageId1 key: id of chatMessage
 @return ApiTeamsChannelsMessagesDeleteRepliesRequest
*/
func (a *TeamsChannelApiService) TeamsChannelsMessagesDeleteReplies(ctx _context.Context, teamId string, channelId string, chatMessageId string, chatMessageId1 string) ApiTeamsChannelsMessagesDeleteRepliesRequest {
	return ApiTeamsChannelsMessagesDeleteRepliesRequest{
		ApiService: a,
		ctx: ctx,
		teamId: teamId,
		channelId: channelId,
		chatMessageId: chatMessageId,
		chatMessageId1: chatMessageId1,
	}
}

// Execute executes the request
func (a *TeamsChannelApiService) TeamsChannelsMessagesDeleteRepliesExecute(r ApiTeamsChannelsMessagesDeleteRepliesRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TeamsChannelApiService.TeamsChannelsMessagesDeleteReplies")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/teams/{team-id}/channels/{channel-id}/messages/{chatMessage-id}/replies/{chatMessage-id1}"
	localVarPath = strings.Replace(localVarPath, "{"+"team-id"+"}", _neturl.PathEscape(parameterToString(r.teamId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"channel-id"+"}", _neturl.PathEscape(parameterToString(r.channelId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"chatMessage-id"+"}", _neturl.PathEscape(parameterToString(r.chatMessageId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"chatMessage-id1"+"}", _neturl.PathEscape(parameterToString(r.chatMessageId1, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ifMatch != nil {
		localVarHeaderParams["If-Match"] = parameterToString(*r.ifMatch, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiTeamsChannelsMessagesGetHostedContentsRequest struct {
	ctx _context.Context
	ApiService *TeamsChannelApiService
	teamId string
	channelId string
	chatMessageId string
	chatMessageHostedContentId string
	select_ *[]string
	expand *[]string
}

// Select properties to be returned
func (r ApiTeamsChannelsMessagesGetHostedContentsRequest) Select_(select_ []string) ApiTeamsChannelsMessagesGetHostedContentsRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiTeamsChannelsMessagesGetHostedContentsRequest) Expand(expand []string) ApiTeamsChannelsMessagesGetHostedContentsRequest {
	r.expand = &expand
	return r
}

func (r ApiTeamsChannelsMessagesGetHostedContentsRequest) Execute() (MicrosoftGraphChatMessageHostedContent, *_nethttp.Response, error) {
	return r.ApiService.TeamsChannelsMessagesGetHostedContentsExecute(r)
}

/*
TeamsChannelsMessagesGetHostedContents Get hostedContents from teams

Content in a message hosted by Microsoft Teams - for example, images or code snippets.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param teamId key: id of team
 @param channelId key: id of channel
 @param chatMessageId key: id of chatMessage
 @param chatMessageHostedContentId key: id of chatMessageHostedContent
 @return ApiTeamsChannelsMessagesGetHostedContentsRequest
*/
func (a *TeamsChannelApiService) TeamsChannelsMessagesGetHostedContents(ctx _context.Context, teamId string, channelId string, chatMessageId string, chatMessageHostedContentId string) ApiTeamsChannelsMessagesGetHostedContentsRequest {
	return ApiTeamsChannelsMessagesGetHostedContentsRequest{
		ApiService: a,
		ctx: ctx,
		teamId: teamId,
		channelId: channelId,
		chatMessageId: chatMessageId,
		chatMessageHostedContentId: chatMessageHostedContentId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphChatMessageHostedContent
func (a *TeamsChannelApiService) TeamsChannelsMessagesGetHostedContentsExecute(r ApiTeamsChannelsMessagesGetHostedContentsRequest) (MicrosoftGraphChatMessageHostedContent, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphChatMessageHostedContent
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TeamsChannelApiService.TeamsChannelsMessagesGetHostedContents")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/teams/{team-id}/channels/{channel-id}/messages/{chatMessage-id}/hostedContents/{chatMessageHostedContent-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"team-id"+"}", _neturl.PathEscape(parameterToString(r.teamId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"channel-id"+"}", _neturl.PathEscape(parameterToString(r.channelId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"chatMessage-id"+"}", _neturl.PathEscape(parameterToString(r.chatMessageId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"chatMessageHostedContent-id"+"}", _neturl.PathEscape(parameterToString(r.chatMessageHostedContentId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiTeamsChannelsMessagesGetRepliesRequest struct {
	ctx _context.Context
	ApiService *TeamsChannelApiService
	teamId string
	channelId string
	chatMessageId string
	chatMessageId1 string
	select_ *[]string
	expand *[]string
}

// Select properties to be returned
func (r ApiTeamsChannelsMessagesGetRepliesRequest) Select_(select_ []string) ApiTeamsChannelsMessagesGetRepliesRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiTeamsChannelsMessagesGetRepliesRequest) Expand(expand []string) ApiTeamsChannelsMessagesGetRepliesRequest {
	r.expand = &expand
	return r
}

func (r ApiTeamsChannelsMessagesGetRepliesRequest) Execute() (MicrosoftGraphChatMessage, *_nethttp.Response, error) {
	return r.ApiService.TeamsChannelsMessagesGetRepliesExecute(r)
}

/*
TeamsChannelsMessagesGetReplies Get replies from teams

Replies for a specified message.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param teamId key: id of team
 @param channelId key: id of channel
 @param chatMessageId key: id of chatMessage
 @param chatMessageId1 key: id of chatMessage
 @return ApiTeamsChannelsMessagesGetRepliesRequest
*/
func (a *TeamsChannelApiService) TeamsChannelsMessagesGetReplies(ctx _context.Context, teamId string, channelId string, chatMessageId string, chatMessageId1 string) ApiTeamsChannelsMessagesGetRepliesRequest {
	return ApiTeamsChannelsMessagesGetRepliesRequest{
		ApiService: a,
		ctx: ctx,
		teamId: teamId,
		channelId: channelId,
		chatMessageId: chatMessageId,
		chatMessageId1: chatMessageId1,
	}
}

// Execute executes the request
//  @return MicrosoftGraphChatMessage
func (a *TeamsChannelApiService) TeamsChannelsMessagesGetRepliesExecute(r ApiTeamsChannelsMessagesGetRepliesRequest) (MicrosoftGraphChatMessage, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphChatMessage
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TeamsChannelApiService.TeamsChannelsMessagesGetReplies")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/teams/{team-id}/channels/{channel-id}/messages/{chatMessage-id}/replies/{chatMessage-id1}"
	localVarPath = strings.Replace(localVarPath, "{"+"team-id"+"}", _neturl.PathEscape(parameterToString(r.teamId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"channel-id"+"}", _neturl.PathEscape(parameterToString(r.channelId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"chatMessage-id"+"}", _neturl.PathEscape(parameterToString(r.chatMessageId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"chatMessage-id1"+"}", _neturl.PathEscape(parameterToString(r.chatMessageId1, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiTeamsChannelsMessagesListHostedContentsRequest struct {
	ctx _context.Context
	ApiService *TeamsChannelApiService
	teamId string
	channelId string
	chatMessageId string
	top *int32
	skip *int32
	search *string
	filter *string
	count *bool
	orderby *[]string
	select_ *[]string
	expand *[]string
}

// Show only the first n items
func (r ApiTeamsChannelsMessagesListHostedContentsRequest) Top(top int32) ApiTeamsChannelsMessagesListHostedContentsRequest {
	r.top = &top
	return r
}
// Skip the first n items
func (r ApiTeamsChannelsMessagesListHostedContentsRequest) Skip(skip int32) ApiTeamsChannelsMessagesListHostedContentsRequest {
	r.skip = &skip
	return r
}
// Search items by search phrases
func (r ApiTeamsChannelsMessagesListHostedContentsRequest) Search(search string) ApiTeamsChannelsMessagesListHostedContentsRequest {
	r.search = &search
	return r
}
// Filter items by property values
func (r ApiTeamsChannelsMessagesListHostedContentsRequest) Filter(filter string) ApiTeamsChannelsMessagesListHostedContentsRequest {
	r.filter = &filter
	return r
}
// Include count of items
func (r ApiTeamsChannelsMessagesListHostedContentsRequest) Count(count bool) ApiTeamsChannelsMessagesListHostedContentsRequest {
	r.count = &count
	return r
}
// Order items by property values
func (r ApiTeamsChannelsMessagesListHostedContentsRequest) Orderby(orderby []string) ApiTeamsChannelsMessagesListHostedContentsRequest {
	r.orderby = &orderby
	return r
}
// Select properties to be returned
func (r ApiTeamsChannelsMessagesListHostedContentsRequest) Select_(select_ []string) ApiTeamsChannelsMessagesListHostedContentsRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiTeamsChannelsMessagesListHostedContentsRequest) Expand(expand []string) ApiTeamsChannelsMessagesListHostedContentsRequest {
	r.expand = &expand
	return r
}

func (r ApiTeamsChannelsMessagesListHostedContentsRequest) Execute() (CollectionOfChatMessageHostedContent, *_nethttp.Response, error) {
	return r.ApiService.TeamsChannelsMessagesListHostedContentsExecute(r)
}

/*
TeamsChannelsMessagesListHostedContents Get hostedContents from teams

Content in a message hosted by Microsoft Teams - for example, images or code snippets.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param teamId key: id of team
 @param channelId key: id of channel
 @param chatMessageId key: id of chatMessage
 @return ApiTeamsChannelsMessagesListHostedContentsRequest
*/
func (a *TeamsChannelApiService) TeamsChannelsMessagesListHostedContents(ctx _context.Context, teamId string, channelId string, chatMessageId string) ApiTeamsChannelsMessagesListHostedContentsRequest {
	return ApiTeamsChannelsMessagesListHostedContentsRequest{
		ApiService: a,
		ctx: ctx,
		teamId: teamId,
		channelId: channelId,
		chatMessageId: chatMessageId,
	}
}

// Execute executes the request
//  @return CollectionOfChatMessageHostedContent
func (a *TeamsChannelApiService) TeamsChannelsMessagesListHostedContentsExecute(r ApiTeamsChannelsMessagesListHostedContentsRequest) (CollectionOfChatMessageHostedContent, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  CollectionOfChatMessageHostedContent
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TeamsChannelApiService.TeamsChannelsMessagesListHostedContents")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/teams/{team-id}/channels/{channel-id}/messages/{chatMessage-id}/hostedContents"
	localVarPath = strings.Replace(localVarPath, "{"+"team-id"+"}", _neturl.PathEscape(parameterToString(r.teamId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"channel-id"+"}", _neturl.PathEscape(parameterToString(r.channelId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"chatMessage-id"+"}", _neturl.PathEscape(parameterToString(r.chatMessageId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.top != nil {
		localVarQueryParams.Add("$top", parameterToString(*r.top, ""))
	}
	if r.skip != nil {
		localVarQueryParams.Add("$skip", parameterToString(*r.skip, ""))
	}
	if r.search != nil {
		localVarQueryParams.Add("$search", parameterToString(*r.search, ""))
	}
	if r.filter != nil {
		localVarQueryParams.Add("$filter", parameterToString(*r.filter, ""))
	}
	if r.count != nil {
		localVarQueryParams.Add("$count", parameterToString(*r.count, ""))
	}
	if r.orderby != nil {
		localVarQueryParams.Add("$orderby", parameterToString(*r.orderby, "csv"))
	}
	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiTeamsChannelsMessagesListRepliesRequest struct {
	ctx _context.Context
	ApiService *TeamsChannelApiService
	teamId string
	channelId string
	chatMessageId string
	top *int32
	skip *int32
	search *string
	filter *string
	count *bool
	orderby *[]string
	select_ *[]string
	expand *[]string
}

// Show only the first n items
func (r ApiTeamsChannelsMessagesListRepliesRequest) Top(top int32) ApiTeamsChannelsMessagesListRepliesRequest {
	r.top = &top
	return r
}
// Skip the first n items
func (r ApiTeamsChannelsMessagesListRepliesRequest) Skip(skip int32) ApiTeamsChannelsMessagesListRepliesRequest {
	r.skip = &skip
	return r
}
// Search items by search phrases
func (r ApiTeamsChannelsMessagesListRepliesRequest) Search(search string) ApiTeamsChannelsMessagesListRepliesRequest {
	r.search = &search
	return r
}
// Filter items by property values
func (r ApiTeamsChannelsMessagesListRepliesRequest) Filter(filter string) ApiTeamsChannelsMessagesListRepliesRequest {
	r.filter = &filter
	return r
}
// Include count of items
func (r ApiTeamsChannelsMessagesListRepliesRequest) Count(count bool) ApiTeamsChannelsMessagesListRepliesRequest {
	r.count = &count
	return r
}
// Order items by property values
func (r ApiTeamsChannelsMessagesListRepliesRequest) Orderby(orderby []string) ApiTeamsChannelsMessagesListRepliesRequest {
	r.orderby = &orderby
	return r
}
// Select properties to be returned
func (r ApiTeamsChannelsMessagesListRepliesRequest) Select_(select_ []string) ApiTeamsChannelsMessagesListRepliesRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiTeamsChannelsMessagesListRepliesRequest) Expand(expand []string) ApiTeamsChannelsMessagesListRepliesRequest {
	r.expand = &expand
	return r
}

func (r ApiTeamsChannelsMessagesListRepliesRequest) Execute() (CollectionOfChatMessage, *_nethttp.Response, error) {
	return r.ApiService.TeamsChannelsMessagesListRepliesExecute(r)
}

/*
TeamsChannelsMessagesListReplies Get replies from teams

Replies for a specified message.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param teamId key: id of team
 @param channelId key: id of channel
 @param chatMessageId key: id of chatMessage
 @return ApiTeamsChannelsMessagesListRepliesRequest
*/
func (a *TeamsChannelApiService) TeamsChannelsMessagesListReplies(ctx _context.Context, teamId string, channelId string, chatMessageId string) ApiTeamsChannelsMessagesListRepliesRequest {
	return ApiTeamsChannelsMessagesListRepliesRequest{
		ApiService: a,
		ctx: ctx,
		teamId: teamId,
		channelId: channelId,
		chatMessageId: chatMessageId,
	}
}

// Execute executes the request
//  @return CollectionOfChatMessage
func (a *TeamsChannelApiService) TeamsChannelsMessagesListRepliesExecute(r ApiTeamsChannelsMessagesListRepliesRequest) (CollectionOfChatMessage, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  CollectionOfChatMessage
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TeamsChannelApiService.TeamsChannelsMessagesListReplies")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/teams/{team-id}/channels/{channel-id}/messages/{chatMessage-id}/replies"
	localVarPath = strings.Replace(localVarPath, "{"+"team-id"+"}", _neturl.PathEscape(parameterToString(r.teamId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"channel-id"+"}", _neturl.PathEscape(parameterToString(r.channelId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"chatMessage-id"+"}", _neturl.PathEscape(parameterToString(r.chatMessageId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.top != nil {
		localVarQueryParams.Add("$top", parameterToString(*r.top, ""))
	}
	if r.skip != nil {
		localVarQueryParams.Add("$skip", parameterToString(*r.skip, ""))
	}
	if r.search != nil {
		localVarQueryParams.Add("$search", parameterToString(*r.search, ""))
	}
	if r.filter != nil {
		localVarQueryParams.Add("$filter", parameterToString(*r.filter, ""))
	}
	if r.count != nil {
		localVarQueryParams.Add("$count", parameterToString(*r.count, ""))
	}
	if r.orderby != nil {
		localVarQueryParams.Add("$orderby", parameterToString(*r.orderby, "csv"))
	}
	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiTeamsChannelsMessagesUpdateHostedContentsRequest struct {
	ctx _context.Context
	ApiService *TeamsChannelApiService
	teamId string
	channelId string
	chatMessageId string
	chatMessageHostedContentId string
	microsoftGraphChatMessageHostedContent *MicrosoftGraphChatMessageHostedContent
}

// New navigation property values
func (r ApiTeamsChannelsMessagesUpdateHostedContentsRequest) MicrosoftGraphChatMessageHostedContent(microsoftGraphChatMessageHostedContent MicrosoftGraphChatMessageHostedContent) ApiTeamsChannelsMessagesUpdateHostedContentsRequest {
	r.microsoftGraphChatMessageHostedContent = &microsoftGraphChatMessageHostedContent
	return r
}

func (r ApiTeamsChannelsMessagesUpdateHostedContentsRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.TeamsChannelsMessagesUpdateHostedContentsExecute(r)
}

/*
TeamsChannelsMessagesUpdateHostedContents Update the navigation property hostedContents in teams

Content in a message hosted by Microsoft Teams - for example, images or code snippets.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param teamId key: id of team
 @param channelId key: id of channel
 @param chatMessageId key: id of chatMessage
 @param chatMessageHostedContentId key: id of chatMessageHostedContent
 @return ApiTeamsChannelsMessagesUpdateHostedContentsRequest
*/
func (a *TeamsChannelApiService) TeamsChannelsMessagesUpdateHostedContents(ctx _context.Context, teamId string, channelId string, chatMessageId string, chatMessageHostedContentId string) ApiTeamsChannelsMessagesUpdateHostedContentsRequest {
	return ApiTeamsChannelsMessagesUpdateHostedContentsRequest{
		ApiService: a,
		ctx: ctx,
		teamId: teamId,
		channelId: channelId,
		chatMessageId: chatMessageId,
		chatMessageHostedContentId: chatMessageHostedContentId,
	}
}

// Execute executes the request
func (a *TeamsChannelApiService) TeamsChannelsMessagesUpdateHostedContentsExecute(r ApiTeamsChannelsMessagesUpdateHostedContentsRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPatch
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TeamsChannelApiService.TeamsChannelsMessagesUpdateHostedContents")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/teams/{team-id}/channels/{channel-id}/messages/{chatMessage-id}/hostedContents/{chatMessageHostedContent-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"team-id"+"}", _neturl.PathEscape(parameterToString(r.teamId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"channel-id"+"}", _neturl.PathEscape(parameterToString(r.channelId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"chatMessage-id"+"}", _neturl.PathEscape(parameterToString(r.chatMessageId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"chatMessageHostedContent-id"+"}", _neturl.PathEscape(parameterToString(r.chatMessageHostedContentId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphChatMessageHostedContent == nil {
		return nil, reportError("microsoftGraphChatMessageHostedContent is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphChatMessageHostedContent
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiTeamsChannelsMessagesUpdateRepliesRequest struct {
	ctx _context.Context
	ApiService *TeamsChannelApiService
	teamId string
	channelId string
	chatMessageId string
	chatMessageId1 string
	microsoftGraphChatMessage *MicrosoftGraphChatMessage
}

// New navigation property values
func (r ApiTeamsChannelsMessagesUpdateRepliesRequest) MicrosoftGraphChatMessage(microsoftGraphChatMessage MicrosoftGraphChatMessage) ApiTeamsChannelsMessagesUpdateRepliesRequest {
	r.microsoftGraphChatMessage = &microsoftGraphChatMessage
	return r
}

func (r ApiTeamsChannelsMessagesUpdateRepliesRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.TeamsChannelsMessagesUpdateRepliesExecute(r)
}

/*
TeamsChannelsMessagesUpdateReplies Update the navigation property replies in teams

Replies for a specified message.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param teamId key: id of team
 @param channelId key: id of channel
 @param chatMessageId key: id of chatMessage
 @param chatMessageId1 key: id of chatMessage
 @return ApiTeamsChannelsMessagesUpdateRepliesRequest
*/
func (a *TeamsChannelApiService) TeamsChannelsMessagesUpdateReplies(ctx _context.Context, teamId string, channelId string, chatMessageId string, chatMessageId1 string) ApiTeamsChannelsMessagesUpdateRepliesRequest {
	return ApiTeamsChannelsMessagesUpdateRepliesRequest{
		ApiService: a,
		ctx: ctx,
		teamId: teamId,
		channelId: channelId,
		chatMessageId: chatMessageId,
		chatMessageId1: chatMessageId1,
	}
}

// Execute executes the request
func (a *TeamsChannelApiService) TeamsChannelsMessagesUpdateRepliesExecute(r ApiTeamsChannelsMessagesUpdateRepliesRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPatch
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TeamsChannelApiService.TeamsChannelsMessagesUpdateReplies")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/teams/{team-id}/channels/{channel-id}/messages/{chatMessage-id}/replies/{chatMessage-id1}"
	localVarPath = strings.Replace(localVarPath, "{"+"team-id"+"}", _neturl.PathEscape(parameterToString(r.teamId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"channel-id"+"}", _neturl.PathEscape(parameterToString(r.channelId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"chatMessage-id"+"}", _neturl.PathEscape(parameterToString(r.chatMessageId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"chatMessage-id1"+"}", _neturl.PathEscape(parameterToString(r.chatMessageId1, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphChatMessage == nil {
		return nil, reportError("microsoftGraphChatMessage is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphChatMessage
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiTeamsChannelsTabsDeleteRefTeamsAppRequest struct {
	ctx _context.Context
	ApiService *TeamsChannelApiService
	teamId string
	channelId string
	teamsTabId string
	ifMatch *string
}

// ETag
func (r ApiTeamsChannelsTabsDeleteRefTeamsAppRequest) IfMatch(ifMatch string) ApiTeamsChannelsTabsDeleteRefTeamsAppRequest {
	r.ifMatch = &ifMatch
	return r
}

func (r ApiTeamsChannelsTabsDeleteRefTeamsAppRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.TeamsChannelsTabsDeleteRefTeamsAppExecute(r)
}

/*
TeamsChannelsTabsDeleteRefTeamsApp Delete ref of navigation property teamsApp for teams

The application that is linked to the tab. This cannot be changed after tab creation.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param teamId key: id of team
 @param channelId key: id of channel
 @param teamsTabId key: id of teamsTab
 @return ApiTeamsChannelsTabsDeleteRefTeamsAppRequest
*/
func (a *TeamsChannelApiService) TeamsChannelsTabsDeleteRefTeamsApp(ctx _context.Context, teamId string, channelId string, teamsTabId string) ApiTeamsChannelsTabsDeleteRefTeamsAppRequest {
	return ApiTeamsChannelsTabsDeleteRefTeamsAppRequest{
		ApiService: a,
		ctx: ctx,
		teamId: teamId,
		channelId: channelId,
		teamsTabId: teamsTabId,
	}
}

// Execute executes the request
func (a *TeamsChannelApiService) TeamsChannelsTabsDeleteRefTeamsAppExecute(r ApiTeamsChannelsTabsDeleteRefTeamsAppRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TeamsChannelApiService.TeamsChannelsTabsDeleteRefTeamsApp")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/teams/{team-id}/channels/{channel-id}/tabs/{teamsTab-id}/teamsApp/$ref"
	localVarPath = strings.Replace(localVarPath, "{"+"team-id"+"}", _neturl.PathEscape(parameterToString(r.teamId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"channel-id"+"}", _neturl.PathEscape(parameterToString(r.channelId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"teamsTab-id"+"}", _neturl.PathEscape(parameterToString(r.teamsTabId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ifMatch != nil {
		localVarHeaderParams["If-Match"] = parameterToString(*r.ifMatch, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiTeamsChannelsTabsGetRefTeamsAppRequest struct {
	ctx _context.Context
	ApiService *TeamsChannelApiService
	teamId string
	channelId string
	teamsTabId string
}


func (r ApiTeamsChannelsTabsGetRefTeamsAppRequest) Execute() (string, *_nethttp.Response, error) {
	return r.ApiService.TeamsChannelsTabsGetRefTeamsAppExecute(r)
}

/*
TeamsChannelsTabsGetRefTeamsApp Get ref of teamsApp from teams

The application that is linked to the tab. This cannot be changed after tab creation.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param teamId key: id of team
 @param channelId key: id of channel
 @param teamsTabId key: id of teamsTab
 @return ApiTeamsChannelsTabsGetRefTeamsAppRequest
*/
func (a *TeamsChannelApiService) TeamsChannelsTabsGetRefTeamsApp(ctx _context.Context, teamId string, channelId string, teamsTabId string) ApiTeamsChannelsTabsGetRefTeamsAppRequest {
	return ApiTeamsChannelsTabsGetRefTeamsAppRequest{
		ApiService: a,
		ctx: ctx,
		teamId: teamId,
		channelId: channelId,
		teamsTabId: teamsTabId,
	}
}

// Execute executes the request
//  @return string
func (a *TeamsChannelApiService) TeamsChannelsTabsGetRefTeamsAppExecute(r ApiTeamsChannelsTabsGetRefTeamsAppRequest) (string, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  string
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TeamsChannelApiService.TeamsChannelsTabsGetRefTeamsApp")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/teams/{team-id}/channels/{channel-id}/tabs/{teamsTab-id}/teamsApp/$ref"
	localVarPath = strings.Replace(localVarPath, "{"+"team-id"+"}", _neturl.PathEscape(parameterToString(r.teamId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"channel-id"+"}", _neturl.PathEscape(parameterToString(r.channelId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"teamsTab-id"+"}", _neturl.PathEscape(parameterToString(r.teamsTabId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiTeamsChannelsTabsGetTeamsAppRequest struct {
	ctx _context.Context
	ApiService *TeamsChannelApiService
	teamId string
	channelId string
	teamsTabId string
	select_ *[]string
	expand *[]string
}

// Select properties to be returned
func (r ApiTeamsChannelsTabsGetTeamsAppRequest) Select_(select_ []string) ApiTeamsChannelsTabsGetTeamsAppRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiTeamsChannelsTabsGetTeamsAppRequest) Expand(expand []string) ApiTeamsChannelsTabsGetTeamsAppRequest {
	r.expand = &expand
	return r
}

func (r ApiTeamsChannelsTabsGetTeamsAppRequest) Execute() (MicrosoftGraphTeamsApp, *_nethttp.Response, error) {
	return r.ApiService.TeamsChannelsTabsGetTeamsAppExecute(r)
}

/*
TeamsChannelsTabsGetTeamsApp Get teamsApp from teams

The application that is linked to the tab. This cannot be changed after tab creation.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param teamId key: id of team
 @param channelId key: id of channel
 @param teamsTabId key: id of teamsTab
 @return ApiTeamsChannelsTabsGetTeamsAppRequest
*/
func (a *TeamsChannelApiService) TeamsChannelsTabsGetTeamsApp(ctx _context.Context, teamId string, channelId string, teamsTabId string) ApiTeamsChannelsTabsGetTeamsAppRequest {
	return ApiTeamsChannelsTabsGetTeamsAppRequest{
		ApiService: a,
		ctx: ctx,
		teamId: teamId,
		channelId: channelId,
		teamsTabId: teamsTabId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphTeamsApp
func (a *TeamsChannelApiService) TeamsChannelsTabsGetTeamsAppExecute(r ApiTeamsChannelsTabsGetTeamsAppRequest) (MicrosoftGraphTeamsApp, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphTeamsApp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TeamsChannelApiService.TeamsChannelsTabsGetTeamsApp")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/teams/{team-id}/channels/{channel-id}/tabs/{teamsTab-id}/teamsApp"
	localVarPath = strings.Replace(localVarPath, "{"+"team-id"+"}", _neturl.PathEscape(parameterToString(r.teamId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"channel-id"+"}", _neturl.PathEscape(parameterToString(r.channelId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"teamsTab-id"+"}", _neturl.PathEscape(parameterToString(r.teamsTabId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiTeamsChannelsTabsUpdateRefTeamsAppRequest struct {
	ctx _context.Context
	ApiService *TeamsChannelApiService
	teamId string
	channelId string
	teamsTabId string
	requestBody *map[string]map[string]interface{}
}

// New navigation property ref values
func (r ApiTeamsChannelsTabsUpdateRefTeamsAppRequest) RequestBody(requestBody map[string]map[string]interface{}) ApiTeamsChannelsTabsUpdateRefTeamsAppRequest {
	r.requestBody = &requestBody
	return r
}

func (r ApiTeamsChannelsTabsUpdateRefTeamsAppRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.TeamsChannelsTabsUpdateRefTeamsAppExecute(r)
}

/*
TeamsChannelsTabsUpdateRefTeamsApp Update the ref of navigation property teamsApp in teams

The application that is linked to the tab. This cannot be changed after tab creation.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param teamId key: id of team
 @param channelId key: id of channel
 @param teamsTabId key: id of teamsTab
 @return ApiTeamsChannelsTabsUpdateRefTeamsAppRequest
*/
func (a *TeamsChannelApiService) TeamsChannelsTabsUpdateRefTeamsApp(ctx _context.Context, teamId string, channelId string, teamsTabId string) ApiTeamsChannelsTabsUpdateRefTeamsAppRequest {
	return ApiTeamsChannelsTabsUpdateRefTeamsAppRequest{
		ApiService: a,
		ctx: ctx,
		teamId: teamId,
		channelId: channelId,
		teamsTabId: teamsTabId,
	}
}

// Execute executes the request
func (a *TeamsChannelApiService) TeamsChannelsTabsUpdateRefTeamsAppExecute(r ApiTeamsChannelsTabsUpdateRefTeamsAppRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPut
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TeamsChannelApiService.TeamsChannelsTabsUpdateRefTeamsApp")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/teams/{team-id}/channels/{channel-id}/tabs/{teamsTab-id}/teamsApp/$ref"
	localVarPath = strings.Replace(localVarPath, "{"+"team-id"+"}", _neturl.PathEscape(parameterToString(r.teamId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"channel-id"+"}", _neturl.PathEscape(parameterToString(r.channelId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"teamsTab-id"+"}", _neturl.PathEscape(parameterToString(r.teamsTabId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.requestBody == nil {
		return nil, reportError("requestBody is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.requestBody
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiTeamsChannelsUpdateFilesFolderRequest struct {
	ctx _context.Context
	ApiService *TeamsChannelApiService
	teamId string
	channelId string
	microsoftGraphDriveItem *MicrosoftGraphDriveItem
}

// New navigation property values
func (r ApiTeamsChannelsUpdateFilesFolderRequest) MicrosoftGraphDriveItem(microsoftGraphDriveItem MicrosoftGraphDriveItem) ApiTeamsChannelsUpdateFilesFolderRequest {
	r.microsoftGraphDriveItem = &microsoftGraphDriveItem
	return r
}

func (r ApiTeamsChannelsUpdateFilesFolderRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.TeamsChannelsUpdateFilesFolderExecute(r)
}

/*
TeamsChannelsUpdateFilesFolder Update the navigation property filesFolder in teams

Metadata for the location where the channel's files are stored.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param teamId key: id of team
 @param channelId key: id of channel
 @return ApiTeamsChannelsUpdateFilesFolderRequest
*/
func (a *TeamsChannelApiService) TeamsChannelsUpdateFilesFolder(ctx _context.Context, teamId string, channelId string) ApiTeamsChannelsUpdateFilesFolderRequest {
	return ApiTeamsChannelsUpdateFilesFolderRequest{
		ApiService: a,
		ctx: ctx,
		teamId: teamId,
		channelId: channelId,
	}
}

// Execute executes the request
func (a *TeamsChannelApiService) TeamsChannelsUpdateFilesFolderExecute(r ApiTeamsChannelsUpdateFilesFolderRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPatch
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TeamsChannelApiService.TeamsChannelsUpdateFilesFolder")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/teams/{team-id}/channels/{channel-id}/filesFolder"
	localVarPath = strings.Replace(localVarPath, "{"+"team-id"+"}", _neturl.PathEscape(parameterToString(r.teamId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"channel-id"+"}", _neturl.PathEscape(parameterToString(r.channelId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphDriveItem == nil {
		return nil, reportError("microsoftGraphDriveItem is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphDriveItem
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiTeamsChannelsUpdateFilesFolderContentRequest struct {
	ctx _context.Context
	ApiService *TeamsChannelApiService
	teamId string
	channelId string
	body **os.File
}

// New media content.
func (r ApiTeamsChannelsUpdateFilesFolderContentRequest) Body(body *os.File) ApiTeamsChannelsUpdateFilesFolderContentRequest {
	r.body = &body
	return r
}

func (r ApiTeamsChannelsUpdateFilesFolderContentRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.TeamsChannelsUpdateFilesFolderContentExecute(r)
}

/*
TeamsChannelsUpdateFilesFolderContent Update media content for the navigation property filesFolder in teams

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param teamId key: id of team
 @param channelId key: id of channel
 @return ApiTeamsChannelsUpdateFilesFolderContentRequest
*/
func (a *TeamsChannelApiService) TeamsChannelsUpdateFilesFolderContent(ctx _context.Context, teamId string, channelId string) ApiTeamsChannelsUpdateFilesFolderContentRequest {
	return ApiTeamsChannelsUpdateFilesFolderContentRequest{
		ApiService: a,
		ctx: ctx,
		teamId: teamId,
		channelId: channelId,
	}
}

// Execute executes the request
func (a *TeamsChannelApiService) TeamsChannelsUpdateFilesFolderContentExecute(r ApiTeamsChannelsUpdateFilesFolderContentRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPut
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TeamsChannelApiService.TeamsChannelsUpdateFilesFolderContent")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/teams/{team-id}/channels/{channel-id}/filesFolder/content"
	localVarPath = strings.Replace(localVarPath, "{"+"team-id"+"}", _neturl.PathEscape(parameterToString(r.teamId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"channel-id"+"}", _neturl.PathEscape(parameterToString(r.channelId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.body == nil {
		return nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/octet-stream"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiTeamsChannelsUpdateMembersRequest struct {
	ctx _context.Context
	ApiService *TeamsChannelApiService
	teamId string
	channelId string
	conversationMemberId string
	microsoftGraphConversationMember *MicrosoftGraphConversationMember
}

// New navigation property values
func (r ApiTeamsChannelsUpdateMembersRequest) MicrosoftGraphConversationMember(microsoftGraphConversationMember MicrosoftGraphConversationMember) ApiTeamsChannelsUpdateMembersRequest {
	r.microsoftGraphConversationMember = &microsoftGraphConversationMember
	return r
}

func (r ApiTeamsChannelsUpdateMembersRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.TeamsChannelsUpdateMembersExecute(r)
}

/*
TeamsChannelsUpdateMembers Update the navigation property members in teams

A collection of membership records associated with the channel.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param teamId key: id of team
 @param channelId key: id of channel
 @param conversationMemberId key: id of conversationMember
 @return ApiTeamsChannelsUpdateMembersRequest
*/
func (a *TeamsChannelApiService) TeamsChannelsUpdateMembers(ctx _context.Context, teamId string, channelId string, conversationMemberId string) ApiTeamsChannelsUpdateMembersRequest {
	return ApiTeamsChannelsUpdateMembersRequest{
		ApiService: a,
		ctx: ctx,
		teamId: teamId,
		channelId: channelId,
		conversationMemberId: conversationMemberId,
	}
}

// Execute executes the request
func (a *TeamsChannelApiService) TeamsChannelsUpdateMembersExecute(r ApiTeamsChannelsUpdateMembersRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPatch
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TeamsChannelApiService.TeamsChannelsUpdateMembers")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/teams/{team-id}/channels/{channel-id}/members/{conversationMember-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"team-id"+"}", _neturl.PathEscape(parameterToString(r.teamId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"channel-id"+"}", _neturl.PathEscape(parameterToString(r.channelId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"conversationMember-id"+"}", _neturl.PathEscape(parameterToString(r.conversationMemberId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphConversationMember == nil {
		return nil, reportError("microsoftGraphConversationMember is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphConversationMember
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiTeamsChannelsUpdateMessagesRequest struct {
	ctx _context.Context
	ApiService *TeamsChannelApiService
	teamId string
	channelId string
	chatMessageId string
	microsoftGraphChatMessage *MicrosoftGraphChatMessage
}

// New navigation property values
func (r ApiTeamsChannelsUpdateMessagesRequest) MicrosoftGraphChatMessage(microsoftGraphChatMessage MicrosoftGraphChatMessage) ApiTeamsChannelsUpdateMessagesRequest {
	r.microsoftGraphChatMessage = &microsoftGraphChatMessage
	return r
}

func (r ApiTeamsChannelsUpdateMessagesRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.TeamsChannelsUpdateMessagesExecute(r)
}

/*
TeamsChannelsUpdateMessages Update the navigation property messages in teams

A collection of all the messages in the channel. A navigation property. Nullable.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param teamId key: id of team
 @param channelId key: id of channel
 @param chatMessageId key: id of chatMessage
 @return ApiTeamsChannelsUpdateMessagesRequest
*/
func (a *TeamsChannelApiService) TeamsChannelsUpdateMessages(ctx _context.Context, teamId string, channelId string, chatMessageId string) ApiTeamsChannelsUpdateMessagesRequest {
	return ApiTeamsChannelsUpdateMessagesRequest{
		ApiService: a,
		ctx: ctx,
		teamId: teamId,
		channelId: channelId,
		chatMessageId: chatMessageId,
	}
}

// Execute executes the request
func (a *TeamsChannelApiService) TeamsChannelsUpdateMessagesExecute(r ApiTeamsChannelsUpdateMessagesRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPatch
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TeamsChannelApiService.TeamsChannelsUpdateMessages")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/teams/{team-id}/channels/{channel-id}/messages/{chatMessage-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"team-id"+"}", _neturl.PathEscape(parameterToString(r.teamId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"channel-id"+"}", _neturl.PathEscape(parameterToString(r.channelId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"chatMessage-id"+"}", _neturl.PathEscape(parameterToString(r.chatMessageId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphChatMessage == nil {
		return nil, reportError("microsoftGraphChatMessage is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphChatMessage
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiTeamsChannelsUpdateTabsRequest struct {
	ctx _context.Context
	ApiService *TeamsChannelApiService
	teamId string
	channelId string
	teamsTabId string
	microsoftGraphTeamsTab *MicrosoftGraphTeamsTab
}

// New navigation property values
func (r ApiTeamsChannelsUpdateTabsRequest) MicrosoftGraphTeamsTab(microsoftGraphTeamsTab MicrosoftGraphTeamsTab) ApiTeamsChannelsUpdateTabsRequest {
	r.microsoftGraphTeamsTab = &microsoftGraphTeamsTab
	return r
}

func (r ApiTeamsChannelsUpdateTabsRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.TeamsChannelsUpdateTabsExecute(r)
}

/*
TeamsChannelsUpdateTabs Update the navigation property tabs in teams

A collection of all the tabs in the channel. A navigation property.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param teamId key: id of team
 @param channelId key: id of channel
 @param teamsTabId key: id of teamsTab
 @return ApiTeamsChannelsUpdateTabsRequest
*/
func (a *TeamsChannelApiService) TeamsChannelsUpdateTabs(ctx _context.Context, teamId string, channelId string, teamsTabId string) ApiTeamsChannelsUpdateTabsRequest {
	return ApiTeamsChannelsUpdateTabsRequest{
		ApiService: a,
		ctx: ctx,
		teamId: teamId,
		channelId: channelId,
		teamsTabId: teamsTabId,
	}
}

// Execute executes the request
func (a *TeamsChannelApiService) TeamsChannelsUpdateTabsExecute(r ApiTeamsChannelsUpdateTabsRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPatch
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TeamsChannelApiService.TeamsChannelsUpdateTabs")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/teams/{team-id}/channels/{channel-id}/tabs/{teamsTab-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"team-id"+"}", _neturl.PathEscape(parameterToString(r.teamId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"channel-id"+"}", _neturl.PathEscape(parameterToString(r.channelId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"teamsTab-id"+"}", _neturl.PathEscape(parameterToString(r.teamsTabId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphTeamsTab == nil {
		return nil, reportError("microsoftGraphTeamsTab is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphTeamsTab
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiTeamsCreateChannelsRequest struct {
	ctx _context.Context
	ApiService *TeamsChannelApiService
	teamId string
	microsoftGraphChannel *MicrosoftGraphChannel
}

// New navigation property
func (r ApiTeamsCreateChannelsRequest) MicrosoftGraphChannel(microsoftGraphChannel MicrosoftGraphChannel) ApiTeamsCreateChannelsRequest {
	r.microsoftGraphChannel = &microsoftGraphChannel
	return r
}

func (r ApiTeamsCreateChannelsRequest) Execute() (MicrosoftGraphChannel, *_nethttp.Response, error) {
	return r.ApiService.TeamsCreateChannelsExecute(r)
}

/*
TeamsCreateChannels Create new navigation property to channels for teams

The collection of channels & messages associated with the team.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param teamId key: id of team
 @return ApiTeamsCreateChannelsRequest
*/
func (a *TeamsChannelApiService) TeamsCreateChannels(ctx _context.Context, teamId string) ApiTeamsCreateChannelsRequest {
	return ApiTeamsCreateChannelsRequest{
		ApiService: a,
		ctx: ctx,
		teamId: teamId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphChannel
func (a *TeamsChannelApiService) TeamsCreateChannelsExecute(r ApiTeamsCreateChannelsRequest) (MicrosoftGraphChannel, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphChannel
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TeamsChannelApiService.TeamsCreateChannels")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/teams/{team-id}/channels"
	localVarPath = strings.Replace(localVarPath, "{"+"team-id"+"}", _neturl.PathEscape(parameterToString(r.teamId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphChannel == nil {
		return localVarReturnValue, nil, reportError("microsoftGraphChannel is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphChannel
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiTeamsDeleteChannelsRequest struct {
	ctx _context.Context
	ApiService *TeamsChannelApiService
	teamId string
	channelId string
	ifMatch *string
}

// ETag
func (r ApiTeamsDeleteChannelsRequest) IfMatch(ifMatch string) ApiTeamsDeleteChannelsRequest {
	r.ifMatch = &ifMatch
	return r
}

func (r ApiTeamsDeleteChannelsRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.TeamsDeleteChannelsExecute(r)
}

/*
TeamsDeleteChannels Delete navigation property channels for teams

The collection of channels & messages associated with the team.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param teamId key: id of team
 @param channelId key: id of channel
 @return ApiTeamsDeleteChannelsRequest
*/
func (a *TeamsChannelApiService) TeamsDeleteChannels(ctx _context.Context, teamId string, channelId string) ApiTeamsDeleteChannelsRequest {
	return ApiTeamsDeleteChannelsRequest{
		ApiService: a,
		ctx: ctx,
		teamId: teamId,
		channelId: channelId,
	}
}

// Execute executes the request
func (a *TeamsChannelApiService) TeamsDeleteChannelsExecute(r ApiTeamsDeleteChannelsRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TeamsChannelApiService.TeamsDeleteChannels")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/teams/{team-id}/channels/{channel-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"team-id"+"}", _neturl.PathEscape(parameterToString(r.teamId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"channel-id"+"}", _neturl.PathEscape(parameterToString(r.channelId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ifMatch != nil {
		localVarHeaderParams["If-Match"] = parameterToString(*r.ifMatch, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiTeamsDeletePrimaryChannelRequest struct {
	ctx _context.Context
	ApiService *TeamsChannelApiService
	teamId string
	ifMatch *string
}

// ETag
func (r ApiTeamsDeletePrimaryChannelRequest) IfMatch(ifMatch string) ApiTeamsDeletePrimaryChannelRequest {
	r.ifMatch = &ifMatch
	return r
}

func (r ApiTeamsDeletePrimaryChannelRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.TeamsDeletePrimaryChannelExecute(r)
}

/*
TeamsDeletePrimaryChannel Delete navigation property primaryChannel for teams

The general channel for the team.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param teamId key: id of team
 @return ApiTeamsDeletePrimaryChannelRequest
*/
func (a *TeamsChannelApiService) TeamsDeletePrimaryChannel(ctx _context.Context, teamId string) ApiTeamsDeletePrimaryChannelRequest {
	return ApiTeamsDeletePrimaryChannelRequest{
		ApiService: a,
		ctx: ctx,
		teamId: teamId,
	}
}

// Execute executes the request
func (a *TeamsChannelApiService) TeamsDeletePrimaryChannelExecute(r ApiTeamsDeletePrimaryChannelRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TeamsChannelApiService.TeamsDeletePrimaryChannel")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/teams/{team-id}/primaryChannel"
	localVarPath = strings.Replace(localVarPath, "{"+"team-id"+"}", _neturl.PathEscape(parameterToString(r.teamId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ifMatch != nil {
		localVarHeaderParams["If-Match"] = parameterToString(*r.ifMatch, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiTeamsGetChannelsRequest struct {
	ctx _context.Context
	ApiService *TeamsChannelApiService
	teamId string
	channelId string
	select_ *[]string
	expand *[]string
}

// Select properties to be returned
func (r ApiTeamsGetChannelsRequest) Select_(select_ []string) ApiTeamsGetChannelsRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiTeamsGetChannelsRequest) Expand(expand []string) ApiTeamsGetChannelsRequest {
	r.expand = &expand
	return r
}

func (r ApiTeamsGetChannelsRequest) Execute() (MicrosoftGraphChannel, *_nethttp.Response, error) {
	return r.ApiService.TeamsGetChannelsExecute(r)
}

/*
TeamsGetChannels Get channels from teams

The collection of channels & messages associated with the team.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param teamId key: id of team
 @param channelId key: id of channel
 @return ApiTeamsGetChannelsRequest
*/
func (a *TeamsChannelApiService) TeamsGetChannels(ctx _context.Context, teamId string, channelId string) ApiTeamsGetChannelsRequest {
	return ApiTeamsGetChannelsRequest{
		ApiService: a,
		ctx: ctx,
		teamId: teamId,
		channelId: channelId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphChannel
func (a *TeamsChannelApiService) TeamsGetChannelsExecute(r ApiTeamsGetChannelsRequest) (MicrosoftGraphChannel, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphChannel
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TeamsChannelApiService.TeamsGetChannels")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/teams/{team-id}/channels/{channel-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"team-id"+"}", _neturl.PathEscape(parameterToString(r.teamId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"channel-id"+"}", _neturl.PathEscape(parameterToString(r.channelId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiTeamsGetPrimaryChannelRequest struct {
	ctx _context.Context
	ApiService *TeamsChannelApiService
	teamId string
	select_ *[]string
	expand *[]string
}

// Select properties to be returned
func (r ApiTeamsGetPrimaryChannelRequest) Select_(select_ []string) ApiTeamsGetPrimaryChannelRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiTeamsGetPrimaryChannelRequest) Expand(expand []string) ApiTeamsGetPrimaryChannelRequest {
	r.expand = &expand
	return r
}

func (r ApiTeamsGetPrimaryChannelRequest) Execute() (MicrosoftGraphChannel, *_nethttp.Response, error) {
	return r.ApiService.TeamsGetPrimaryChannelExecute(r)
}

/*
TeamsGetPrimaryChannel Get primaryChannel from teams

The general channel for the team.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param teamId key: id of team
 @return ApiTeamsGetPrimaryChannelRequest
*/
func (a *TeamsChannelApiService) TeamsGetPrimaryChannel(ctx _context.Context, teamId string) ApiTeamsGetPrimaryChannelRequest {
	return ApiTeamsGetPrimaryChannelRequest{
		ApiService: a,
		ctx: ctx,
		teamId: teamId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphChannel
func (a *TeamsChannelApiService) TeamsGetPrimaryChannelExecute(r ApiTeamsGetPrimaryChannelRequest) (MicrosoftGraphChannel, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphChannel
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TeamsChannelApiService.TeamsGetPrimaryChannel")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/teams/{team-id}/primaryChannel"
	localVarPath = strings.Replace(localVarPath, "{"+"team-id"+"}", _neturl.PathEscape(parameterToString(r.teamId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiTeamsListChannelsRequest struct {
	ctx _context.Context
	ApiService *TeamsChannelApiService
	teamId string
	top *int32
	skip *int32
	search *string
	filter *string
	count *bool
	orderby *[]string
	select_ *[]string
	expand *[]string
}

// Show only the first n items
func (r ApiTeamsListChannelsRequest) Top(top int32) ApiTeamsListChannelsRequest {
	r.top = &top
	return r
}
// Skip the first n items
func (r ApiTeamsListChannelsRequest) Skip(skip int32) ApiTeamsListChannelsRequest {
	r.skip = &skip
	return r
}
// Search items by search phrases
func (r ApiTeamsListChannelsRequest) Search(search string) ApiTeamsListChannelsRequest {
	r.search = &search
	return r
}
// Filter items by property values
func (r ApiTeamsListChannelsRequest) Filter(filter string) ApiTeamsListChannelsRequest {
	r.filter = &filter
	return r
}
// Include count of items
func (r ApiTeamsListChannelsRequest) Count(count bool) ApiTeamsListChannelsRequest {
	r.count = &count
	return r
}
// Order items by property values
func (r ApiTeamsListChannelsRequest) Orderby(orderby []string) ApiTeamsListChannelsRequest {
	r.orderby = &orderby
	return r
}
// Select properties to be returned
func (r ApiTeamsListChannelsRequest) Select_(select_ []string) ApiTeamsListChannelsRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiTeamsListChannelsRequest) Expand(expand []string) ApiTeamsListChannelsRequest {
	r.expand = &expand
	return r
}

func (r ApiTeamsListChannelsRequest) Execute() (CollectionOfChannel, *_nethttp.Response, error) {
	return r.ApiService.TeamsListChannelsExecute(r)
}

/*
TeamsListChannels Get channels from teams

The collection of channels & messages associated with the team.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param teamId key: id of team
 @return ApiTeamsListChannelsRequest
*/
func (a *TeamsChannelApiService) TeamsListChannels(ctx _context.Context, teamId string) ApiTeamsListChannelsRequest {
	return ApiTeamsListChannelsRequest{
		ApiService: a,
		ctx: ctx,
		teamId: teamId,
	}
}

// Execute executes the request
//  @return CollectionOfChannel
func (a *TeamsChannelApiService) TeamsListChannelsExecute(r ApiTeamsListChannelsRequest) (CollectionOfChannel, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  CollectionOfChannel
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TeamsChannelApiService.TeamsListChannels")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/teams/{team-id}/channels"
	localVarPath = strings.Replace(localVarPath, "{"+"team-id"+"}", _neturl.PathEscape(parameterToString(r.teamId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.top != nil {
		localVarQueryParams.Add("$top", parameterToString(*r.top, ""))
	}
	if r.skip != nil {
		localVarQueryParams.Add("$skip", parameterToString(*r.skip, ""))
	}
	if r.search != nil {
		localVarQueryParams.Add("$search", parameterToString(*r.search, ""))
	}
	if r.filter != nil {
		localVarQueryParams.Add("$filter", parameterToString(*r.filter, ""))
	}
	if r.count != nil {
		localVarQueryParams.Add("$count", parameterToString(*r.count, ""))
	}
	if r.orderby != nil {
		localVarQueryParams.Add("$orderby", parameterToString(*r.orderby, "csv"))
	}
	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiTeamsPrimaryChannelCreateMembersRequest struct {
	ctx _context.Context
	ApiService *TeamsChannelApiService
	teamId string
	microsoftGraphConversationMember *MicrosoftGraphConversationMember
}

// New navigation property
func (r ApiTeamsPrimaryChannelCreateMembersRequest) MicrosoftGraphConversationMember(microsoftGraphConversationMember MicrosoftGraphConversationMember) ApiTeamsPrimaryChannelCreateMembersRequest {
	r.microsoftGraphConversationMember = &microsoftGraphConversationMember
	return r
}

func (r ApiTeamsPrimaryChannelCreateMembersRequest) Execute() (MicrosoftGraphConversationMember, *_nethttp.Response, error) {
	return r.ApiService.TeamsPrimaryChannelCreateMembersExecute(r)
}

/*
TeamsPrimaryChannelCreateMembers Create new navigation property to members for teams

A collection of membership records associated with the channel.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param teamId key: id of team
 @return ApiTeamsPrimaryChannelCreateMembersRequest
*/
func (a *TeamsChannelApiService) TeamsPrimaryChannelCreateMembers(ctx _context.Context, teamId string) ApiTeamsPrimaryChannelCreateMembersRequest {
	return ApiTeamsPrimaryChannelCreateMembersRequest{
		ApiService: a,
		ctx: ctx,
		teamId: teamId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphConversationMember
func (a *TeamsChannelApiService) TeamsPrimaryChannelCreateMembersExecute(r ApiTeamsPrimaryChannelCreateMembersRequest) (MicrosoftGraphConversationMember, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphConversationMember
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TeamsChannelApiService.TeamsPrimaryChannelCreateMembers")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/teams/{team-id}/primaryChannel/members"
	localVarPath = strings.Replace(localVarPath, "{"+"team-id"+"}", _neturl.PathEscape(parameterToString(r.teamId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphConversationMember == nil {
		return localVarReturnValue, nil, reportError("microsoftGraphConversationMember is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphConversationMember
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiTeamsPrimaryChannelCreateMessagesRequest struct {
	ctx _context.Context
	ApiService *TeamsChannelApiService
	teamId string
	microsoftGraphChatMessage *MicrosoftGraphChatMessage
}

// New navigation property
func (r ApiTeamsPrimaryChannelCreateMessagesRequest) MicrosoftGraphChatMessage(microsoftGraphChatMessage MicrosoftGraphChatMessage) ApiTeamsPrimaryChannelCreateMessagesRequest {
	r.microsoftGraphChatMessage = &microsoftGraphChatMessage
	return r
}

func (r ApiTeamsPrimaryChannelCreateMessagesRequest) Execute() (MicrosoftGraphChatMessage, *_nethttp.Response, error) {
	return r.ApiService.TeamsPrimaryChannelCreateMessagesExecute(r)
}

/*
TeamsPrimaryChannelCreateMessages Create new navigation property to messages for teams

A collection of all the messages in the channel. A navigation property. Nullable.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param teamId key: id of team
 @return ApiTeamsPrimaryChannelCreateMessagesRequest
*/
func (a *TeamsChannelApiService) TeamsPrimaryChannelCreateMessages(ctx _context.Context, teamId string) ApiTeamsPrimaryChannelCreateMessagesRequest {
	return ApiTeamsPrimaryChannelCreateMessagesRequest{
		ApiService: a,
		ctx: ctx,
		teamId: teamId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphChatMessage
func (a *TeamsChannelApiService) TeamsPrimaryChannelCreateMessagesExecute(r ApiTeamsPrimaryChannelCreateMessagesRequest) (MicrosoftGraphChatMessage, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphChatMessage
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TeamsChannelApiService.TeamsPrimaryChannelCreateMessages")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/teams/{team-id}/primaryChannel/messages"
	localVarPath = strings.Replace(localVarPath, "{"+"team-id"+"}", _neturl.PathEscape(parameterToString(r.teamId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphChatMessage == nil {
		return localVarReturnValue, nil, reportError("microsoftGraphChatMessage is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphChatMessage
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiTeamsPrimaryChannelCreateTabsRequest struct {
	ctx _context.Context
	ApiService *TeamsChannelApiService
	teamId string
	microsoftGraphTeamsTab *MicrosoftGraphTeamsTab
}

// New navigation property
func (r ApiTeamsPrimaryChannelCreateTabsRequest) MicrosoftGraphTeamsTab(microsoftGraphTeamsTab MicrosoftGraphTeamsTab) ApiTeamsPrimaryChannelCreateTabsRequest {
	r.microsoftGraphTeamsTab = &microsoftGraphTeamsTab
	return r
}

func (r ApiTeamsPrimaryChannelCreateTabsRequest) Execute() (MicrosoftGraphTeamsTab, *_nethttp.Response, error) {
	return r.ApiService.TeamsPrimaryChannelCreateTabsExecute(r)
}

/*
TeamsPrimaryChannelCreateTabs Create new navigation property to tabs for teams

A collection of all the tabs in the channel. A navigation property.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param teamId key: id of team
 @return ApiTeamsPrimaryChannelCreateTabsRequest
*/
func (a *TeamsChannelApiService) TeamsPrimaryChannelCreateTabs(ctx _context.Context, teamId string) ApiTeamsPrimaryChannelCreateTabsRequest {
	return ApiTeamsPrimaryChannelCreateTabsRequest{
		ApiService: a,
		ctx: ctx,
		teamId: teamId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphTeamsTab
func (a *TeamsChannelApiService) TeamsPrimaryChannelCreateTabsExecute(r ApiTeamsPrimaryChannelCreateTabsRequest) (MicrosoftGraphTeamsTab, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphTeamsTab
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TeamsChannelApiService.TeamsPrimaryChannelCreateTabs")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/teams/{team-id}/primaryChannel/tabs"
	localVarPath = strings.Replace(localVarPath, "{"+"team-id"+"}", _neturl.PathEscape(parameterToString(r.teamId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphTeamsTab == nil {
		return localVarReturnValue, nil, reportError("microsoftGraphTeamsTab is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphTeamsTab
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiTeamsPrimaryChannelDeleteFilesFolderRequest struct {
	ctx _context.Context
	ApiService *TeamsChannelApiService
	teamId string
	ifMatch *string
}

// ETag
func (r ApiTeamsPrimaryChannelDeleteFilesFolderRequest) IfMatch(ifMatch string) ApiTeamsPrimaryChannelDeleteFilesFolderRequest {
	r.ifMatch = &ifMatch
	return r
}

func (r ApiTeamsPrimaryChannelDeleteFilesFolderRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.TeamsPrimaryChannelDeleteFilesFolderExecute(r)
}

/*
TeamsPrimaryChannelDeleteFilesFolder Delete navigation property filesFolder for teams

Metadata for the location where the channel's files are stored.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param teamId key: id of team
 @return ApiTeamsPrimaryChannelDeleteFilesFolderRequest
*/
func (a *TeamsChannelApiService) TeamsPrimaryChannelDeleteFilesFolder(ctx _context.Context, teamId string) ApiTeamsPrimaryChannelDeleteFilesFolderRequest {
	return ApiTeamsPrimaryChannelDeleteFilesFolderRequest{
		ApiService: a,
		ctx: ctx,
		teamId: teamId,
	}
}

// Execute executes the request
func (a *TeamsChannelApiService) TeamsPrimaryChannelDeleteFilesFolderExecute(r ApiTeamsPrimaryChannelDeleteFilesFolderRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TeamsChannelApiService.TeamsPrimaryChannelDeleteFilesFolder")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/teams/{team-id}/primaryChannel/filesFolder"
	localVarPath = strings.Replace(localVarPath, "{"+"team-id"+"}", _neturl.PathEscape(parameterToString(r.teamId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ifMatch != nil {
		localVarHeaderParams["If-Match"] = parameterToString(*r.ifMatch, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiTeamsPrimaryChannelDeleteMembersRequest struct {
	ctx _context.Context
	ApiService *TeamsChannelApiService
	teamId string
	conversationMemberId string
	ifMatch *string
}

// ETag
func (r ApiTeamsPrimaryChannelDeleteMembersRequest) IfMatch(ifMatch string) ApiTeamsPrimaryChannelDeleteMembersRequest {
	r.ifMatch = &ifMatch
	return r
}

func (r ApiTeamsPrimaryChannelDeleteMembersRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.TeamsPrimaryChannelDeleteMembersExecute(r)
}

/*
TeamsPrimaryChannelDeleteMembers Delete navigation property members for teams

A collection of membership records associated with the channel.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param teamId key: id of team
 @param conversationMemberId key: id of conversationMember
 @return ApiTeamsPrimaryChannelDeleteMembersRequest
*/
func (a *TeamsChannelApiService) TeamsPrimaryChannelDeleteMembers(ctx _context.Context, teamId string, conversationMemberId string) ApiTeamsPrimaryChannelDeleteMembersRequest {
	return ApiTeamsPrimaryChannelDeleteMembersRequest{
		ApiService: a,
		ctx: ctx,
		teamId: teamId,
		conversationMemberId: conversationMemberId,
	}
}

// Execute executes the request
func (a *TeamsChannelApiService) TeamsPrimaryChannelDeleteMembersExecute(r ApiTeamsPrimaryChannelDeleteMembersRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TeamsChannelApiService.TeamsPrimaryChannelDeleteMembers")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/teams/{team-id}/primaryChannel/members/{conversationMember-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"team-id"+"}", _neturl.PathEscape(parameterToString(r.teamId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"conversationMember-id"+"}", _neturl.PathEscape(parameterToString(r.conversationMemberId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ifMatch != nil {
		localVarHeaderParams["If-Match"] = parameterToString(*r.ifMatch, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiTeamsPrimaryChannelDeleteMessagesRequest struct {
	ctx _context.Context
	ApiService *TeamsChannelApiService
	teamId string
	chatMessageId string
	ifMatch *string
}

// ETag
func (r ApiTeamsPrimaryChannelDeleteMessagesRequest) IfMatch(ifMatch string) ApiTeamsPrimaryChannelDeleteMessagesRequest {
	r.ifMatch = &ifMatch
	return r
}

func (r ApiTeamsPrimaryChannelDeleteMessagesRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.TeamsPrimaryChannelDeleteMessagesExecute(r)
}

/*
TeamsPrimaryChannelDeleteMessages Delete navigation property messages for teams

A collection of all the messages in the channel. A navigation property. Nullable.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param teamId key: id of team
 @param chatMessageId key: id of chatMessage
 @return ApiTeamsPrimaryChannelDeleteMessagesRequest
*/
func (a *TeamsChannelApiService) TeamsPrimaryChannelDeleteMessages(ctx _context.Context, teamId string, chatMessageId string) ApiTeamsPrimaryChannelDeleteMessagesRequest {
	return ApiTeamsPrimaryChannelDeleteMessagesRequest{
		ApiService: a,
		ctx: ctx,
		teamId: teamId,
		chatMessageId: chatMessageId,
	}
}

// Execute executes the request
func (a *TeamsChannelApiService) TeamsPrimaryChannelDeleteMessagesExecute(r ApiTeamsPrimaryChannelDeleteMessagesRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TeamsChannelApiService.TeamsPrimaryChannelDeleteMessages")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/teams/{team-id}/primaryChannel/messages/{chatMessage-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"team-id"+"}", _neturl.PathEscape(parameterToString(r.teamId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"chatMessage-id"+"}", _neturl.PathEscape(parameterToString(r.chatMessageId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ifMatch != nil {
		localVarHeaderParams["If-Match"] = parameterToString(*r.ifMatch, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiTeamsPrimaryChannelDeleteTabsRequest struct {
	ctx _context.Context
	ApiService *TeamsChannelApiService
	teamId string
	teamsTabId string
	ifMatch *string
}

// ETag
func (r ApiTeamsPrimaryChannelDeleteTabsRequest) IfMatch(ifMatch string) ApiTeamsPrimaryChannelDeleteTabsRequest {
	r.ifMatch = &ifMatch
	return r
}

func (r ApiTeamsPrimaryChannelDeleteTabsRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.TeamsPrimaryChannelDeleteTabsExecute(r)
}

/*
TeamsPrimaryChannelDeleteTabs Delete navigation property tabs for teams

A collection of all the tabs in the channel. A navigation property.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param teamId key: id of team
 @param teamsTabId key: id of teamsTab
 @return ApiTeamsPrimaryChannelDeleteTabsRequest
*/
func (a *TeamsChannelApiService) TeamsPrimaryChannelDeleteTabs(ctx _context.Context, teamId string, teamsTabId string) ApiTeamsPrimaryChannelDeleteTabsRequest {
	return ApiTeamsPrimaryChannelDeleteTabsRequest{
		ApiService: a,
		ctx: ctx,
		teamId: teamId,
		teamsTabId: teamsTabId,
	}
}

// Execute executes the request
func (a *TeamsChannelApiService) TeamsPrimaryChannelDeleteTabsExecute(r ApiTeamsPrimaryChannelDeleteTabsRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TeamsChannelApiService.TeamsPrimaryChannelDeleteTabs")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/teams/{team-id}/primaryChannel/tabs/{teamsTab-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"team-id"+"}", _neturl.PathEscape(parameterToString(r.teamId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"teamsTab-id"+"}", _neturl.PathEscape(parameterToString(r.teamsTabId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ifMatch != nil {
		localVarHeaderParams["If-Match"] = parameterToString(*r.ifMatch, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiTeamsPrimaryChannelGetFilesFolderRequest struct {
	ctx _context.Context
	ApiService *TeamsChannelApiService
	teamId string
	select_ *[]string
	expand *[]string
}

// Select properties to be returned
func (r ApiTeamsPrimaryChannelGetFilesFolderRequest) Select_(select_ []string) ApiTeamsPrimaryChannelGetFilesFolderRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiTeamsPrimaryChannelGetFilesFolderRequest) Expand(expand []string) ApiTeamsPrimaryChannelGetFilesFolderRequest {
	r.expand = &expand
	return r
}

func (r ApiTeamsPrimaryChannelGetFilesFolderRequest) Execute() (MicrosoftGraphDriveItem, *_nethttp.Response, error) {
	return r.ApiService.TeamsPrimaryChannelGetFilesFolderExecute(r)
}

/*
TeamsPrimaryChannelGetFilesFolder Get filesFolder from teams

Metadata for the location where the channel's files are stored.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param teamId key: id of team
 @return ApiTeamsPrimaryChannelGetFilesFolderRequest
*/
func (a *TeamsChannelApiService) TeamsPrimaryChannelGetFilesFolder(ctx _context.Context, teamId string) ApiTeamsPrimaryChannelGetFilesFolderRequest {
	return ApiTeamsPrimaryChannelGetFilesFolderRequest{
		ApiService: a,
		ctx: ctx,
		teamId: teamId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphDriveItem
func (a *TeamsChannelApiService) TeamsPrimaryChannelGetFilesFolderExecute(r ApiTeamsPrimaryChannelGetFilesFolderRequest) (MicrosoftGraphDriveItem, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphDriveItem
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TeamsChannelApiService.TeamsPrimaryChannelGetFilesFolder")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/teams/{team-id}/primaryChannel/filesFolder"
	localVarPath = strings.Replace(localVarPath, "{"+"team-id"+"}", _neturl.PathEscape(parameterToString(r.teamId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiTeamsPrimaryChannelGetFilesFolderContentRequest struct {
	ctx _context.Context
	ApiService *TeamsChannelApiService
	teamId string
}


func (r ApiTeamsPrimaryChannelGetFilesFolderContentRequest) Execute() (*os.File, *_nethttp.Response, error) {
	return r.ApiService.TeamsPrimaryChannelGetFilesFolderContentExecute(r)
}

/*
TeamsPrimaryChannelGetFilesFolderContent Get media content for the navigation property filesFolder from teams

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param teamId key: id of team
 @return ApiTeamsPrimaryChannelGetFilesFolderContentRequest
*/
func (a *TeamsChannelApiService) TeamsPrimaryChannelGetFilesFolderContent(ctx _context.Context, teamId string) ApiTeamsPrimaryChannelGetFilesFolderContentRequest {
	return ApiTeamsPrimaryChannelGetFilesFolderContentRequest{
		ApiService: a,
		ctx: ctx,
		teamId: teamId,
	}
}

// Execute executes the request
//  @return *os.File
func (a *TeamsChannelApiService) TeamsPrimaryChannelGetFilesFolderContentExecute(r ApiTeamsPrimaryChannelGetFilesFolderContentRequest) (*os.File, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  *os.File
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TeamsChannelApiService.TeamsPrimaryChannelGetFilesFolderContent")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/teams/{team-id}/primaryChannel/filesFolder/content"
	localVarPath = strings.Replace(localVarPath, "{"+"team-id"+"}", _neturl.PathEscape(parameterToString(r.teamId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/octet-stream", "application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiTeamsPrimaryChannelGetMembersRequest struct {
	ctx _context.Context
	ApiService *TeamsChannelApiService
	teamId string
	conversationMemberId string
	select_ *[]string
	expand *[]string
}

// Select properties to be returned
func (r ApiTeamsPrimaryChannelGetMembersRequest) Select_(select_ []string) ApiTeamsPrimaryChannelGetMembersRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiTeamsPrimaryChannelGetMembersRequest) Expand(expand []string) ApiTeamsPrimaryChannelGetMembersRequest {
	r.expand = &expand
	return r
}

func (r ApiTeamsPrimaryChannelGetMembersRequest) Execute() (MicrosoftGraphConversationMember, *_nethttp.Response, error) {
	return r.ApiService.TeamsPrimaryChannelGetMembersExecute(r)
}

/*
TeamsPrimaryChannelGetMembers Get members from teams

A collection of membership records associated with the channel.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param teamId key: id of team
 @param conversationMemberId key: id of conversationMember
 @return ApiTeamsPrimaryChannelGetMembersRequest
*/
func (a *TeamsChannelApiService) TeamsPrimaryChannelGetMembers(ctx _context.Context, teamId string, conversationMemberId string) ApiTeamsPrimaryChannelGetMembersRequest {
	return ApiTeamsPrimaryChannelGetMembersRequest{
		ApiService: a,
		ctx: ctx,
		teamId: teamId,
		conversationMemberId: conversationMemberId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphConversationMember
func (a *TeamsChannelApiService) TeamsPrimaryChannelGetMembersExecute(r ApiTeamsPrimaryChannelGetMembersRequest) (MicrosoftGraphConversationMember, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphConversationMember
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TeamsChannelApiService.TeamsPrimaryChannelGetMembers")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/teams/{team-id}/primaryChannel/members/{conversationMember-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"team-id"+"}", _neturl.PathEscape(parameterToString(r.teamId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"conversationMember-id"+"}", _neturl.PathEscape(parameterToString(r.conversationMemberId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiTeamsPrimaryChannelGetMessagesRequest struct {
	ctx _context.Context
	ApiService *TeamsChannelApiService
	teamId string
	chatMessageId string
	select_ *[]string
	expand *[]string
}

// Select properties to be returned
func (r ApiTeamsPrimaryChannelGetMessagesRequest) Select_(select_ []string) ApiTeamsPrimaryChannelGetMessagesRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiTeamsPrimaryChannelGetMessagesRequest) Expand(expand []string) ApiTeamsPrimaryChannelGetMessagesRequest {
	r.expand = &expand
	return r
}

func (r ApiTeamsPrimaryChannelGetMessagesRequest) Execute() (MicrosoftGraphChatMessage, *_nethttp.Response, error) {
	return r.ApiService.TeamsPrimaryChannelGetMessagesExecute(r)
}

/*
TeamsPrimaryChannelGetMessages Get messages from teams

A collection of all the messages in the channel. A navigation property. Nullable.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param teamId key: id of team
 @param chatMessageId key: id of chatMessage
 @return ApiTeamsPrimaryChannelGetMessagesRequest
*/
func (a *TeamsChannelApiService) TeamsPrimaryChannelGetMessages(ctx _context.Context, teamId string, chatMessageId string) ApiTeamsPrimaryChannelGetMessagesRequest {
	return ApiTeamsPrimaryChannelGetMessagesRequest{
		ApiService: a,
		ctx: ctx,
		teamId: teamId,
		chatMessageId: chatMessageId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphChatMessage
func (a *TeamsChannelApiService) TeamsPrimaryChannelGetMessagesExecute(r ApiTeamsPrimaryChannelGetMessagesRequest) (MicrosoftGraphChatMessage, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphChatMessage
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TeamsChannelApiService.TeamsPrimaryChannelGetMessages")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/teams/{team-id}/primaryChannel/messages/{chatMessage-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"team-id"+"}", _neturl.PathEscape(parameterToString(r.teamId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"chatMessage-id"+"}", _neturl.PathEscape(parameterToString(r.chatMessageId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiTeamsPrimaryChannelGetTabsRequest struct {
	ctx _context.Context
	ApiService *TeamsChannelApiService
	teamId string
	teamsTabId string
	select_ *[]string
	expand *[]string
}

// Select properties to be returned
func (r ApiTeamsPrimaryChannelGetTabsRequest) Select_(select_ []string) ApiTeamsPrimaryChannelGetTabsRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiTeamsPrimaryChannelGetTabsRequest) Expand(expand []string) ApiTeamsPrimaryChannelGetTabsRequest {
	r.expand = &expand
	return r
}

func (r ApiTeamsPrimaryChannelGetTabsRequest) Execute() (MicrosoftGraphTeamsTab, *_nethttp.Response, error) {
	return r.ApiService.TeamsPrimaryChannelGetTabsExecute(r)
}

/*
TeamsPrimaryChannelGetTabs Get tabs from teams

A collection of all the tabs in the channel. A navigation property.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param teamId key: id of team
 @param teamsTabId key: id of teamsTab
 @return ApiTeamsPrimaryChannelGetTabsRequest
*/
func (a *TeamsChannelApiService) TeamsPrimaryChannelGetTabs(ctx _context.Context, teamId string, teamsTabId string) ApiTeamsPrimaryChannelGetTabsRequest {
	return ApiTeamsPrimaryChannelGetTabsRequest{
		ApiService: a,
		ctx: ctx,
		teamId: teamId,
		teamsTabId: teamsTabId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphTeamsTab
func (a *TeamsChannelApiService) TeamsPrimaryChannelGetTabsExecute(r ApiTeamsPrimaryChannelGetTabsRequest) (MicrosoftGraphTeamsTab, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphTeamsTab
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TeamsChannelApiService.TeamsPrimaryChannelGetTabs")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/teams/{team-id}/primaryChannel/tabs/{teamsTab-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"team-id"+"}", _neturl.PathEscape(parameterToString(r.teamId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"teamsTab-id"+"}", _neturl.PathEscape(parameterToString(r.teamsTabId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiTeamsPrimaryChannelListMembersRequest struct {
	ctx _context.Context
	ApiService *TeamsChannelApiService
	teamId string
	top *int32
	skip *int32
	search *string
	filter *string
	count *bool
	orderby *[]string
	select_ *[]string
	expand *[]string
}

// Show only the first n items
func (r ApiTeamsPrimaryChannelListMembersRequest) Top(top int32) ApiTeamsPrimaryChannelListMembersRequest {
	r.top = &top
	return r
}
// Skip the first n items
func (r ApiTeamsPrimaryChannelListMembersRequest) Skip(skip int32) ApiTeamsPrimaryChannelListMembersRequest {
	r.skip = &skip
	return r
}
// Search items by search phrases
func (r ApiTeamsPrimaryChannelListMembersRequest) Search(search string) ApiTeamsPrimaryChannelListMembersRequest {
	r.search = &search
	return r
}
// Filter items by property values
func (r ApiTeamsPrimaryChannelListMembersRequest) Filter(filter string) ApiTeamsPrimaryChannelListMembersRequest {
	r.filter = &filter
	return r
}
// Include count of items
func (r ApiTeamsPrimaryChannelListMembersRequest) Count(count bool) ApiTeamsPrimaryChannelListMembersRequest {
	r.count = &count
	return r
}
// Order items by property values
func (r ApiTeamsPrimaryChannelListMembersRequest) Orderby(orderby []string) ApiTeamsPrimaryChannelListMembersRequest {
	r.orderby = &orderby
	return r
}
// Select properties to be returned
func (r ApiTeamsPrimaryChannelListMembersRequest) Select_(select_ []string) ApiTeamsPrimaryChannelListMembersRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiTeamsPrimaryChannelListMembersRequest) Expand(expand []string) ApiTeamsPrimaryChannelListMembersRequest {
	r.expand = &expand
	return r
}

func (r ApiTeamsPrimaryChannelListMembersRequest) Execute() (CollectionOfConversationMember, *_nethttp.Response, error) {
	return r.ApiService.TeamsPrimaryChannelListMembersExecute(r)
}

/*
TeamsPrimaryChannelListMembers Get members from teams

A collection of membership records associated with the channel.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param teamId key: id of team
 @return ApiTeamsPrimaryChannelListMembersRequest
*/
func (a *TeamsChannelApiService) TeamsPrimaryChannelListMembers(ctx _context.Context, teamId string) ApiTeamsPrimaryChannelListMembersRequest {
	return ApiTeamsPrimaryChannelListMembersRequest{
		ApiService: a,
		ctx: ctx,
		teamId: teamId,
	}
}

// Execute executes the request
//  @return CollectionOfConversationMember
func (a *TeamsChannelApiService) TeamsPrimaryChannelListMembersExecute(r ApiTeamsPrimaryChannelListMembersRequest) (CollectionOfConversationMember, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  CollectionOfConversationMember
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TeamsChannelApiService.TeamsPrimaryChannelListMembers")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/teams/{team-id}/primaryChannel/members"
	localVarPath = strings.Replace(localVarPath, "{"+"team-id"+"}", _neturl.PathEscape(parameterToString(r.teamId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.top != nil {
		localVarQueryParams.Add("$top", parameterToString(*r.top, ""))
	}
	if r.skip != nil {
		localVarQueryParams.Add("$skip", parameterToString(*r.skip, ""))
	}
	if r.search != nil {
		localVarQueryParams.Add("$search", parameterToString(*r.search, ""))
	}
	if r.filter != nil {
		localVarQueryParams.Add("$filter", parameterToString(*r.filter, ""))
	}
	if r.count != nil {
		localVarQueryParams.Add("$count", parameterToString(*r.count, ""))
	}
	if r.orderby != nil {
		localVarQueryParams.Add("$orderby", parameterToString(*r.orderby, "csv"))
	}
	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiTeamsPrimaryChannelListMessagesRequest struct {
	ctx _context.Context
	ApiService *TeamsChannelApiService
	teamId string
	top *int32
	skip *int32
	search *string
	filter *string
	count *bool
	orderby *[]string
	select_ *[]string
	expand *[]string
}

// Show only the first n items
func (r ApiTeamsPrimaryChannelListMessagesRequest) Top(top int32) ApiTeamsPrimaryChannelListMessagesRequest {
	r.top = &top
	return r
}
// Skip the first n items
func (r ApiTeamsPrimaryChannelListMessagesRequest) Skip(skip int32) ApiTeamsPrimaryChannelListMessagesRequest {
	r.skip = &skip
	return r
}
// Search items by search phrases
func (r ApiTeamsPrimaryChannelListMessagesRequest) Search(search string) ApiTeamsPrimaryChannelListMessagesRequest {
	r.search = &search
	return r
}
// Filter items by property values
func (r ApiTeamsPrimaryChannelListMessagesRequest) Filter(filter string) ApiTeamsPrimaryChannelListMessagesRequest {
	r.filter = &filter
	return r
}
// Include count of items
func (r ApiTeamsPrimaryChannelListMessagesRequest) Count(count bool) ApiTeamsPrimaryChannelListMessagesRequest {
	r.count = &count
	return r
}
// Order items by property values
func (r ApiTeamsPrimaryChannelListMessagesRequest) Orderby(orderby []string) ApiTeamsPrimaryChannelListMessagesRequest {
	r.orderby = &orderby
	return r
}
// Select properties to be returned
func (r ApiTeamsPrimaryChannelListMessagesRequest) Select_(select_ []string) ApiTeamsPrimaryChannelListMessagesRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiTeamsPrimaryChannelListMessagesRequest) Expand(expand []string) ApiTeamsPrimaryChannelListMessagesRequest {
	r.expand = &expand
	return r
}

func (r ApiTeamsPrimaryChannelListMessagesRequest) Execute() (CollectionOfChatMessage, *_nethttp.Response, error) {
	return r.ApiService.TeamsPrimaryChannelListMessagesExecute(r)
}

/*
TeamsPrimaryChannelListMessages Get messages from teams

A collection of all the messages in the channel. A navigation property. Nullable.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param teamId key: id of team
 @return ApiTeamsPrimaryChannelListMessagesRequest
*/
func (a *TeamsChannelApiService) TeamsPrimaryChannelListMessages(ctx _context.Context, teamId string) ApiTeamsPrimaryChannelListMessagesRequest {
	return ApiTeamsPrimaryChannelListMessagesRequest{
		ApiService: a,
		ctx: ctx,
		teamId: teamId,
	}
}

// Execute executes the request
//  @return CollectionOfChatMessage
func (a *TeamsChannelApiService) TeamsPrimaryChannelListMessagesExecute(r ApiTeamsPrimaryChannelListMessagesRequest) (CollectionOfChatMessage, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  CollectionOfChatMessage
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TeamsChannelApiService.TeamsPrimaryChannelListMessages")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/teams/{team-id}/primaryChannel/messages"
	localVarPath = strings.Replace(localVarPath, "{"+"team-id"+"}", _neturl.PathEscape(parameterToString(r.teamId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.top != nil {
		localVarQueryParams.Add("$top", parameterToString(*r.top, ""))
	}
	if r.skip != nil {
		localVarQueryParams.Add("$skip", parameterToString(*r.skip, ""))
	}
	if r.search != nil {
		localVarQueryParams.Add("$search", parameterToString(*r.search, ""))
	}
	if r.filter != nil {
		localVarQueryParams.Add("$filter", parameterToString(*r.filter, ""))
	}
	if r.count != nil {
		localVarQueryParams.Add("$count", parameterToString(*r.count, ""))
	}
	if r.orderby != nil {
		localVarQueryParams.Add("$orderby", parameterToString(*r.orderby, "csv"))
	}
	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiTeamsPrimaryChannelListTabsRequest struct {
	ctx _context.Context
	ApiService *TeamsChannelApiService
	teamId string
	top *int32
	skip *int32
	search *string
	filter *string
	count *bool
	orderby *[]string
	select_ *[]string
	expand *[]string
}

// Show only the first n items
func (r ApiTeamsPrimaryChannelListTabsRequest) Top(top int32) ApiTeamsPrimaryChannelListTabsRequest {
	r.top = &top
	return r
}
// Skip the first n items
func (r ApiTeamsPrimaryChannelListTabsRequest) Skip(skip int32) ApiTeamsPrimaryChannelListTabsRequest {
	r.skip = &skip
	return r
}
// Search items by search phrases
func (r ApiTeamsPrimaryChannelListTabsRequest) Search(search string) ApiTeamsPrimaryChannelListTabsRequest {
	r.search = &search
	return r
}
// Filter items by property values
func (r ApiTeamsPrimaryChannelListTabsRequest) Filter(filter string) ApiTeamsPrimaryChannelListTabsRequest {
	r.filter = &filter
	return r
}
// Include count of items
func (r ApiTeamsPrimaryChannelListTabsRequest) Count(count bool) ApiTeamsPrimaryChannelListTabsRequest {
	r.count = &count
	return r
}
// Order items by property values
func (r ApiTeamsPrimaryChannelListTabsRequest) Orderby(orderby []string) ApiTeamsPrimaryChannelListTabsRequest {
	r.orderby = &orderby
	return r
}
// Select properties to be returned
func (r ApiTeamsPrimaryChannelListTabsRequest) Select_(select_ []string) ApiTeamsPrimaryChannelListTabsRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiTeamsPrimaryChannelListTabsRequest) Expand(expand []string) ApiTeamsPrimaryChannelListTabsRequest {
	r.expand = &expand
	return r
}

func (r ApiTeamsPrimaryChannelListTabsRequest) Execute() (CollectionOfTeamsTab, *_nethttp.Response, error) {
	return r.ApiService.TeamsPrimaryChannelListTabsExecute(r)
}

/*
TeamsPrimaryChannelListTabs Get tabs from teams

A collection of all the tabs in the channel. A navigation property.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param teamId key: id of team
 @return ApiTeamsPrimaryChannelListTabsRequest
*/
func (a *TeamsChannelApiService) TeamsPrimaryChannelListTabs(ctx _context.Context, teamId string) ApiTeamsPrimaryChannelListTabsRequest {
	return ApiTeamsPrimaryChannelListTabsRequest{
		ApiService: a,
		ctx: ctx,
		teamId: teamId,
	}
}

// Execute executes the request
//  @return CollectionOfTeamsTab
func (a *TeamsChannelApiService) TeamsPrimaryChannelListTabsExecute(r ApiTeamsPrimaryChannelListTabsRequest) (CollectionOfTeamsTab, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  CollectionOfTeamsTab
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TeamsChannelApiService.TeamsPrimaryChannelListTabs")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/teams/{team-id}/primaryChannel/tabs"
	localVarPath = strings.Replace(localVarPath, "{"+"team-id"+"}", _neturl.PathEscape(parameterToString(r.teamId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.top != nil {
		localVarQueryParams.Add("$top", parameterToString(*r.top, ""))
	}
	if r.skip != nil {
		localVarQueryParams.Add("$skip", parameterToString(*r.skip, ""))
	}
	if r.search != nil {
		localVarQueryParams.Add("$search", parameterToString(*r.search, ""))
	}
	if r.filter != nil {
		localVarQueryParams.Add("$filter", parameterToString(*r.filter, ""))
	}
	if r.count != nil {
		localVarQueryParams.Add("$count", parameterToString(*r.count, ""))
	}
	if r.orderby != nil {
		localVarQueryParams.Add("$orderby", parameterToString(*r.orderby, "csv"))
	}
	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiTeamsPrimaryChannelMessagesCreateHostedContentsRequest struct {
	ctx _context.Context
	ApiService *TeamsChannelApiService
	teamId string
	chatMessageId string
	microsoftGraphChatMessageHostedContent *MicrosoftGraphChatMessageHostedContent
}

// New navigation property
func (r ApiTeamsPrimaryChannelMessagesCreateHostedContentsRequest) MicrosoftGraphChatMessageHostedContent(microsoftGraphChatMessageHostedContent MicrosoftGraphChatMessageHostedContent) ApiTeamsPrimaryChannelMessagesCreateHostedContentsRequest {
	r.microsoftGraphChatMessageHostedContent = &microsoftGraphChatMessageHostedContent
	return r
}

func (r ApiTeamsPrimaryChannelMessagesCreateHostedContentsRequest) Execute() (MicrosoftGraphChatMessageHostedContent, *_nethttp.Response, error) {
	return r.ApiService.TeamsPrimaryChannelMessagesCreateHostedContentsExecute(r)
}

/*
TeamsPrimaryChannelMessagesCreateHostedContents Create new navigation property to hostedContents for teams

Content in a message hosted by Microsoft Teams - for example, images or code snippets.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param teamId key: id of team
 @param chatMessageId key: id of chatMessage
 @return ApiTeamsPrimaryChannelMessagesCreateHostedContentsRequest
*/
func (a *TeamsChannelApiService) TeamsPrimaryChannelMessagesCreateHostedContents(ctx _context.Context, teamId string, chatMessageId string) ApiTeamsPrimaryChannelMessagesCreateHostedContentsRequest {
	return ApiTeamsPrimaryChannelMessagesCreateHostedContentsRequest{
		ApiService: a,
		ctx: ctx,
		teamId: teamId,
		chatMessageId: chatMessageId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphChatMessageHostedContent
func (a *TeamsChannelApiService) TeamsPrimaryChannelMessagesCreateHostedContentsExecute(r ApiTeamsPrimaryChannelMessagesCreateHostedContentsRequest) (MicrosoftGraphChatMessageHostedContent, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphChatMessageHostedContent
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TeamsChannelApiService.TeamsPrimaryChannelMessagesCreateHostedContents")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/teams/{team-id}/primaryChannel/messages/{chatMessage-id}/hostedContents"
	localVarPath = strings.Replace(localVarPath, "{"+"team-id"+"}", _neturl.PathEscape(parameterToString(r.teamId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"chatMessage-id"+"}", _neturl.PathEscape(parameterToString(r.chatMessageId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphChatMessageHostedContent == nil {
		return localVarReturnValue, nil, reportError("microsoftGraphChatMessageHostedContent is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphChatMessageHostedContent
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiTeamsPrimaryChannelMessagesCreateRepliesRequest struct {
	ctx _context.Context
	ApiService *TeamsChannelApiService
	teamId string
	chatMessageId string
	microsoftGraphChatMessage *MicrosoftGraphChatMessage
}

// New navigation property
func (r ApiTeamsPrimaryChannelMessagesCreateRepliesRequest) MicrosoftGraphChatMessage(microsoftGraphChatMessage MicrosoftGraphChatMessage) ApiTeamsPrimaryChannelMessagesCreateRepliesRequest {
	r.microsoftGraphChatMessage = &microsoftGraphChatMessage
	return r
}

func (r ApiTeamsPrimaryChannelMessagesCreateRepliesRequest) Execute() (MicrosoftGraphChatMessage, *_nethttp.Response, error) {
	return r.ApiService.TeamsPrimaryChannelMessagesCreateRepliesExecute(r)
}

/*
TeamsPrimaryChannelMessagesCreateReplies Create new navigation property to replies for teams

Replies for a specified message.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param teamId key: id of team
 @param chatMessageId key: id of chatMessage
 @return ApiTeamsPrimaryChannelMessagesCreateRepliesRequest
*/
func (a *TeamsChannelApiService) TeamsPrimaryChannelMessagesCreateReplies(ctx _context.Context, teamId string, chatMessageId string) ApiTeamsPrimaryChannelMessagesCreateRepliesRequest {
	return ApiTeamsPrimaryChannelMessagesCreateRepliesRequest{
		ApiService: a,
		ctx: ctx,
		teamId: teamId,
		chatMessageId: chatMessageId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphChatMessage
func (a *TeamsChannelApiService) TeamsPrimaryChannelMessagesCreateRepliesExecute(r ApiTeamsPrimaryChannelMessagesCreateRepliesRequest) (MicrosoftGraphChatMessage, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphChatMessage
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TeamsChannelApiService.TeamsPrimaryChannelMessagesCreateReplies")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/teams/{team-id}/primaryChannel/messages/{chatMessage-id}/replies"
	localVarPath = strings.Replace(localVarPath, "{"+"team-id"+"}", _neturl.PathEscape(parameterToString(r.teamId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"chatMessage-id"+"}", _neturl.PathEscape(parameterToString(r.chatMessageId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphChatMessage == nil {
		return localVarReturnValue, nil, reportError("microsoftGraphChatMessage is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphChatMessage
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiTeamsPrimaryChannelMessagesDeleteHostedContentsRequest struct {
	ctx _context.Context
	ApiService *TeamsChannelApiService
	teamId string
	chatMessageId string
	chatMessageHostedContentId string
	ifMatch *string
}

// ETag
func (r ApiTeamsPrimaryChannelMessagesDeleteHostedContentsRequest) IfMatch(ifMatch string) ApiTeamsPrimaryChannelMessagesDeleteHostedContentsRequest {
	r.ifMatch = &ifMatch
	return r
}

func (r ApiTeamsPrimaryChannelMessagesDeleteHostedContentsRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.TeamsPrimaryChannelMessagesDeleteHostedContentsExecute(r)
}

/*
TeamsPrimaryChannelMessagesDeleteHostedContents Delete navigation property hostedContents for teams

Content in a message hosted by Microsoft Teams - for example, images or code snippets.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param teamId key: id of team
 @param chatMessageId key: id of chatMessage
 @param chatMessageHostedContentId key: id of chatMessageHostedContent
 @return ApiTeamsPrimaryChannelMessagesDeleteHostedContentsRequest
*/
func (a *TeamsChannelApiService) TeamsPrimaryChannelMessagesDeleteHostedContents(ctx _context.Context, teamId string, chatMessageId string, chatMessageHostedContentId string) ApiTeamsPrimaryChannelMessagesDeleteHostedContentsRequest {
	return ApiTeamsPrimaryChannelMessagesDeleteHostedContentsRequest{
		ApiService: a,
		ctx: ctx,
		teamId: teamId,
		chatMessageId: chatMessageId,
		chatMessageHostedContentId: chatMessageHostedContentId,
	}
}

// Execute executes the request
func (a *TeamsChannelApiService) TeamsPrimaryChannelMessagesDeleteHostedContentsExecute(r ApiTeamsPrimaryChannelMessagesDeleteHostedContentsRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TeamsChannelApiService.TeamsPrimaryChannelMessagesDeleteHostedContents")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/teams/{team-id}/primaryChannel/messages/{chatMessage-id}/hostedContents/{chatMessageHostedContent-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"team-id"+"}", _neturl.PathEscape(parameterToString(r.teamId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"chatMessage-id"+"}", _neturl.PathEscape(parameterToString(r.chatMessageId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"chatMessageHostedContent-id"+"}", _neturl.PathEscape(parameterToString(r.chatMessageHostedContentId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ifMatch != nil {
		localVarHeaderParams["If-Match"] = parameterToString(*r.ifMatch, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiTeamsPrimaryChannelMessagesDeleteRepliesRequest struct {
	ctx _context.Context
	ApiService *TeamsChannelApiService
	teamId string
	chatMessageId string
	chatMessageId1 string
	ifMatch *string
}

// ETag
func (r ApiTeamsPrimaryChannelMessagesDeleteRepliesRequest) IfMatch(ifMatch string) ApiTeamsPrimaryChannelMessagesDeleteRepliesRequest {
	r.ifMatch = &ifMatch
	return r
}

func (r ApiTeamsPrimaryChannelMessagesDeleteRepliesRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.TeamsPrimaryChannelMessagesDeleteRepliesExecute(r)
}

/*
TeamsPrimaryChannelMessagesDeleteReplies Delete navigation property replies for teams

Replies for a specified message.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param teamId key: id of team
 @param chatMessageId key: id of chatMessage
 @param chatMessageId1 key: id of chatMessage
 @return ApiTeamsPrimaryChannelMessagesDeleteRepliesRequest
*/
func (a *TeamsChannelApiService) TeamsPrimaryChannelMessagesDeleteReplies(ctx _context.Context, teamId string, chatMessageId string, chatMessageId1 string) ApiTeamsPrimaryChannelMessagesDeleteRepliesRequest {
	return ApiTeamsPrimaryChannelMessagesDeleteRepliesRequest{
		ApiService: a,
		ctx: ctx,
		teamId: teamId,
		chatMessageId: chatMessageId,
		chatMessageId1: chatMessageId1,
	}
}

// Execute executes the request
func (a *TeamsChannelApiService) TeamsPrimaryChannelMessagesDeleteRepliesExecute(r ApiTeamsPrimaryChannelMessagesDeleteRepliesRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TeamsChannelApiService.TeamsPrimaryChannelMessagesDeleteReplies")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/teams/{team-id}/primaryChannel/messages/{chatMessage-id}/replies/{chatMessage-id1}"
	localVarPath = strings.Replace(localVarPath, "{"+"team-id"+"}", _neturl.PathEscape(parameterToString(r.teamId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"chatMessage-id"+"}", _neturl.PathEscape(parameterToString(r.chatMessageId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"chatMessage-id1"+"}", _neturl.PathEscape(parameterToString(r.chatMessageId1, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ifMatch != nil {
		localVarHeaderParams["If-Match"] = parameterToString(*r.ifMatch, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiTeamsPrimaryChannelMessagesGetHostedContentsRequest struct {
	ctx _context.Context
	ApiService *TeamsChannelApiService
	teamId string
	chatMessageId string
	chatMessageHostedContentId string
	select_ *[]string
	expand *[]string
}

// Select properties to be returned
func (r ApiTeamsPrimaryChannelMessagesGetHostedContentsRequest) Select_(select_ []string) ApiTeamsPrimaryChannelMessagesGetHostedContentsRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiTeamsPrimaryChannelMessagesGetHostedContentsRequest) Expand(expand []string) ApiTeamsPrimaryChannelMessagesGetHostedContentsRequest {
	r.expand = &expand
	return r
}

func (r ApiTeamsPrimaryChannelMessagesGetHostedContentsRequest) Execute() (MicrosoftGraphChatMessageHostedContent, *_nethttp.Response, error) {
	return r.ApiService.TeamsPrimaryChannelMessagesGetHostedContentsExecute(r)
}

/*
TeamsPrimaryChannelMessagesGetHostedContents Get hostedContents from teams

Content in a message hosted by Microsoft Teams - for example, images or code snippets.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param teamId key: id of team
 @param chatMessageId key: id of chatMessage
 @param chatMessageHostedContentId key: id of chatMessageHostedContent
 @return ApiTeamsPrimaryChannelMessagesGetHostedContentsRequest
*/
func (a *TeamsChannelApiService) TeamsPrimaryChannelMessagesGetHostedContents(ctx _context.Context, teamId string, chatMessageId string, chatMessageHostedContentId string) ApiTeamsPrimaryChannelMessagesGetHostedContentsRequest {
	return ApiTeamsPrimaryChannelMessagesGetHostedContentsRequest{
		ApiService: a,
		ctx: ctx,
		teamId: teamId,
		chatMessageId: chatMessageId,
		chatMessageHostedContentId: chatMessageHostedContentId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphChatMessageHostedContent
func (a *TeamsChannelApiService) TeamsPrimaryChannelMessagesGetHostedContentsExecute(r ApiTeamsPrimaryChannelMessagesGetHostedContentsRequest) (MicrosoftGraphChatMessageHostedContent, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphChatMessageHostedContent
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TeamsChannelApiService.TeamsPrimaryChannelMessagesGetHostedContents")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/teams/{team-id}/primaryChannel/messages/{chatMessage-id}/hostedContents/{chatMessageHostedContent-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"team-id"+"}", _neturl.PathEscape(parameterToString(r.teamId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"chatMessage-id"+"}", _neturl.PathEscape(parameterToString(r.chatMessageId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"chatMessageHostedContent-id"+"}", _neturl.PathEscape(parameterToString(r.chatMessageHostedContentId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiTeamsPrimaryChannelMessagesGetRepliesRequest struct {
	ctx _context.Context
	ApiService *TeamsChannelApiService
	teamId string
	chatMessageId string
	chatMessageId1 string
	select_ *[]string
	expand *[]string
}

// Select properties to be returned
func (r ApiTeamsPrimaryChannelMessagesGetRepliesRequest) Select_(select_ []string) ApiTeamsPrimaryChannelMessagesGetRepliesRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiTeamsPrimaryChannelMessagesGetRepliesRequest) Expand(expand []string) ApiTeamsPrimaryChannelMessagesGetRepliesRequest {
	r.expand = &expand
	return r
}

func (r ApiTeamsPrimaryChannelMessagesGetRepliesRequest) Execute() (MicrosoftGraphChatMessage, *_nethttp.Response, error) {
	return r.ApiService.TeamsPrimaryChannelMessagesGetRepliesExecute(r)
}

/*
TeamsPrimaryChannelMessagesGetReplies Get replies from teams

Replies for a specified message.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param teamId key: id of team
 @param chatMessageId key: id of chatMessage
 @param chatMessageId1 key: id of chatMessage
 @return ApiTeamsPrimaryChannelMessagesGetRepliesRequest
*/
func (a *TeamsChannelApiService) TeamsPrimaryChannelMessagesGetReplies(ctx _context.Context, teamId string, chatMessageId string, chatMessageId1 string) ApiTeamsPrimaryChannelMessagesGetRepliesRequest {
	return ApiTeamsPrimaryChannelMessagesGetRepliesRequest{
		ApiService: a,
		ctx: ctx,
		teamId: teamId,
		chatMessageId: chatMessageId,
		chatMessageId1: chatMessageId1,
	}
}

// Execute executes the request
//  @return MicrosoftGraphChatMessage
func (a *TeamsChannelApiService) TeamsPrimaryChannelMessagesGetRepliesExecute(r ApiTeamsPrimaryChannelMessagesGetRepliesRequest) (MicrosoftGraphChatMessage, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphChatMessage
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TeamsChannelApiService.TeamsPrimaryChannelMessagesGetReplies")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/teams/{team-id}/primaryChannel/messages/{chatMessage-id}/replies/{chatMessage-id1}"
	localVarPath = strings.Replace(localVarPath, "{"+"team-id"+"}", _neturl.PathEscape(parameterToString(r.teamId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"chatMessage-id"+"}", _neturl.PathEscape(parameterToString(r.chatMessageId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"chatMessage-id1"+"}", _neturl.PathEscape(parameterToString(r.chatMessageId1, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiTeamsPrimaryChannelMessagesListHostedContentsRequest struct {
	ctx _context.Context
	ApiService *TeamsChannelApiService
	teamId string
	chatMessageId string
	top *int32
	skip *int32
	search *string
	filter *string
	count *bool
	orderby *[]string
	select_ *[]string
	expand *[]string
}

// Show only the first n items
func (r ApiTeamsPrimaryChannelMessagesListHostedContentsRequest) Top(top int32) ApiTeamsPrimaryChannelMessagesListHostedContentsRequest {
	r.top = &top
	return r
}
// Skip the first n items
func (r ApiTeamsPrimaryChannelMessagesListHostedContentsRequest) Skip(skip int32) ApiTeamsPrimaryChannelMessagesListHostedContentsRequest {
	r.skip = &skip
	return r
}
// Search items by search phrases
func (r ApiTeamsPrimaryChannelMessagesListHostedContentsRequest) Search(search string) ApiTeamsPrimaryChannelMessagesListHostedContentsRequest {
	r.search = &search
	return r
}
// Filter items by property values
func (r ApiTeamsPrimaryChannelMessagesListHostedContentsRequest) Filter(filter string) ApiTeamsPrimaryChannelMessagesListHostedContentsRequest {
	r.filter = &filter
	return r
}
// Include count of items
func (r ApiTeamsPrimaryChannelMessagesListHostedContentsRequest) Count(count bool) ApiTeamsPrimaryChannelMessagesListHostedContentsRequest {
	r.count = &count
	return r
}
// Order items by property values
func (r ApiTeamsPrimaryChannelMessagesListHostedContentsRequest) Orderby(orderby []string) ApiTeamsPrimaryChannelMessagesListHostedContentsRequest {
	r.orderby = &orderby
	return r
}
// Select properties to be returned
func (r ApiTeamsPrimaryChannelMessagesListHostedContentsRequest) Select_(select_ []string) ApiTeamsPrimaryChannelMessagesListHostedContentsRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiTeamsPrimaryChannelMessagesListHostedContentsRequest) Expand(expand []string) ApiTeamsPrimaryChannelMessagesListHostedContentsRequest {
	r.expand = &expand
	return r
}

func (r ApiTeamsPrimaryChannelMessagesListHostedContentsRequest) Execute() (CollectionOfChatMessageHostedContent, *_nethttp.Response, error) {
	return r.ApiService.TeamsPrimaryChannelMessagesListHostedContentsExecute(r)
}

/*
TeamsPrimaryChannelMessagesListHostedContents Get hostedContents from teams

Content in a message hosted by Microsoft Teams - for example, images or code snippets.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param teamId key: id of team
 @param chatMessageId key: id of chatMessage
 @return ApiTeamsPrimaryChannelMessagesListHostedContentsRequest
*/
func (a *TeamsChannelApiService) TeamsPrimaryChannelMessagesListHostedContents(ctx _context.Context, teamId string, chatMessageId string) ApiTeamsPrimaryChannelMessagesListHostedContentsRequest {
	return ApiTeamsPrimaryChannelMessagesListHostedContentsRequest{
		ApiService: a,
		ctx: ctx,
		teamId: teamId,
		chatMessageId: chatMessageId,
	}
}

// Execute executes the request
//  @return CollectionOfChatMessageHostedContent
func (a *TeamsChannelApiService) TeamsPrimaryChannelMessagesListHostedContentsExecute(r ApiTeamsPrimaryChannelMessagesListHostedContentsRequest) (CollectionOfChatMessageHostedContent, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  CollectionOfChatMessageHostedContent
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TeamsChannelApiService.TeamsPrimaryChannelMessagesListHostedContents")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/teams/{team-id}/primaryChannel/messages/{chatMessage-id}/hostedContents"
	localVarPath = strings.Replace(localVarPath, "{"+"team-id"+"}", _neturl.PathEscape(parameterToString(r.teamId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"chatMessage-id"+"}", _neturl.PathEscape(parameterToString(r.chatMessageId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.top != nil {
		localVarQueryParams.Add("$top", parameterToString(*r.top, ""))
	}
	if r.skip != nil {
		localVarQueryParams.Add("$skip", parameterToString(*r.skip, ""))
	}
	if r.search != nil {
		localVarQueryParams.Add("$search", parameterToString(*r.search, ""))
	}
	if r.filter != nil {
		localVarQueryParams.Add("$filter", parameterToString(*r.filter, ""))
	}
	if r.count != nil {
		localVarQueryParams.Add("$count", parameterToString(*r.count, ""))
	}
	if r.orderby != nil {
		localVarQueryParams.Add("$orderby", parameterToString(*r.orderby, "csv"))
	}
	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiTeamsPrimaryChannelMessagesListRepliesRequest struct {
	ctx _context.Context
	ApiService *TeamsChannelApiService
	teamId string
	chatMessageId string
	top *int32
	skip *int32
	search *string
	filter *string
	count *bool
	orderby *[]string
	select_ *[]string
	expand *[]string
}

// Show only the first n items
func (r ApiTeamsPrimaryChannelMessagesListRepliesRequest) Top(top int32) ApiTeamsPrimaryChannelMessagesListRepliesRequest {
	r.top = &top
	return r
}
// Skip the first n items
func (r ApiTeamsPrimaryChannelMessagesListRepliesRequest) Skip(skip int32) ApiTeamsPrimaryChannelMessagesListRepliesRequest {
	r.skip = &skip
	return r
}
// Search items by search phrases
func (r ApiTeamsPrimaryChannelMessagesListRepliesRequest) Search(search string) ApiTeamsPrimaryChannelMessagesListRepliesRequest {
	r.search = &search
	return r
}
// Filter items by property values
func (r ApiTeamsPrimaryChannelMessagesListRepliesRequest) Filter(filter string) ApiTeamsPrimaryChannelMessagesListRepliesRequest {
	r.filter = &filter
	return r
}
// Include count of items
func (r ApiTeamsPrimaryChannelMessagesListRepliesRequest) Count(count bool) ApiTeamsPrimaryChannelMessagesListRepliesRequest {
	r.count = &count
	return r
}
// Order items by property values
func (r ApiTeamsPrimaryChannelMessagesListRepliesRequest) Orderby(orderby []string) ApiTeamsPrimaryChannelMessagesListRepliesRequest {
	r.orderby = &orderby
	return r
}
// Select properties to be returned
func (r ApiTeamsPrimaryChannelMessagesListRepliesRequest) Select_(select_ []string) ApiTeamsPrimaryChannelMessagesListRepliesRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiTeamsPrimaryChannelMessagesListRepliesRequest) Expand(expand []string) ApiTeamsPrimaryChannelMessagesListRepliesRequest {
	r.expand = &expand
	return r
}

func (r ApiTeamsPrimaryChannelMessagesListRepliesRequest) Execute() (CollectionOfChatMessage, *_nethttp.Response, error) {
	return r.ApiService.TeamsPrimaryChannelMessagesListRepliesExecute(r)
}

/*
TeamsPrimaryChannelMessagesListReplies Get replies from teams

Replies for a specified message.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param teamId key: id of team
 @param chatMessageId key: id of chatMessage
 @return ApiTeamsPrimaryChannelMessagesListRepliesRequest
*/
func (a *TeamsChannelApiService) TeamsPrimaryChannelMessagesListReplies(ctx _context.Context, teamId string, chatMessageId string) ApiTeamsPrimaryChannelMessagesListRepliesRequest {
	return ApiTeamsPrimaryChannelMessagesListRepliesRequest{
		ApiService: a,
		ctx: ctx,
		teamId: teamId,
		chatMessageId: chatMessageId,
	}
}

// Execute executes the request
//  @return CollectionOfChatMessage
func (a *TeamsChannelApiService) TeamsPrimaryChannelMessagesListRepliesExecute(r ApiTeamsPrimaryChannelMessagesListRepliesRequest) (CollectionOfChatMessage, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  CollectionOfChatMessage
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TeamsChannelApiService.TeamsPrimaryChannelMessagesListReplies")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/teams/{team-id}/primaryChannel/messages/{chatMessage-id}/replies"
	localVarPath = strings.Replace(localVarPath, "{"+"team-id"+"}", _neturl.PathEscape(parameterToString(r.teamId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"chatMessage-id"+"}", _neturl.PathEscape(parameterToString(r.chatMessageId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.top != nil {
		localVarQueryParams.Add("$top", parameterToString(*r.top, ""))
	}
	if r.skip != nil {
		localVarQueryParams.Add("$skip", parameterToString(*r.skip, ""))
	}
	if r.search != nil {
		localVarQueryParams.Add("$search", parameterToString(*r.search, ""))
	}
	if r.filter != nil {
		localVarQueryParams.Add("$filter", parameterToString(*r.filter, ""))
	}
	if r.count != nil {
		localVarQueryParams.Add("$count", parameterToString(*r.count, ""))
	}
	if r.orderby != nil {
		localVarQueryParams.Add("$orderby", parameterToString(*r.orderby, "csv"))
	}
	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiTeamsPrimaryChannelMessagesUpdateHostedContentsRequest struct {
	ctx _context.Context
	ApiService *TeamsChannelApiService
	teamId string
	chatMessageId string
	chatMessageHostedContentId string
	microsoftGraphChatMessageHostedContent *MicrosoftGraphChatMessageHostedContent
}

// New navigation property values
func (r ApiTeamsPrimaryChannelMessagesUpdateHostedContentsRequest) MicrosoftGraphChatMessageHostedContent(microsoftGraphChatMessageHostedContent MicrosoftGraphChatMessageHostedContent) ApiTeamsPrimaryChannelMessagesUpdateHostedContentsRequest {
	r.microsoftGraphChatMessageHostedContent = &microsoftGraphChatMessageHostedContent
	return r
}

func (r ApiTeamsPrimaryChannelMessagesUpdateHostedContentsRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.TeamsPrimaryChannelMessagesUpdateHostedContentsExecute(r)
}

/*
TeamsPrimaryChannelMessagesUpdateHostedContents Update the navigation property hostedContents in teams

Content in a message hosted by Microsoft Teams - for example, images or code snippets.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param teamId key: id of team
 @param chatMessageId key: id of chatMessage
 @param chatMessageHostedContentId key: id of chatMessageHostedContent
 @return ApiTeamsPrimaryChannelMessagesUpdateHostedContentsRequest
*/
func (a *TeamsChannelApiService) TeamsPrimaryChannelMessagesUpdateHostedContents(ctx _context.Context, teamId string, chatMessageId string, chatMessageHostedContentId string) ApiTeamsPrimaryChannelMessagesUpdateHostedContentsRequest {
	return ApiTeamsPrimaryChannelMessagesUpdateHostedContentsRequest{
		ApiService: a,
		ctx: ctx,
		teamId: teamId,
		chatMessageId: chatMessageId,
		chatMessageHostedContentId: chatMessageHostedContentId,
	}
}

// Execute executes the request
func (a *TeamsChannelApiService) TeamsPrimaryChannelMessagesUpdateHostedContentsExecute(r ApiTeamsPrimaryChannelMessagesUpdateHostedContentsRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPatch
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TeamsChannelApiService.TeamsPrimaryChannelMessagesUpdateHostedContents")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/teams/{team-id}/primaryChannel/messages/{chatMessage-id}/hostedContents/{chatMessageHostedContent-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"team-id"+"}", _neturl.PathEscape(parameterToString(r.teamId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"chatMessage-id"+"}", _neturl.PathEscape(parameterToString(r.chatMessageId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"chatMessageHostedContent-id"+"}", _neturl.PathEscape(parameterToString(r.chatMessageHostedContentId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphChatMessageHostedContent == nil {
		return nil, reportError("microsoftGraphChatMessageHostedContent is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphChatMessageHostedContent
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiTeamsPrimaryChannelMessagesUpdateRepliesRequest struct {
	ctx _context.Context
	ApiService *TeamsChannelApiService
	teamId string
	chatMessageId string
	chatMessageId1 string
	microsoftGraphChatMessage *MicrosoftGraphChatMessage
}

// New navigation property values
func (r ApiTeamsPrimaryChannelMessagesUpdateRepliesRequest) MicrosoftGraphChatMessage(microsoftGraphChatMessage MicrosoftGraphChatMessage) ApiTeamsPrimaryChannelMessagesUpdateRepliesRequest {
	r.microsoftGraphChatMessage = &microsoftGraphChatMessage
	return r
}

func (r ApiTeamsPrimaryChannelMessagesUpdateRepliesRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.TeamsPrimaryChannelMessagesUpdateRepliesExecute(r)
}

/*
TeamsPrimaryChannelMessagesUpdateReplies Update the navigation property replies in teams

Replies for a specified message.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param teamId key: id of team
 @param chatMessageId key: id of chatMessage
 @param chatMessageId1 key: id of chatMessage
 @return ApiTeamsPrimaryChannelMessagesUpdateRepliesRequest
*/
func (a *TeamsChannelApiService) TeamsPrimaryChannelMessagesUpdateReplies(ctx _context.Context, teamId string, chatMessageId string, chatMessageId1 string) ApiTeamsPrimaryChannelMessagesUpdateRepliesRequest {
	return ApiTeamsPrimaryChannelMessagesUpdateRepliesRequest{
		ApiService: a,
		ctx: ctx,
		teamId: teamId,
		chatMessageId: chatMessageId,
		chatMessageId1: chatMessageId1,
	}
}

// Execute executes the request
func (a *TeamsChannelApiService) TeamsPrimaryChannelMessagesUpdateRepliesExecute(r ApiTeamsPrimaryChannelMessagesUpdateRepliesRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPatch
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TeamsChannelApiService.TeamsPrimaryChannelMessagesUpdateReplies")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/teams/{team-id}/primaryChannel/messages/{chatMessage-id}/replies/{chatMessage-id1}"
	localVarPath = strings.Replace(localVarPath, "{"+"team-id"+"}", _neturl.PathEscape(parameterToString(r.teamId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"chatMessage-id"+"}", _neturl.PathEscape(parameterToString(r.chatMessageId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"chatMessage-id1"+"}", _neturl.PathEscape(parameterToString(r.chatMessageId1, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphChatMessage == nil {
		return nil, reportError("microsoftGraphChatMessage is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphChatMessage
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiTeamsPrimaryChannelTabsDeleteRefTeamsAppRequest struct {
	ctx _context.Context
	ApiService *TeamsChannelApiService
	teamId string
	teamsTabId string
	ifMatch *string
}

// ETag
func (r ApiTeamsPrimaryChannelTabsDeleteRefTeamsAppRequest) IfMatch(ifMatch string) ApiTeamsPrimaryChannelTabsDeleteRefTeamsAppRequest {
	r.ifMatch = &ifMatch
	return r
}

func (r ApiTeamsPrimaryChannelTabsDeleteRefTeamsAppRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.TeamsPrimaryChannelTabsDeleteRefTeamsAppExecute(r)
}

/*
TeamsPrimaryChannelTabsDeleteRefTeamsApp Delete ref of navigation property teamsApp for teams

The application that is linked to the tab. This cannot be changed after tab creation.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param teamId key: id of team
 @param teamsTabId key: id of teamsTab
 @return ApiTeamsPrimaryChannelTabsDeleteRefTeamsAppRequest
*/
func (a *TeamsChannelApiService) TeamsPrimaryChannelTabsDeleteRefTeamsApp(ctx _context.Context, teamId string, teamsTabId string) ApiTeamsPrimaryChannelTabsDeleteRefTeamsAppRequest {
	return ApiTeamsPrimaryChannelTabsDeleteRefTeamsAppRequest{
		ApiService: a,
		ctx: ctx,
		teamId: teamId,
		teamsTabId: teamsTabId,
	}
}

// Execute executes the request
func (a *TeamsChannelApiService) TeamsPrimaryChannelTabsDeleteRefTeamsAppExecute(r ApiTeamsPrimaryChannelTabsDeleteRefTeamsAppRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TeamsChannelApiService.TeamsPrimaryChannelTabsDeleteRefTeamsApp")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/teams/{team-id}/primaryChannel/tabs/{teamsTab-id}/teamsApp/$ref"
	localVarPath = strings.Replace(localVarPath, "{"+"team-id"+"}", _neturl.PathEscape(parameterToString(r.teamId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"teamsTab-id"+"}", _neturl.PathEscape(parameterToString(r.teamsTabId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ifMatch != nil {
		localVarHeaderParams["If-Match"] = parameterToString(*r.ifMatch, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiTeamsPrimaryChannelTabsGetRefTeamsAppRequest struct {
	ctx _context.Context
	ApiService *TeamsChannelApiService
	teamId string
	teamsTabId string
}


func (r ApiTeamsPrimaryChannelTabsGetRefTeamsAppRequest) Execute() (string, *_nethttp.Response, error) {
	return r.ApiService.TeamsPrimaryChannelTabsGetRefTeamsAppExecute(r)
}

/*
TeamsPrimaryChannelTabsGetRefTeamsApp Get ref of teamsApp from teams

The application that is linked to the tab. This cannot be changed after tab creation.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param teamId key: id of team
 @param teamsTabId key: id of teamsTab
 @return ApiTeamsPrimaryChannelTabsGetRefTeamsAppRequest
*/
func (a *TeamsChannelApiService) TeamsPrimaryChannelTabsGetRefTeamsApp(ctx _context.Context, teamId string, teamsTabId string) ApiTeamsPrimaryChannelTabsGetRefTeamsAppRequest {
	return ApiTeamsPrimaryChannelTabsGetRefTeamsAppRequest{
		ApiService: a,
		ctx: ctx,
		teamId: teamId,
		teamsTabId: teamsTabId,
	}
}

// Execute executes the request
//  @return string
func (a *TeamsChannelApiService) TeamsPrimaryChannelTabsGetRefTeamsAppExecute(r ApiTeamsPrimaryChannelTabsGetRefTeamsAppRequest) (string, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  string
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TeamsChannelApiService.TeamsPrimaryChannelTabsGetRefTeamsApp")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/teams/{team-id}/primaryChannel/tabs/{teamsTab-id}/teamsApp/$ref"
	localVarPath = strings.Replace(localVarPath, "{"+"team-id"+"}", _neturl.PathEscape(parameterToString(r.teamId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"teamsTab-id"+"}", _neturl.PathEscape(parameterToString(r.teamsTabId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiTeamsPrimaryChannelTabsGetTeamsAppRequest struct {
	ctx _context.Context
	ApiService *TeamsChannelApiService
	teamId string
	teamsTabId string
	select_ *[]string
	expand *[]string
}

// Select properties to be returned
func (r ApiTeamsPrimaryChannelTabsGetTeamsAppRequest) Select_(select_ []string) ApiTeamsPrimaryChannelTabsGetTeamsAppRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiTeamsPrimaryChannelTabsGetTeamsAppRequest) Expand(expand []string) ApiTeamsPrimaryChannelTabsGetTeamsAppRequest {
	r.expand = &expand
	return r
}

func (r ApiTeamsPrimaryChannelTabsGetTeamsAppRequest) Execute() (MicrosoftGraphTeamsApp, *_nethttp.Response, error) {
	return r.ApiService.TeamsPrimaryChannelTabsGetTeamsAppExecute(r)
}

/*
TeamsPrimaryChannelTabsGetTeamsApp Get teamsApp from teams

The application that is linked to the tab. This cannot be changed after tab creation.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param teamId key: id of team
 @param teamsTabId key: id of teamsTab
 @return ApiTeamsPrimaryChannelTabsGetTeamsAppRequest
*/
func (a *TeamsChannelApiService) TeamsPrimaryChannelTabsGetTeamsApp(ctx _context.Context, teamId string, teamsTabId string) ApiTeamsPrimaryChannelTabsGetTeamsAppRequest {
	return ApiTeamsPrimaryChannelTabsGetTeamsAppRequest{
		ApiService: a,
		ctx: ctx,
		teamId: teamId,
		teamsTabId: teamsTabId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphTeamsApp
func (a *TeamsChannelApiService) TeamsPrimaryChannelTabsGetTeamsAppExecute(r ApiTeamsPrimaryChannelTabsGetTeamsAppRequest) (MicrosoftGraphTeamsApp, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphTeamsApp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TeamsChannelApiService.TeamsPrimaryChannelTabsGetTeamsApp")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/teams/{team-id}/primaryChannel/tabs/{teamsTab-id}/teamsApp"
	localVarPath = strings.Replace(localVarPath, "{"+"team-id"+"}", _neturl.PathEscape(parameterToString(r.teamId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"teamsTab-id"+"}", _neturl.PathEscape(parameterToString(r.teamsTabId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiTeamsPrimaryChannelTabsUpdateRefTeamsAppRequest struct {
	ctx _context.Context
	ApiService *TeamsChannelApiService
	teamId string
	teamsTabId string
	requestBody *map[string]map[string]interface{}
}

// New navigation property ref values
func (r ApiTeamsPrimaryChannelTabsUpdateRefTeamsAppRequest) RequestBody(requestBody map[string]map[string]interface{}) ApiTeamsPrimaryChannelTabsUpdateRefTeamsAppRequest {
	r.requestBody = &requestBody
	return r
}

func (r ApiTeamsPrimaryChannelTabsUpdateRefTeamsAppRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.TeamsPrimaryChannelTabsUpdateRefTeamsAppExecute(r)
}

/*
TeamsPrimaryChannelTabsUpdateRefTeamsApp Update the ref of navigation property teamsApp in teams

The application that is linked to the tab. This cannot be changed after tab creation.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param teamId key: id of team
 @param teamsTabId key: id of teamsTab
 @return ApiTeamsPrimaryChannelTabsUpdateRefTeamsAppRequest
*/
func (a *TeamsChannelApiService) TeamsPrimaryChannelTabsUpdateRefTeamsApp(ctx _context.Context, teamId string, teamsTabId string) ApiTeamsPrimaryChannelTabsUpdateRefTeamsAppRequest {
	return ApiTeamsPrimaryChannelTabsUpdateRefTeamsAppRequest{
		ApiService: a,
		ctx: ctx,
		teamId: teamId,
		teamsTabId: teamsTabId,
	}
}

// Execute executes the request
func (a *TeamsChannelApiService) TeamsPrimaryChannelTabsUpdateRefTeamsAppExecute(r ApiTeamsPrimaryChannelTabsUpdateRefTeamsAppRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPut
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TeamsChannelApiService.TeamsPrimaryChannelTabsUpdateRefTeamsApp")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/teams/{team-id}/primaryChannel/tabs/{teamsTab-id}/teamsApp/$ref"
	localVarPath = strings.Replace(localVarPath, "{"+"team-id"+"}", _neturl.PathEscape(parameterToString(r.teamId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"teamsTab-id"+"}", _neturl.PathEscape(parameterToString(r.teamsTabId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.requestBody == nil {
		return nil, reportError("requestBody is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.requestBody
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiTeamsPrimaryChannelUpdateFilesFolderRequest struct {
	ctx _context.Context
	ApiService *TeamsChannelApiService
	teamId string
	microsoftGraphDriveItem *MicrosoftGraphDriveItem
}

// New navigation property values
func (r ApiTeamsPrimaryChannelUpdateFilesFolderRequest) MicrosoftGraphDriveItem(microsoftGraphDriveItem MicrosoftGraphDriveItem) ApiTeamsPrimaryChannelUpdateFilesFolderRequest {
	r.microsoftGraphDriveItem = &microsoftGraphDriveItem
	return r
}

func (r ApiTeamsPrimaryChannelUpdateFilesFolderRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.TeamsPrimaryChannelUpdateFilesFolderExecute(r)
}

/*
TeamsPrimaryChannelUpdateFilesFolder Update the navigation property filesFolder in teams

Metadata for the location where the channel's files are stored.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param teamId key: id of team
 @return ApiTeamsPrimaryChannelUpdateFilesFolderRequest
*/
func (a *TeamsChannelApiService) TeamsPrimaryChannelUpdateFilesFolder(ctx _context.Context, teamId string) ApiTeamsPrimaryChannelUpdateFilesFolderRequest {
	return ApiTeamsPrimaryChannelUpdateFilesFolderRequest{
		ApiService: a,
		ctx: ctx,
		teamId: teamId,
	}
}

// Execute executes the request
func (a *TeamsChannelApiService) TeamsPrimaryChannelUpdateFilesFolderExecute(r ApiTeamsPrimaryChannelUpdateFilesFolderRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPatch
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TeamsChannelApiService.TeamsPrimaryChannelUpdateFilesFolder")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/teams/{team-id}/primaryChannel/filesFolder"
	localVarPath = strings.Replace(localVarPath, "{"+"team-id"+"}", _neturl.PathEscape(parameterToString(r.teamId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphDriveItem == nil {
		return nil, reportError("microsoftGraphDriveItem is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphDriveItem
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiTeamsPrimaryChannelUpdateFilesFolderContentRequest struct {
	ctx _context.Context
	ApiService *TeamsChannelApiService
	teamId string
	body **os.File
}

// New media content.
func (r ApiTeamsPrimaryChannelUpdateFilesFolderContentRequest) Body(body *os.File) ApiTeamsPrimaryChannelUpdateFilesFolderContentRequest {
	r.body = &body
	return r
}

func (r ApiTeamsPrimaryChannelUpdateFilesFolderContentRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.TeamsPrimaryChannelUpdateFilesFolderContentExecute(r)
}

/*
TeamsPrimaryChannelUpdateFilesFolderContent Update media content for the navigation property filesFolder in teams

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param teamId key: id of team
 @return ApiTeamsPrimaryChannelUpdateFilesFolderContentRequest
*/
func (a *TeamsChannelApiService) TeamsPrimaryChannelUpdateFilesFolderContent(ctx _context.Context, teamId string) ApiTeamsPrimaryChannelUpdateFilesFolderContentRequest {
	return ApiTeamsPrimaryChannelUpdateFilesFolderContentRequest{
		ApiService: a,
		ctx: ctx,
		teamId: teamId,
	}
}

// Execute executes the request
func (a *TeamsChannelApiService) TeamsPrimaryChannelUpdateFilesFolderContentExecute(r ApiTeamsPrimaryChannelUpdateFilesFolderContentRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPut
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TeamsChannelApiService.TeamsPrimaryChannelUpdateFilesFolderContent")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/teams/{team-id}/primaryChannel/filesFolder/content"
	localVarPath = strings.Replace(localVarPath, "{"+"team-id"+"}", _neturl.PathEscape(parameterToString(r.teamId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.body == nil {
		return nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/octet-stream"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiTeamsPrimaryChannelUpdateMembersRequest struct {
	ctx _context.Context
	ApiService *TeamsChannelApiService
	teamId string
	conversationMemberId string
	microsoftGraphConversationMember *MicrosoftGraphConversationMember
}

// New navigation property values
func (r ApiTeamsPrimaryChannelUpdateMembersRequest) MicrosoftGraphConversationMember(microsoftGraphConversationMember MicrosoftGraphConversationMember) ApiTeamsPrimaryChannelUpdateMembersRequest {
	r.microsoftGraphConversationMember = &microsoftGraphConversationMember
	return r
}

func (r ApiTeamsPrimaryChannelUpdateMembersRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.TeamsPrimaryChannelUpdateMembersExecute(r)
}

/*
TeamsPrimaryChannelUpdateMembers Update the navigation property members in teams

A collection of membership records associated with the channel.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param teamId key: id of team
 @param conversationMemberId key: id of conversationMember
 @return ApiTeamsPrimaryChannelUpdateMembersRequest
*/
func (a *TeamsChannelApiService) TeamsPrimaryChannelUpdateMembers(ctx _context.Context, teamId string, conversationMemberId string) ApiTeamsPrimaryChannelUpdateMembersRequest {
	return ApiTeamsPrimaryChannelUpdateMembersRequest{
		ApiService: a,
		ctx: ctx,
		teamId: teamId,
		conversationMemberId: conversationMemberId,
	}
}

// Execute executes the request
func (a *TeamsChannelApiService) TeamsPrimaryChannelUpdateMembersExecute(r ApiTeamsPrimaryChannelUpdateMembersRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPatch
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TeamsChannelApiService.TeamsPrimaryChannelUpdateMembers")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/teams/{team-id}/primaryChannel/members/{conversationMember-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"team-id"+"}", _neturl.PathEscape(parameterToString(r.teamId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"conversationMember-id"+"}", _neturl.PathEscape(parameterToString(r.conversationMemberId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphConversationMember == nil {
		return nil, reportError("microsoftGraphConversationMember is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphConversationMember
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiTeamsPrimaryChannelUpdateMessagesRequest struct {
	ctx _context.Context
	ApiService *TeamsChannelApiService
	teamId string
	chatMessageId string
	microsoftGraphChatMessage *MicrosoftGraphChatMessage
}

// New navigation property values
func (r ApiTeamsPrimaryChannelUpdateMessagesRequest) MicrosoftGraphChatMessage(microsoftGraphChatMessage MicrosoftGraphChatMessage) ApiTeamsPrimaryChannelUpdateMessagesRequest {
	r.microsoftGraphChatMessage = &microsoftGraphChatMessage
	return r
}

func (r ApiTeamsPrimaryChannelUpdateMessagesRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.TeamsPrimaryChannelUpdateMessagesExecute(r)
}

/*
TeamsPrimaryChannelUpdateMessages Update the navigation property messages in teams

A collection of all the messages in the channel. A navigation property. Nullable.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param teamId key: id of team
 @param chatMessageId key: id of chatMessage
 @return ApiTeamsPrimaryChannelUpdateMessagesRequest
*/
func (a *TeamsChannelApiService) TeamsPrimaryChannelUpdateMessages(ctx _context.Context, teamId string, chatMessageId string) ApiTeamsPrimaryChannelUpdateMessagesRequest {
	return ApiTeamsPrimaryChannelUpdateMessagesRequest{
		ApiService: a,
		ctx: ctx,
		teamId: teamId,
		chatMessageId: chatMessageId,
	}
}

// Execute executes the request
func (a *TeamsChannelApiService) TeamsPrimaryChannelUpdateMessagesExecute(r ApiTeamsPrimaryChannelUpdateMessagesRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPatch
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TeamsChannelApiService.TeamsPrimaryChannelUpdateMessages")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/teams/{team-id}/primaryChannel/messages/{chatMessage-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"team-id"+"}", _neturl.PathEscape(parameterToString(r.teamId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"chatMessage-id"+"}", _neturl.PathEscape(parameterToString(r.chatMessageId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphChatMessage == nil {
		return nil, reportError("microsoftGraphChatMessage is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphChatMessage
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiTeamsPrimaryChannelUpdateTabsRequest struct {
	ctx _context.Context
	ApiService *TeamsChannelApiService
	teamId string
	teamsTabId string
	microsoftGraphTeamsTab *MicrosoftGraphTeamsTab
}

// New navigation property values
func (r ApiTeamsPrimaryChannelUpdateTabsRequest) MicrosoftGraphTeamsTab(microsoftGraphTeamsTab MicrosoftGraphTeamsTab) ApiTeamsPrimaryChannelUpdateTabsRequest {
	r.microsoftGraphTeamsTab = &microsoftGraphTeamsTab
	return r
}

func (r ApiTeamsPrimaryChannelUpdateTabsRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.TeamsPrimaryChannelUpdateTabsExecute(r)
}

/*
TeamsPrimaryChannelUpdateTabs Update the navigation property tabs in teams

A collection of all the tabs in the channel. A navigation property.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param teamId key: id of team
 @param teamsTabId key: id of teamsTab
 @return ApiTeamsPrimaryChannelUpdateTabsRequest
*/
func (a *TeamsChannelApiService) TeamsPrimaryChannelUpdateTabs(ctx _context.Context, teamId string, teamsTabId string) ApiTeamsPrimaryChannelUpdateTabsRequest {
	return ApiTeamsPrimaryChannelUpdateTabsRequest{
		ApiService: a,
		ctx: ctx,
		teamId: teamId,
		teamsTabId: teamsTabId,
	}
}

// Execute executes the request
func (a *TeamsChannelApiService) TeamsPrimaryChannelUpdateTabsExecute(r ApiTeamsPrimaryChannelUpdateTabsRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPatch
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TeamsChannelApiService.TeamsPrimaryChannelUpdateTabs")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/teams/{team-id}/primaryChannel/tabs/{teamsTab-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"team-id"+"}", _neturl.PathEscape(parameterToString(r.teamId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"teamsTab-id"+"}", _neturl.PathEscape(parameterToString(r.teamsTabId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphTeamsTab == nil {
		return nil, reportError("microsoftGraphTeamsTab is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphTeamsTab
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiTeamsUpdateChannelsRequest struct {
	ctx _context.Context
	ApiService *TeamsChannelApiService
	teamId string
	channelId string
	microsoftGraphChannel *MicrosoftGraphChannel
}

// New navigation property values
func (r ApiTeamsUpdateChannelsRequest) MicrosoftGraphChannel(microsoftGraphChannel MicrosoftGraphChannel) ApiTeamsUpdateChannelsRequest {
	r.microsoftGraphChannel = &microsoftGraphChannel
	return r
}

func (r ApiTeamsUpdateChannelsRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.TeamsUpdateChannelsExecute(r)
}

/*
TeamsUpdateChannels Update the navigation property channels in teams

The collection of channels & messages associated with the team.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param teamId key: id of team
 @param channelId key: id of channel
 @return ApiTeamsUpdateChannelsRequest
*/
func (a *TeamsChannelApiService) TeamsUpdateChannels(ctx _context.Context, teamId string, channelId string) ApiTeamsUpdateChannelsRequest {
	return ApiTeamsUpdateChannelsRequest{
		ApiService: a,
		ctx: ctx,
		teamId: teamId,
		channelId: channelId,
	}
}

// Execute executes the request
func (a *TeamsChannelApiService) TeamsUpdateChannelsExecute(r ApiTeamsUpdateChannelsRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPatch
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TeamsChannelApiService.TeamsUpdateChannels")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/teams/{team-id}/channels/{channel-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"team-id"+"}", _neturl.PathEscape(parameterToString(r.teamId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"channel-id"+"}", _neturl.PathEscape(parameterToString(r.channelId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphChannel == nil {
		return nil, reportError("microsoftGraphChannel is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphChannel
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiTeamsUpdatePrimaryChannelRequest struct {
	ctx _context.Context
	ApiService *TeamsChannelApiService
	teamId string
	microsoftGraphChannel *MicrosoftGraphChannel
}

// New navigation property values
func (r ApiTeamsUpdatePrimaryChannelRequest) MicrosoftGraphChannel(microsoftGraphChannel MicrosoftGraphChannel) ApiTeamsUpdatePrimaryChannelRequest {
	r.microsoftGraphChannel = &microsoftGraphChannel
	return r
}

func (r ApiTeamsUpdatePrimaryChannelRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.TeamsUpdatePrimaryChannelExecute(r)
}

/*
TeamsUpdatePrimaryChannel Update the navigation property primaryChannel in teams

The general channel for the team.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param teamId key: id of team
 @return ApiTeamsUpdatePrimaryChannelRequest
*/
func (a *TeamsChannelApiService) TeamsUpdatePrimaryChannel(ctx _context.Context, teamId string) ApiTeamsUpdatePrimaryChannelRequest {
	return ApiTeamsUpdatePrimaryChannelRequest{
		ApiService: a,
		ctx: ctx,
		teamId: teamId,
	}
}

// Execute executes the request
func (a *TeamsChannelApiService) TeamsUpdatePrimaryChannelExecute(r ApiTeamsUpdatePrimaryChannelRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPatch
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TeamsChannelApiService.TeamsUpdatePrimaryChannel")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/teams/{team-id}/primaryChannel"
	localVarPath = strings.Replace(localVarPath, "{"+"team-id"+"}", _neturl.PathEscape(parameterToString(r.teamId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphChannel == nil {
		return nil, reportError("microsoftGraphChannel is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphChannel
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}
