/*
Partial Graph API

No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

API version: v1.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package openapi

import (
	"bytes"
	_context "context"
	_ioutil "io/ioutil"
	_nethttp "net/http"
	_neturl "net/url"
	"strings"
)

// Linger please
var (
	_ _context.Context
)

// TeamsScheduleApiService TeamsScheduleApi service
type TeamsScheduleApiService service

type ApiTeamsDeleteScheduleRequest struct {
	ctx _context.Context
	ApiService *TeamsScheduleApiService
	teamId string
	ifMatch *string
}

// ETag
func (r ApiTeamsDeleteScheduleRequest) IfMatch(ifMatch string) ApiTeamsDeleteScheduleRequest {
	r.ifMatch = &ifMatch
	return r
}

func (r ApiTeamsDeleteScheduleRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.TeamsDeleteScheduleExecute(r)
}

/*
TeamsDeleteSchedule Delete navigation property schedule for teams

The schedule of shifts for this team.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param teamId key: id of team
 @return ApiTeamsDeleteScheduleRequest
*/
func (a *TeamsScheduleApiService) TeamsDeleteSchedule(ctx _context.Context, teamId string) ApiTeamsDeleteScheduleRequest {
	return ApiTeamsDeleteScheduleRequest{
		ApiService: a,
		ctx: ctx,
		teamId: teamId,
	}
}

// Execute executes the request
func (a *TeamsScheduleApiService) TeamsDeleteScheduleExecute(r ApiTeamsDeleteScheduleRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TeamsScheduleApiService.TeamsDeleteSchedule")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/teams/{team-id}/schedule"
	localVarPath = strings.Replace(localVarPath, "{"+"team-id"+"}", _neturl.PathEscape(parameterToString(r.teamId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ifMatch != nil {
		localVarHeaderParams["If-Match"] = parameterToString(*r.ifMatch, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiTeamsGetScheduleRequest struct {
	ctx _context.Context
	ApiService *TeamsScheduleApiService
	teamId string
	select_ *[]string
	expand *[]string
}

// Select properties to be returned
func (r ApiTeamsGetScheduleRequest) Select_(select_ []string) ApiTeamsGetScheduleRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiTeamsGetScheduleRequest) Expand(expand []string) ApiTeamsGetScheduleRequest {
	r.expand = &expand
	return r
}

func (r ApiTeamsGetScheduleRequest) Execute() (MicrosoftGraphSchedule, *_nethttp.Response, error) {
	return r.ApiService.TeamsGetScheduleExecute(r)
}

/*
TeamsGetSchedule Get schedule from teams

The schedule of shifts for this team.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param teamId key: id of team
 @return ApiTeamsGetScheduleRequest
*/
func (a *TeamsScheduleApiService) TeamsGetSchedule(ctx _context.Context, teamId string) ApiTeamsGetScheduleRequest {
	return ApiTeamsGetScheduleRequest{
		ApiService: a,
		ctx: ctx,
		teamId: teamId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphSchedule
func (a *TeamsScheduleApiService) TeamsGetScheduleExecute(r ApiTeamsGetScheduleRequest) (MicrosoftGraphSchedule, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphSchedule
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TeamsScheduleApiService.TeamsGetSchedule")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/teams/{team-id}/schedule"
	localVarPath = strings.Replace(localVarPath, "{"+"team-id"+"}", _neturl.PathEscape(parameterToString(r.teamId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiTeamsScheduleCreateOfferShiftRequestsRequest struct {
	ctx _context.Context
	ApiService *TeamsScheduleApiService
	teamId string
	microsoftGraphOfferShiftRequest *MicrosoftGraphOfferShiftRequest
}

// New navigation property
func (r ApiTeamsScheduleCreateOfferShiftRequestsRequest) MicrosoftGraphOfferShiftRequest(microsoftGraphOfferShiftRequest MicrosoftGraphOfferShiftRequest) ApiTeamsScheduleCreateOfferShiftRequestsRequest {
	r.microsoftGraphOfferShiftRequest = &microsoftGraphOfferShiftRequest
	return r
}

func (r ApiTeamsScheduleCreateOfferShiftRequestsRequest) Execute() (MicrosoftGraphOfferShiftRequest, *_nethttp.Response, error) {
	return r.ApiService.TeamsScheduleCreateOfferShiftRequestsExecute(r)
}

/*
TeamsScheduleCreateOfferShiftRequests Create new navigation property to offerShiftRequests for teams

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param teamId key: id of team
 @return ApiTeamsScheduleCreateOfferShiftRequestsRequest
*/
func (a *TeamsScheduleApiService) TeamsScheduleCreateOfferShiftRequests(ctx _context.Context, teamId string) ApiTeamsScheduleCreateOfferShiftRequestsRequest {
	return ApiTeamsScheduleCreateOfferShiftRequestsRequest{
		ApiService: a,
		ctx: ctx,
		teamId: teamId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphOfferShiftRequest
func (a *TeamsScheduleApiService) TeamsScheduleCreateOfferShiftRequestsExecute(r ApiTeamsScheduleCreateOfferShiftRequestsRequest) (MicrosoftGraphOfferShiftRequest, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphOfferShiftRequest
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TeamsScheduleApiService.TeamsScheduleCreateOfferShiftRequests")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/teams/{team-id}/schedule/offerShiftRequests"
	localVarPath = strings.Replace(localVarPath, "{"+"team-id"+"}", _neturl.PathEscape(parameterToString(r.teamId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphOfferShiftRequest == nil {
		return localVarReturnValue, nil, reportError("microsoftGraphOfferShiftRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphOfferShiftRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiTeamsScheduleCreateOpenShiftChangeRequestsRequest struct {
	ctx _context.Context
	ApiService *TeamsScheduleApiService
	teamId string
	microsoftGraphOpenShiftChangeRequest *MicrosoftGraphOpenShiftChangeRequest
}

// New navigation property
func (r ApiTeamsScheduleCreateOpenShiftChangeRequestsRequest) MicrosoftGraphOpenShiftChangeRequest(microsoftGraphOpenShiftChangeRequest MicrosoftGraphOpenShiftChangeRequest) ApiTeamsScheduleCreateOpenShiftChangeRequestsRequest {
	r.microsoftGraphOpenShiftChangeRequest = &microsoftGraphOpenShiftChangeRequest
	return r
}

func (r ApiTeamsScheduleCreateOpenShiftChangeRequestsRequest) Execute() (MicrosoftGraphOpenShiftChangeRequest, *_nethttp.Response, error) {
	return r.ApiService.TeamsScheduleCreateOpenShiftChangeRequestsExecute(r)
}

/*
TeamsScheduleCreateOpenShiftChangeRequests Create new navigation property to openShiftChangeRequests for teams

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param teamId key: id of team
 @return ApiTeamsScheduleCreateOpenShiftChangeRequestsRequest
*/
func (a *TeamsScheduleApiService) TeamsScheduleCreateOpenShiftChangeRequests(ctx _context.Context, teamId string) ApiTeamsScheduleCreateOpenShiftChangeRequestsRequest {
	return ApiTeamsScheduleCreateOpenShiftChangeRequestsRequest{
		ApiService: a,
		ctx: ctx,
		teamId: teamId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphOpenShiftChangeRequest
func (a *TeamsScheduleApiService) TeamsScheduleCreateOpenShiftChangeRequestsExecute(r ApiTeamsScheduleCreateOpenShiftChangeRequestsRequest) (MicrosoftGraphOpenShiftChangeRequest, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphOpenShiftChangeRequest
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TeamsScheduleApiService.TeamsScheduleCreateOpenShiftChangeRequests")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/teams/{team-id}/schedule/openShiftChangeRequests"
	localVarPath = strings.Replace(localVarPath, "{"+"team-id"+"}", _neturl.PathEscape(parameterToString(r.teamId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphOpenShiftChangeRequest == nil {
		return localVarReturnValue, nil, reportError("microsoftGraphOpenShiftChangeRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphOpenShiftChangeRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiTeamsScheduleCreateOpenShiftsRequest struct {
	ctx _context.Context
	ApiService *TeamsScheduleApiService
	teamId string
	microsoftGraphOpenShift *MicrosoftGraphOpenShift
}

// New navigation property
func (r ApiTeamsScheduleCreateOpenShiftsRequest) MicrosoftGraphOpenShift(microsoftGraphOpenShift MicrosoftGraphOpenShift) ApiTeamsScheduleCreateOpenShiftsRequest {
	r.microsoftGraphOpenShift = &microsoftGraphOpenShift
	return r
}

func (r ApiTeamsScheduleCreateOpenShiftsRequest) Execute() (MicrosoftGraphOpenShift, *_nethttp.Response, error) {
	return r.ApiService.TeamsScheduleCreateOpenShiftsExecute(r)
}

/*
TeamsScheduleCreateOpenShifts Create new navigation property to openShifts for teams

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param teamId key: id of team
 @return ApiTeamsScheduleCreateOpenShiftsRequest
*/
func (a *TeamsScheduleApiService) TeamsScheduleCreateOpenShifts(ctx _context.Context, teamId string) ApiTeamsScheduleCreateOpenShiftsRequest {
	return ApiTeamsScheduleCreateOpenShiftsRequest{
		ApiService: a,
		ctx: ctx,
		teamId: teamId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphOpenShift
func (a *TeamsScheduleApiService) TeamsScheduleCreateOpenShiftsExecute(r ApiTeamsScheduleCreateOpenShiftsRequest) (MicrosoftGraphOpenShift, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphOpenShift
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TeamsScheduleApiService.TeamsScheduleCreateOpenShifts")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/teams/{team-id}/schedule/openShifts"
	localVarPath = strings.Replace(localVarPath, "{"+"team-id"+"}", _neturl.PathEscape(parameterToString(r.teamId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphOpenShift == nil {
		return localVarReturnValue, nil, reportError("microsoftGraphOpenShift is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphOpenShift
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiTeamsScheduleCreateSchedulingGroupsRequest struct {
	ctx _context.Context
	ApiService *TeamsScheduleApiService
	teamId string
	microsoftGraphSchedulingGroup *MicrosoftGraphSchedulingGroup
}

// New navigation property
func (r ApiTeamsScheduleCreateSchedulingGroupsRequest) MicrosoftGraphSchedulingGroup(microsoftGraphSchedulingGroup MicrosoftGraphSchedulingGroup) ApiTeamsScheduleCreateSchedulingGroupsRequest {
	r.microsoftGraphSchedulingGroup = &microsoftGraphSchedulingGroup
	return r
}

func (r ApiTeamsScheduleCreateSchedulingGroupsRequest) Execute() (MicrosoftGraphSchedulingGroup, *_nethttp.Response, error) {
	return r.ApiService.TeamsScheduleCreateSchedulingGroupsExecute(r)
}

/*
TeamsScheduleCreateSchedulingGroups Create new navigation property to schedulingGroups for teams

The logical grouping of users in the schedule (usually by role).

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param teamId key: id of team
 @return ApiTeamsScheduleCreateSchedulingGroupsRequest
*/
func (a *TeamsScheduleApiService) TeamsScheduleCreateSchedulingGroups(ctx _context.Context, teamId string) ApiTeamsScheduleCreateSchedulingGroupsRequest {
	return ApiTeamsScheduleCreateSchedulingGroupsRequest{
		ApiService: a,
		ctx: ctx,
		teamId: teamId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphSchedulingGroup
func (a *TeamsScheduleApiService) TeamsScheduleCreateSchedulingGroupsExecute(r ApiTeamsScheduleCreateSchedulingGroupsRequest) (MicrosoftGraphSchedulingGroup, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphSchedulingGroup
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TeamsScheduleApiService.TeamsScheduleCreateSchedulingGroups")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/teams/{team-id}/schedule/schedulingGroups"
	localVarPath = strings.Replace(localVarPath, "{"+"team-id"+"}", _neturl.PathEscape(parameterToString(r.teamId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphSchedulingGroup == nil {
		return localVarReturnValue, nil, reportError("microsoftGraphSchedulingGroup is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphSchedulingGroup
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiTeamsScheduleCreateShiftsRequest struct {
	ctx _context.Context
	ApiService *TeamsScheduleApiService
	teamId string
	microsoftGraphShift *MicrosoftGraphShift
}

// New navigation property
func (r ApiTeamsScheduleCreateShiftsRequest) MicrosoftGraphShift(microsoftGraphShift MicrosoftGraphShift) ApiTeamsScheduleCreateShiftsRequest {
	r.microsoftGraphShift = &microsoftGraphShift
	return r
}

func (r ApiTeamsScheduleCreateShiftsRequest) Execute() (MicrosoftGraphShift, *_nethttp.Response, error) {
	return r.ApiService.TeamsScheduleCreateShiftsExecute(r)
}

/*
TeamsScheduleCreateShifts Create new navigation property to shifts for teams

The shifts in the schedule.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param teamId key: id of team
 @return ApiTeamsScheduleCreateShiftsRequest
*/
func (a *TeamsScheduleApiService) TeamsScheduleCreateShifts(ctx _context.Context, teamId string) ApiTeamsScheduleCreateShiftsRequest {
	return ApiTeamsScheduleCreateShiftsRequest{
		ApiService: a,
		ctx: ctx,
		teamId: teamId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphShift
func (a *TeamsScheduleApiService) TeamsScheduleCreateShiftsExecute(r ApiTeamsScheduleCreateShiftsRequest) (MicrosoftGraphShift, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphShift
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TeamsScheduleApiService.TeamsScheduleCreateShifts")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/teams/{team-id}/schedule/shifts"
	localVarPath = strings.Replace(localVarPath, "{"+"team-id"+"}", _neturl.PathEscape(parameterToString(r.teamId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphShift == nil {
		return localVarReturnValue, nil, reportError("microsoftGraphShift is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphShift
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiTeamsScheduleCreateSwapShiftsChangeRequestsRequest struct {
	ctx _context.Context
	ApiService *TeamsScheduleApiService
	teamId string
	microsoftGraphSwapShiftsChangeRequest *MicrosoftGraphSwapShiftsChangeRequest
}

// New navigation property
func (r ApiTeamsScheduleCreateSwapShiftsChangeRequestsRequest) MicrosoftGraphSwapShiftsChangeRequest(microsoftGraphSwapShiftsChangeRequest MicrosoftGraphSwapShiftsChangeRequest) ApiTeamsScheduleCreateSwapShiftsChangeRequestsRequest {
	r.microsoftGraphSwapShiftsChangeRequest = &microsoftGraphSwapShiftsChangeRequest
	return r
}

func (r ApiTeamsScheduleCreateSwapShiftsChangeRequestsRequest) Execute() (MicrosoftGraphSwapShiftsChangeRequest, *_nethttp.Response, error) {
	return r.ApiService.TeamsScheduleCreateSwapShiftsChangeRequestsExecute(r)
}

/*
TeamsScheduleCreateSwapShiftsChangeRequests Create new navigation property to swapShiftsChangeRequests for teams

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param teamId key: id of team
 @return ApiTeamsScheduleCreateSwapShiftsChangeRequestsRequest
*/
func (a *TeamsScheduleApiService) TeamsScheduleCreateSwapShiftsChangeRequests(ctx _context.Context, teamId string) ApiTeamsScheduleCreateSwapShiftsChangeRequestsRequest {
	return ApiTeamsScheduleCreateSwapShiftsChangeRequestsRequest{
		ApiService: a,
		ctx: ctx,
		teamId: teamId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphSwapShiftsChangeRequest
func (a *TeamsScheduleApiService) TeamsScheduleCreateSwapShiftsChangeRequestsExecute(r ApiTeamsScheduleCreateSwapShiftsChangeRequestsRequest) (MicrosoftGraphSwapShiftsChangeRequest, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphSwapShiftsChangeRequest
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TeamsScheduleApiService.TeamsScheduleCreateSwapShiftsChangeRequests")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/teams/{team-id}/schedule/swapShiftsChangeRequests"
	localVarPath = strings.Replace(localVarPath, "{"+"team-id"+"}", _neturl.PathEscape(parameterToString(r.teamId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphSwapShiftsChangeRequest == nil {
		return localVarReturnValue, nil, reportError("microsoftGraphSwapShiftsChangeRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphSwapShiftsChangeRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiTeamsScheduleCreateTimeOffReasonsRequest struct {
	ctx _context.Context
	ApiService *TeamsScheduleApiService
	teamId string
	microsoftGraphTimeOffReason *MicrosoftGraphTimeOffReason
}

// New navigation property
func (r ApiTeamsScheduleCreateTimeOffReasonsRequest) MicrosoftGraphTimeOffReason(microsoftGraphTimeOffReason MicrosoftGraphTimeOffReason) ApiTeamsScheduleCreateTimeOffReasonsRequest {
	r.microsoftGraphTimeOffReason = &microsoftGraphTimeOffReason
	return r
}

func (r ApiTeamsScheduleCreateTimeOffReasonsRequest) Execute() (MicrosoftGraphTimeOffReason, *_nethttp.Response, error) {
	return r.ApiService.TeamsScheduleCreateTimeOffReasonsExecute(r)
}

/*
TeamsScheduleCreateTimeOffReasons Create new navigation property to timeOffReasons for teams

The set of reasons for a time off in the schedule.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param teamId key: id of team
 @return ApiTeamsScheduleCreateTimeOffReasonsRequest
*/
func (a *TeamsScheduleApiService) TeamsScheduleCreateTimeOffReasons(ctx _context.Context, teamId string) ApiTeamsScheduleCreateTimeOffReasonsRequest {
	return ApiTeamsScheduleCreateTimeOffReasonsRequest{
		ApiService: a,
		ctx: ctx,
		teamId: teamId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphTimeOffReason
func (a *TeamsScheduleApiService) TeamsScheduleCreateTimeOffReasonsExecute(r ApiTeamsScheduleCreateTimeOffReasonsRequest) (MicrosoftGraphTimeOffReason, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphTimeOffReason
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TeamsScheduleApiService.TeamsScheduleCreateTimeOffReasons")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/teams/{team-id}/schedule/timeOffReasons"
	localVarPath = strings.Replace(localVarPath, "{"+"team-id"+"}", _neturl.PathEscape(parameterToString(r.teamId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphTimeOffReason == nil {
		return localVarReturnValue, nil, reportError("microsoftGraphTimeOffReason is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphTimeOffReason
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiTeamsScheduleCreateTimeOffRequestsRequest struct {
	ctx _context.Context
	ApiService *TeamsScheduleApiService
	teamId string
	microsoftGraphTimeOffRequest *MicrosoftGraphTimeOffRequest
}

// New navigation property
func (r ApiTeamsScheduleCreateTimeOffRequestsRequest) MicrosoftGraphTimeOffRequest(microsoftGraphTimeOffRequest MicrosoftGraphTimeOffRequest) ApiTeamsScheduleCreateTimeOffRequestsRequest {
	r.microsoftGraphTimeOffRequest = &microsoftGraphTimeOffRequest
	return r
}

func (r ApiTeamsScheduleCreateTimeOffRequestsRequest) Execute() (MicrosoftGraphTimeOffRequest, *_nethttp.Response, error) {
	return r.ApiService.TeamsScheduleCreateTimeOffRequestsExecute(r)
}

/*
TeamsScheduleCreateTimeOffRequests Create new navigation property to timeOffRequests for teams

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param teamId key: id of team
 @return ApiTeamsScheduleCreateTimeOffRequestsRequest
*/
func (a *TeamsScheduleApiService) TeamsScheduleCreateTimeOffRequests(ctx _context.Context, teamId string) ApiTeamsScheduleCreateTimeOffRequestsRequest {
	return ApiTeamsScheduleCreateTimeOffRequestsRequest{
		ApiService: a,
		ctx: ctx,
		teamId: teamId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphTimeOffRequest
func (a *TeamsScheduleApiService) TeamsScheduleCreateTimeOffRequestsExecute(r ApiTeamsScheduleCreateTimeOffRequestsRequest) (MicrosoftGraphTimeOffRequest, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphTimeOffRequest
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TeamsScheduleApiService.TeamsScheduleCreateTimeOffRequests")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/teams/{team-id}/schedule/timeOffRequests"
	localVarPath = strings.Replace(localVarPath, "{"+"team-id"+"}", _neturl.PathEscape(parameterToString(r.teamId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphTimeOffRequest == nil {
		return localVarReturnValue, nil, reportError("microsoftGraphTimeOffRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphTimeOffRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiTeamsScheduleCreateTimesOffRequest struct {
	ctx _context.Context
	ApiService *TeamsScheduleApiService
	teamId string
	microsoftGraphTimeOff *MicrosoftGraphTimeOff
}

// New navigation property
func (r ApiTeamsScheduleCreateTimesOffRequest) MicrosoftGraphTimeOff(microsoftGraphTimeOff MicrosoftGraphTimeOff) ApiTeamsScheduleCreateTimesOffRequest {
	r.microsoftGraphTimeOff = &microsoftGraphTimeOff
	return r
}

func (r ApiTeamsScheduleCreateTimesOffRequest) Execute() (MicrosoftGraphTimeOff, *_nethttp.Response, error) {
	return r.ApiService.TeamsScheduleCreateTimesOffExecute(r)
}

/*
TeamsScheduleCreateTimesOff Create new navigation property to timesOff for teams

The instances of times off in the schedule.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param teamId key: id of team
 @return ApiTeamsScheduleCreateTimesOffRequest
*/
func (a *TeamsScheduleApiService) TeamsScheduleCreateTimesOff(ctx _context.Context, teamId string) ApiTeamsScheduleCreateTimesOffRequest {
	return ApiTeamsScheduleCreateTimesOffRequest{
		ApiService: a,
		ctx: ctx,
		teamId: teamId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphTimeOff
func (a *TeamsScheduleApiService) TeamsScheduleCreateTimesOffExecute(r ApiTeamsScheduleCreateTimesOffRequest) (MicrosoftGraphTimeOff, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphTimeOff
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TeamsScheduleApiService.TeamsScheduleCreateTimesOff")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/teams/{team-id}/schedule/timesOff"
	localVarPath = strings.Replace(localVarPath, "{"+"team-id"+"}", _neturl.PathEscape(parameterToString(r.teamId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphTimeOff == nil {
		return localVarReturnValue, nil, reportError("microsoftGraphTimeOff is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphTimeOff
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiTeamsScheduleDeleteOfferShiftRequestsRequest struct {
	ctx _context.Context
	ApiService *TeamsScheduleApiService
	teamId string
	offerShiftRequestId string
	ifMatch *string
}

// ETag
func (r ApiTeamsScheduleDeleteOfferShiftRequestsRequest) IfMatch(ifMatch string) ApiTeamsScheduleDeleteOfferShiftRequestsRequest {
	r.ifMatch = &ifMatch
	return r
}

func (r ApiTeamsScheduleDeleteOfferShiftRequestsRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.TeamsScheduleDeleteOfferShiftRequestsExecute(r)
}

/*
TeamsScheduleDeleteOfferShiftRequests Delete navigation property offerShiftRequests for teams

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param teamId key: id of team
 @param offerShiftRequestId key: id of offerShiftRequest
 @return ApiTeamsScheduleDeleteOfferShiftRequestsRequest
*/
func (a *TeamsScheduleApiService) TeamsScheduleDeleteOfferShiftRequests(ctx _context.Context, teamId string, offerShiftRequestId string) ApiTeamsScheduleDeleteOfferShiftRequestsRequest {
	return ApiTeamsScheduleDeleteOfferShiftRequestsRequest{
		ApiService: a,
		ctx: ctx,
		teamId: teamId,
		offerShiftRequestId: offerShiftRequestId,
	}
}

// Execute executes the request
func (a *TeamsScheduleApiService) TeamsScheduleDeleteOfferShiftRequestsExecute(r ApiTeamsScheduleDeleteOfferShiftRequestsRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TeamsScheduleApiService.TeamsScheduleDeleteOfferShiftRequests")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/teams/{team-id}/schedule/offerShiftRequests/{offerShiftRequest-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"team-id"+"}", _neturl.PathEscape(parameterToString(r.teamId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"offerShiftRequest-id"+"}", _neturl.PathEscape(parameterToString(r.offerShiftRequestId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ifMatch != nil {
		localVarHeaderParams["If-Match"] = parameterToString(*r.ifMatch, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiTeamsScheduleDeleteOpenShiftChangeRequestsRequest struct {
	ctx _context.Context
	ApiService *TeamsScheduleApiService
	teamId string
	openShiftChangeRequestId string
	ifMatch *string
}

// ETag
func (r ApiTeamsScheduleDeleteOpenShiftChangeRequestsRequest) IfMatch(ifMatch string) ApiTeamsScheduleDeleteOpenShiftChangeRequestsRequest {
	r.ifMatch = &ifMatch
	return r
}

func (r ApiTeamsScheduleDeleteOpenShiftChangeRequestsRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.TeamsScheduleDeleteOpenShiftChangeRequestsExecute(r)
}

/*
TeamsScheduleDeleteOpenShiftChangeRequests Delete navigation property openShiftChangeRequests for teams

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param teamId key: id of team
 @param openShiftChangeRequestId key: id of openShiftChangeRequest
 @return ApiTeamsScheduleDeleteOpenShiftChangeRequestsRequest
*/
func (a *TeamsScheduleApiService) TeamsScheduleDeleteOpenShiftChangeRequests(ctx _context.Context, teamId string, openShiftChangeRequestId string) ApiTeamsScheduleDeleteOpenShiftChangeRequestsRequest {
	return ApiTeamsScheduleDeleteOpenShiftChangeRequestsRequest{
		ApiService: a,
		ctx: ctx,
		teamId: teamId,
		openShiftChangeRequestId: openShiftChangeRequestId,
	}
}

// Execute executes the request
func (a *TeamsScheduleApiService) TeamsScheduleDeleteOpenShiftChangeRequestsExecute(r ApiTeamsScheduleDeleteOpenShiftChangeRequestsRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TeamsScheduleApiService.TeamsScheduleDeleteOpenShiftChangeRequests")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/teams/{team-id}/schedule/openShiftChangeRequests/{openShiftChangeRequest-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"team-id"+"}", _neturl.PathEscape(parameterToString(r.teamId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"openShiftChangeRequest-id"+"}", _neturl.PathEscape(parameterToString(r.openShiftChangeRequestId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ifMatch != nil {
		localVarHeaderParams["If-Match"] = parameterToString(*r.ifMatch, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiTeamsScheduleDeleteOpenShiftsRequest struct {
	ctx _context.Context
	ApiService *TeamsScheduleApiService
	teamId string
	openShiftId string
	ifMatch *string
}

// ETag
func (r ApiTeamsScheduleDeleteOpenShiftsRequest) IfMatch(ifMatch string) ApiTeamsScheduleDeleteOpenShiftsRequest {
	r.ifMatch = &ifMatch
	return r
}

func (r ApiTeamsScheduleDeleteOpenShiftsRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.TeamsScheduleDeleteOpenShiftsExecute(r)
}

/*
TeamsScheduleDeleteOpenShifts Delete navigation property openShifts for teams

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param teamId key: id of team
 @param openShiftId key: id of openShift
 @return ApiTeamsScheduleDeleteOpenShiftsRequest
*/
func (a *TeamsScheduleApiService) TeamsScheduleDeleteOpenShifts(ctx _context.Context, teamId string, openShiftId string) ApiTeamsScheduleDeleteOpenShiftsRequest {
	return ApiTeamsScheduleDeleteOpenShiftsRequest{
		ApiService: a,
		ctx: ctx,
		teamId: teamId,
		openShiftId: openShiftId,
	}
}

// Execute executes the request
func (a *TeamsScheduleApiService) TeamsScheduleDeleteOpenShiftsExecute(r ApiTeamsScheduleDeleteOpenShiftsRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TeamsScheduleApiService.TeamsScheduleDeleteOpenShifts")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/teams/{team-id}/schedule/openShifts/{openShift-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"team-id"+"}", _neturl.PathEscape(parameterToString(r.teamId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"openShift-id"+"}", _neturl.PathEscape(parameterToString(r.openShiftId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ifMatch != nil {
		localVarHeaderParams["If-Match"] = parameterToString(*r.ifMatch, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiTeamsScheduleDeleteSchedulingGroupsRequest struct {
	ctx _context.Context
	ApiService *TeamsScheduleApiService
	teamId string
	schedulingGroupId string
	ifMatch *string
}

// ETag
func (r ApiTeamsScheduleDeleteSchedulingGroupsRequest) IfMatch(ifMatch string) ApiTeamsScheduleDeleteSchedulingGroupsRequest {
	r.ifMatch = &ifMatch
	return r
}

func (r ApiTeamsScheduleDeleteSchedulingGroupsRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.TeamsScheduleDeleteSchedulingGroupsExecute(r)
}

/*
TeamsScheduleDeleteSchedulingGroups Delete navigation property schedulingGroups for teams

The logical grouping of users in the schedule (usually by role).

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param teamId key: id of team
 @param schedulingGroupId key: id of schedulingGroup
 @return ApiTeamsScheduleDeleteSchedulingGroupsRequest
*/
func (a *TeamsScheduleApiService) TeamsScheduleDeleteSchedulingGroups(ctx _context.Context, teamId string, schedulingGroupId string) ApiTeamsScheduleDeleteSchedulingGroupsRequest {
	return ApiTeamsScheduleDeleteSchedulingGroupsRequest{
		ApiService: a,
		ctx: ctx,
		teamId: teamId,
		schedulingGroupId: schedulingGroupId,
	}
}

// Execute executes the request
func (a *TeamsScheduleApiService) TeamsScheduleDeleteSchedulingGroupsExecute(r ApiTeamsScheduleDeleteSchedulingGroupsRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TeamsScheduleApiService.TeamsScheduleDeleteSchedulingGroups")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/teams/{team-id}/schedule/schedulingGroups/{schedulingGroup-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"team-id"+"}", _neturl.PathEscape(parameterToString(r.teamId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"schedulingGroup-id"+"}", _neturl.PathEscape(parameterToString(r.schedulingGroupId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ifMatch != nil {
		localVarHeaderParams["If-Match"] = parameterToString(*r.ifMatch, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiTeamsScheduleDeleteShiftsRequest struct {
	ctx _context.Context
	ApiService *TeamsScheduleApiService
	teamId string
	shiftId string
	ifMatch *string
}

// ETag
func (r ApiTeamsScheduleDeleteShiftsRequest) IfMatch(ifMatch string) ApiTeamsScheduleDeleteShiftsRequest {
	r.ifMatch = &ifMatch
	return r
}

func (r ApiTeamsScheduleDeleteShiftsRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.TeamsScheduleDeleteShiftsExecute(r)
}

/*
TeamsScheduleDeleteShifts Delete navigation property shifts for teams

The shifts in the schedule.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param teamId key: id of team
 @param shiftId key: id of shift
 @return ApiTeamsScheduleDeleteShiftsRequest
*/
func (a *TeamsScheduleApiService) TeamsScheduleDeleteShifts(ctx _context.Context, teamId string, shiftId string) ApiTeamsScheduleDeleteShiftsRequest {
	return ApiTeamsScheduleDeleteShiftsRequest{
		ApiService: a,
		ctx: ctx,
		teamId: teamId,
		shiftId: shiftId,
	}
}

// Execute executes the request
func (a *TeamsScheduleApiService) TeamsScheduleDeleteShiftsExecute(r ApiTeamsScheduleDeleteShiftsRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TeamsScheduleApiService.TeamsScheduleDeleteShifts")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/teams/{team-id}/schedule/shifts/{shift-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"team-id"+"}", _neturl.PathEscape(parameterToString(r.teamId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"shift-id"+"}", _neturl.PathEscape(parameterToString(r.shiftId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ifMatch != nil {
		localVarHeaderParams["If-Match"] = parameterToString(*r.ifMatch, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiTeamsScheduleDeleteSwapShiftsChangeRequestsRequest struct {
	ctx _context.Context
	ApiService *TeamsScheduleApiService
	teamId string
	swapShiftsChangeRequestId string
	ifMatch *string
}

// ETag
func (r ApiTeamsScheduleDeleteSwapShiftsChangeRequestsRequest) IfMatch(ifMatch string) ApiTeamsScheduleDeleteSwapShiftsChangeRequestsRequest {
	r.ifMatch = &ifMatch
	return r
}

func (r ApiTeamsScheduleDeleteSwapShiftsChangeRequestsRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.TeamsScheduleDeleteSwapShiftsChangeRequestsExecute(r)
}

/*
TeamsScheduleDeleteSwapShiftsChangeRequests Delete navigation property swapShiftsChangeRequests for teams

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param teamId key: id of team
 @param swapShiftsChangeRequestId key: id of swapShiftsChangeRequest
 @return ApiTeamsScheduleDeleteSwapShiftsChangeRequestsRequest
*/
func (a *TeamsScheduleApiService) TeamsScheduleDeleteSwapShiftsChangeRequests(ctx _context.Context, teamId string, swapShiftsChangeRequestId string) ApiTeamsScheduleDeleteSwapShiftsChangeRequestsRequest {
	return ApiTeamsScheduleDeleteSwapShiftsChangeRequestsRequest{
		ApiService: a,
		ctx: ctx,
		teamId: teamId,
		swapShiftsChangeRequestId: swapShiftsChangeRequestId,
	}
}

// Execute executes the request
func (a *TeamsScheduleApiService) TeamsScheduleDeleteSwapShiftsChangeRequestsExecute(r ApiTeamsScheduleDeleteSwapShiftsChangeRequestsRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TeamsScheduleApiService.TeamsScheduleDeleteSwapShiftsChangeRequests")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/teams/{team-id}/schedule/swapShiftsChangeRequests/{swapShiftsChangeRequest-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"team-id"+"}", _neturl.PathEscape(parameterToString(r.teamId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"swapShiftsChangeRequest-id"+"}", _neturl.PathEscape(parameterToString(r.swapShiftsChangeRequestId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ifMatch != nil {
		localVarHeaderParams["If-Match"] = parameterToString(*r.ifMatch, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiTeamsScheduleDeleteTimeOffReasonsRequest struct {
	ctx _context.Context
	ApiService *TeamsScheduleApiService
	teamId string
	timeOffReasonId string
	ifMatch *string
}

// ETag
func (r ApiTeamsScheduleDeleteTimeOffReasonsRequest) IfMatch(ifMatch string) ApiTeamsScheduleDeleteTimeOffReasonsRequest {
	r.ifMatch = &ifMatch
	return r
}

func (r ApiTeamsScheduleDeleteTimeOffReasonsRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.TeamsScheduleDeleteTimeOffReasonsExecute(r)
}

/*
TeamsScheduleDeleteTimeOffReasons Delete navigation property timeOffReasons for teams

The set of reasons for a time off in the schedule.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param teamId key: id of team
 @param timeOffReasonId key: id of timeOffReason
 @return ApiTeamsScheduleDeleteTimeOffReasonsRequest
*/
func (a *TeamsScheduleApiService) TeamsScheduleDeleteTimeOffReasons(ctx _context.Context, teamId string, timeOffReasonId string) ApiTeamsScheduleDeleteTimeOffReasonsRequest {
	return ApiTeamsScheduleDeleteTimeOffReasonsRequest{
		ApiService: a,
		ctx: ctx,
		teamId: teamId,
		timeOffReasonId: timeOffReasonId,
	}
}

// Execute executes the request
func (a *TeamsScheduleApiService) TeamsScheduleDeleteTimeOffReasonsExecute(r ApiTeamsScheduleDeleteTimeOffReasonsRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TeamsScheduleApiService.TeamsScheduleDeleteTimeOffReasons")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/teams/{team-id}/schedule/timeOffReasons/{timeOffReason-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"team-id"+"}", _neturl.PathEscape(parameterToString(r.teamId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"timeOffReason-id"+"}", _neturl.PathEscape(parameterToString(r.timeOffReasonId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ifMatch != nil {
		localVarHeaderParams["If-Match"] = parameterToString(*r.ifMatch, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiTeamsScheduleDeleteTimeOffRequestsRequest struct {
	ctx _context.Context
	ApiService *TeamsScheduleApiService
	teamId string
	timeOffRequestId string
	ifMatch *string
}

// ETag
func (r ApiTeamsScheduleDeleteTimeOffRequestsRequest) IfMatch(ifMatch string) ApiTeamsScheduleDeleteTimeOffRequestsRequest {
	r.ifMatch = &ifMatch
	return r
}

func (r ApiTeamsScheduleDeleteTimeOffRequestsRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.TeamsScheduleDeleteTimeOffRequestsExecute(r)
}

/*
TeamsScheduleDeleteTimeOffRequests Delete navigation property timeOffRequests for teams

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param teamId key: id of team
 @param timeOffRequestId key: id of timeOffRequest
 @return ApiTeamsScheduleDeleteTimeOffRequestsRequest
*/
func (a *TeamsScheduleApiService) TeamsScheduleDeleteTimeOffRequests(ctx _context.Context, teamId string, timeOffRequestId string) ApiTeamsScheduleDeleteTimeOffRequestsRequest {
	return ApiTeamsScheduleDeleteTimeOffRequestsRequest{
		ApiService: a,
		ctx: ctx,
		teamId: teamId,
		timeOffRequestId: timeOffRequestId,
	}
}

// Execute executes the request
func (a *TeamsScheduleApiService) TeamsScheduleDeleteTimeOffRequestsExecute(r ApiTeamsScheduleDeleteTimeOffRequestsRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TeamsScheduleApiService.TeamsScheduleDeleteTimeOffRequests")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/teams/{team-id}/schedule/timeOffRequests/{timeOffRequest-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"team-id"+"}", _neturl.PathEscape(parameterToString(r.teamId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"timeOffRequest-id"+"}", _neturl.PathEscape(parameterToString(r.timeOffRequestId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ifMatch != nil {
		localVarHeaderParams["If-Match"] = parameterToString(*r.ifMatch, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiTeamsScheduleDeleteTimesOffRequest struct {
	ctx _context.Context
	ApiService *TeamsScheduleApiService
	teamId string
	timeOffId string
	ifMatch *string
}

// ETag
func (r ApiTeamsScheduleDeleteTimesOffRequest) IfMatch(ifMatch string) ApiTeamsScheduleDeleteTimesOffRequest {
	r.ifMatch = &ifMatch
	return r
}

func (r ApiTeamsScheduleDeleteTimesOffRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.TeamsScheduleDeleteTimesOffExecute(r)
}

/*
TeamsScheduleDeleteTimesOff Delete navigation property timesOff for teams

The instances of times off in the schedule.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param teamId key: id of team
 @param timeOffId key: id of timeOff
 @return ApiTeamsScheduleDeleteTimesOffRequest
*/
func (a *TeamsScheduleApiService) TeamsScheduleDeleteTimesOff(ctx _context.Context, teamId string, timeOffId string) ApiTeamsScheduleDeleteTimesOffRequest {
	return ApiTeamsScheduleDeleteTimesOffRequest{
		ApiService: a,
		ctx: ctx,
		teamId: teamId,
		timeOffId: timeOffId,
	}
}

// Execute executes the request
func (a *TeamsScheduleApiService) TeamsScheduleDeleteTimesOffExecute(r ApiTeamsScheduleDeleteTimesOffRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TeamsScheduleApiService.TeamsScheduleDeleteTimesOff")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/teams/{team-id}/schedule/timesOff/{timeOff-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"team-id"+"}", _neturl.PathEscape(parameterToString(r.teamId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"timeOff-id"+"}", _neturl.PathEscape(parameterToString(r.timeOffId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ifMatch != nil {
		localVarHeaderParams["If-Match"] = parameterToString(*r.ifMatch, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiTeamsScheduleGetOfferShiftRequestsRequest struct {
	ctx _context.Context
	ApiService *TeamsScheduleApiService
	teamId string
	offerShiftRequestId string
	select_ *[]string
	expand *[]string
}

// Select properties to be returned
func (r ApiTeamsScheduleGetOfferShiftRequestsRequest) Select_(select_ []string) ApiTeamsScheduleGetOfferShiftRequestsRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiTeamsScheduleGetOfferShiftRequestsRequest) Expand(expand []string) ApiTeamsScheduleGetOfferShiftRequestsRequest {
	r.expand = &expand
	return r
}

func (r ApiTeamsScheduleGetOfferShiftRequestsRequest) Execute() (MicrosoftGraphOfferShiftRequest, *_nethttp.Response, error) {
	return r.ApiService.TeamsScheduleGetOfferShiftRequestsExecute(r)
}

/*
TeamsScheduleGetOfferShiftRequests Get offerShiftRequests from teams

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param teamId key: id of team
 @param offerShiftRequestId key: id of offerShiftRequest
 @return ApiTeamsScheduleGetOfferShiftRequestsRequest
*/
func (a *TeamsScheduleApiService) TeamsScheduleGetOfferShiftRequests(ctx _context.Context, teamId string, offerShiftRequestId string) ApiTeamsScheduleGetOfferShiftRequestsRequest {
	return ApiTeamsScheduleGetOfferShiftRequestsRequest{
		ApiService: a,
		ctx: ctx,
		teamId: teamId,
		offerShiftRequestId: offerShiftRequestId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphOfferShiftRequest
func (a *TeamsScheduleApiService) TeamsScheduleGetOfferShiftRequestsExecute(r ApiTeamsScheduleGetOfferShiftRequestsRequest) (MicrosoftGraphOfferShiftRequest, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphOfferShiftRequest
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TeamsScheduleApiService.TeamsScheduleGetOfferShiftRequests")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/teams/{team-id}/schedule/offerShiftRequests/{offerShiftRequest-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"team-id"+"}", _neturl.PathEscape(parameterToString(r.teamId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"offerShiftRequest-id"+"}", _neturl.PathEscape(parameterToString(r.offerShiftRequestId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiTeamsScheduleGetOpenShiftChangeRequestsRequest struct {
	ctx _context.Context
	ApiService *TeamsScheduleApiService
	teamId string
	openShiftChangeRequestId string
	select_ *[]string
	expand *[]string
}

// Select properties to be returned
func (r ApiTeamsScheduleGetOpenShiftChangeRequestsRequest) Select_(select_ []string) ApiTeamsScheduleGetOpenShiftChangeRequestsRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiTeamsScheduleGetOpenShiftChangeRequestsRequest) Expand(expand []string) ApiTeamsScheduleGetOpenShiftChangeRequestsRequest {
	r.expand = &expand
	return r
}

func (r ApiTeamsScheduleGetOpenShiftChangeRequestsRequest) Execute() (MicrosoftGraphOpenShiftChangeRequest, *_nethttp.Response, error) {
	return r.ApiService.TeamsScheduleGetOpenShiftChangeRequestsExecute(r)
}

/*
TeamsScheduleGetOpenShiftChangeRequests Get openShiftChangeRequests from teams

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param teamId key: id of team
 @param openShiftChangeRequestId key: id of openShiftChangeRequest
 @return ApiTeamsScheduleGetOpenShiftChangeRequestsRequest
*/
func (a *TeamsScheduleApiService) TeamsScheduleGetOpenShiftChangeRequests(ctx _context.Context, teamId string, openShiftChangeRequestId string) ApiTeamsScheduleGetOpenShiftChangeRequestsRequest {
	return ApiTeamsScheduleGetOpenShiftChangeRequestsRequest{
		ApiService: a,
		ctx: ctx,
		teamId: teamId,
		openShiftChangeRequestId: openShiftChangeRequestId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphOpenShiftChangeRequest
func (a *TeamsScheduleApiService) TeamsScheduleGetOpenShiftChangeRequestsExecute(r ApiTeamsScheduleGetOpenShiftChangeRequestsRequest) (MicrosoftGraphOpenShiftChangeRequest, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphOpenShiftChangeRequest
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TeamsScheduleApiService.TeamsScheduleGetOpenShiftChangeRequests")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/teams/{team-id}/schedule/openShiftChangeRequests/{openShiftChangeRequest-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"team-id"+"}", _neturl.PathEscape(parameterToString(r.teamId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"openShiftChangeRequest-id"+"}", _neturl.PathEscape(parameterToString(r.openShiftChangeRequestId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiTeamsScheduleGetOpenShiftsRequest struct {
	ctx _context.Context
	ApiService *TeamsScheduleApiService
	teamId string
	openShiftId string
	select_ *[]string
	expand *[]string
}

// Select properties to be returned
func (r ApiTeamsScheduleGetOpenShiftsRequest) Select_(select_ []string) ApiTeamsScheduleGetOpenShiftsRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiTeamsScheduleGetOpenShiftsRequest) Expand(expand []string) ApiTeamsScheduleGetOpenShiftsRequest {
	r.expand = &expand
	return r
}

func (r ApiTeamsScheduleGetOpenShiftsRequest) Execute() (MicrosoftGraphOpenShift, *_nethttp.Response, error) {
	return r.ApiService.TeamsScheduleGetOpenShiftsExecute(r)
}

/*
TeamsScheduleGetOpenShifts Get openShifts from teams

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param teamId key: id of team
 @param openShiftId key: id of openShift
 @return ApiTeamsScheduleGetOpenShiftsRequest
*/
func (a *TeamsScheduleApiService) TeamsScheduleGetOpenShifts(ctx _context.Context, teamId string, openShiftId string) ApiTeamsScheduleGetOpenShiftsRequest {
	return ApiTeamsScheduleGetOpenShiftsRequest{
		ApiService: a,
		ctx: ctx,
		teamId: teamId,
		openShiftId: openShiftId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphOpenShift
func (a *TeamsScheduleApiService) TeamsScheduleGetOpenShiftsExecute(r ApiTeamsScheduleGetOpenShiftsRequest) (MicrosoftGraphOpenShift, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphOpenShift
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TeamsScheduleApiService.TeamsScheduleGetOpenShifts")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/teams/{team-id}/schedule/openShifts/{openShift-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"team-id"+"}", _neturl.PathEscape(parameterToString(r.teamId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"openShift-id"+"}", _neturl.PathEscape(parameterToString(r.openShiftId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiTeamsScheduleGetSchedulingGroupsRequest struct {
	ctx _context.Context
	ApiService *TeamsScheduleApiService
	teamId string
	schedulingGroupId string
	select_ *[]string
}

// Select properties to be returned
func (r ApiTeamsScheduleGetSchedulingGroupsRequest) Select_(select_ []string) ApiTeamsScheduleGetSchedulingGroupsRequest {
	r.select_ = &select_
	return r
}

func (r ApiTeamsScheduleGetSchedulingGroupsRequest) Execute() (MicrosoftGraphSchedulingGroup, *_nethttp.Response, error) {
	return r.ApiService.TeamsScheduleGetSchedulingGroupsExecute(r)
}

/*
TeamsScheduleGetSchedulingGroups Get schedulingGroups from teams

The logical grouping of users in the schedule (usually by role).

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param teamId key: id of team
 @param schedulingGroupId key: id of schedulingGroup
 @return ApiTeamsScheduleGetSchedulingGroupsRequest
*/
func (a *TeamsScheduleApiService) TeamsScheduleGetSchedulingGroups(ctx _context.Context, teamId string, schedulingGroupId string) ApiTeamsScheduleGetSchedulingGroupsRequest {
	return ApiTeamsScheduleGetSchedulingGroupsRequest{
		ApiService: a,
		ctx: ctx,
		teamId: teamId,
		schedulingGroupId: schedulingGroupId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphSchedulingGroup
func (a *TeamsScheduleApiService) TeamsScheduleGetSchedulingGroupsExecute(r ApiTeamsScheduleGetSchedulingGroupsRequest) (MicrosoftGraphSchedulingGroup, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphSchedulingGroup
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TeamsScheduleApiService.TeamsScheduleGetSchedulingGroups")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/teams/{team-id}/schedule/schedulingGroups/{schedulingGroup-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"team-id"+"}", _neturl.PathEscape(parameterToString(r.teamId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"schedulingGroup-id"+"}", _neturl.PathEscape(parameterToString(r.schedulingGroupId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiTeamsScheduleGetShiftsRequest struct {
	ctx _context.Context
	ApiService *TeamsScheduleApiService
	teamId string
	shiftId string
	select_ *[]string
}

// Select properties to be returned
func (r ApiTeamsScheduleGetShiftsRequest) Select_(select_ []string) ApiTeamsScheduleGetShiftsRequest {
	r.select_ = &select_
	return r
}

func (r ApiTeamsScheduleGetShiftsRequest) Execute() (MicrosoftGraphShift, *_nethttp.Response, error) {
	return r.ApiService.TeamsScheduleGetShiftsExecute(r)
}

/*
TeamsScheduleGetShifts Get shifts from teams

The shifts in the schedule.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param teamId key: id of team
 @param shiftId key: id of shift
 @return ApiTeamsScheduleGetShiftsRequest
*/
func (a *TeamsScheduleApiService) TeamsScheduleGetShifts(ctx _context.Context, teamId string, shiftId string) ApiTeamsScheduleGetShiftsRequest {
	return ApiTeamsScheduleGetShiftsRequest{
		ApiService: a,
		ctx: ctx,
		teamId: teamId,
		shiftId: shiftId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphShift
func (a *TeamsScheduleApiService) TeamsScheduleGetShiftsExecute(r ApiTeamsScheduleGetShiftsRequest) (MicrosoftGraphShift, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphShift
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TeamsScheduleApiService.TeamsScheduleGetShifts")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/teams/{team-id}/schedule/shifts/{shift-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"team-id"+"}", _neturl.PathEscape(parameterToString(r.teamId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"shift-id"+"}", _neturl.PathEscape(parameterToString(r.shiftId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiTeamsScheduleGetSwapShiftsChangeRequestsRequest struct {
	ctx _context.Context
	ApiService *TeamsScheduleApiService
	teamId string
	swapShiftsChangeRequestId string
	select_ *[]string
	expand *[]string
}

// Select properties to be returned
func (r ApiTeamsScheduleGetSwapShiftsChangeRequestsRequest) Select_(select_ []string) ApiTeamsScheduleGetSwapShiftsChangeRequestsRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiTeamsScheduleGetSwapShiftsChangeRequestsRequest) Expand(expand []string) ApiTeamsScheduleGetSwapShiftsChangeRequestsRequest {
	r.expand = &expand
	return r
}

func (r ApiTeamsScheduleGetSwapShiftsChangeRequestsRequest) Execute() (MicrosoftGraphSwapShiftsChangeRequest, *_nethttp.Response, error) {
	return r.ApiService.TeamsScheduleGetSwapShiftsChangeRequestsExecute(r)
}

/*
TeamsScheduleGetSwapShiftsChangeRequests Get swapShiftsChangeRequests from teams

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param teamId key: id of team
 @param swapShiftsChangeRequestId key: id of swapShiftsChangeRequest
 @return ApiTeamsScheduleGetSwapShiftsChangeRequestsRequest
*/
func (a *TeamsScheduleApiService) TeamsScheduleGetSwapShiftsChangeRequests(ctx _context.Context, teamId string, swapShiftsChangeRequestId string) ApiTeamsScheduleGetSwapShiftsChangeRequestsRequest {
	return ApiTeamsScheduleGetSwapShiftsChangeRequestsRequest{
		ApiService: a,
		ctx: ctx,
		teamId: teamId,
		swapShiftsChangeRequestId: swapShiftsChangeRequestId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphSwapShiftsChangeRequest
func (a *TeamsScheduleApiService) TeamsScheduleGetSwapShiftsChangeRequestsExecute(r ApiTeamsScheduleGetSwapShiftsChangeRequestsRequest) (MicrosoftGraphSwapShiftsChangeRequest, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphSwapShiftsChangeRequest
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TeamsScheduleApiService.TeamsScheduleGetSwapShiftsChangeRequests")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/teams/{team-id}/schedule/swapShiftsChangeRequests/{swapShiftsChangeRequest-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"team-id"+"}", _neturl.PathEscape(parameterToString(r.teamId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"swapShiftsChangeRequest-id"+"}", _neturl.PathEscape(parameterToString(r.swapShiftsChangeRequestId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiTeamsScheduleGetTimeOffReasonsRequest struct {
	ctx _context.Context
	ApiService *TeamsScheduleApiService
	teamId string
	timeOffReasonId string
	select_ *[]string
}

// Select properties to be returned
func (r ApiTeamsScheduleGetTimeOffReasonsRequest) Select_(select_ []string) ApiTeamsScheduleGetTimeOffReasonsRequest {
	r.select_ = &select_
	return r
}

func (r ApiTeamsScheduleGetTimeOffReasonsRequest) Execute() (MicrosoftGraphTimeOffReason, *_nethttp.Response, error) {
	return r.ApiService.TeamsScheduleGetTimeOffReasonsExecute(r)
}

/*
TeamsScheduleGetTimeOffReasons Get timeOffReasons from teams

The set of reasons for a time off in the schedule.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param teamId key: id of team
 @param timeOffReasonId key: id of timeOffReason
 @return ApiTeamsScheduleGetTimeOffReasonsRequest
*/
func (a *TeamsScheduleApiService) TeamsScheduleGetTimeOffReasons(ctx _context.Context, teamId string, timeOffReasonId string) ApiTeamsScheduleGetTimeOffReasonsRequest {
	return ApiTeamsScheduleGetTimeOffReasonsRequest{
		ApiService: a,
		ctx: ctx,
		teamId: teamId,
		timeOffReasonId: timeOffReasonId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphTimeOffReason
func (a *TeamsScheduleApiService) TeamsScheduleGetTimeOffReasonsExecute(r ApiTeamsScheduleGetTimeOffReasonsRequest) (MicrosoftGraphTimeOffReason, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphTimeOffReason
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TeamsScheduleApiService.TeamsScheduleGetTimeOffReasons")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/teams/{team-id}/schedule/timeOffReasons/{timeOffReason-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"team-id"+"}", _neturl.PathEscape(parameterToString(r.teamId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"timeOffReason-id"+"}", _neturl.PathEscape(parameterToString(r.timeOffReasonId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiTeamsScheduleGetTimeOffRequestsRequest struct {
	ctx _context.Context
	ApiService *TeamsScheduleApiService
	teamId string
	timeOffRequestId string
	select_ *[]string
}

// Select properties to be returned
func (r ApiTeamsScheduleGetTimeOffRequestsRequest) Select_(select_ []string) ApiTeamsScheduleGetTimeOffRequestsRequest {
	r.select_ = &select_
	return r
}

func (r ApiTeamsScheduleGetTimeOffRequestsRequest) Execute() (MicrosoftGraphTimeOffRequest, *_nethttp.Response, error) {
	return r.ApiService.TeamsScheduleGetTimeOffRequestsExecute(r)
}

/*
TeamsScheduleGetTimeOffRequests Get timeOffRequests from teams

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param teamId key: id of team
 @param timeOffRequestId key: id of timeOffRequest
 @return ApiTeamsScheduleGetTimeOffRequestsRequest
*/
func (a *TeamsScheduleApiService) TeamsScheduleGetTimeOffRequests(ctx _context.Context, teamId string, timeOffRequestId string) ApiTeamsScheduleGetTimeOffRequestsRequest {
	return ApiTeamsScheduleGetTimeOffRequestsRequest{
		ApiService: a,
		ctx: ctx,
		teamId: teamId,
		timeOffRequestId: timeOffRequestId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphTimeOffRequest
func (a *TeamsScheduleApiService) TeamsScheduleGetTimeOffRequestsExecute(r ApiTeamsScheduleGetTimeOffRequestsRequest) (MicrosoftGraphTimeOffRequest, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphTimeOffRequest
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TeamsScheduleApiService.TeamsScheduleGetTimeOffRequests")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/teams/{team-id}/schedule/timeOffRequests/{timeOffRequest-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"team-id"+"}", _neturl.PathEscape(parameterToString(r.teamId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"timeOffRequest-id"+"}", _neturl.PathEscape(parameterToString(r.timeOffRequestId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiTeamsScheduleGetTimesOffRequest struct {
	ctx _context.Context
	ApiService *TeamsScheduleApiService
	teamId string
	timeOffId string
	select_ *[]string
}

// Select properties to be returned
func (r ApiTeamsScheduleGetTimesOffRequest) Select_(select_ []string) ApiTeamsScheduleGetTimesOffRequest {
	r.select_ = &select_
	return r
}

func (r ApiTeamsScheduleGetTimesOffRequest) Execute() (MicrosoftGraphTimeOff, *_nethttp.Response, error) {
	return r.ApiService.TeamsScheduleGetTimesOffExecute(r)
}

/*
TeamsScheduleGetTimesOff Get timesOff from teams

The instances of times off in the schedule.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param teamId key: id of team
 @param timeOffId key: id of timeOff
 @return ApiTeamsScheduleGetTimesOffRequest
*/
func (a *TeamsScheduleApiService) TeamsScheduleGetTimesOff(ctx _context.Context, teamId string, timeOffId string) ApiTeamsScheduleGetTimesOffRequest {
	return ApiTeamsScheduleGetTimesOffRequest{
		ApiService: a,
		ctx: ctx,
		teamId: teamId,
		timeOffId: timeOffId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphTimeOff
func (a *TeamsScheduleApiService) TeamsScheduleGetTimesOffExecute(r ApiTeamsScheduleGetTimesOffRequest) (MicrosoftGraphTimeOff, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphTimeOff
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TeamsScheduleApiService.TeamsScheduleGetTimesOff")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/teams/{team-id}/schedule/timesOff/{timeOff-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"team-id"+"}", _neturl.PathEscape(parameterToString(r.teamId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"timeOff-id"+"}", _neturl.PathEscape(parameterToString(r.timeOffId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiTeamsScheduleListOfferShiftRequestsRequest struct {
	ctx _context.Context
	ApiService *TeamsScheduleApiService
	teamId string
	top *int32
	skip *int32
	search *string
	filter *string
	count *bool
	orderby *[]string
	select_ *[]string
	expand *[]string
}

// Show only the first n items
func (r ApiTeamsScheduleListOfferShiftRequestsRequest) Top(top int32) ApiTeamsScheduleListOfferShiftRequestsRequest {
	r.top = &top
	return r
}
// Skip the first n items
func (r ApiTeamsScheduleListOfferShiftRequestsRequest) Skip(skip int32) ApiTeamsScheduleListOfferShiftRequestsRequest {
	r.skip = &skip
	return r
}
// Search items by search phrases
func (r ApiTeamsScheduleListOfferShiftRequestsRequest) Search(search string) ApiTeamsScheduleListOfferShiftRequestsRequest {
	r.search = &search
	return r
}
// Filter items by property values
func (r ApiTeamsScheduleListOfferShiftRequestsRequest) Filter(filter string) ApiTeamsScheduleListOfferShiftRequestsRequest {
	r.filter = &filter
	return r
}
// Include count of items
func (r ApiTeamsScheduleListOfferShiftRequestsRequest) Count(count bool) ApiTeamsScheduleListOfferShiftRequestsRequest {
	r.count = &count
	return r
}
// Order items by property values
func (r ApiTeamsScheduleListOfferShiftRequestsRequest) Orderby(orderby []string) ApiTeamsScheduleListOfferShiftRequestsRequest {
	r.orderby = &orderby
	return r
}
// Select properties to be returned
func (r ApiTeamsScheduleListOfferShiftRequestsRequest) Select_(select_ []string) ApiTeamsScheduleListOfferShiftRequestsRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiTeamsScheduleListOfferShiftRequestsRequest) Expand(expand []string) ApiTeamsScheduleListOfferShiftRequestsRequest {
	r.expand = &expand
	return r
}

func (r ApiTeamsScheduleListOfferShiftRequestsRequest) Execute() (CollectionOfOfferShiftRequest, *_nethttp.Response, error) {
	return r.ApiService.TeamsScheduleListOfferShiftRequestsExecute(r)
}

/*
TeamsScheduleListOfferShiftRequests Get offerShiftRequests from teams

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param teamId key: id of team
 @return ApiTeamsScheduleListOfferShiftRequestsRequest
*/
func (a *TeamsScheduleApiService) TeamsScheduleListOfferShiftRequests(ctx _context.Context, teamId string) ApiTeamsScheduleListOfferShiftRequestsRequest {
	return ApiTeamsScheduleListOfferShiftRequestsRequest{
		ApiService: a,
		ctx: ctx,
		teamId: teamId,
	}
}

// Execute executes the request
//  @return CollectionOfOfferShiftRequest
func (a *TeamsScheduleApiService) TeamsScheduleListOfferShiftRequestsExecute(r ApiTeamsScheduleListOfferShiftRequestsRequest) (CollectionOfOfferShiftRequest, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  CollectionOfOfferShiftRequest
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TeamsScheduleApiService.TeamsScheduleListOfferShiftRequests")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/teams/{team-id}/schedule/offerShiftRequests"
	localVarPath = strings.Replace(localVarPath, "{"+"team-id"+"}", _neturl.PathEscape(parameterToString(r.teamId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.top != nil {
		localVarQueryParams.Add("$top", parameterToString(*r.top, ""))
	}
	if r.skip != nil {
		localVarQueryParams.Add("$skip", parameterToString(*r.skip, ""))
	}
	if r.search != nil {
		localVarQueryParams.Add("$search", parameterToString(*r.search, ""))
	}
	if r.filter != nil {
		localVarQueryParams.Add("$filter", parameterToString(*r.filter, ""))
	}
	if r.count != nil {
		localVarQueryParams.Add("$count", parameterToString(*r.count, ""))
	}
	if r.orderby != nil {
		localVarQueryParams.Add("$orderby", parameterToString(*r.orderby, "csv"))
	}
	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiTeamsScheduleListOpenShiftChangeRequestsRequest struct {
	ctx _context.Context
	ApiService *TeamsScheduleApiService
	teamId string
	top *int32
	skip *int32
	search *string
	filter *string
	count *bool
	orderby *[]string
	select_ *[]string
	expand *[]string
}

// Show only the first n items
func (r ApiTeamsScheduleListOpenShiftChangeRequestsRequest) Top(top int32) ApiTeamsScheduleListOpenShiftChangeRequestsRequest {
	r.top = &top
	return r
}
// Skip the first n items
func (r ApiTeamsScheduleListOpenShiftChangeRequestsRequest) Skip(skip int32) ApiTeamsScheduleListOpenShiftChangeRequestsRequest {
	r.skip = &skip
	return r
}
// Search items by search phrases
func (r ApiTeamsScheduleListOpenShiftChangeRequestsRequest) Search(search string) ApiTeamsScheduleListOpenShiftChangeRequestsRequest {
	r.search = &search
	return r
}
// Filter items by property values
func (r ApiTeamsScheduleListOpenShiftChangeRequestsRequest) Filter(filter string) ApiTeamsScheduleListOpenShiftChangeRequestsRequest {
	r.filter = &filter
	return r
}
// Include count of items
func (r ApiTeamsScheduleListOpenShiftChangeRequestsRequest) Count(count bool) ApiTeamsScheduleListOpenShiftChangeRequestsRequest {
	r.count = &count
	return r
}
// Order items by property values
func (r ApiTeamsScheduleListOpenShiftChangeRequestsRequest) Orderby(orderby []string) ApiTeamsScheduleListOpenShiftChangeRequestsRequest {
	r.orderby = &orderby
	return r
}
// Select properties to be returned
func (r ApiTeamsScheduleListOpenShiftChangeRequestsRequest) Select_(select_ []string) ApiTeamsScheduleListOpenShiftChangeRequestsRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiTeamsScheduleListOpenShiftChangeRequestsRequest) Expand(expand []string) ApiTeamsScheduleListOpenShiftChangeRequestsRequest {
	r.expand = &expand
	return r
}

func (r ApiTeamsScheduleListOpenShiftChangeRequestsRequest) Execute() (CollectionOfOpenShiftChangeRequest, *_nethttp.Response, error) {
	return r.ApiService.TeamsScheduleListOpenShiftChangeRequestsExecute(r)
}

/*
TeamsScheduleListOpenShiftChangeRequests Get openShiftChangeRequests from teams

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param teamId key: id of team
 @return ApiTeamsScheduleListOpenShiftChangeRequestsRequest
*/
func (a *TeamsScheduleApiService) TeamsScheduleListOpenShiftChangeRequests(ctx _context.Context, teamId string) ApiTeamsScheduleListOpenShiftChangeRequestsRequest {
	return ApiTeamsScheduleListOpenShiftChangeRequestsRequest{
		ApiService: a,
		ctx: ctx,
		teamId: teamId,
	}
}

// Execute executes the request
//  @return CollectionOfOpenShiftChangeRequest
func (a *TeamsScheduleApiService) TeamsScheduleListOpenShiftChangeRequestsExecute(r ApiTeamsScheduleListOpenShiftChangeRequestsRequest) (CollectionOfOpenShiftChangeRequest, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  CollectionOfOpenShiftChangeRequest
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TeamsScheduleApiService.TeamsScheduleListOpenShiftChangeRequests")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/teams/{team-id}/schedule/openShiftChangeRequests"
	localVarPath = strings.Replace(localVarPath, "{"+"team-id"+"}", _neturl.PathEscape(parameterToString(r.teamId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.top != nil {
		localVarQueryParams.Add("$top", parameterToString(*r.top, ""))
	}
	if r.skip != nil {
		localVarQueryParams.Add("$skip", parameterToString(*r.skip, ""))
	}
	if r.search != nil {
		localVarQueryParams.Add("$search", parameterToString(*r.search, ""))
	}
	if r.filter != nil {
		localVarQueryParams.Add("$filter", parameterToString(*r.filter, ""))
	}
	if r.count != nil {
		localVarQueryParams.Add("$count", parameterToString(*r.count, ""))
	}
	if r.orderby != nil {
		localVarQueryParams.Add("$orderby", parameterToString(*r.orderby, "csv"))
	}
	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiTeamsScheduleListOpenShiftsRequest struct {
	ctx _context.Context
	ApiService *TeamsScheduleApiService
	teamId string
	top *int32
	skip *int32
	search *string
	filter *string
	count *bool
	orderby *[]string
	select_ *[]string
	expand *[]string
}

// Show only the first n items
func (r ApiTeamsScheduleListOpenShiftsRequest) Top(top int32) ApiTeamsScheduleListOpenShiftsRequest {
	r.top = &top
	return r
}
// Skip the first n items
func (r ApiTeamsScheduleListOpenShiftsRequest) Skip(skip int32) ApiTeamsScheduleListOpenShiftsRequest {
	r.skip = &skip
	return r
}
// Search items by search phrases
func (r ApiTeamsScheduleListOpenShiftsRequest) Search(search string) ApiTeamsScheduleListOpenShiftsRequest {
	r.search = &search
	return r
}
// Filter items by property values
func (r ApiTeamsScheduleListOpenShiftsRequest) Filter(filter string) ApiTeamsScheduleListOpenShiftsRequest {
	r.filter = &filter
	return r
}
// Include count of items
func (r ApiTeamsScheduleListOpenShiftsRequest) Count(count bool) ApiTeamsScheduleListOpenShiftsRequest {
	r.count = &count
	return r
}
// Order items by property values
func (r ApiTeamsScheduleListOpenShiftsRequest) Orderby(orderby []string) ApiTeamsScheduleListOpenShiftsRequest {
	r.orderby = &orderby
	return r
}
// Select properties to be returned
func (r ApiTeamsScheduleListOpenShiftsRequest) Select_(select_ []string) ApiTeamsScheduleListOpenShiftsRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiTeamsScheduleListOpenShiftsRequest) Expand(expand []string) ApiTeamsScheduleListOpenShiftsRequest {
	r.expand = &expand
	return r
}

func (r ApiTeamsScheduleListOpenShiftsRequest) Execute() (CollectionOfOpenShift, *_nethttp.Response, error) {
	return r.ApiService.TeamsScheduleListOpenShiftsExecute(r)
}

/*
TeamsScheduleListOpenShifts Get openShifts from teams

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param teamId key: id of team
 @return ApiTeamsScheduleListOpenShiftsRequest
*/
func (a *TeamsScheduleApiService) TeamsScheduleListOpenShifts(ctx _context.Context, teamId string) ApiTeamsScheduleListOpenShiftsRequest {
	return ApiTeamsScheduleListOpenShiftsRequest{
		ApiService: a,
		ctx: ctx,
		teamId: teamId,
	}
}

// Execute executes the request
//  @return CollectionOfOpenShift
func (a *TeamsScheduleApiService) TeamsScheduleListOpenShiftsExecute(r ApiTeamsScheduleListOpenShiftsRequest) (CollectionOfOpenShift, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  CollectionOfOpenShift
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TeamsScheduleApiService.TeamsScheduleListOpenShifts")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/teams/{team-id}/schedule/openShifts"
	localVarPath = strings.Replace(localVarPath, "{"+"team-id"+"}", _neturl.PathEscape(parameterToString(r.teamId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.top != nil {
		localVarQueryParams.Add("$top", parameterToString(*r.top, ""))
	}
	if r.skip != nil {
		localVarQueryParams.Add("$skip", parameterToString(*r.skip, ""))
	}
	if r.search != nil {
		localVarQueryParams.Add("$search", parameterToString(*r.search, ""))
	}
	if r.filter != nil {
		localVarQueryParams.Add("$filter", parameterToString(*r.filter, ""))
	}
	if r.count != nil {
		localVarQueryParams.Add("$count", parameterToString(*r.count, ""))
	}
	if r.orderby != nil {
		localVarQueryParams.Add("$orderby", parameterToString(*r.orderby, "csv"))
	}
	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiTeamsScheduleListSchedulingGroupsRequest struct {
	ctx _context.Context
	ApiService *TeamsScheduleApiService
	teamId string
	top *int32
	skip *int32
	search *string
	filter *string
	count *bool
	orderby *[]string
	select_ *[]string
}

// Show only the first n items
func (r ApiTeamsScheduleListSchedulingGroupsRequest) Top(top int32) ApiTeamsScheduleListSchedulingGroupsRequest {
	r.top = &top
	return r
}
// Skip the first n items
func (r ApiTeamsScheduleListSchedulingGroupsRequest) Skip(skip int32) ApiTeamsScheduleListSchedulingGroupsRequest {
	r.skip = &skip
	return r
}
// Search items by search phrases
func (r ApiTeamsScheduleListSchedulingGroupsRequest) Search(search string) ApiTeamsScheduleListSchedulingGroupsRequest {
	r.search = &search
	return r
}
// Filter items by property values
func (r ApiTeamsScheduleListSchedulingGroupsRequest) Filter(filter string) ApiTeamsScheduleListSchedulingGroupsRequest {
	r.filter = &filter
	return r
}
// Include count of items
func (r ApiTeamsScheduleListSchedulingGroupsRequest) Count(count bool) ApiTeamsScheduleListSchedulingGroupsRequest {
	r.count = &count
	return r
}
// Order items by property values
func (r ApiTeamsScheduleListSchedulingGroupsRequest) Orderby(orderby []string) ApiTeamsScheduleListSchedulingGroupsRequest {
	r.orderby = &orderby
	return r
}
// Select properties to be returned
func (r ApiTeamsScheduleListSchedulingGroupsRequest) Select_(select_ []string) ApiTeamsScheduleListSchedulingGroupsRequest {
	r.select_ = &select_
	return r
}

func (r ApiTeamsScheduleListSchedulingGroupsRequest) Execute() (CollectionOfSchedulingGroup, *_nethttp.Response, error) {
	return r.ApiService.TeamsScheduleListSchedulingGroupsExecute(r)
}

/*
TeamsScheduleListSchedulingGroups Get schedulingGroups from teams

The logical grouping of users in the schedule (usually by role).

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param teamId key: id of team
 @return ApiTeamsScheduleListSchedulingGroupsRequest
*/
func (a *TeamsScheduleApiService) TeamsScheduleListSchedulingGroups(ctx _context.Context, teamId string) ApiTeamsScheduleListSchedulingGroupsRequest {
	return ApiTeamsScheduleListSchedulingGroupsRequest{
		ApiService: a,
		ctx: ctx,
		teamId: teamId,
	}
}

// Execute executes the request
//  @return CollectionOfSchedulingGroup
func (a *TeamsScheduleApiService) TeamsScheduleListSchedulingGroupsExecute(r ApiTeamsScheduleListSchedulingGroupsRequest) (CollectionOfSchedulingGroup, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  CollectionOfSchedulingGroup
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TeamsScheduleApiService.TeamsScheduleListSchedulingGroups")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/teams/{team-id}/schedule/schedulingGroups"
	localVarPath = strings.Replace(localVarPath, "{"+"team-id"+"}", _neturl.PathEscape(parameterToString(r.teamId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.top != nil {
		localVarQueryParams.Add("$top", parameterToString(*r.top, ""))
	}
	if r.skip != nil {
		localVarQueryParams.Add("$skip", parameterToString(*r.skip, ""))
	}
	if r.search != nil {
		localVarQueryParams.Add("$search", parameterToString(*r.search, ""))
	}
	if r.filter != nil {
		localVarQueryParams.Add("$filter", parameterToString(*r.filter, ""))
	}
	if r.count != nil {
		localVarQueryParams.Add("$count", parameterToString(*r.count, ""))
	}
	if r.orderby != nil {
		localVarQueryParams.Add("$orderby", parameterToString(*r.orderby, "csv"))
	}
	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiTeamsScheduleListShiftsRequest struct {
	ctx _context.Context
	ApiService *TeamsScheduleApiService
	teamId string
	top *int32
	skip *int32
	search *string
	filter *string
	count *bool
	orderby *[]string
	select_ *[]string
}

// Show only the first n items
func (r ApiTeamsScheduleListShiftsRequest) Top(top int32) ApiTeamsScheduleListShiftsRequest {
	r.top = &top
	return r
}
// Skip the first n items
func (r ApiTeamsScheduleListShiftsRequest) Skip(skip int32) ApiTeamsScheduleListShiftsRequest {
	r.skip = &skip
	return r
}
// Search items by search phrases
func (r ApiTeamsScheduleListShiftsRequest) Search(search string) ApiTeamsScheduleListShiftsRequest {
	r.search = &search
	return r
}
// Filter items by property values
func (r ApiTeamsScheduleListShiftsRequest) Filter(filter string) ApiTeamsScheduleListShiftsRequest {
	r.filter = &filter
	return r
}
// Include count of items
func (r ApiTeamsScheduleListShiftsRequest) Count(count bool) ApiTeamsScheduleListShiftsRequest {
	r.count = &count
	return r
}
// Order items by property values
func (r ApiTeamsScheduleListShiftsRequest) Orderby(orderby []string) ApiTeamsScheduleListShiftsRequest {
	r.orderby = &orderby
	return r
}
// Select properties to be returned
func (r ApiTeamsScheduleListShiftsRequest) Select_(select_ []string) ApiTeamsScheduleListShiftsRequest {
	r.select_ = &select_
	return r
}

func (r ApiTeamsScheduleListShiftsRequest) Execute() (CollectionOfShift, *_nethttp.Response, error) {
	return r.ApiService.TeamsScheduleListShiftsExecute(r)
}

/*
TeamsScheduleListShifts Get shifts from teams

The shifts in the schedule.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param teamId key: id of team
 @return ApiTeamsScheduleListShiftsRequest
*/
func (a *TeamsScheduleApiService) TeamsScheduleListShifts(ctx _context.Context, teamId string) ApiTeamsScheduleListShiftsRequest {
	return ApiTeamsScheduleListShiftsRequest{
		ApiService: a,
		ctx: ctx,
		teamId: teamId,
	}
}

// Execute executes the request
//  @return CollectionOfShift
func (a *TeamsScheduleApiService) TeamsScheduleListShiftsExecute(r ApiTeamsScheduleListShiftsRequest) (CollectionOfShift, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  CollectionOfShift
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TeamsScheduleApiService.TeamsScheduleListShifts")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/teams/{team-id}/schedule/shifts"
	localVarPath = strings.Replace(localVarPath, "{"+"team-id"+"}", _neturl.PathEscape(parameterToString(r.teamId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.top != nil {
		localVarQueryParams.Add("$top", parameterToString(*r.top, ""))
	}
	if r.skip != nil {
		localVarQueryParams.Add("$skip", parameterToString(*r.skip, ""))
	}
	if r.search != nil {
		localVarQueryParams.Add("$search", parameterToString(*r.search, ""))
	}
	if r.filter != nil {
		localVarQueryParams.Add("$filter", parameterToString(*r.filter, ""))
	}
	if r.count != nil {
		localVarQueryParams.Add("$count", parameterToString(*r.count, ""))
	}
	if r.orderby != nil {
		localVarQueryParams.Add("$orderby", parameterToString(*r.orderby, "csv"))
	}
	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiTeamsScheduleListSwapShiftsChangeRequestsRequest struct {
	ctx _context.Context
	ApiService *TeamsScheduleApiService
	teamId string
	top *int32
	skip *int32
	search *string
	filter *string
	count *bool
	orderby *[]string
	select_ *[]string
	expand *[]string
}

// Show only the first n items
func (r ApiTeamsScheduleListSwapShiftsChangeRequestsRequest) Top(top int32) ApiTeamsScheduleListSwapShiftsChangeRequestsRequest {
	r.top = &top
	return r
}
// Skip the first n items
func (r ApiTeamsScheduleListSwapShiftsChangeRequestsRequest) Skip(skip int32) ApiTeamsScheduleListSwapShiftsChangeRequestsRequest {
	r.skip = &skip
	return r
}
// Search items by search phrases
func (r ApiTeamsScheduleListSwapShiftsChangeRequestsRequest) Search(search string) ApiTeamsScheduleListSwapShiftsChangeRequestsRequest {
	r.search = &search
	return r
}
// Filter items by property values
func (r ApiTeamsScheduleListSwapShiftsChangeRequestsRequest) Filter(filter string) ApiTeamsScheduleListSwapShiftsChangeRequestsRequest {
	r.filter = &filter
	return r
}
// Include count of items
func (r ApiTeamsScheduleListSwapShiftsChangeRequestsRequest) Count(count bool) ApiTeamsScheduleListSwapShiftsChangeRequestsRequest {
	r.count = &count
	return r
}
// Order items by property values
func (r ApiTeamsScheduleListSwapShiftsChangeRequestsRequest) Orderby(orderby []string) ApiTeamsScheduleListSwapShiftsChangeRequestsRequest {
	r.orderby = &orderby
	return r
}
// Select properties to be returned
func (r ApiTeamsScheduleListSwapShiftsChangeRequestsRequest) Select_(select_ []string) ApiTeamsScheduleListSwapShiftsChangeRequestsRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiTeamsScheduleListSwapShiftsChangeRequestsRequest) Expand(expand []string) ApiTeamsScheduleListSwapShiftsChangeRequestsRequest {
	r.expand = &expand
	return r
}

func (r ApiTeamsScheduleListSwapShiftsChangeRequestsRequest) Execute() (CollectionOfSwapShiftsChangeRequest, *_nethttp.Response, error) {
	return r.ApiService.TeamsScheduleListSwapShiftsChangeRequestsExecute(r)
}

/*
TeamsScheduleListSwapShiftsChangeRequests Get swapShiftsChangeRequests from teams

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param teamId key: id of team
 @return ApiTeamsScheduleListSwapShiftsChangeRequestsRequest
*/
func (a *TeamsScheduleApiService) TeamsScheduleListSwapShiftsChangeRequests(ctx _context.Context, teamId string) ApiTeamsScheduleListSwapShiftsChangeRequestsRequest {
	return ApiTeamsScheduleListSwapShiftsChangeRequestsRequest{
		ApiService: a,
		ctx: ctx,
		teamId: teamId,
	}
}

// Execute executes the request
//  @return CollectionOfSwapShiftsChangeRequest
func (a *TeamsScheduleApiService) TeamsScheduleListSwapShiftsChangeRequestsExecute(r ApiTeamsScheduleListSwapShiftsChangeRequestsRequest) (CollectionOfSwapShiftsChangeRequest, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  CollectionOfSwapShiftsChangeRequest
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TeamsScheduleApiService.TeamsScheduleListSwapShiftsChangeRequests")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/teams/{team-id}/schedule/swapShiftsChangeRequests"
	localVarPath = strings.Replace(localVarPath, "{"+"team-id"+"}", _neturl.PathEscape(parameterToString(r.teamId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.top != nil {
		localVarQueryParams.Add("$top", parameterToString(*r.top, ""))
	}
	if r.skip != nil {
		localVarQueryParams.Add("$skip", parameterToString(*r.skip, ""))
	}
	if r.search != nil {
		localVarQueryParams.Add("$search", parameterToString(*r.search, ""))
	}
	if r.filter != nil {
		localVarQueryParams.Add("$filter", parameterToString(*r.filter, ""))
	}
	if r.count != nil {
		localVarQueryParams.Add("$count", parameterToString(*r.count, ""))
	}
	if r.orderby != nil {
		localVarQueryParams.Add("$orderby", parameterToString(*r.orderby, "csv"))
	}
	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiTeamsScheduleListTimeOffReasonsRequest struct {
	ctx _context.Context
	ApiService *TeamsScheduleApiService
	teamId string
	top *int32
	skip *int32
	search *string
	filter *string
	count *bool
	orderby *[]string
	select_ *[]string
}

// Show only the first n items
func (r ApiTeamsScheduleListTimeOffReasonsRequest) Top(top int32) ApiTeamsScheduleListTimeOffReasonsRequest {
	r.top = &top
	return r
}
// Skip the first n items
func (r ApiTeamsScheduleListTimeOffReasonsRequest) Skip(skip int32) ApiTeamsScheduleListTimeOffReasonsRequest {
	r.skip = &skip
	return r
}
// Search items by search phrases
func (r ApiTeamsScheduleListTimeOffReasonsRequest) Search(search string) ApiTeamsScheduleListTimeOffReasonsRequest {
	r.search = &search
	return r
}
// Filter items by property values
func (r ApiTeamsScheduleListTimeOffReasonsRequest) Filter(filter string) ApiTeamsScheduleListTimeOffReasonsRequest {
	r.filter = &filter
	return r
}
// Include count of items
func (r ApiTeamsScheduleListTimeOffReasonsRequest) Count(count bool) ApiTeamsScheduleListTimeOffReasonsRequest {
	r.count = &count
	return r
}
// Order items by property values
func (r ApiTeamsScheduleListTimeOffReasonsRequest) Orderby(orderby []string) ApiTeamsScheduleListTimeOffReasonsRequest {
	r.orderby = &orderby
	return r
}
// Select properties to be returned
func (r ApiTeamsScheduleListTimeOffReasonsRequest) Select_(select_ []string) ApiTeamsScheduleListTimeOffReasonsRequest {
	r.select_ = &select_
	return r
}

func (r ApiTeamsScheduleListTimeOffReasonsRequest) Execute() (CollectionOfTimeOffReason, *_nethttp.Response, error) {
	return r.ApiService.TeamsScheduleListTimeOffReasonsExecute(r)
}

/*
TeamsScheduleListTimeOffReasons Get timeOffReasons from teams

The set of reasons for a time off in the schedule.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param teamId key: id of team
 @return ApiTeamsScheduleListTimeOffReasonsRequest
*/
func (a *TeamsScheduleApiService) TeamsScheduleListTimeOffReasons(ctx _context.Context, teamId string) ApiTeamsScheduleListTimeOffReasonsRequest {
	return ApiTeamsScheduleListTimeOffReasonsRequest{
		ApiService: a,
		ctx: ctx,
		teamId: teamId,
	}
}

// Execute executes the request
//  @return CollectionOfTimeOffReason
func (a *TeamsScheduleApiService) TeamsScheduleListTimeOffReasonsExecute(r ApiTeamsScheduleListTimeOffReasonsRequest) (CollectionOfTimeOffReason, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  CollectionOfTimeOffReason
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TeamsScheduleApiService.TeamsScheduleListTimeOffReasons")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/teams/{team-id}/schedule/timeOffReasons"
	localVarPath = strings.Replace(localVarPath, "{"+"team-id"+"}", _neturl.PathEscape(parameterToString(r.teamId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.top != nil {
		localVarQueryParams.Add("$top", parameterToString(*r.top, ""))
	}
	if r.skip != nil {
		localVarQueryParams.Add("$skip", parameterToString(*r.skip, ""))
	}
	if r.search != nil {
		localVarQueryParams.Add("$search", parameterToString(*r.search, ""))
	}
	if r.filter != nil {
		localVarQueryParams.Add("$filter", parameterToString(*r.filter, ""))
	}
	if r.count != nil {
		localVarQueryParams.Add("$count", parameterToString(*r.count, ""))
	}
	if r.orderby != nil {
		localVarQueryParams.Add("$orderby", parameterToString(*r.orderby, "csv"))
	}
	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiTeamsScheduleListTimeOffRequestsRequest struct {
	ctx _context.Context
	ApiService *TeamsScheduleApiService
	teamId string
	top *int32
	skip *int32
	search *string
	filter *string
	count *bool
	orderby *[]string
	select_ *[]string
}

// Show only the first n items
func (r ApiTeamsScheduleListTimeOffRequestsRequest) Top(top int32) ApiTeamsScheduleListTimeOffRequestsRequest {
	r.top = &top
	return r
}
// Skip the first n items
func (r ApiTeamsScheduleListTimeOffRequestsRequest) Skip(skip int32) ApiTeamsScheduleListTimeOffRequestsRequest {
	r.skip = &skip
	return r
}
// Search items by search phrases
func (r ApiTeamsScheduleListTimeOffRequestsRequest) Search(search string) ApiTeamsScheduleListTimeOffRequestsRequest {
	r.search = &search
	return r
}
// Filter items by property values
func (r ApiTeamsScheduleListTimeOffRequestsRequest) Filter(filter string) ApiTeamsScheduleListTimeOffRequestsRequest {
	r.filter = &filter
	return r
}
// Include count of items
func (r ApiTeamsScheduleListTimeOffRequestsRequest) Count(count bool) ApiTeamsScheduleListTimeOffRequestsRequest {
	r.count = &count
	return r
}
// Order items by property values
func (r ApiTeamsScheduleListTimeOffRequestsRequest) Orderby(orderby []string) ApiTeamsScheduleListTimeOffRequestsRequest {
	r.orderby = &orderby
	return r
}
// Select properties to be returned
func (r ApiTeamsScheduleListTimeOffRequestsRequest) Select_(select_ []string) ApiTeamsScheduleListTimeOffRequestsRequest {
	r.select_ = &select_
	return r
}

func (r ApiTeamsScheduleListTimeOffRequestsRequest) Execute() (CollectionOfTimeOffRequest, *_nethttp.Response, error) {
	return r.ApiService.TeamsScheduleListTimeOffRequestsExecute(r)
}

/*
TeamsScheduleListTimeOffRequests Get timeOffRequests from teams

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param teamId key: id of team
 @return ApiTeamsScheduleListTimeOffRequestsRequest
*/
func (a *TeamsScheduleApiService) TeamsScheduleListTimeOffRequests(ctx _context.Context, teamId string) ApiTeamsScheduleListTimeOffRequestsRequest {
	return ApiTeamsScheduleListTimeOffRequestsRequest{
		ApiService: a,
		ctx: ctx,
		teamId: teamId,
	}
}

// Execute executes the request
//  @return CollectionOfTimeOffRequest
func (a *TeamsScheduleApiService) TeamsScheduleListTimeOffRequestsExecute(r ApiTeamsScheduleListTimeOffRequestsRequest) (CollectionOfTimeOffRequest, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  CollectionOfTimeOffRequest
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TeamsScheduleApiService.TeamsScheduleListTimeOffRequests")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/teams/{team-id}/schedule/timeOffRequests"
	localVarPath = strings.Replace(localVarPath, "{"+"team-id"+"}", _neturl.PathEscape(parameterToString(r.teamId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.top != nil {
		localVarQueryParams.Add("$top", parameterToString(*r.top, ""))
	}
	if r.skip != nil {
		localVarQueryParams.Add("$skip", parameterToString(*r.skip, ""))
	}
	if r.search != nil {
		localVarQueryParams.Add("$search", parameterToString(*r.search, ""))
	}
	if r.filter != nil {
		localVarQueryParams.Add("$filter", parameterToString(*r.filter, ""))
	}
	if r.count != nil {
		localVarQueryParams.Add("$count", parameterToString(*r.count, ""))
	}
	if r.orderby != nil {
		localVarQueryParams.Add("$orderby", parameterToString(*r.orderby, "csv"))
	}
	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiTeamsScheduleListTimesOffRequest struct {
	ctx _context.Context
	ApiService *TeamsScheduleApiService
	teamId string
	top *int32
	skip *int32
	search *string
	filter *string
	count *bool
	orderby *[]string
	select_ *[]string
}

// Show only the first n items
func (r ApiTeamsScheduleListTimesOffRequest) Top(top int32) ApiTeamsScheduleListTimesOffRequest {
	r.top = &top
	return r
}
// Skip the first n items
func (r ApiTeamsScheduleListTimesOffRequest) Skip(skip int32) ApiTeamsScheduleListTimesOffRequest {
	r.skip = &skip
	return r
}
// Search items by search phrases
func (r ApiTeamsScheduleListTimesOffRequest) Search(search string) ApiTeamsScheduleListTimesOffRequest {
	r.search = &search
	return r
}
// Filter items by property values
func (r ApiTeamsScheduleListTimesOffRequest) Filter(filter string) ApiTeamsScheduleListTimesOffRequest {
	r.filter = &filter
	return r
}
// Include count of items
func (r ApiTeamsScheduleListTimesOffRequest) Count(count bool) ApiTeamsScheduleListTimesOffRequest {
	r.count = &count
	return r
}
// Order items by property values
func (r ApiTeamsScheduleListTimesOffRequest) Orderby(orderby []string) ApiTeamsScheduleListTimesOffRequest {
	r.orderby = &orderby
	return r
}
// Select properties to be returned
func (r ApiTeamsScheduleListTimesOffRequest) Select_(select_ []string) ApiTeamsScheduleListTimesOffRequest {
	r.select_ = &select_
	return r
}

func (r ApiTeamsScheduleListTimesOffRequest) Execute() (CollectionOfTimeOff, *_nethttp.Response, error) {
	return r.ApiService.TeamsScheduleListTimesOffExecute(r)
}

/*
TeamsScheduleListTimesOff Get timesOff from teams

The instances of times off in the schedule.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param teamId key: id of team
 @return ApiTeamsScheduleListTimesOffRequest
*/
func (a *TeamsScheduleApiService) TeamsScheduleListTimesOff(ctx _context.Context, teamId string) ApiTeamsScheduleListTimesOffRequest {
	return ApiTeamsScheduleListTimesOffRequest{
		ApiService: a,
		ctx: ctx,
		teamId: teamId,
	}
}

// Execute executes the request
//  @return CollectionOfTimeOff
func (a *TeamsScheduleApiService) TeamsScheduleListTimesOffExecute(r ApiTeamsScheduleListTimesOffRequest) (CollectionOfTimeOff, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  CollectionOfTimeOff
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TeamsScheduleApiService.TeamsScheduleListTimesOff")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/teams/{team-id}/schedule/timesOff"
	localVarPath = strings.Replace(localVarPath, "{"+"team-id"+"}", _neturl.PathEscape(parameterToString(r.teamId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.top != nil {
		localVarQueryParams.Add("$top", parameterToString(*r.top, ""))
	}
	if r.skip != nil {
		localVarQueryParams.Add("$skip", parameterToString(*r.skip, ""))
	}
	if r.search != nil {
		localVarQueryParams.Add("$search", parameterToString(*r.search, ""))
	}
	if r.filter != nil {
		localVarQueryParams.Add("$filter", parameterToString(*r.filter, ""))
	}
	if r.count != nil {
		localVarQueryParams.Add("$count", parameterToString(*r.count, ""))
	}
	if r.orderby != nil {
		localVarQueryParams.Add("$orderby", parameterToString(*r.orderby, "csv"))
	}
	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiTeamsScheduleUpdateOfferShiftRequestsRequest struct {
	ctx _context.Context
	ApiService *TeamsScheduleApiService
	teamId string
	offerShiftRequestId string
	microsoftGraphOfferShiftRequest *MicrosoftGraphOfferShiftRequest
}

// New navigation property values
func (r ApiTeamsScheduleUpdateOfferShiftRequestsRequest) MicrosoftGraphOfferShiftRequest(microsoftGraphOfferShiftRequest MicrosoftGraphOfferShiftRequest) ApiTeamsScheduleUpdateOfferShiftRequestsRequest {
	r.microsoftGraphOfferShiftRequest = &microsoftGraphOfferShiftRequest
	return r
}

func (r ApiTeamsScheduleUpdateOfferShiftRequestsRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.TeamsScheduleUpdateOfferShiftRequestsExecute(r)
}

/*
TeamsScheduleUpdateOfferShiftRequests Update the navigation property offerShiftRequests in teams

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param teamId key: id of team
 @param offerShiftRequestId key: id of offerShiftRequest
 @return ApiTeamsScheduleUpdateOfferShiftRequestsRequest
*/
func (a *TeamsScheduleApiService) TeamsScheduleUpdateOfferShiftRequests(ctx _context.Context, teamId string, offerShiftRequestId string) ApiTeamsScheduleUpdateOfferShiftRequestsRequest {
	return ApiTeamsScheduleUpdateOfferShiftRequestsRequest{
		ApiService: a,
		ctx: ctx,
		teamId: teamId,
		offerShiftRequestId: offerShiftRequestId,
	}
}

// Execute executes the request
func (a *TeamsScheduleApiService) TeamsScheduleUpdateOfferShiftRequestsExecute(r ApiTeamsScheduleUpdateOfferShiftRequestsRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPatch
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TeamsScheduleApiService.TeamsScheduleUpdateOfferShiftRequests")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/teams/{team-id}/schedule/offerShiftRequests/{offerShiftRequest-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"team-id"+"}", _neturl.PathEscape(parameterToString(r.teamId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"offerShiftRequest-id"+"}", _neturl.PathEscape(parameterToString(r.offerShiftRequestId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphOfferShiftRequest == nil {
		return nil, reportError("microsoftGraphOfferShiftRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphOfferShiftRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiTeamsScheduleUpdateOpenShiftChangeRequestsRequest struct {
	ctx _context.Context
	ApiService *TeamsScheduleApiService
	teamId string
	openShiftChangeRequestId string
	microsoftGraphOpenShiftChangeRequest *MicrosoftGraphOpenShiftChangeRequest
}

// New navigation property values
func (r ApiTeamsScheduleUpdateOpenShiftChangeRequestsRequest) MicrosoftGraphOpenShiftChangeRequest(microsoftGraphOpenShiftChangeRequest MicrosoftGraphOpenShiftChangeRequest) ApiTeamsScheduleUpdateOpenShiftChangeRequestsRequest {
	r.microsoftGraphOpenShiftChangeRequest = &microsoftGraphOpenShiftChangeRequest
	return r
}

func (r ApiTeamsScheduleUpdateOpenShiftChangeRequestsRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.TeamsScheduleUpdateOpenShiftChangeRequestsExecute(r)
}

/*
TeamsScheduleUpdateOpenShiftChangeRequests Update the navigation property openShiftChangeRequests in teams

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param teamId key: id of team
 @param openShiftChangeRequestId key: id of openShiftChangeRequest
 @return ApiTeamsScheduleUpdateOpenShiftChangeRequestsRequest
*/
func (a *TeamsScheduleApiService) TeamsScheduleUpdateOpenShiftChangeRequests(ctx _context.Context, teamId string, openShiftChangeRequestId string) ApiTeamsScheduleUpdateOpenShiftChangeRequestsRequest {
	return ApiTeamsScheduleUpdateOpenShiftChangeRequestsRequest{
		ApiService: a,
		ctx: ctx,
		teamId: teamId,
		openShiftChangeRequestId: openShiftChangeRequestId,
	}
}

// Execute executes the request
func (a *TeamsScheduleApiService) TeamsScheduleUpdateOpenShiftChangeRequestsExecute(r ApiTeamsScheduleUpdateOpenShiftChangeRequestsRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPatch
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TeamsScheduleApiService.TeamsScheduleUpdateOpenShiftChangeRequests")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/teams/{team-id}/schedule/openShiftChangeRequests/{openShiftChangeRequest-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"team-id"+"}", _neturl.PathEscape(parameterToString(r.teamId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"openShiftChangeRequest-id"+"}", _neturl.PathEscape(parameterToString(r.openShiftChangeRequestId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphOpenShiftChangeRequest == nil {
		return nil, reportError("microsoftGraphOpenShiftChangeRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphOpenShiftChangeRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiTeamsScheduleUpdateOpenShiftsRequest struct {
	ctx _context.Context
	ApiService *TeamsScheduleApiService
	teamId string
	openShiftId string
	microsoftGraphOpenShift *MicrosoftGraphOpenShift
}

// New navigation property values
func (r ApiTeamsScheduleUpdateOpenShiftsRequest) MicrosoftGraphOpenShift(microsoftGraphOpenShift MicrosoftGraphOpenShift) ApiTeamsScheduleUpdateOpenShiftsRequest {
	r.microsoftGraphOpenShift = &microsoftGraphOpenShift
	return r
}

func (r ApiTeamsScheduleUpdateOpenShiftsRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.TeamsScheduleUpdateOpenShiftsExecute(r)
}

/*
TeamsScheduleUpdateOpenShifts Update the navigation property openShifts in teams

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param teamId key: id of team
 @param openShiftId key: id of openShift
 @return ApiTeamsScheduleUpdateOpenShiftsRequest
*/
func (a *TeamsScheduleApiService) TeamsScheduleUpdateOpenShifts(ctx _context.Context, teamId string, openShiftId string) ApiTeamsScheduleUpdateOpenShiftsRequest {
	return ApiTeamsScheduleUpdateOpenShiftsRequest{
		ApiService: a,
		ctx: ctx,
		teamId: teamId,
		openShiftId: openShiftId,
	}
}

// Execute executes the request
func (a *TeamsScheduleApiService) TeamsScheduleUpdateOpenShiftsExecute(r ApiTeamsScheduleUpdateOpenShiftsRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPatch
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TeamsScheduleApiService.TeamsScheduleUpdateOpenShifts")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/teams/{team-id}/schedule/openShifts/{openShift-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"team-id"+"}", _neturl.PathEscape(parameterToString(r.teamId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"openShift-id"+"}", _neturl.PathEscape(parameterToString(r.openShiftId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphOpenShift == nil {
		return nil, reportError("microsoftGraphOpenShift is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphOpenShift
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiTeamsScheduleUpdateSchedulingGroupsRequest struct {
	ctx _context.Context
	ApiService *TeamsScheduleApiService
	teamId string
	schedulingGroupId string
	microsoftGraphSchedulingGroup *MicrosoftGraphSchedulingGroup
}

// New navigation property values
func (r ApiTeamsScheduleUpdateSchedulingGroupsRequest) MicrosoftGraphSchedulingGroup(microsoftGraphSchedulingGroup MicrosoftGraphSchedulingGroup) ApiTeamsScheduleUpdateSchedulingGroupsRequest {
	r.microsoftGraphSchedulingGroup = &microsoftGraphSchedulingGroup
	return r
}

func (r ApiTeamsScheduleUpdateSchedulingGroupsRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.TeamsScheduleUpdateSchedulingGroupsExecute(r)
}

/*
TeamsScheduleUpdateSchedulingGroups Update the navigation property schedulingGroups in teams

The logical grouping of users in the schedule (usually by role).

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param teamId key: id of team
 @param schedulingGroupId key: id of schedulingGroup
 @return ApiTeamsScheduleUpdateSchedulingGroupsRequest
*/
func (a *TeamsScheduleApiService) TeamsScheduleUpdateSchedulingGroups(ctx _context.Context, teamId string, schedulingGroupId string) ApiTeamsScheduleUpdateSchedulingGroupsRequest {
	return ApiTeamsScheduleUpdateSchedulingGroupsRequest{
		ApiService: a,
		ctx: ctx,
		teamId: teamId,
		schedulingGroupId: schedulingGroupId,
	}
}

// Execute executes the request
func (a *TeamsScheduleApiService) TeamsScheduleUpdateSchedulingGroupsExecute(r ApiTeamsScheduleUpdateSchedulingGroupsRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPatch
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TeamsScheduleApiService.TeamsScheduleUpdateSchedulingGroups")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/teams/{team-id}/schedule/schedulingGroups/{schedulingGroup-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"team-id"+"}", _neturl.PathEscape(parameterToString(r.teamId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"schedulingGroup-id"+"}", _neturl.PathEscape(parameterToString(r.schedulingGroupId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphSchedulingGroup == nil {
		return nil, reportError("microsoftGraphSchedulingGroup is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphSchedulingGroup
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiTeamsScheduleUpdateShiftsRequest struct {
	ctx _context.Context
	ApiService *TeamsScheduleApiService
	teamId string
	shiftId string
	microsoftGraphShift *MicrosoftGraphShift
}

// New navigation property values
func (r ApiTeamsScheduleUpdateShiftsRequest) MicrosoftGraphShift(microsoftGraphShift MicrosoftGraphShift) ApiTeamsScheduleUpdateShiftsRequest {
	r.microsoftGraphShift = &microsoftGraphShift
	return r
}

func (r ApiTeamsScheduleUpdateShiftsRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.TeamsScheduleUpdateShiftsExecute(r)
}

/*
TeamsScheduleUpdateShifts Update the navigation property shifts in teams

The shifts in the schedule.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param teamId key: id of team
 @param shiftId key: id of shift
 @return ApiTeamsScheduleUpdateShiftsRequest
*/
func (a *TeamsScheduleApiService) TeamsScheduleUpdateShifts(ctx _context.Context, teamId string, shiftId string) ApiTeamsScheduleUpdateShiftsRequest {
	return ApiTeamsScheduleUpdateShiftsRequest{
		ApiService: a,
		ctx: ctx,
		teamId: teamId,
		shiftId: shiftId,
	}
}

// Execute executes the request
func (a *TeamsScheduleApiService) TeamsScheduleUpdateShiftsExecute(r ApiTeamsScheduleUpdateShiftsRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPatch
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TeamsScheduleApiService.TeamsScheduleUpdateShifts")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/teams/{team-id}/schedule/shifts/{shift-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"team-id"+"}", _neturl.PathEscape(parameterToString(r.teamId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"shift-id"+"}", _neturl.PathEscape(parameterToString(r.shiftId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphShift == nil {
		return nil, reportError("microsoftGraphShift is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphShift
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiTeamsScheduleUpdateSwapShiftsChangeRequestsRequest struct {
	ctx _context.Context
	ApiService *TeamsScheduleApiService
	teamId string
	swapShiftsChangeRequestId string
	microsoftGraphSwapShiftsChangeRequest *MicrosoftGraphSwapShiftsChangeRequest
}

// New navigation property values
func (r ApiTeamsScheduleUpdateSwapShiftsChangeRequestsRequest) MicrosoftGraphSwapShiftsChangeRequest(microsoftGraphSwapShiftsChangeRequest MicrosoftGraphSwapShiftsChangeRequest) ApiTeamsScheduleUpdateSwapShiftsChangeRequestsRequest {
	r.microsoftGraphSwapShiftsChangeRequest = &microsoftGraphSwapShiftsChangeRequest
	return r
}

func (r ApiTeamsScheduleUpdateSwapShiftsChangeRequestsRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.TeamsScheduleUpdateSwapShiftsChangeRequestsExecute(r)
}

/*
TeamsScheduleUpdateSwapShiftsChangeRequests Update the navigation property swapShiftsChangeRequests in teams

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param teamId key: id of team
 @param swapShiftsChangeRequestId key: id of swapShiftsChangeRequest
 @return ApiTeamsScheduleUpdateSwapShiftsChangeRequestsRequest
*/
func (a *TeamsScheduleApiService) TeamsScheduleUpdateSwapShiftsChangeRequests(ctx _context.Context, teamId string, swapShiftsChangeRequestId string) ApiTeamsScheduleUpdateSwapShiftsChangeRequestsRequest {
	return ApiTeamsScheduleUpdateSwapShiftsChangeRequestsRequest{
		ApiService: a,
		ctx: ctx,
		teamId: teamId,
		swapShiftsChangeRequestId: swapShiftsChangeRequestId,
	}
}

// Execute executes the request
func (a *TeamsScheduleApiService) TeamsScheduleUpdateSwapShiftsChangeRequestsExecute(r ApiTeamsScheduleUpdateSwapShiftsChangeRequestsRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPatch
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TeamsScheduleApiService.TeamsScheduleUpdateSwapShiftsChangeRequests")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/teams/{team-id}/schedule/swapShiftsChangeRequests/{swapShiftsChangeRequest-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"team-id"+"}", _neturl.PathEscape(parameterToString(r.teamId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"swapShiftsChangeRequest-id"+"}", _neturl.PathEscape(parameterToString(r.swapShiftsChangeRequestId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphSwapShiftsChangeRequest == nil {
		return nil, reportError("microsoftGraphSwapShiftsChangeRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphSwapShiftsChangeRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiTeamsScheduleUpdateTimeOffReasonsRequest struct {
	ctx _context.Context
	ApiService *TeamsScheduleApiService
	teamId string
	timeOffReasonId string
	microsoftGraphTimeOffReason *MicrosoftGraphTimeOffReason
}

// New navigation property values
func (r ApiTeamsScheduleUpdateTimeOffReasonsRequest) MicrosoftGraphTimeOffReason(microsoftGraphTimeOffReason MicrosoftGraphTimeOffReason) ApiTeamsScheduleUpdateTimeOffReasonsRequest {
	r.microsoftGraphTimeOffReason = &microsoftGraphTimeOffReason
	return r
}

func (r ApiTeamsScheduleUpdateTimeOffReasonsRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.TeamsScheduleUpdateTimeOffReasonsExecute(r)
}

/*
TeamsScheduleUpdateTimeOffReasons Update the navigation property timeOffReasons in teams

The set of reasons for a time off in the schedule.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param teamId key: id of team
 @param timeOffReasonId key: id of timeOffReason
 @return ApiTeamsScheduleUpdateTimeOffReasonsRequest
*/
func (a *TeamsScheduleApiService) TeamsScheduleUpdateTimeOffReasons(ctx _context.Context, teamId string, timeOffReasonId string) ApiTeamsScheduleUpdateTimeOffReasonsRequest {
	return ApiTeamsScheduleUpdateTimeOffReasonsRequest{
		ApiService: a,
		ctx: ctx,
		teamId: teamId,
		timeOffReasonId: timeOffReasonId,
	}
}

// Execute executes the request
func (a *TeamsScheduleApiService) TeamsScheduleUpdateTimeOffReasonsExecute(r ApiTeamsScheduleUpdateTimeOffReasonsRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPatch
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TeamsScheduleApiService.TeamsScheduleUpdateTimeOffReasons")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/teams/{team-id}/schedule/timeOffReasons/{timeOffReason-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"team-id"+"}", _neturl.PathEscape(parameterToString(r.teamId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"timeOffReason-id"+"}", _neturl.PathEscape(parameterToString(r.timeOffReasonId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphTimeOffReason == nil {
		return nil, reportError("microsoftGraphTimeOffReason is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphTimeOffReason
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiTeamsScheduleUpdateTimeOffRequestsRequest struct {
	ctx _context.Context
	ApiService *TeamsScheduleApiService
	teamId string
	timeOffRequestId string
	microsoftGraphTimeOffRequest *MicrosoftGraphTimeOffRequest
}

// New navigation property values
func (r ApiTeamsScheduleUpdateTimeOffRequestsRequest) MicrosoftGraphTimeOffRequest(microsoftGraphTimeOffRequest MicrosoftGraphTimeOffRequest) ApiTeamsScheduleUpdateTimeOffRequestsRequest {
	r.microsoftGraphTimeOffRequest = &microsoftGraphTimeOffRequest
	return r
}

func (r ApiTeamsScheduleUpdateTimeOffRequestsRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.TeamsScheduleUpdateTimeOffRequestsExecute(r)
}

/*
TeamsScheduleUpdateTimeOffRequests Update the navigation property timeOffRequests in teams

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param teamId key: id of team
 @param timeOffRequestId key: id of timeOffRequest
 @return ApiTeamsScheduleUpdateTimeOffRequestsRequest
*/
func (a *TeamsScheduleApiService) TeamsScheduleUpdateTimeOffRequests(ctx _context.Context, teamId string, timeOffRequestId string) ApiTeamsScheduleUpdateTimeOffRequestsRequest {
	return ApiTeamsScheduleUpdateTimeOffRequestsRequest{
		ApiService: a,
		ctx: ctx,
		teamId: teamId,
		timeOffRequestId: timeOffRequestId,
	}
}

// Execute executes the request
func (a *TeamsScheduleApiService) TeamsScheduleUpdateTimeOffRequestsExecute(r ApiTeamsScheduleUpdateTimeOffRequestsRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPatch
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TeamsScheduleApiService.TeamsScheduleUpdateTimeOffRequests")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/teams/{team-id}/schedule/timeOffRequests/{timeOffRequest-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"team-id"+"}", _neturl.PathEscape(parameterToString(r.teamId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"timeOffRequest-id"+"}", _neturl.PathEscape(parameterToString(r.timeOffRequestId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphTimeOffRequest == nil {
		return nil, reportError("microsoftGraphTimeOffRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphTimeOffRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiTeamsScheduleUpdateTimesOffRequest struct {
	ctx _context.Context
	ApiService *TeamsScheduleApiService
	teamId string
	timeOffId string
	microsoftGraphTimeOff *MicrosoftGraphTimeOff
}

// New navigation property values
func (r ApiTeamsScheduleUpdateTimesOffRequest) MicrosoftGraphTimeOff(microsoftGraphTimeOff MicrosoftGraphTimeOff) ApiTeamsScheduleUpdateTimesOffRequest {
	r.microsoftGraphTimeOff = &microsoftGraphTimeOff
	return r
}

func (r ApiTeamsScheduleUpdateTimesOffRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.TeamsScheduleUpdateTimesOffExecute(r)
}

/*
TeamsScheduleUpdateTimesOff Update the navigation property timesOff in teams

The instances of times off in the schedule.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param teamId key: id of team
 @param timeOffId key: id of timeOff
 @return ApiTeamsScheduleUpdateTimesOffRequest
*/
func (a *TeamsScheduleApiService) TeamsScheduleUpdateTimesOff(ctx _context.Context, teamId string, timeOffId string) ApiTeamsScheduleUpdateTimesOffRequest {
	return ApiTeamsScheduleUpdateTimesOffRequest{
		ApiService: a,
		ctx: ctx,
		teamId: teamId,
		timeOffId: timeOffId,
	}
}

// Execute executes the request
func (a *TeamsScheduleApiService) TeamsScheduleUpdateTimesOffExecute(r ApiTeamsScheduleUpdateTimesOffRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPatch
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TeamsScheduleApiService.TeamsScheduleUpdateTimesOff")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/teams/{team-id}/schedule/timesOff/{timeOff-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"team-id"+"}", _neturl.PathEscape(parameterToString(r.teamId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"timeOff-id"+"}", _neturl.PathEscape(parameterToString(r.timeOffId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphTimeOff == nil {
		return nil, reportError("microsoftGraphTimeOff is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphTimeOff
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiTeamsUpdateScheduleRequest struct {
	ctx _context.Context
	ApiService *TeamsScheduleApiService
	teamId string
	microsoftGraphSchedule *MicrosoftGraphSchedule
}

// New navigation property values
func (r ApiTeamsUpdateScheduleRequest) MicrosoftGraphSchedule(microsoftGraphSchedule MicrosoftGraphSchedule) ApiTeamsUpdateScheduleRequest {
	r.microsoftGraphSchedule = &microsoftGraphSchedule
	return r
}

func (r ApiTeamsUpdateScheduleRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.TeamsUpdateScheduleExecute(r)
}

/*
TeamsUpdateSchedule Update the navigation property schedule in teams

The schedule of shifts for this team.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param teamId key: id of team
 @return ApiTeamsUpdateScheduleRequest
*/
func (a *TeamsScheduleApiService) TeamsUpdateSchedule(ctx _context.Context, teamId string) ApiTeamsUpdateScheduleRequest {
	return ApiTeamsUpdateScheduleRequest{
		ApiService: a,
		ctx: ctx,
		teamId: teamId,
	}
}

// Execute executes the request
func (a *TeamsScheduleApiService) TeamsUpdateScheduleExecute(r ApiTeamsUpdateScheduleRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPatch
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TeamsScheduleApiService.TeamsUpdateSchedule")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/teams/{team-id}/schedule"
	localVarPath = strings.Replace(localVarPath, "{"+"team-id"+"}", _neturl.PathEscape(parameterToString(r.teamId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphSchedule == nil {
		return nil, reportError("microsoftGraphSchedule is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphSchedule
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}
