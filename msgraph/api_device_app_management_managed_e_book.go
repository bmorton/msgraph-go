/*
Partial Graph API

No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

API version: v1.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package msgraph

import (
	"bytes"
	_context "context"
	_ioutil "io/ioutil"
	_nethttp "net/http"
	_neturl "net/url"
	"strings"
)

// Linger please
var (
	_ _context.Context
)

// DeviceAppManagementManagedEBookApiService DeviceAppManagementManagedEBookApi service
type DeviceAppManagementManagedEBookApiService service

type ApiDeviceAppManagementCreateManagedEBooksRequest struct {
	ctx _context.Context
	ApiService *DeviceAppManagementManagedEBookApiService
	microsoftGraphManagedEBook *MicrosoftGraphManagedEBook
}

// New navigation property
func (r ApiDeviceAppManagementCreateManagedEBooksRequest) MicrosoftGraphManagedEBook(microsoftGraphManagedEBook MicrosoftGraphManagedEBook) ApiDeviceAppManagementCreateManagedEBooksRequest {
	r.microsoftGraphManagedEBook = &microsoftGraphManagedEBook
	return r
}

func (r ApiDeviceAppManagementCreateManagedEBooksRequest) Execute() (MicrosoftGraphManagedEBook, *_nethttp.Response, error) {
	return r.ApiService.DeviceAppManagementCreateManagedEBooksExecute(r)
}

/*
DeviceAppManagementCreateManagedEBooks Create new navigation property to managedEBooks for deviceAppManagement

The Managed eBook.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDeviceAppManagementCreateManagedEBooksRequest
*/
func (a *DeviceAppManagementManagedEBookApiService) DeviceAppManagementCreateManagedEBooks(ctx _context.Context) ApiDeviceAppManagementCreateManagedEBooksRequest {
	return ApiDeviceAppManagementCreateManagedEBooksRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return MicrosoftGraphManagedEBook
func (a *DeviceAppManagementManagedEBookApiService) DeviceAppManagementCreateManagedEBooksExecute(r ApiDeviceAppManagementCreateManagedEBooksRequest) (MicrosoftGraphManagedEBook, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphManagedEBook
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DeviceAppManagementManagedEBookApiService.DeviceAppManagementCreateManagedEBooks")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/deviceAppManagement/managedEBooks"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphManagedEBook == nil {
		return localVarReturnValue, nil, reportError("microsoftGraphManagedEBook is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphManagedEBook
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeviceAppManagementDeleteManagedEBooksRequest struct {
	ctx _context.Context
	ApiService *DeviceAppManagementManagedEBookApiService
	managedEBookId string
	ifMatch *string
}

// ETag
func (r ApiDeviceAppManagementDeleteManagedEBooksRequest) IfMatch(ifMatch string) ApiDeviceAppManagementDeleteManagedEBooksRequest {
	r.ifMatch = &ifMatch
	return r
}

func (r ApiDeviceAppManagementDeleteManagedEBooksRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.DeviceAppManagementDeleteManagedEBooksExecute(r)
}

/*
DeviceAppManagementDeleteManagedEBooks Delete navigation property managedEBooks for deviceAppManagement

The Managed eBook.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param managedEBookId key: id of managedEBook
 @return ApiDeviceAppManagementDeleteManagedEBooksRequest
*/
func (a *DeviceAppManagementManagedEBookApiService) DeviceAppManagementDeleteManagedEBooks(ctx _context.Context, managedEBookId string) ApiDeviceAppManagementDeleteManagedEBooksRequest {
	return ApiDeviceAppManagementDeleteManagedEBooksRequest{
		ApiService: a,
		ctx: ctx,
		managedEBookId: managedEBookId,
	}
}

// Execute executes the request
func (a *DeviceAppManagementManagedEBookApiService) DeviceAppManagementDeleteManagedEBooksExecute(r ApiDeviceAppManagementDeleteManagedEBooksRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DeviceAppManagementManagedEBookApiService.DeviceAppManagementDeleteManagedEBooks")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/deviceAppManagement/managedEBooks/{managedEBook-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"managedEBook-id"+"}", _neturl.PathEscape(parameterToString(r.managedEBookId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ifMatch != nil {
		localVarHeaderParams["If-Match"] = parameterToString(*r.ifMatch, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDeviceAppManagementGetManagedEBooksRequest struct {
	ctx _context.Context
	ApiService *DeviceAppManagementManagedEBookApiService
	managedEBookId string
	select_ *[]string
	expand *[]string
}

// Select properties to be returned
func (r ApiDeviceAppManagementGetManagedEBooksRequest) Select_(select_ []string) ApiDeviceAppManagementGetManagedEBooksRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiDeviceAppManagementGetManagedEBooksRequest) Expand(expand []string) ApiDeviceAppManagementGetManagedEBooksRequest {
	r.expand = &expand
	return r
}

func (r ApiDeviceAppManagementGetManagedEBooksRequest) Execute() (MicrosoftGraphManagedEBook, *_nethttp.Response, error) {
	return r.ApiService.DeviceAppManagementGetManagedEBooksExecute(r)
}

/*
DeviceAppManagementGetManagedEBooks Get managedEBooks from deviceAppManagement

The Managed eBook.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param managedEBookId key: id of managedEBook
 @return ApiDeviceAppManagementGetManagedEBooksRequest
*/
func (a *DeviceAppManagementManagedEBookApiService) DeviceAppManagementGetManagedEBooks(ctx _context.Context, managedEBookId string) ApiDeviceAppManagementGetManagedEBooksRequest {
	return ApiDeviceAppManagementGetManagedEBooksRequest{
		ApiService: a,
		ctx: ctx,
		managedEBookId: managedEBookId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphManagedEBook
func (a *DeviceAppManagementManagedEBookApiService) DeviceAppManagementGetManagedEBooksExecute(r ApiDeviceAppManagementGetManagedEBooksRequest) (MicrosoftGraphManagedEBook, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphManagedEBook
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DeviceAppManagementManagedEBookApiService.DeviceAppManagementGetManagedEBooks")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/deviceAppManagement/managedEBooks/{managedEBook-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"managedEBook-id"+"}", _neturl.PathEscape(parameterToString(r.managedEBookId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeviceAppManagementListManagedEBooksRequest struct {
	ctx _context.Context
	ApiService *DeviceAppManagementManagedEBookApiService
	top *int32
	skip *int32
	search *string
	filter *string
	count *bool
	orderby *[]string
	select_ *[]string
	expand *[]string
}

// Show only the first n items
func (r ApiDeviceAppManagementListManagedEBooksRequest) Top(top int32) ApiDeviceAppManagementListManagedEBooksRequest {
	r.top = &top
	return r
}
// Skip the first n items
func (r ApiDeviceAppManagementListManagedEBooksRequest) Skip(skip int32) ApiDeviceAppManagementListManagedEBooksRequest {
	r.skip = &skip
	return r
}
// Search items by search phrases
func (r ApiDeviceAppManagementListManagedEBooksRequest) Search(search string) ApiDeviceAppManagementListManagedEBooksRequest {
	r.search = &search
	return r
}
// Filter items by property values
func (r ApiDeviceAppManagementListManagedEBooksRequest) Filter(filter string) ApiDeviceAppManagementListManagedEBooksRequest {
	r.filter = &filter
	return r
}
// Include count of items
func (r ApiDeviceAppManagementListManagedEBooksRequest) Count(count bool) ApiDeviceAppManagementListManagedEBooksRequest {
	r.count = &count
	return r
}
// Order items by property values
func (r ApiDeviceAppManagementListManagedEBooksRequest) Orderby(orderby []string) ApiDeviceAppManagementListManagedEBooksRequest {
	r.orderby = &orderby
	return r
}
// Select properties to be returned
func (r ApiDeviceAppManagementListManagedEBooksRequest) Select_(select_ []string) ApiDeviceAppManagementListManagedEBooksRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiDeviceAppManagementListManagedEBooksRequest) Expand(expand []string) ApiDeviceAppManagementListManagedEBooksRequest {
	r.expand = &expand
	return r
}

func (r ApiDeviceAppManagementListManagedEBooksRequest) Execute() (CollectionOfManagedEBook, *_nethttp.Response, error) {
	return r.ApiService.DeviceAppManagementListManagedEBooksExecute(r)
}

/*
DeviceAppManagementListManagedEBooks Get managedEBooks from deviceAppManagement

The Managed eBook.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDeviceAppManagementListManagedEBooksRequest
*/
func (a *DeviceAppManagementManagedEBookApiService) DeviceAppManagementListManagedEBooks(ctx _context.Context) ApiDeviceAppManagementListManagedEBooksRequest {
	return ApiDeviceAppManagementListManagedEBooksRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CollectionOfManagedEBook
func (a *DeviceAppManagementManagedEBookApiService) DeviceAppManagementListManagedEBooksExecute(r ApiDeviceAppManagementListManagedEBooksRequest) (CollectionOfManagedEBook, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  CollectionOfManagedEBook
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DeviceAppManagementManagedEBookApiService.DeviceAppManagementListManagedEBooks")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/deviceAppManagement/managedEBooks"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.top != nil {
		localVarQueryParams.Add("$top", parameterToString(*r.top, ""))
	}
	if r.skip != nil {
		localVarQueryParams.Add("$skip", parameterToString(*r.skip, ""))
	}
	if r.search != nil {
		localVarQueryParams.Add("$search", parameterToString(*r.search, ""))
	}
	if r.filter != nil {
		localVarQueryParams.Add("$filter", parameterToString(*r.filter, ""))
	}
	if r.count != nil {
		localVarQueryParams.Add("$count", parameterToString(*r.count, ""))
	}
	if r.orderby != nil {
		localVarQueryParams.Add("$orderby", parameterToString(*r.orderby, "csv"))
	}
	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeviceAppManagementManagedEBooksCreateAssignmentsRequest struct {
	ctx _context.Context
	ApiService *DeviceAppManagementManagedEBookApiService
	managedEBookId string
	microsoftGraphManagedEBookAssignment *MicrosoftGraphManagedEBookAssignment
}

// New navigation property
func (r ApiDeviceAppManagementManagedEBooksCreateAssignmentsRequest) MicrosoftGraphManagedEBookAssignment(microsoftGraphManagedEBookAssignment MicrosoftGraphManagedEBookAssignment) ApiDeviceAppManagementManagedEBooksCreateAssignmentsRequest {
	r.microsoftGraphManagedEBookAssignment = &microsoftGraphManagedEBookAssignment
	return r
}

func (r ApiDeviceAppManagementManagedEBooksCreateAssignmentsRequest) Execute() (MicrosoftGraphManagedEBookAssignment, *_nethttp.Response, error) {
	return r.ApiService.DeviceAppManagementManagedEBooksCreateAssignmentsExecute(r)
}

/*
DeviceAppManagementManagedEBooksCreateAssignments Create new navigation property to assignments for deviceAppManagement

The list of assignments for this eBook.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param managedEBookId key: id of managedEBook
 @return ApiDeviceAppManagementManagedEBooksCreateAssignmentsRequest
*/
func (a *DeviceAppManagementManagedEBookApiService) DeviceAppManagementManagedEBooksCreateAssignments(ctx _context.Context, managedEBookId string) ApiDeviceAppManagementManagedEBooksCreateAssignmentsRequest {
	return ApiDeviceAppManagementManagedEBooksCreateAssignmentsRequest{
		ApiService: a,
		ctx: ctx,
		managedEBookId: managedEBookId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphManagedEBookAssignment
func (a *DeviceAppManagementManagedEBookApiService) DeviceAppManagementManagedEBooksCreateAssignmentsExecute(r ApiDeviceAppManagementManagedEBooksCreateAssignmentsRequest) (MicrosoftGraphManagedEBookAssignment, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphManagedEBookAssignment
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DeviceAppManagementManagedEBookApiService.DeviceAppManagementManagedEBooksCreateAssignments")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/deviceAppManagement/managedEBooks/{managedEBook-id}/assignments"
	localVarPath = strings.Replace(localVarPath, "{"+"managedEBook-id"+"}", _neturl.PathEscape(parameterToString(r.managedEBookId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphManagedEBookAssignment == nil {
		return localVarReturnValue, nil, reportError("microsoftGraphManagedEBookAssignment is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphManagedEBookAssignment
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeviceAppManagementManagedEBooksCreateDeviceStatesRequest struct {
	ctx _context.Context
	ApiService *DeviceAppManagementManagedEBookApiService
	managedEBookId string
	microsoftGraphDeviceInstallState *MicrosoftGraphDeviceInstallState
}

// New navigation property
func (r ApiDeviceAppManagementManagedEBooksCreateDeviceStatesRequest) MicrosoftGraphDeviceInstallState(microsoftGraphDeviceInstallState MicrosoftGraphDeviceInstallState) ApiDeviceAppManagementManagedEBooksCreateDeviceStatesRequest {
	r.microsoftGraphDeviceInstallState = &microsoftGraphDeviceInstallState
	return r
}

func (r ApiDeviceAppManagementManagedEBooksCreateDeviceStatesRequest) Execute() (MicrosoftGraphDeviceInstallState, *_nethttp.Response, error) {
	return r.ApiService.DeviceAppManagementManagedEBooksCreateDeviceStatesExecute(r)
}

/*
DeviceAppManagementManagedEBooksCreateDeviceStates Create new navigation property to deviceStates for deviceAppManagement

The list of installation states for this eBook.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param managedEBookId key: id of managedEBook
 @return ApiDeviceAppManagementManagedEBooksCreateDeviceStatesRequest
*/
func (a *DeviceAppManagementManagedEBookApiService) DeviceAppManagementManagedEBooksCreateDeviceStates(ctx _context.Context, managedEBookId string) ApiDeviceAppManagementManagedEBooksCreateDeviceStatesRequest {
	return ApiDeviceAppManagementManagedEBooksCreateDeviceStatesRequest{
		ApiService: a,
		ctx: ctx,
		managedEBookId: managedEBookId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphDeviceInstallState
func (a *DeviceAppManagementManagedEBookApiService) DeviceAppManagementManagedEBooksCreateDeviceStatesExecute(r ApiDeviceAppManagementManagedEBooksCreateDeviceStatesRequest) (MicrosoftGraphDeviceInstallState, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphDeviceInstallState
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DeviceAppManagementManagedEBookApiService.DeviceAppManagementManagedEBooksCreateDeviceStates")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/deviceAppManagement/managedEBooks/{managedEBook-id}/deviceStates"
	localVarPath = strings.Replace(localVarPath, "{"+"managedEBook-id"+"}", _neturl.PathEscape(parameterToString(r.managedEBookId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphDeviceInstallState == nil {
		return localVarReturnValue, nil, reportError("microsoftGraphDeviceInstallState is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphDeviceInstallState
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeviceAppManagementManagedEBooksCreateUserStateSummaryRequest struct {
	ctx _context.Context
	ApiService *DeviceAppManagementManagedEBookApiService
	managedEBookId string
	microsoftGraphUserInstallStateSummary *MicrosoftGraphUserInstallStateSummary
}

// New navigation property
func (r ApiDeviceAppManagementManagedEBooksCreateUserStateSummaryRequest) MicrosoftGraphUserInstallStateSummary(microsoftGraphUserInstallStateSummary MicrosoftGraphUserInstallStateSummary) ApiDeviceAppManagementManagedEBooksCreateUserStateSummaryRequest {
	r.microsoftGraphUserInstallStateSummary = &microsoftGraphUserInstallStateSummary
	return r
}

func (r ApiDeviceAppManagementManagedEBooksCreateUserStateSummaryRequest) Execute() (MicrosoftGraphUserInstallStateSummary, *_nethttp.Response, error) {
	return r.ApiService.DeviceAppManagementManagedEBooksCreateUserStateSummaryExecute(r)
}

/*
DeviceAppManagementManagedEBooksCreateUserStateSummary Create new navigation property to userStateSummary for deviceAppManagement

The list of installation states for this eBook.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param managedEBookId key: id of managedEBook
 @return ApiDeviceAppManagementManagedEBooksCreateUserStateSummaryRequest
*/
func (a *DeviceAppManagementManagedEBookApiService) DeviceAppManagementManagedEBooksCreateUserStateSummary(ctx _context.Context, managedEBookId string) ApiDeviceAppManagementManagedEBooksCreateUserStateSummaryRequest {
	return ApiDeviceAppManagementManagedEBooksCreateUserStateSummaryRequest{
		ApiService: a,
		ctx: ctx,
		managedEBookId: managedEBookId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphUserInstallStateSummary
func (a *DeviceAppManagementManagedEBookApiService) DeviceAppManagementManagedEBooksCreateUserStateSummaryExecute(r ApiDeviceAppManagementManagedEBooksCreateUserStateSummaryRequest) (MicrosoftGraphUserInstallStateSummary, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphUserInstallStateSummary
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DeviceAppManagementManagedEBookApiService.DeviceAppManagementManagedEBooksCreateUserStateSummary")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/deviceAppManagement/managedEBooks/{managedEBook-id}/userStateSummary"
	localVarPath = strings.Replace(localVarPath, "{"+"managedEBook-id"+"}", _neturl.PathEscape(parameterToString(r.managedEBookId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphUserInstallStateSummary == nil {
		return localVarReturnValue, nil, reportError("microsoftGraphUserInstallStateSummary is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphUserInstallStateSummary
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeviceAppManagementManagedEBooksDeleteAssignmentsRequest struct {
	ctx _context.Context
	ApiService *DeviceAppManagementManagedEBookApiService
	managedEBookId string
	managedEBookAssignmentId string
	ifMatch *string
}

// ETag
func (r ApiDeviceAppManagementManagedEBooksDeleteAssignmentsRequest) IfMatch(ifMatch string) ApiDeviceAppManagementManagedEBooksDeleteAssignmentsRequest {
	r.ifMatch = &ifMatch
	return r
}

func (r ApiDeviceAppManagementManagedEBooksDeleteAssignmentsRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.DeviceAppManagementManagedEBooksDeleteAssignmentsExecute(r)
}

/*
DeviceAppManagementManagedEBooksDeleteAssignments Delete navigation property assignments for deviceAppManagement

The list of assignments for this eBook.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param managedEBookId key: id of managedEBook
 @param managedEBookAssignmentId key: id of managedEBookAssignment
 @return ApiDeviceAppManagementManagedEBooksDeleteAssignmentsRequest
*/
func (a *DeviceAppManagementManagedEBookApiService) DeviceAppManagementManagedEBooksDeleteAssignments(ctx _context.Context, managedEBookId string, managedEBookAssignmentId string) ApiDeviceAppManagementManagedEBooksDeleteAssignmentsRequest {
	return ApiDeviceAppManagementManagedEBooksDeleteAssignmentsRequest{
		ApiService: a,
		ctx: ctx,
		managedEBookId: managedEBookId,
		managedEBookAssignmentId: managedEBookAssignmentId,
	}
}

// Execute executes the request
func (a *DeviceAppManagementManagedEBookApiService) DeviceAppManagementManagedEBooksDeleteAssignmentsExecute(r ApiDeviceAppManagementManagedEBooksDeleteAssignmentsRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DeviceAppManagementManagedEBookApiService.DeviceAppManagementManagedEBooksDeleteAssignments")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/deviceAppManagement/managedEBooks/{managedEBook-id}/assignments/{managedEBookAssignment-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"managedEBook-id"+"}", _neturl.PathEscape(parameterToString(r.managedEBookId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"managedEBookAssignment-id"+"}", _neturl.PathEscape(parameterToString(r.managedEBookAssignmentId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ifMatch != nil {
		localVarHeaderParams["If-Match"] = parameterToString(*r.ifMatch, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDeviceAppManagementManagedEBooksDeleteDeviceStatesRequest struct {
	ctx _context.Context
	ApiService *DeviceAppManagementManagedEBookApiService
	managedEBookId string
	deviceInstallStateId string
	ifMatch *string
}

// ETag
func (r ApiDeviceAppManagementManagedEBooksDeleteDeviceStatesRequest) IfMatch(ifMatch string) ApiDeviceAppManagementManagedEBooksDeleteDeviceStatesRequest {
	r.ifMatch = &ifMatch
	return r
}

func (r ApiDeviceAppManagementManagedEBooksDeleteDeviceStatesRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.DeviceAppManagementManagedEBooksDeleteDeviceStatesExecute(r)
}

/*
DeviceAppManagementManagedEBooksDeleteDeviceStates Delete navigation property deviceStates for deviceAppManagement

The list of installation states for this eBook.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param managedEBookId key: id of managedEBook
 @param deviceInstallStateId key: id of deviceInstallState
 @return ApiDeviceAppManagementManagedEBooksDeleteDeviceStatesRequest
*/
func (a *DeviceAppManagementManagedEBookApiService) DeviceAppManagementManagedEBooksDeleteDeviceStates(ctx _context.Context, managedEBookId string, deviceInstallStateId string) ApiDeviceAppManagementManagedEBooksDeleteDeviceStatesRequest {
	return ApiDeviceAppManagementManagedEBooksDeleteDeviceStatesRequest{
		ApiService: a,
		ctx: ctx,
		managedEBookId: managedEBookId,
		deviceInstallStateId: deviceInstallStateId,
	}
}

// Execute executes the request
func (a *DeviceAppManagementManagedEBookApiService) DeviceAppManagementManagedEBooksDeleteDeviceStatesExecute(r ApiDeviceAppManagementManagedEBooksDeleteDeviceStatesRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DeviceAppManagementManagedEBookApiService.DeviceAppManagementManagedEBooksDeleteDeviceStates")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/deviceAppManagement/managedEBooks/{managedEBook-id}/deviceStates/{deviceInstallState-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"managedEBook-id"+"}", _neturl.PathEscape(parameterToString(r.managedEBookId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"deviceInstallState-id"+"}", _neturl.PathEscape(parameterToString(r.deviceInstallStateId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ifMatch != nil {
		localVarHeaderParams["If-Match"] = parameterToString(*r.ifMatch, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDeviceAppManagementManagedEBooksDeleteInstallSummaryRequest struct {
	ctx _context.Context
	ApiService *DeviceAppManagementManagedEBookApiService
	managedEBookId string
	ifMatch *string
}

// ETag
func (r ApiDeviceAppManagementManagedEBooksDeleteInstallSummaryRequest) IfMatch(ifMatch string) ApiDeviceAppManagementManagedEBooksDeleteInstallSummaryRequest {
	r.ifMatch = &ifMatch
	return r
}

func (r ApiDeviceAppManagementManagedEBooksDeleteInstallSummaryRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.DeviceAppManagementManagedEBooksDeleteInstallSummaryExecute(r)
}

/*
DeviceAppManagementManagedEBooksDeleteInstallSummary Delete navigation property installSummary for deviceAppManagement

Mobile App Install Summary.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param managedEBookId key: id of managedEBook
 @return ApiDeviceAppManagementManagedEBooksDeleteInstallSummaryRequest
*/
func (a *DeviceAppManagementManagedEBookApiService) DeviceAppManagementManagedEBooksDeleteInstallSummary(ctx _context.Context, managedEBookId string) ApiDeviceAppManagementManagedEBooksDeleteInstallSummaryRequest {
	return ApiDeviceAppManagementManagedEBooksDeleteInstallSummaryRequest{
		ApiService: a,
		ctx: ctx,
		managedEBookId: managedEBookId,
	}
}

// Execute executes the request
func (a *DeviceAppManagementManagedEBookApiService) DeviceAppManagementManagedEBooksDeleteInstallSummaryExecute(r ApiDeviceAppManagementManagedEBooksDeleteInstallSummaryRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DeviceAppManagementManagedEBookApiService.DeviceAppManagementManagedEBooksDeleteInstallSummary")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/deviceAppManagement/managedEBooks/{managedEBook-id}/installSummary"
	localVarPath = strings.Replace(localVarPath, "{"+"managedEBook-id"+"}", _neturl.PathEscape(parameterToString(r.managedEBookId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ifMatch != nil {
		localVarHeaderParams["If-Match"] = parameterToString(*r.ifMatch, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDeviceAppManagementManagedEBooksDeleteUserStateSummaryRequest struct {
	ctx _context.Context
	ApiService *DeviceAppManagementManagedEBookApiService
	managedEBookId string
	userInstallStateSummaryId string
	ifMatch *string
}

// ETag
func (r ApiDeviceAppManagementManagedEBooksDeleteUserStateSummaryRequest) IfMatch(ifMatch string) ApiDeviceAppManagementManagedEBooksDeleteUserStateSummaryRequest {
	r.ifMatch = &ifMatch
	return r
}

func (r ApiDeviceAppManagementManagedEBooksDeleteUserStateSummaryRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.DeviceAppManagementManagedEBooksDeleteUserStateSummaryExecute(r)
}

/*
DeviceAppManagementManagedEBooksDeleteUserStateSummary Delete navigation property userStateSummary for deviceAppManagement

The list of installation states for this eBook.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param managedEBookId key: id of managedEBook
 @param userInstallStateSummaryId key: id of userInstallStateSummary
 @return ApiDeviceAppManagementManagedEBooksDeleteUserStateSummaryRequest
*/
func (a *DeviceAppManagementManagedEBookApiService) DeviceAppManagementManagedEBooksDeleteUserStateSummary(ctx _context.Context, managedEBookId string, userInstallStateSummaryId string) ApiDeviceAppManagementManagedEBooksDeleteUserStateSummaryRequest {
	return ApiDeviceAppManagementManagedEBooksDeleteUserStateSummaryRequest{
		ApiService: a,
		ctx: ctx,
		managedEBookId: managedEBookId,
		userInstallStateSummaryId: userInstallStateSummaryId,
	}
}

// Execute executes the request
func (a *DeviceAppManagementManagedEBookApiService) DeviceAppManagementManagedEBooksDeleteUserStateSummaryExecute(r ApiDeviceAppManagementManagedEBooksDeleteUserStateSummaryRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DeviceAppManagementManagedEBookApiService.DeviceAppManagementManagedEBooksDeleteUserStateSummary")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/deviceAppManagement/managedEBooks/{managedEBook-id}/userStateSummary/{userInstallStateSummary-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"managedEBook-id"+"}", _neturl.PathEscape(parameterToString(r.managedEBookId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"userInstallStateSummary-id"+"}", _neturl.PathEscape(parameterToString(r.userInstallStateSummaryId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ifMatch != nil {
		localVarHeaderParams["If-Match"] = parameterToString(*r.ifMatch, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDeviceAppManagementManagedEBooksGetAssignmentsRequest struct {
	ctx _context.Context
	ApiService *DeviceAppManagementManagedEBookApiService
	managedEBookId string
	managedEBookAssignmentId string
	select_ *[]string
	expand *[]string
}

// Select properties to be returned
func (r ApiDeviceAppManagementManagedEBooksGetAssignmentsRequest) Select_(select_ []string) ApiDeviceAppManagementManagedEBooksGetAssignmentsRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiDeviceAppManagementManagedEBooksGetAssignmentsRequest) Expand(expand []string) ApiDeviceAppManagementManagedEBooksGetAssignmentsRequest {
	r.expand = &expand
	return r
}

func (r ApiDeviceAppManagementManagedEBooksGetAssignmentsRequest) Execute() (MicrosoftGraphManagedEBookAssignment, *_nethttp.Response, error) {
	return r.ApiService.DeviceAppManagementManagedEBooksGetAssignmentsExecute(r)
}

/*
DeviceAppManagementManagedEBooksGetAssignments Get assignments from deviceAppManagement

The list of assignments for this eBook.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param managedEBookId key: id of managedEBook
 @param managedEBookAssignmentId key: id of managedEBookAssignment
 @return ApiDeviceAppManagementManagedEBooksGetAssignmentsRequest
*/
func (a *DeviceAppManagementManagedEBookApiService) DeviceAppManagementManagedEBooksGetAssignments(ctx _context.Context, managedEBookId string, managedEBookAssignmentId string) ApiDeviceAppManagementManagedEBooksGetAssignmentsRequest {
	return ApiDeviceAppManagementManagedEBooksGetAssignmentsRequest{
		ApiService: a,
		ctx: ctx,
		managedEBookId: managedEBookId,
		managedEBookAssignmentId: managedEBookAssignmentId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphManagedEBookAssignment
func (a *DeviceAppManagementManagedEBookApiService) DeviceAppManagementManagedEBooksGetAssignmentsExecute(r ApiDeviceAppManagementManagedEBooksGetAssignmentsRequest) (MicrosoftGraphManagedEBookAssignment, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphManagedEBookAssignment
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DeviceAppManagementManagedEBookApiService.DeviceAppManagementManagedEBooksGetAssignments")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/deviceAppManagement/managedEBooks/{managedEBook-id}/assignments/{managedEBookAssignment-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"managedEBook-id"+"}", _neturl.PathEscape(parameterToString(r.managedEBookId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"managedEBookAssignment-id"+"}", _neturl.PathEscape(parameterToString(r.managedEBookAssignmentId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeviceAppManagementManagedEBooksGetDeviceStatesRequest struct {
	ctx _context.Context
	ApiService *DeviceAppManagementManagedEBookApiService
	managedEBookId string
	deviceInstallStateId string
	select_ *[]string
	expand *[]string
}

// Select properties to be returned
func (r ApiDeviceAppManagementManagedEBooksGetDeviceStatesRequest) Select_(select_ []string) ApiDeviceAppManagementManagedEBooksGetDeviceStatesRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiDeviceAppManagementManagedEBooksGetDeviceStatesRequest) Expand(expand []string) ApiDeviceAppManagementManagedEBooksGetDeviceStatesRequest {
	r.expand = &expand
	return r
}

func (r ApiDeviceAppManagementManagedEBooksGetDeviceStatesRequest) Execute() (MicrosoftGraphDeviceInstallState, *_nethttp.Response, error) {
	return r.ApiService.DeviceAppManagementManagedEBooksGetDeviceStatesExecute(r)
}

/*
DeviceAppManagementManagedEBooksGetDeviceStates Get deviceStates from deviceAppManagement

The list of installation states for this eBook.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param managedEBookId key: id of managedEBook
 @param deviceInstallStateId key: id of deviceInstallState
 @return ApiDeviceAppManagementManagedEBooksGetDeviceStatesRequest
*/
func (a *DeviceAppManagementManagedEBookApiService) DeviceAppManagementManagedEBooksGetDeviceStates(ctx _context.Context, managedEBookId string, deviceInstallStateId string) ApiDeviceAppManagementManagedEBooksGetDeviceStatesRequest {
	return ApiDeviceAppManagementManagedEBooksGetDeviceStatesRequest{
		ApiService: a,
		ctx: ctx,
		managedEBookId: managedEBookId,
		deviceInstallStateId: deviceInstallStateId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphDeviceInstallState
func (a *DeviceAppManagementManagedEBookApiService) DeviceAppManagementManagedEBooksGetDeviceStatesExecute(r ApiDeviceAppManagementManagedEBooksGetDeviceStatesRequest) (MicrosoftGraphDeviceInstallState, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphDeviceInstallState
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DeviceAppManagementManagedEBookApiService.DeviceAppManagementManagedEBooksGetDeviceStates")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/deviceAppManagement/managedEBooks/{managedEBook-id}/deviceStates/{deviceInstallState-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"managedEBook-id"+"}", _neturl.PathEscape(parameterToString(r.managedEBookId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"deviceInstallState-id"+"}", _neturl.PathEscape(parameterToString(r.deviceInstallStateId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeviceAppManagementManagedEBooksGetInstallSummaryRequest struct {
	ctx _context.Context
	ApiService *DeviceAppManagementManagedEBookApiService
	managedEBookId string
	select_ *[]string
	expand *[]string
}

// Select properties to be returned
func (r ApiDeviceAppManagementManagedEBooksGetInstallSummaryRequest) Select_(select_ []string) ApiDeviceAppManagementManagedEBooksGetInstallSummaryRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiDeviceAppManagementManagedEBooksGetInstallSummaryRequest) Expand(expand []string) ApiDeviceAppManagementManagedEBooksGetInstallSummaryRequest {
	r.expand = &expand
	return r
}

func (r ApiDeviceAppManagementManagedEBooksGetInstallSummaryRequest) Execute() (MicrosoftGraphEBookInstallSummary, *_nethttp.Response, error) {
	return r.ApiService.DeviceAppManagementManagedEBooksGetInstallSummaryExecute(r)
}

/*
DeviceAppManagementManagedEBooksGetInstallSummary Get installSummary from deviceAppManagement

Mobile App Install Summary.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param managedEBookId key: id of managedEBook
 @return ApiDeviceAppManagementManagedEBooksGetInstallSummaryRequest
*/
func (a *DeviceAppManagementManagedEBookApiService) DeviceAppManagementManagedEBooksGetInstallSummary(ctx _context.Context, managedEBookId string) ApiDeviceAppManagementManagedEBooksGetInstallSummaryRequest {
	return ApiDeviceAppManagementManagedEBooksGetInstallSummaryRequest{
		ApiService: a,
		ctx: ctx,
		managedEBookId: managedEBookId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphEBookInstallSummary
func (a *DeviceAppManagementManagedEBookApiService) DeviceAppManagementManagedEBooksGetInstallSummaryExecute(r ApiDeviceAppManagementManagedEBooksGetInstallSummaryRequest) (MicrosoftGraphEBookInstallSummary, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphEBookInstallSummary
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DeviceAppManagementManagedEBookApiService.DeviceAppManagementManagedEBooksGetInstallSummary")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/deviceAppManagement/managedEBooks/{managedEBook-id}/installSummary"
	localVarPath = strings.Replace(localVarPath, "{"+"managedEBook-id"+"}", _neturl.PathEscape(parameterToString(r.managedEBookId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeviceAppManagementManagedEBooksGetUserStateSummaryRequest struct {
	ctx _context.Context
	ApiService *DeviceAppManagementManagedEBookApiService
	managedEBookId string
	userInstallStateSummaryId string
	select_ *[]string
	expand *[]string
}

// Select properties to be returned
func (r ApiDeviceAppManagementManagedEBooksGetUserStateSummaryRequest) Select_(select_ []string) ApiDeviceAppManagementManagedEBooksGetUserStateSummaryRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiDeviceAppManagementManagedEBooksGetUserStateSummaryRequest) Expand(expand []string) ApiDeviceAppManagementManagedEBooksGetUserStateSummaryRequest {
	r.expand = &expand
	return r
}

func (r ApiDeviceAppManagementManagedEBooksGetUserStateSummaryRequest) Execute() (MicrosoftGraphUserInstallStateSummary, *_nethttp.Response, error) {
	return r.ApiService.DeviceAppManagementManagedEBooksGetUserStateSummaryExecute(r)
}

/*
DeviceAppManagementManagedEBooksGetUserStateSummary Get userStateSummary from deviceAppManagement

The list of installation states for this eBook.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param managedEBookId key: id of managedEBook
 @param userInstallStateSummaryId key: id of userInstallStateSummary
 @return ApiDeviceAppManagementManagedEBooksGetUserStateSummaryRequest
*/
func (a *DeviceAppManagementManagedEBookApiService) DeviceAppManagementManagedEBooksGetUserStateSummary(ctx _context.Context, managedEBookId string, userInstallStateSummaryId string) ApiDeviceAppManagementManagedEBooksGetUserStateSummaryRequest {
	return ApiDeviceAppManagementManagedEBooksGetUserStateSummaryRequest{
		ApiService: a,
		ctx: ctx,
		managedEBookId: managedEBookId,
		userInstallStateSummaryId: userInstallStateSummaryId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphUserInstallStateSummary
func (a *DeviceAppManagementManagedEBookApiService) DeviceAppManagementManagedEBooksGetUserStateSummaryExecute(r ApiDeviceAppManagementManagedEBooksGetUserStateSummaryRequest) (MicrosoftGraphUserInstallStateSummary, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphUserInstallStateSummary
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DeviceAppManagementManagedEBookApiService.DeviceAppManagementManagedEBooksGetUserStateSummary")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/deviceAppManagement/managedEBooks/{managedEBook-id}/userStateSummary/{userInstallStateSummary-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"managedEBook-id"+"}", _neturl.PathEscape(parameterToString(r.managedEBookId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"userInstallStateSummary-id"+"}", _neturl.PathEscape(parameterToString(r.userInstallStateSummaryId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeviceAppManagementManagedEBooksListAssignmentsRequest struct {
	ctx _context.Context
	ApiService *DeviceAppManagementManagedEBookApiService
	managedEBookId string
	top *int32
	skip *int32
	search *string
	filter *string
	count *bool
	orderby *[]string
	select_ *[]string
	expand *[]string
}

// Show only the first n items
func (r ApiDeviceAppManagementManagedEBooksListAssignmentsRequest) Top(top int32) ApiDeviceAppManagementManagedEBooksListAssignmentsRequest {
	r.top = &top
	return r
}
// Skip the first n items
func (r ApiDeviceAppManagementManagedEBooksListAssignmentsRequest) Skip(skip int32) ApiDeviceAppManagementManagedEBooksListAssignmentsRequest {
	r.skip = &skip
	return r
}
// Search items by search phrases
func (r ApiDeviceAppManagementManagedEBooksListAssignmentsRequest) Search(search string) ApiDeviceAppManagementManagedEBooksListAssignmentsRequest {
	r.search = &search
	return r
}
// Filter items by property values
func (r ApiDeviceAppManagementManagedEBooksListAssignmentsRequest) Filter(filter string) ApiDeviceAppManagementManagedEBooksListAssignmentsRequest {
	r.filter = &filter
	return r
}
// Include count of items
func (r ApiDeviceAppManagementManagedEBooksListAssignmentsRequest) Count(count bool) ApiDeviceAppManagementManagedEBooksListAssignmentsRequest {
	r.count = &count
	return r
}
// Order items by property values
func (r ApiDeviceAppManagementManagedEBooksListAssignmentsRequest) Orderby(orderby []string) ApiDeviceAppManagementManagedEBooksListAssignmentsRequest {
	r.orderby = &orderby
	return r
}
// Select properties to be returned
func (r ApiDeviceAppManagementManagedEBooksListAssignmentsRequest) Select_(select_ []string) ApiDeviceAppManagementManagedEBooksListAssignmentsRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiDeviceAppManagementManagedEBooksListAssignmentsRequest) Expand(expand []string) ApiDeviceAppManagementManagedEBooksListAssignmentsRequest {
	r.expand = &expand
	return r
}

func (r ApiDeviceAppManagementManagedEBooksListAssignmentsRequest) Execute() (CollectionOfManagedEBookAssignment, *_nethttp.Response, error) {
	return r.ApiService.DeviceAppManagementManagedEBooksListAssignmentsExecute(r)
}

/*
DeviceAppManagementManagedEBooksListAssignments Get assignments from deviceAppManagement

The list of assignments for this eBook.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param managedEBookId key: id of managedEBook
 @return ApiDeviceAppManagementManagedEBooksListAssignmentsRequest
*/
func (a *DeviceAppManagementManagedEBookApiService) DeviceAppManagementManagedEBooksListAssignments(ctx _context.Context, managedEBookId string) ApiDeviceAppManagementManagedEBooksListAssignmentsRequest {
	return ApiDeviceAppManagementManagedEBooksListAssignmentsRequest{
		ApiService: a,
		ctx: ctx,
		managedEBookId: managedEBookId,
	}
}

// Execute executes the request
//  @return CollectionOfManagedEBookAssignment
func (a *DeviceAppManagementManagedEBookApiService) DeviceAppManagementManagedEBooksListAssignmentsExecute(r ApiDeviceAppManagementManagedEBooksListAssignmentsRequest) (CollectionOfManagedEBookAssignment, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  CollectionOfManagedEBookAssignment
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DeviceAppManagementManagedEBookApiService.DeviceAppManagementManagedEBooksListAssignments")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/deviceAppManagement/managedEBooks/{managedEBook-id}/assignments"
	localVarPath = strings.Replace(localVarPath, "{"+"managedEBook-id"+"}", _neturl.PathEscape(parameterToString(r.managedEBookId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.top != nil {
		localVarQueryParams.Add("$top", parameterToString(*r.top, ""))
	}
	if r.skip != nil {
		localVarQueryParams.Add("$skip", parameterToString(*r.skip, ""))
	}
	if r.search != nil {
		localVarQueryParams.Add("$search", parameterToString(*r.search, ""))
	}
	if r.filter != nil {
		localVarQueryParams.Add("$filter", parameterToString(*r.filter, ""))
	}
	if r.count != nil {
		localVarQueryParams.Add("$count", parameterToString(*r.count, ""))
	}
	if r.orderby != nil {
		localVarQueryParams.Add("$orderby", parameterToString(*r.orderby, "csv"))
	}
	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeviceAppManagementManagedEBooksListDeviceStatesRequest struct {
	ctx _context.Context
	ApiService *DeviceAppManagementManagedEBookApiService
	managedEBookId string
	top *int32
	skip *int32
	search *string
	filter *string
	count *bool
	orderby *[]string
	select_ *[]string
	expand *[]string
}

// Show only the first n items
func (r ApiDeviceAppManagementManagedEBooksListDeviceStatesRequest) Top(top int32) ApiDeviceAppManagementManagedEBooksListDeviceStatesRequest {
	r.top = &top
	return r
}
// Skip the first n items
func (r ApiDeviceAppManagementManagedEBooksListDeviceStatesRequest) Skip(skip int32) ApiDeviceAppManagementManagedEBooksListDeviceStatesRequest {
	r.skip = &skip
	return r
}
// Search items by search phrases
func (r ApiDeviceAppManagementManagedEBooksListDeviceStatesRequest) Search(search string) ApiDeviceAppManagementManagedEBooksListDeviceStatesRequest {
	r.search = &search
	return r
}
// Filter items by property values
func (r ApiDeviceAppManagementManagedEBooksListDeviceStatesRequest) Filter(filter string) ApiDeviceAppManagementManagedEBooksListDeviceStatesRequest {
	r.filter = &filter
	return r
}
// Include count of items
func (r ApiDeviceAppManagementManagedEBooksListDeviceStatesRequest) Count(count bool) ApiDeviceAppManagementManagedEBooksListDeviceStatesRequest {
	r.count = &count
	return r
}
// Order items by property values
func (r ApiDeviceAppManagementManagedEBooksListDeviceStatesRequest) Orderby(orderby []string) ApiDeviceAppManagementManagedEBooksListDeviceStatesRequest {
	r.orderby = &orderby
	return r
}
// Select properties to be returned
func (r ApiDeviceAppManagementManagedEBooksListDeviceStatesRequest) Select_(select_ []string) ApiDeviceAppManagementManagedEBooksListDeviceStatesRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiDeviceAppManagementManagedEBooksListDeviceStatesRequest) Expand(expand []string) ApiDeviceAppManagementManagedEBooksListDeviceStatesRequest {
	r.expand = &expand
	return r
}

func (r ApiDeviceAppManagementManagedEBooksListDeviceStatesRequest) Execute() (CollectionOfDeviceInstallState, *_nethttp.Response, error) {
	return r.ApiService.DeviceAppManagementManagedEBooksListDeviceStatesExecute(r)
}

/*
DeviceAppManagementManagedEBooksListDeviceStates Get deviceStates from deviceAppManagement

The list of installation states for this eBook.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param managedEBookId key: id of managedEBook
 @return ApiDeviceAppManagementManagedEBooksListDeviceStatesRequest
*/
func (a *DeviceAppManagementManagedEBookApiService) DeviceAppManagementManagedEBooksListDeviceStates(ctx _context.Context, managedEBookId string) ApiDeviceAppManagementManagedEBooksListDeviceStatesRequest {
	return ApiDeviceAppManagementManagedEBooksListDeviceStatesRequest{
		ApiService: a,
		ctx: ctx,
		managedEBookId: managedEBookId,
	}
}

// Execute executes the request
//  @return CollectionOfDeviceInstallState
func (a *DeviceAppManagementManagedEBookApiService) DeviceAppManagementManagedEBooksListDeviceStatesExecute(r ApiDeviceAppManagementManagedEBooksListDeviceStatesRequest) (CollectionOfDeviceInstallState, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  CollectionOfDeviceInstallState
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DeviceAppManagementManagedEBookApiService.DeviceAppManagementManagedEBooksListDeviceStates")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/deviceAppManagement/managedEBooks/{managedEBook-id}/deviceStates"
	localVarPath = strings.Replace(localVarPath, "{"+"managedEBook-id"+"}", _neturl.PathEscape(parameterToString(r.managedEBookId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.top != nil {
		localVarQueryParams.Add("$top", parameterToString(*r.top, ""))
	}
	if r.skip != nil {
		localVarQueryParams.Add("$skip", parameterToString(*r.skip, ""))
	}
	if r.search != nil {
		localVarQueryParams.Add("$search", parameterToString(*r.search, ""))
	}
	if r.filter != nil {
		localVarQueryParams.Add("$filter", parameterToString(*r.filter, ""))
	}
	if r.count != nil {
		localVarQueryParams.Add("$count", parameterToString(*r.count, ""))
	}
	if r.orderby != nil {
		localVarQueryParams.Add("$orderby", parameterToString(*r.orderby, "csv"))
	}
	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeviceAppManagementManagedEBooksListUserStateSummaryRequest struct {
	ctx _context.Context
	ApiService *DeviceAppManagementManagedEBookApiService
	managedEBookId string
	top *int32
	skip *int32
	search *string
	filter *string
	count *bool
	orderby *[]string
	select_ *[]string
	expand *[]string
}

// Show only the first n items
func (r ApiDeviceAppManagementManagedEBooksListUserStateSummaryRequest) Top(top int32) ApiDeviceAppManagementManagedEBooksListUserStateSummaryRequest {
	r.top = &top
	return r
}
// Skip the first n items
func (r ApiDeviceAppManagementManagedEBooksListUserStateSummaryRequest) Skip(skip int32) ApiDeviceAppManagementManagedEBooksListUserStateSummaryRequest {
	r.skip = &skip
	return r
}
// Search items by search phrases
func (r ApiDeviceAppManagementManagedEBooksListUserStateSummaryRequest) Search(search string) ApiDeviceAppManagementManagedEBooksListUserStateSummaryRequest {
	r.search = &search
	return r
}
// Filter items by property values
func (r ApiDeviceAppManagementManagedEBooksListUserStateSummaryRequest) Filter(filter string) ApiDeviceAppManagementManagedEBooksListUserStateSummaryRequest {
	r.filter = &filter
	return r
}
// Include count of items
func (r ApiDeviceAppManagementManagedEBooksListUserStateSummaryRequest) Count(count bool) ApiDeviceAppManagementManagedEBooksListUserStateSummaryRequest {
	r.count = &count
	return r
}
// Order items by property values
func (r ApiDeviceAppManagementManagedEBooksListUserStateSummaryRequest) Orderby(orderby []string) ApiDeviceAppManagementManagedEBooksListUserStateSummaryRequest {
	r.orderby = &orderby
	return r
}
// Select properties to be returned
func (r ApiDeviceAppManagementManagedEBooksListUserStateSummaryRequest) Select_(select_ []string) ApiDeviceAppManagementManagedEBooksListUserStateSummaryRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiDeviceAppManagementManagedEBooksListUserStateSummaryRequest) Expand(expand []string) ApiDeviceAppManagementManagedEBooksListUserStateSummaryRequest {
	r.expand = &expand
	return r
}

func (r ApiDeviceAppManagementManagedEBooksListUserStateSummaryRequest) Execute() (CollectionOfUserInstallStateSummary, *_nethttp.Response, error) {
	return r.ApiService.DeviceAppManagementManagedEBooksListUserStateSummaryExecute(r)
}

/*
DeviceAppManagementManagedEBooksListUserStateSummary Get userStateSummary from deviceAppManagement

The list of installation states for this eBook.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param managedEBookId key: id of managedEBook
 @return ApiDeviceAppManagementManagedEBooksListUserStateSummaryRequest
*/
func (a *DeviceAppManagementManagedEBookApiService) DeviceAppManagementManagedEBooksListUserStateSummary(ctx _context.Context, managedEBookId string) ApiDeviceAppManagementManagedEBooksListUserStateSummaryRequest {
	return ApiDeviceAppManagementManagedEBooksListUserStateSummaryRequest{
		ApiService: a,
		ctx: ctx,
		managedEBookId: managedEBookId,
	}
}

// Execute executes the request
//  @return CollectionOfUserInstallStateSummary
func (a *DeviceAppManagementManagedEBookApiService) DeviceAppManagementManagedEBooksListUserStateSummaryExecute(r ApiDeviceAppManagementManagedEBooksListUserStateSummaryRequest) (CollectionOfUserInstallStateSummary, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  CollectionOfUserInstallStateSummary
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DeviceAppManagementManagedEBookApiService.DeviceAppManagementManagedEBooksListUserStateSummary")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/deviceAppManagement/managedEBooks/{managedEBook-id}/userStateSummary"
	localVarPath = strings.Replace(localVarPath, "{"+"managedEBook-id"+"}", _neturl.PathEscape(parameterToString(r.managedEBookId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.top != nil {
		localVarQueryParams.Add("$top", parameterToString(*r.top, ""))
	}
	if r.skip != nil {
		localVarQueryParams.Add("$skip", parameterToString(*r.skip, ""))
	}
	if r.search != nil {
		localVarQueryParams.Add("$search", parameterToString(*r.search, ""))
	}
	if r.filter != nil {
		localVarQueryParams.Add("$filter", parameterToString(*r.filter, ""))
	}
	if r.count != nil {
		localVarQueryParams.Add("$count", parameterToString(*r.count, ""))
	}
	if r.orderby != nil {
		localVarQueryParams.Add("$orderby", parameterToString(*r.orderby, "csv"))
	}
	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeviceAppManagementManagedEBooksUpdateAssignmentsRequest struct {
	ctx _context.Context
	ApiService *DeviceAppManagementManagedEBookApiService
	managedEBookId string
	managedEBookAssignmentId string
	microsoftGraphManagedEBookAssignment *MicrosoftGraphManagedEBookAssignment
}

// New navigation property values
func (r ApiDeviceAppManagementManagedEBooksUpdateAssignmentsRequest) MicrosoftGraphManagedEBookAssignment(microsoftGraphManagedEBookAssignment MicrosoftGraphManagedEBookAssignment) ApiDeviceAppManagementManagedEBooksUpdateAssignmentsRequest {
	r.microsoftGraphManagedEBookAssignment = &microsoftGraphManagedEBookAssignment
	return r
}

func (r ApiDeviceAppManagementManagedEBooksUpdateAssignmentsRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.DeviceAppManagementManagedEBooksUpdateAssignmentsExecute(r)
}

/*
DeviceAppManagementManagedEBooksUpdateAssignments Update the navigation property assignments in deviceAppManagement

The list of assignments for this eBook.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param managedEBookId key: id of managedEBook
 @param managedEBookAssignmentId key: id of managedEBookAssignment
 @return ApiDeviceAppManagementManagedEBooksUpdateAssignmentsRequest
*/
func (a *DeviceAppManagementManagedEBookApiService) DeviceAppManagementManagedEBooksUpdateAssignments(ctx _context.Context, managedEBookId string, managedEBookAssignmentId string) ApiDeviceAppManagementManagedEBooksUpdateAssignmentsRequest {
	return ApiDeviceAppManagementManagedEBooksUpdateAssignmentsRequest{
		ApiService: a,
		ctx: ctx,
		managedEBookId: managedEBookId,
		managedEBookAssignmentId: managedEBookAssignmentId,
	}
}

// Execute executes the request
func (a *DeviceAppManagementManagedEBookApiService) DeviceAppManagementManagedEBooksUpdateAssignmentsExecute(r ApiDeviceAppManagementManagedEBooksUpdateAssignmentsRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPatch
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DeviceAppManagementManagedEBookApiService.DeviceAppManagementManagedEBooksUpdateAssignments")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/deviceAppManagement/managedEBooks/{managedEBook-id}/assignments/{managedEBookAssignment-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"managedEBook-id"+"}", _neturl.PathEscape(parameterToString(r.managedEBookId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"managedEBookAssignment-id"+"}", _neturl.PathEscape(parameterToString(r.managedEBookAssignmentId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphManagedEBookAssignment == nil {
		return nil, reportError("microsoftGraphManagedEBookAssignment is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphManagedEBookAssignment
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDeviceAppManagementManagedEBooksUpdateDeviceStatesRequest struct {
	ctx _context.Context
	ApiService *DeviceAppManagementManagedEBookApiService
	managedEBookId string
	deviceInstallStateId string
	microsoftGraphDeviceInstallState *MicrosoftGraphDeviceInstallState
}

// New navigation property values
func (r ApiDeviceAppManagementManagedEBooksUpdateDeviceStatesRequest) MicrosoftGraphDeviceInstallState(microsoftGraphDeviceInstallState MicrosoftGraphDeviceInstallState) ApiDeviceAppManagementManagedEBooksUpdateDeviceStatesRequest {
	r.microsoftGraphDeviceInstallState = &microsoftGraphDeviceInstallState
	return r
}

func (r ApiDeviceAppManagementManagedEBooksUpdateDeviceStatesRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.DeviceAppManagementManagedEBooksUpdateDeviceStatesExecute(r)
}

/*
DeviceAppManagementManagedEBooksUpdateDeviceStates Update the navigation property deviceStates in deviceAppManagement

The list of installation states for this eBook.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param managedEBookId key: id of managedEBook
 @param deviceInstallStateId key: id of deviceInstallState
 @return ApiDeviceAppManagementManagedEBooksUpdateDeviceStatesRequest
*/
func (a *DeviceAppManagementManagedEBookApiService) DeviceAppManagementManagedEBooksUpdateDeviceStates(ctx _context.Context, managedEBookId string, deviceInstallStateId string) ApiDeviceAppManagementManagedEBooksUpdateDeviceStatesRequest {
	return ApiDeviceAppManagementManagedEBooksUpdateDeviceStatesRequest{
		ApiService: a,
		ctx: ctx,
		managedEBookId: managedEBookId,
		deviceInstallStateId: deviceInstallStateId,
	}
}

// Execute executes the request
func (a *DeviceAppManagementManagedEBookApiService) DeviceAppManagementManagedEBooksUpdateDeviceStatesExecute(r ApiDeviceAppManagementManagedEBooksUpdateDeviceStatesRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPatch
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DeviceAppManagementManagedEBookApiService.DeviceAppManagementManagedEBooksUpdateDeviceStates")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/deviceAppManagement/managedEBooks/{managedEBook-id}/deviceStates/{deviceInstallState-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"managedEBook-id"+"}", _neturl.PathEscape(parameterToString(r.managedEBookId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"deviceInstallState-id"+"}", _neturl.PathEscape(parameterToString(r.deviceInstallStateId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphDeviceInstallState == nil {
		return nil, reportError("microsoftGraphDeviceInstallState is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphDeviceInstallState
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDeviceAppManagementManagedEBooksUpdateInstallSummaryRequest struct {
	ctx _context.Context
	ApiService *DeviceAppManagementManagedEBookApiService
	managedEBookId string
	microsoftGraphEBookInstallSummary *MicrosoftGraphEBookInstallSummary
}

// New navigation property values
func (r ApiDeviceAppManagementManagedEBooksUpdateInstallSummaryRequest) MicrosoftGraphEBookInstallSummary(microsoftGraphEBookInstallSummary MicrosoftGraphEBookInstallSummary) ApiDeviceAppManagementManagedEBooksUpdateInstallSummaryRequest {
	r.microsoftGraphEBookInstallSummary = &microsoftGraphEBookInstallSummary
	return r
}

func (r ApiDeviceAppManagementManagedEBooksUpdateInstallSummaryRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.DeviceAppManagementManagedEBooksUpdateInstallSummaryExecute(r)
}

/*
DeviceAppManagementManagedEBooksUpdateInstallSummary Update the navigation property installSummary in deviceAppManagement

Mobile App Install Summary.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param managedEBookId key: id of managedEBook
 @return ApiDeviceAppManagementManagedEBooksUpdateInstallSummaryRequest
*/
func (a *DeviceAppManagementManagedEBookApiService) DeviceAppManagementManagedEBooksUpdateInstallSummary(ctx _context.Context, managedEBookId string) ApiDeviceAppManagementManagedEBooksUpdateInstallSummaryRequest {
	return ApiDeviceAppManagementManagedEBooksUpdateInstallSummaryRequest{
		ApiService: a,
		ctx: ctx,
		managedEBookId: managedEBookId,
	}
}

// Execute executes the request
func (a *DeviceAppManagementManagedEBookApiService) DeviceAppManagementManagedEBooksUpdateInstallSummaryExecute(r ApiDeviceAppManagementManagedEBooksUpdateInstallSummaryRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPatch
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DeviceAppManagementManagedEBookApiService.DeviceAppManagementManagedEBooksUpdateInstallSummary")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/deviceAppManagement/managedEBooks/{managedEBook-id}/installSummary"
	localVarPath = strings.Replace(localVarPath, "{"+"managedEBook-id"+"}", _neturl.PathEscape(parameterToString(r.managedEBookId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphEBookInstallSummary == nil {
		return nil, reportError("microsoftGraphEBookInstallSummary is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphEBookInstallSummary
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDeviceAppManagementManagedEBooksUpdateUserStateSummaryRequest struct {
	ctx _context.Context
	ApiService *DeviceAppManagementManagedEBookApiService
	managedEBookId string
	userInstallStateSummaryId string
	microsoftGraphUserInstallStateSummary *MicrosoftGraphUserInstallStateSummary
}

// New navigation property values
func (r ApiDeviceAppManagementManagedEBooksUpdateUserStateSummaryRequest) MicrosoftGraphUserInstallStateSummary(microsoftGraphUserInstallStateSummary MicrosoftGraphUserInstallStateSummary) ApiDeviceAppManagementManagedEBooksUpdateUserStateSummaryRequest {
	r.microsoftGraphUserInstallStateSummary = &microsoftGraphUserInstallStateSummary
	return r
}

func (r ApiDeviceAppManagementManagedEBooksUpdateUserStateSummaryRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.DeviceAppManagementManagedEBooksUpdateUserStateSummaryExecute(r)
}

/*
DeviceAppManagementManagedEBooksUpdateUserStateSummary Update the navigation property userStateSummary in deviceAppManagement

The list of installation states for this eBook.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param managedEBookId key: id of managedEBook
 @param userInstallStateSummaryId key: id of userInstallStateSummary
 @return ApiDeviceAppManagementManagedEBooksUpdateUserStateSummaryRequest
*/
func (a *DeviceAppManagementManagedEBookApiService) DeviceAppManagementManagedEBooksUpdateUserStateSummary(ctx _context.Context, managedEBookId string, userInstallStateSummaryId string) ApiDeviceAppManagementManagedEBooksUpdateUserStateSummaryRequest {
	return ApiDeviceAppManagementManagedEBooksUpdateUserStateSummaryRequest{
		ApiService: a,
		ctx: ctx,
		managedEBookId: managedEBookId,
		userInstallStateSummaryId: userInstallStateSummaryId,
	}
}

// Execute executes the request
func (a *DeviceAppManagementManagedEBookApiService) DeviceAppManagementManagedEBooksUpdateUserStateSummaryExecute(r ApiDeviceAppManagementManagedEBooksUpdateUserStateSummaryRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPatch
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DeviceAppManagementManagedEBookApiService.DeviceAppManagementManagedEBooksUpdateUserStateSummary")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/deviceAppManagement/managedEBooks/{managedEBook-id}/userStateSummary/{userInstallStateSummary-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"managedEBook-id"+"}", _neturl.PathEscape(parameterToString(r.managedEBookId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"userInstallStateSummary-id"+"}", _neturl.PathEscape(parameterToString(r.userInstallStateSummaryId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphUserInstallStateSummary == nil {
		return nil, reportError("microsoftGraphUserInstallStateSummary is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphUserInstallStateSummary
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDeviceAppManagementManagedEBooksUserStateSummaryCreateDeviceStatesRequest struct {
	ctx _context.Context
	ApiService *DeviceAppManagementManagedEBookApiService
	managedEBookId string
	userInstallStateSummaryId string
	microsoftGraphDeviceInstallState *MicrosoftGraphDeviceInstallState
}

// New navigation property
func (r ApiDeviceAppManagementManagedEBooksUserStateSummaryCreateDeviceStatesRequest) MicrosoftGraphDeviceInstallState(microsoftGraphDeviceInstallState MicrosoftGraphDeviceInstallState) ApiDeviceAppManagementManagedEBooksUserStateSummaryCreateDeviceStatesRequest {
	r.microsoftGraphDeviceInstallState = &microsoftGraphDeviceInstallState
	return r
}

func (r ApiDeviceAppManagementManagedEBooksUserStateSummaryCreateDeviceStatesRequest) Execute() (MicrosoftGraphDeviceInstallState, *_nethttp.Response, error) {
	return r.ApiService.DeviceAppManagementManagedEBooksUserStateSummaryCreateDeviceStatesExecute(r)
}

/*
DeviceAppManagementManagedEBooksUserStateSummaryCreateDeviceStates Create new navigation property to deviceStates for deviceAppManagement

The install state of the eBook.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param managedEBookId key: id of managedEBook
 @param userInstallStateSummaryId key: id of userInstallStateSummary
 @return ApiDeviceAppManagementManagedEBooksUserStateSummaryCreateDeviceStatesRequest
*/
func (a *DeviceAppManagementManagedEBookApiService) DeviceAppManagementManagedEBooksUserStateSummaryCreateDeviceStates(ctx _context.Context, managedEBookId string, userInstallStateSummaryId string) ApiDeviceAppManagementManagedEBooksUserStateSummaryCreateDeviceStatesRequest {
	return ApiDeviceAppManagementManagedEBooksUserStateSummaryCreateDeviceStatesRequest{
		ApiService: a,
		ctx: ctx,
		managedEBookId: managedEBookId,
		userInstallStateSummaryId: userInstallStateSummaryId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphDeviceInstallState
func (a *DeviceAppManagementManagedEBookApiService) DeviceAppManagementManagedEBooksUserStateSummaryCreateDeviceStatesExecute(r ApiDeviceAppManagementManagedEBooksUserStateSummaryCreateDeviceStatesRequest) (MicrosoftGraphDeviceInstallState, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphDeviceInstallState
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DeviceAppManagementManagedEBookApiService.DeviceAppManagementManagedEBooksUserStateSummaryCreateDeviceStates")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/deviceAppManagement/managedEBooks/{managedEBook-id}/userStateSummary/{userInstallStateSummary-id}/deviceStates"
	localVarPath = strings.Replace(localVarPath, "{"+"managedEBook-id"+"}", _neturl.PathEscape(parameterToString(r.managedEBookId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"userInstallStateSummary-id"+"}", _neturl.PathEscape(parameterToString(r.userInstallStateSummaryId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphDeviceInstallState == nil {
		return localVarReturnValue, nil, reportError("microsoftGraphDeviceInstallState is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphDeviceInstallState
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeviceAppManagementManagedEBooksUserStateSummaryDeleteDeviceStatesRequest struct {
	ctx _context.Context
	ApiService *DeviceAppManagementManagedEBookApiService
	managedEBookId string
	userInstallStateSummaryId string
	deviceInstallStateId string
	ifMatch *string
}

// ETag
func (r ApiDeviceAppManagementManagedEBooksUserStateSummaryDeleteDeviceStatesRequest) IfMatch(ifMatch string) ApiDeviceAppManagementManagedEBooksUserStateSummaryDeleteDeviceStatesRequest {
	r.ifMatch = &ifMatch
	return r
}

func (r ApiDeviceAppManagementManagedEBooksUserStateSummaryDeleteDeviceStatesRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.DeviceAppManagementManagedEBooksUserStateSummaryDeleteDeviceStatesExecute(r)
}

/*
DeviceAppManagementManagedEBooksUserStateSummaryDeleteDeviceStates Delete navigation property deviceStates for deviceAppManagement

The install state of the eBook.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param managedEBookId key: id of managedEBook
 @param userInstallStateSummaryId key: id of userInstallStateSummary
 @param deviceInstallStateId key: id of deviceInstallState
 @return ApiDeviceAppManagementManagedEBooksUserStateSummaryDeleteDeviceStatesRequest
*/
func (a *DeviceAppManagementManagedEBookApiService) DeviceAppManagementManagedEBooksUserStateSummaryDeleteDeviceStates(ctx _context.Context, managedEBookId string, userInstallStateSummaryId string, deviceInstallStateId string) ApiDeviceAppManagementManagedEBooksUserStateSummaryDeleteDeviceStatesRequest {
	return ApiDeviceAppManagementManagedEBooksUserStateSummaryDeleteDeviceStatesRequest{
		ApiService: a,
		ctx: ctx,
		managedEBookId: managedEBookId,
		userInstallStateSummaryId: userInstallStateSummaryId,
		deviceInstallStateId: deviceInstallStateId,
	}
}

// Execute executes the request
func (a *DeviceAppManagementManagedEBookApiService) DeviceAppManagementManagedEBooksUserStateSummaryDeleteDeviceStatesExecute(r ApiDeviceAppManagementManagedEBooksUserStateSummaryDeleteDeviceStatesRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DeviceAppManagementManagedEBookApiService.DeviceAppManagementManagedEBooksUserStateSummaryDeleteDeviceStates")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/deviceAppManagement/managedEBooks/{managedEBook-id}/userStateSummary/{userInstallStateSummary-id}/deviceStates/{deviceInstallState-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"managedEBook-id"+"}", _neturl.PathEscape(parameterToString(r.managedEBookId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"userInstallStateSummary-id"+"}", _neturl.PathEscape(parameterToString(r.userInstallStateSummaryId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"deviceInstallState-id"+"}", _neturl.PathEscape(parameterToString(r.deviceInstallStateId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ifMatch != nil {
		localVarHeaderParams["If-Match"] = parameterToString(*r.ifMatch, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDeviceAppManagementManagedEBooksUserStateSummaryGetDeviceStatesRequest struct {
	ctx _context.Context
	ApiService *DeviceAppManagementManagedEBookApiService
	managedEBookId string
	userInstallStateSummaryId string
	deviceInstallStateId string
	select_ *[]string
	expand *[]string
}

// Select properties to be returned
func (r ApiDeviceAppManagementManagedEBooksUserStateSummaryGetDeviceStatesRequest) Select_(select_ []string) ApiDeviceAppManagementManagedEBooksUserStateSummaryGetDeviceStatesRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiDeviceAppManagementManagedEBooksUserStateSummaryGetDeviceStatesRequest) Expand(expand []string) ApiDeviceAppManagementManagedEBooksUserStateSummaryGetDeviceStatesRequest {
	r.expand = &expand
	return r
}

func (r ApiDeviceAppManagementManagedEBooksUserStateSummaryGetDeviceStatesRequest) Execute() (MicrosoftGraphDeviceInstallState, *_nethttp.Response, error) {
	return r.ApiService.DeviceAppManagementManagedEBooksUserStateSummaryGetDeviceStatesExecute(r)
}

/*
DeviceAppManagementManagedEBooksUserStateSummaryGetDeviceStates Get deviceStates from deviceAppManagement

The install state of the eBook.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param managedEBookId key: id of managedEBook
 @param userInstallStateSummaryId key: id of userInstallStateSummary
 @param deviceInstallStateId key: id of deviceInstallState
 @return ApiDeviceAppManagementManagedEBooksUserStateSummaryGetDeviceStatesRequest
*/
func (a *DeviceAppManagementManagedEBookApiService) DeviceAppManagementManagedEBooksUserStateSummaryGetDeviceStates(ctx _context.Context, managedEBookId string, userInstallStateSummaryId string, deviceInstallStateId string) ApiDeviceAppManagementManagedEBooksUserStateSummaryGetDeviceStatesRequest {
	return ApiDeviceAppManagementManagedEBooksUserStateSummaryGetDeviceStatesRequest{
		ApiService: a,
		ctx: ctx,
		managedEBookId: managedEBookId,
		userInstallStateSummaryId: userInstallStateSummaryId,
		deviceInstallStateId: deviceInstallStateId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphDeviceInstallState
func (a *DeviceAppManagementManagedEBookApiService) DeviceAppManagementManagedEBooksUserStateSummaryGetDeviceStatesExecute(r ApiDeviceAppManagementManagedEBooksUserStateSummaryGetDeviceStatesRequest) (MicrosoftGraphDeviceInstallState, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphDeviceInstallState
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DeviceAppManagementManagedEBookApiService.DeviceAppManagementManagedEBooksUserStateSummaryGetDeviceStates")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/deviceAppManagement/managedEBooks/{managedEBook-id}/userStateSummary/{userInstallStateSummary-id}/deviceStates/{deviceInstallState-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"managedEBook-id"+"}", _neturl.PathEscape(parameterToString(r.managedEBookId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"userInstallStateSummary-id"+"}", _neturl.PathEscape(parameterToString(r.userInstallStateSummaryId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"deviceInstallState-id"+"}", _neturl.PathEscape(parameterToString(r.deviceInstallStateId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeviceAppManagementManagedEBooksUserStateSummaryListDeviceStatesRequest struct {
	ctx _context.Context
	ApiService *DeviceAppManagementManagedEBookApiService
	managedEBookId string
	userInstallStateSummaryId string
	top *int32
	skip *int32
	search *string
	filter *string
	count *bool
	orderby *[]string
	select_ *[]string
	expand *[]string
}

// Show only the first n items
func (r ApiDeviceAppManagementManagedEBooksUserStateSummaryListDeviceStatesRequest) Top(top int32) ApiDeviceAppManagementManagedEBooksUserStateSummaryListDeviceStatesRequest {
	r.top = &top
	return r
}
// Skip the first n items
func (r ApiDeviceAppManagementManagedEBooksUserStateSummaryListDeviceStatesRequest) Skip(skip int32) ApiDeviceAppManagementManagedEBooksUserStateSummaryListDeviceStatesRequest {
	r.skip = &skip
	return r
}
// Search items by search phrases
func (r ApiDeviceAppManagementManagedEBooksUserStateSummaryListDeviceStatesRequest) Search(search string) ApiDeviceAppManagementManagedEBooksUserStateSummaryListDeviceStatesRequest {
	r.search = &search
	return r
}
// Filter items by property values
func (r ApiDeviceAppManagementManagedEBooksUserStateSummaryListDeviceStatesRequest) Filter(filter string) ApiDeviceAppManagementManagedEBooksUserStateSummaryListDeviceStatesRequest {
	r.filter = &filter
	return r
}
// Include count of items
func (r ApiDeviceAppManagementManagedEBooksUserStateSummaryListDeviceStatesRequest) Count(count bool) ApiDeviceAppManagementManagedEBooksUserStateSummaryListDeviceStatesRequest {
	r.count = &count
	return r
}
// Order items by property values
func (r ApiDeviceAppManagementManagedEBooksUserStateSummaryListDeviceStatesRequest) Orderby(orderby []string) ApiDeviceAppManagementManagedEBooksUserStateSummaryListDeviceStatesRequest {
	r.orderby = &orderby
	return r
}
// Select properties to be returned
func (r ApiDeviceAppManagementManagedEBooksUserStateSummaryListDeviceStatesRequest) Select_(select_ []string) ApiDeviceAppManagementManagedEBooksUserStateSummaryListDeviceStatesRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiDeviceAppManagementManagedEBooksUserStateSummaryListDeviceStatesRequest) Expand(expand []string) ApiDeviceAppManagementManagedEBooksUserStateSummaryListDeviceStatesRequest {
	r.expand = &expand
	return r
}

func (r ApiDeviceAppManagementManagedEBooksUserStateSummaryListDeviceStatesRequest) Execute() (CollectionOfDeviceInstallState, *_nethttp.Response, error) {
	return r.ApiService.DeviceAppManagementManagedEBooksUserStateSummaryListDeviceStatesExecute(r)
}

/*
DeviceAppManagementManagedEBooksUserStateSummaryListDeviceStates Get deviceStates from deviceAppManagement

The install state of the eBook.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param managedEBookId key: id of managedEBook
 @param userInstallStateSummaryId key: id of userInstallStateSummary
 @return ApiDeviceAppManagementManagedEBooksUserStateSummaryListDeviceStatesRequest
*/
func (a *DeviceAppManagementManagedEBookApiService) DeviceAppManagementManagedEBooksUserStateSummaryListDeviceStates(ctx _context.Context, managedEBookId string, userInstallStateSummaryId string) ApiDeviceAppManagementManagedEBooksUserStateSummaryListDeviceStatesRequest {
	return ApiDeviceAppManagementManagedEBooksUserStateSummaryListDeviceStatesRequest{
		ApiService: a,
		ctx: ctx,
		managedEBookId: managedEBookId,
		userInstallStateSummaryId: userInstallStateSummaryId,
	}
}

// Execute executes the request
//  @return CollectionOfDeviceInstallState
func (a *DeviceAppManagementManagedEBookApiService) DeviceAppManagementManagedEBooksUserStateSummaryListDeviceStatesExecute(r ApiDeviceAppManagementManagedEBooksUserStateSummaryListDeviceStatesRequest) (CollectionOfDeviceInstallState, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  CollectionOfDeviceInstallState
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DeviceAppManagementManagedEBookApiService.DeviceAppManagementManagedEBooksUserStateSummaryListDeviceStates")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/deviceAppManagement/managedEBooks/{managedEBook-id}/userStateSummary/{userInstallStateSummary-id}/deviceStates"
	localVarPath = strings.Replace(localVarPath, "{"+"managedEBook-id"+"}", _neturl.PathEscape(parameterToString(r.managedEBookId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"userInstallStateSummary-id"+"}", _neturl.PathEscape(parameterToString(r.userInstallStateSummaryId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.top != nil {
		localVarQueryParams.Add("$top", parameterToString(*r.top, ""))
	}
	if r.skip != nil {
		localVarQueryParams.Add("$skip", parameterToString(*r.skip, ""))
	}
	if r.search != nil {
		localVarQueryParams.Add("$search", parameterToString(*r.search, ""))
	}
	if r.filter != nil {
		localVarQueryParams.Add("$filter", parameterToString(*r.filter, ""))
	}
	if r.count != nil {
		localVarQueryParams.Add("$count", parameterToString(*r.count, ""))
	}
	if r.orderby != nil {
		localVarQueryParams.Add("$orderby", parameterToString(*r.orderby, "csv"))
	}
	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeviceAppManagementManagedEBooksUserStateSummaryUpdateDeviceStatesRequest struct {
	ctx _context.Context
	ApiService *DeviceAppManagementManagedEBookApiService
	managedEBookId string
	userInstallStateSummaryId string
	deviceInstallStateId string
	microsoftGraphDeviceInstallState *MicrosoftGraphDeviceInstallState
}

// New navigation property values
func (r ApiDeviceAppManagementManagedEBooksUserStateSummaryUpdateDeviceStatesRequest) MicrosoftGraphDeviceInstallState(microsoftGraphDeviceInstallState MicrosoftGraphDeviceInstallState) ApiDeviceAppManagementManagedEBooksUserStateSummaryUpdateDeviceStatesRequest {
	r.microsoftGraphDeviceInstallState = &microsoftGraphDeviceInstallState
	return r
}

func (r ApiDeviceAppManagementManagedEBooksUserStateSummaryUpdateDeviceStatesRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.DeviceAppManagementManagedEBooksUserStateSummaryUpdateDeviceStatesExecute(r)
}

/*
DeviceAppManagementManagedEBooksUserStateSummaryUpdateDeviceStates Update the navigation property deviceStates in deviceAppManagement

The install state of the eBook.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param managedEBookId key: id of managedEBook
 @param userInstallStateSummaryId key: id of userInstallStateSummary
 @param deviceInstallStateId key: id of deviceInstallState
 @return ApiDeviceAppManagementManagedEBooksUserStateSummaryUpdateDeviceStatesRequest
*/
func (a *DeviceAppManagementManagedEBookApiService) DeviceAppManagementManagedEBooksUserStateSummaryUpdateDeviceStates(ctx _context.Context, managedEBookId string, userInstallStateSummaryId string, deviceInstallStateId string) ApiDeviceAppManagementManagedEBooksUserStateSummaryUpdateDeviceStatesRequest {
	return ApiDeviceAppManagementManagedEBooksUserStateSummaryUpdateDeviceStatesRequest{
		ApiService: a,
		ctx: ctx,
		managedEBookId: managedEBookId,
		userInstallStateSummaryId: userInstallStateSummaryId,
		deviceInstallStateId: deviceInstallStateId,
	}
}

// Execute executes the request
func (a *DeviceAppManagementManagedEBookApiService) DeviceAppManagementManagedEBooksUserStateSummaryUpdateDeviceStatesExecute(r ApiDeviceAppManagementManagedEBooksUserStateSummaryUpdateDeviceStatesRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPatch
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DeviceAppManagementManagedEBookApiService.DeviceAppManagementManagedEBooksUserStateSummaryUpdateDeviceStates")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/deviceAppManagement/managedEBooks/{managedEBook-id}/userStateSummary/{userInstallStateSummary-id}/deviceStates/{deviceInstallState-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"managedEBook-id"+"}", _neturl.PathEscape(parameterToString(r.managedEBookId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"userInstallStateSummary-id"+"}", _neturl.PathEscape(parameterToString(r.userInstallStateSummaryId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"deviceInstallState-id"+"}", _neturl.PathEscape(parameterToString(r.deviceInstallStateId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphDeviceInstallState == nil {
		return nil, reportError("microsoftGraphDeviceInstallState is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphDeviceInstallState
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDeviceAppManagementUpdateManagedEBooksRequest struct {
	ctx _context.Context
	ApiService *DeviceAppManagementManagedEBookApiService
	managedEBookId string
	microsoftGraphManagedEBook *MicrosoftGraphManagedEBook
}

// New navigation property values
func (r ApiDeviceAppManagementUpdateManagedEBooksRequest) MicrosoftGraphManagedEBook(microsoftGraphManagedEBook MicrosoftGraphManagedEBook) ApiDeviceAppManagementUpdateManagedEBooksRequest {
	r.microsoftGraphManagedEBook = &microsoftGraphManagedEBook
	return r
}

func (r ApiDeviceAppManagementUpdateManagedEBooksRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.DeviceAppManagementUpdateManagedEBooksExecute(r)
}

/*
DeviceAppManagementUpdateManagedEBooks Update the navigation property managedEBooks in deviceAppManagement

The Managed eBook.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param managedEBookId key: id of managedEBook
 @return ApiDeviceAppManagementUpdateManagedEBooksRequest
*/
func (a *DeviceAppManagementManagedEBookApiService) DeviceAppManagementUpdateManagedEBooks(ctx _context.Context, managedEBookId string) ApiDeviceAppManagementUpdateManagedEBooksRequest {
	return ApiDeviceAppManagementUpdateManagedEBooksRequest{
		ApiService: a,
		ctx: ctx,
		managedEBookId: managedEBookId,
	}
}

// Execute executes the request
func (a *DeviceAppManagementManagedEBookApiService) DeviceAppManagementUpdateManagedEBooksExecute(r ApiDeviceAppManagementUpdateManagedEBooksRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPatch
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DeviceAppManagementManagedEBookApiService.DeviceAppManagementUpdateManagedEBooks")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/deviceAppManagement/managedEBooks/{managedEBook-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"managedEBook-id"+"}", _neturl.PathEscape(parameterToString(r.managedEBookId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphManagedEBook == nil {
		return nil, reportError("microsoftGraphManagedEBook is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphManagedEBook
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}
