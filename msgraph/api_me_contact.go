/*
Partial Graph API

No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

API version: v1.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package openapi

import (
	"bytes"
	_context "context"
	_ioutil "io/ioutil"
	_nethttp "net/http"
	_neturl "net/url"
	"strings"
	"os"
)

// Linger please
var (
	_ _context.Context
)

// MeContactApiService MeContactApi service
type MeContactApiService service

type ApiMeContactsCreateExtensionsRequest struct {
	ctx _context.Context
	ApiService *MeContactApiService
	contactId string
	microsoftGraphExtension *MicrosoftGraphExtension
}

// New navigation property
func (r ApiMeContactsCreateExtensionsRequest) MicrosoftGraphExtension(microsoftGraphExtension MicrosoftGraphExtension) ApiMeContactsCreateExtensionsRequest {
	r.microsoftGraphExtension = &microsoftGraphExtension
	return r
}

func (r ApiMeContactsCreateExtensionsRequest) Execute() (MicrosoftGraphExtension, *_nethttp.Response, error) {
	return r.ApiService.MeContactsCreateExtensionsExecute(r)
}

/*
MeContactsCreateExtensions Create new navigation property to extensions for me

The collection of open extensions defined for the contact. Read-only. Nullable.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param contactId key: id of contact
 @return ApiMeContactsCreateExtensionsRequest
*/
func (a *MeContactApiService) MeContactsCreateExtensions(ctx _context.Context, contactId string) ApiMeContactsCreateExtensionsRequest {
	return ApiMeContactsCreateExtensionsRequest{
		ApiService: a,
		ctx: ctx,
		contactId: contactId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphExtension
func (a *MeContactApiService) MeContactsCreateExtensionsExecute(r ApiMeContactsCreateExtensionsRequest) (MicrosoftGraphExtension, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphExtension
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MeContactApiService.MeContactsCreateExtensions")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/contacts/{contact-id}/extensions"
	localVarPath = strings.Replace(localVarPath, "{"+"contact-id"+"}", _neturl.PathEscape(parameterToString(r.contactId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphExtension == nil {
		return localVarReturnValue, nil, reportError("microsoftGraphExtension is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphExtension
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMeContactsCreateMultiValueExtendedPropertiesRequest struct {
	ctx _context.Context
	ApiService *MeContactApiService
	contactId string
	microsoftGraphMultiValueLegacyExtendedProperty *MicrosoftGraphMultiValueLegacyExtendedProperty
}

// New navigation property
func (r ApiMeContactsCreateMultiValueExtendedPropertiesRequest) MicrosoftGraphMultiValueLegacyExtendedProperty(microsoftGraphMultiValueLegacyExtendedProperty MicrosoftGraphMultiValueLegacyExtendedProperty) ApiMeContactsCreateMultiValueExtendedPropertiesRequest {
	r.microsoftGraphMultiValueLegacyExtendedProperty = &microsoftGraphMultiValueLegacyExtendedProperty
	return r
}

func (r ApiMeContactsCreateMultiValueExtendedPropertiesRequest) Execute() (MicrosoftGraphMultiValueLegacyExtendedProperty, *_nethttp.Response, error) {
	return r.ApiService.MeContactsCreateMultiValueExtendedPropertiesExecute(r)
}

/*
MeContactsCreateMultiValueExtendedProperties Create new navigation property to multiValueExtendedProperties for me

The collection of multi-value extended properties defined for the contact. Read-only. Nullable.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param contactId key: id of contact
 @return ApiMeContactsCreateMultiValueExtendedPropertiesRequest
*/
func (a *MeContactApiService) MeContactsCreateMultiValueExtendedProperties(ctx _context.Context, contactId string) ApiMeContactsCreateMultiValueExtendedPropertiesRequest {
	return ApiMeContactsCreateMultiValueExtendedPropertiesRequest{
		ApiService: a,
		ctx: ctx,
		contactId: contactId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphMultiValueLegacyExtendedProperty
func (a *MeContactApiService) MeContactsCreateMultiValueExtendedPropertiesExecute(r ApiMeContactsCreateMultiValueExtendedPropertiesRequest) (MicrosoftGraphMultiValueLegacyExtendedProperty, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphMultiValueLegacyExtendedProperty
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MeContactApiService.MeContactsCreateMultiValueExtendedProperties")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/contacts/{contact-id}/multiValueExtendedProperties"
	localVarPath = strings.Replace(localVarPath, "{"+"contact-id"+"}", _neturl.PathEscape(parameterToString(r.contactId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphMultiValueLegacyExtendedProperty == nil {
		return localVarReturnValue, nil, reportError("microsoftGraphMultiValueLegacyExtendedProperty is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphMultiValueLegacyExtendedProperty
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMeContactsCreateSingleValueExtendedPropertiesRequest struct {
	ctx _context.Context
	ApiService *MeContactApiService
	contactId string
	microsoftGraphSingleValueLegacyExtendedProperty *MicrosoftGraphSingleValueLegacyExtendedProperty
}

// New navigation property
func (r ApiMeContactsCreateSingleValueExtendedPropertiesRequest) MicrosoftGraphSingleValueLegacyExtendedProperty(microsoftGraphSingleValueLegacyExtendedProperty MicrosoftGraphSingleValueLegacyExtendedProperty) ApiMeContactsCreateSingleValueExtendedPropertiesRequest {
	r.microsoftGraphSingleValueLegacyExtendedProperty = &microsoftGraphSingleValueLegacyExtendedProperty
	return r
}

func (r ApiMeContactsCreateSingleValueExtendedPropertiesRequest) Execute() (MicrosoftGraphSingleValueLegacyExtendedProperty, *_nethttp.Response, error) {
	return r.ApiService.MeContactsCreateSingleValueExtendedPropertiesExecute(r)
}

/*
MeContactsCreateSingleValueExtendedProperties Create new navigation property to singleValueExtendedProperties for me

The collection of single-value extended properties defined for the contact. Read-only. Nullable.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param contactId key: id of contact
 @return ApiMeContactsCreateSingleValueExtendedPropertiesRequest
*/
func (a *MeContactApiService) MeContactsCreateSingleValueExtendedProperties(ctx _context.Context, contactId string) ApiMeContactsCreateSingleValueExtendedPropertiesRequest {
	return ApiMeContactsCreateSingleValueExtendedPropertiesRequest{
		ApiService: a,
		ctx: ctx,
		contactId: contactId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphSingleValueLegacyExtendedProperty
func (a *MeContactApiService) MeContactsCreateSingleValueExtendedPropertiesExecute(r ApiMeContactsCreateSingleValueExtendedPropertiesRequest) (MicrosoftGraphSingleValueLegacyExtendedProperty, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphSingleValueLegacyExtendedProperty
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MeContactApiService.MeContactsCreateSingleValueExtendedProperties")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/contacts/{contact-id}/singleValueExtendedProperties"
	localVarPath = strings.Replace(localVarPath, "{"+"contact-id"+"}", _neturl.PathEscape(parameterToString(r.contactId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphSingleValueLegacyExtendedProperty == nil {
		return localVarReturnValue, nil, reportError("microsoftGraphSingleValueLegacyExtendedProperty is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphSingleValueLegacyExtendedProperty
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMeContactsDeleteExtensionsRequest struct {
	ctx _context.Context
	ApiService *MeContactApiService
	contactId string
	extensionId string
	ifMatch *string
}

// ETag
func (r ApiMeContactsDeleteExtensionsRequest) IfMatch(ifMatch string) ApiMeContactsDeleteExtensionsRequest {
	r.ifMatch = &ifMatch
	return r
}

func (r ApiMeContactsDeleteExtensionsRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.MeContactsDeleteExtensionsExecute(r)
}

/*
MeContactsDeleteExtensions Delete navigation property extensions for me

The collection of open extensions defined for the contact. Read-only. Nullable.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param contactId key: id of contact
 @param extensionId key: id of extension
 @return ApiMeContactsDeleteExtensionsRequest
*/
func (a *MeContactApiService) MeContactsDeleteExtensions(ctx _context.Context, contactId string, extensionId string) ApiMeContactsDeleteExtensionsRequest {
	return ApiMeContactsDeleteExtensionsRequest{
		ApiService: a,
		ctx: ctx,
		contactId: contactId,
		extensionId: extensionId,
	}
}

// Execute executes the request
func (a *MeContactApiService) MeContactsDeleteExtensionsExecute(r ApiMeContactsDeleteExtensionsRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MeContactApiService.MeContactsDeleteExtensions")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/contacts/{contact-id}/extensions/{extension-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"contact-id"+"}", _neturl.PathEscape(parameterToString(r.contactId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"extension-id"+"}", _neturl.PathEscape(parameterToString(r.extensionId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ifMatch != nil {
		localVarHeaderParams["If-Match"] = parameterToString(*r.ifMatch, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiMeContactsDeleteMultiValueExtendedPropertiesRequest struct {
	ctx _context.Context
	ApiService *MeContactApiService
	contactId string
	multiValueLegacyExtendedPropertyId string
	ifMatch *string
}

// ETag
func (r ApiMeContactsDeleteMultiValueExtendedPropertiesRequest) IfMatch(ifMatch string) ApiMeContactsDeleteMultiValueExtendedPropertiesRequest {
	r.ifMatch = &ifMatch
	return r
}

func (r ApiMeContactsDeleteMultiValueExtendedPropertiesRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.MeContactsDeleteMultiValueExtendedPropertiesExecute(r)
}

/*
MeContactsDeleteMultiValueExtendedProperties Delete navigation property multiValueExtendedProperties for me

The collection of multi-value extended properties defined for the contact. Read-only. Nullable.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param contactId key: id of contact
 @param multiValueLegacyExtendedPropertyId key: id of multiValueLegacyExtendedProperty
 @return ApiMeContactsDeleteMultiValueExtendedPropertiesRequest
*/
func (a *MeContactApiService) MeContactsDeleteMultiValueExtendedProperties(ctx _context.Context, contactId string, multiValueLegacyExtendedPropertyId string) ApiMeContactsDeleteMultiValueExtendedPropertiesRequest {
	return ApiMeContactsDeleteMultiValueExtendedPropertiesRequest{
		ApiService: a,
		ctx: ctx,
		contactId: contactId,
		multiValueLegacyExtendedPropertyId: multiValueLegacyExtendedPropertyId,
	}
}

// Execute executes the request
func (a *MeContactApiService) MeContactsDeleteMultiValueExtendedPropertiesExecute(r ApiMeContactsDeleteMultiValueExtendedPropertiesRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MeContactApiService.MeContactsDeleteMultiValueExtendedProperties")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/contacts/{contact-id}/multiValueExtendedProperties/{multiValueLegacyExtendedProperty-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"contact-id"+"}", _neturl.PathEscape(parameterToString(r.contactId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"multiValueLegacyExtendedProperty-id"+"}", _neturl.PathEscape(parameterToString(r.multiValueLegacyExtendedPropertyId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ifMatch != nil {
		localVarHeaderParams["If-Match"] = parameterToString(*r.ifMatch, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiMeContactsDeletePhotoRequest struct {
	ctx _context.Context
	ApiService *MeContactApiService
	contactId string
	ifMatch *string
}

// ETag
func (r ApiMeContactsDeletePhotoRequest) IfMatch(ifMatch string) ApiMeContactsDeletePhotoRequest {
	r.ifMatch = &ifMatch
	return r
}

func (r ApiMeContactsDeletePhotoRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.MeContactsDeletePhotoExecute(r)
}

/*
MeContactsDeletePhoto Delete navigation property photo for me

Optional contact picture. You can get or set a photo for a contact.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param contactId key: id of contact
 @return ApiMeContactsDeletePhotoRequest
*/
func (a *MeContactApiService) MeContactsDeletePhoto(ctx _context.Context, contactId string) ApiMeContactsDeletePhotoRequest {
	return ApiMeContactsDeletePhotoRequest{
		ApiService: a,
		ctx: ctx,
		contactId: contactId,
	}
}

// Execute executes the request
func (a *MeContactApiService) MeContactsDeletePhotoExecute(r ApiMeContactsDeletePhotoRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MeContactApiService.MeContactsDeletePhoto")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/contacts/{contact-id}/photo"
	localVarPath = strings.Replace(localVarPath, "{"+"contact-id"+"}", _neturl.PathEscape(parameterToString(r.contactId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ifMatch != nil {
		localVarHeaderParams["If-Match"] = parameterToString(*r.ifMatch, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiMeContactsDeleteSingleValueExtendedPropertiesRequest struct {
	ctx _context.Context
	ApiService *MeContactApiService
	contactId string
	singleValueLegacyExtendedPropertyId string
	ifMatch *string
}

// ETag
func (r ApiMeContactsDeleteSingleValueExtendedPropertiesRequest) IfMatch(ifMatch string) ApiMeContactsDeleteSingleValueExtendedPropertiesRequest {
	r.ifMatch = &ifMatch
	return r
}

func (r ApiMeContactsDeleteSingleValueExtendedPropertiesRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.MeContactsDeleteSingleValueExtendedPropertiesExecute(r)
}

/*
MeContactsDeleteSingleValueExtendedProperties Delete navigation property singleValueExtendedProperties for me

The collection of single-value extended properties defined for the contact. Read-only. Nullable.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param contactId key: id of contact
 @param singleValueLegacyExtendedPropertyId key: id of singleValueLegacyExtendedProperty
 @return ApiMeContactsDeleteSingleValueExtendedPropertiesRequest
*/
func (a *MeContactApiService) MeContactsDeleteSingleValueExtendedProperties(ctx _context.Context, contactId string, singleValueLegacyExtendedPropertyId string) ApiMeContactsDeleteSingleValueExtendedPropertiesRequest {
	return ApiMeContactsDeleteSingleValueExtendedPropertiesRequest{
		ApiService: a,
		ctx: ctx,
		contactId: contactId,
		singleValueLegacyExtendedPropertyId: singleValueLegacyExtendedPropertyId,
	}
}

// Execute executes the request
func (a *MeContactApiService) MeContactsDeleteSingleValueExtendedPropertiesExecute(r ApiMeContactsDeleteSingleValueExtendedPropertiesRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MeContactApiService.MeContactsDeleteSingleValueExtendedProperties")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/contacts/{contact-id}/singleValueExtendedProperties/{singleValueLegacyExtendedProperty-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"contact-id"+"}", _neturl.PathEscape(parameterToString(r.contactId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"singleValueLegacyExtendedProperty-id"+"}", _neturl.PathEscape(parameterToString(r.singleValueLegacyExtendedPropertyId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ifMatch != nil {
		localVarHeaderParams["If-Match"] = parameterToString(*r.ifMatch, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiMeContactsGetExtensionsRequest struct {
	ctx _context.Context
	ApiService *MeContactApiService
	contactId string
	extensionId string
	select_ *[]string
	expand *[]string
}

// Select properties to be returned
func (r ApiMeContactsGetExtensionsRequest) Select_(select_ []string) ApiMeContactsGetExtensionsRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiMeContactsGetExtensionsRequest) Expand(expand []string) ApiMeContactsGetExtensionsRequest {
	r.expand = &expand
	return r
}

func (r ApiMeContactsGetExtensionsRequest) Execute() (MicrosoftGraphExtension, *_nethttp.Response, error) {
	return r.ApiService.MeContactsGetExtensionsExecute(r)
}

/*
MeContactsGetExtensions Get extensions from me

The collection of open extensions defined for the contact. Read-only. Nullable.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param contactId key: id of contact
 @param extensionId key: id of extension
 @return ApiMeContactsGetExtensionsRequest
*/
func (a *MeContactApiService) MeContactsGetExtensions(ctx _context.Context, contactId string, extensionId string) ApiMeContactsGetExtensionsRequest {
	return ApiMeContactsGetExtensionsRequest{
		ApiService: a,
		ctx: ctx,
		contactId: contactId,
		extensionId: extensionId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphExtension
func (a *MeContactApiService) MeContactsGetExtensionsExecute(r ApiMeContactsGetExtensionsRequest) (MicrosoftGraphExtension, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphExtension
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MeContactApiService.MeContactsGetExtensions")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/contacts/{contact-id}/extensions/{extension-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"contact-id"+"}", _neturl.PathEscape(parameterToString(r.contactId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"extension-id"+"}", _neturl.PathEscape(parameterToString(r.extensionId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMeContactsGetMultiValueExtendedPropertiesRequest struct {
	ctx _context.Context
	ApiService *MeContactApiService
	contactId string
	multiValueLegacyExtendedPropertyId string
	select_ *[]string
	expand *[]string
}

// Select properties to be returned
func (r ApiMeContactsGetMultiValueExtendedPropertiesRequest) Select_(select_ []string) ApiMeContactsGetMultiValueExtendedPropertiesRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiMeContactsGetMultiValueExtendedPropertiesRequest) Expand(expand []string) ApiMeContactsGetMultiValueExtendedPropertiesRequest {
	r.expand = &expand
	return r
}

func (r ApiMeContactsGetMultiValueExtendedPropertiesRequest) Execute() (MicrosoftGraphMultiValueLegacyExtendedProperty, *_nethttp.Response, error) {
	return r.ApiService.MeContactsGetMultiValueExtendedPropertiesExecute(r)
}

/*
MeContactsGetMultiValueExtendedProperties Get multiValueExtendedProperties from me

The collection of multi-value extended properties defined for the contact. Read-only. Nullable.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param contactId key: id of contact
 @param multiValueLegacyExtendedPropertyId key: id of multiValueLegacyExtendedProperty
 @return ApiMeContactsGetMultiValueExtendedPropertiesRequest
*/
func (a *MeContactApiService) MeContactsGetMultiValueExtendedProperties(ctx _context.Context, contactId string, multiValueLegacyExtendedPropertyId string) ApiMeContactsGetMultiValueExtendedPropertiesRequest {
	return ApiMeContactsGetMultiValueExtendedPropertiesRequest{
		ApiService: a,
		ctx: ctx,
		contactId: contactId,
		multiValueLegacyExtendedPropertyId: multiValueLegacyExtendedPropertyId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphMultiValueLegacyExtendedProperty
func (a *MeContactApiService) MeContactsGetMultiValueExtendedPropertiesExecute(r ApiMeContactsGetMultiValueExtendedPropertiesRequest) (MicrosoftGraphMultiValueLegacyExtendedProperty, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphMultiValueLegacyExtendedProperty
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MeContactApiService.MeContactsGetMultiValueExtendedProperties")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/contacts/{contact-id}/multiValueExtendedProperties/{multiValueLegacyExtendedProperty-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"contact-id"+"}", _neturl.PathEscape(parameterToString(r.contactId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"multiValueLegacyExtendedProperty-id"+"}", _neturl.PathEscape(parameterToString(r.multiValueLegacyExtendedPropertyId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMeContactsGetPhotoRequest struct {
	ctx _context.Context
	ApiService *MeContactApiService
	contactId string
	select_ *[]string
}

// Select properties to be returned
func (r ApiMeContactsGetPhotoRequest) Select_(select_ []string) ApiMeContactsGetPhotoRequest {
	r.select_ = &select_
	return r
}

func (r ApiMeContactsGetPhotoRequest) Execute() (MicrosoftGraphProfilePhoto, *_nethttp.Response, error) {
	return r.ApiService.MeContactsGetPhotoExecute(r)
}

/*
MeContactsGetPhoto Get photo from me

Optional contact picture. You can get or set a photo for a contact.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param contactId key: id of contact
 @return ApiMeContactsGetPhotoRequest
*/
func (a *MeContactApiService) MeContactsGetPhoto(ctx _context.Context, contactId string) ApiMeContactsGetPhotoRequest {
	return ApiMeContactsGetPhotoRequest{
		ApiService: a,
		ctx: ctx,
		contactId: contactId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphProfilePhoto
func (a *MeContactApiService) MeContactsGetPhotoExecute(r ApiMeContactsGetPhotoRequest) (MicrosoftGraphProfilePhoto, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphProfilePhoto
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MeContactApiService.MeContactsGetPhoto")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/contacts/{contact-id}/photo"
	localVarPath = strings.Replace(localVarPath, "{"+"contact-id"+"}", _neturl.PathEscape(parameterToString(r.contactId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMeContactsGetPhotoContentRequest struct {
	ctx _context.Context
	ApiService *MeContactApiService
	contactId string
}


func (r ApiMeContactsGetPhotoContentRequest) Execute() (*os.File, *_nethttp.Response, error) {
	return r.ApiService.MeContactsGetPhotoContentExecute(r)
}

/*
MeContactsGetPhotoContent Get media content for the navigation property photo from me

The user's profile photo. Read-only.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param contactId key: id of contact
 @return ApiMeContactsGetPhotoContentRequest
*/
func (a *MeContactApiService) MeContactsGetPhotoContent(ctx _context.Context, contactId string) ApiMeContactsGetPhotoContentRequest {
	return ApiMeContactsGetPhotoContentRequest{
		ApiService: a,
		ctx: ctx,
		contactId: contactId,
	}
}

// Execute executes the request
//  @return *os.File
func (a *MeContactApiService) MeContactsGetPhotoContentExecute(r ApiMeContactsGetPhotoContentRequest) (*os.File, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  *os.File
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MeContactApiService.MeContactsGetPhotoContent")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/contacts/{contact-id}/photo/$value"
	localVarPath = strings.Replace(localVarPath, "{"+"contact-id"+"}", _neturl.PathEscape(parameterToString(r.contactId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/octet-stream", "application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMeContactsGetSingleValueExtendedPropertiesRequest struct {
	ctx _context.Context
	ApiService *MeContactApiService
	contactId string
	singleValueLegacyExtendedPropertyId string
	select_ *[]string
	expand *[]string
}

// Select properties to be returned
func (r ApiMeContactsGetSingleValueExtendedPropertiesRequest) Select_(select_ []string) ApiMeContactsGetSingleValueExtendedPropertiesRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiMeContactsGetSingleValueExtendedPropertiesRequest) Expand(expand []string) ApiMeContactsGetSingleValueExtendedPropertiesRequest {
	r.expand = &expand
	return r
}

func (r ApiMeContactsGetSingleValueExtendedPropertiesRequest) Execute() (MicrosoftGraphSingleValueLegacyExtendedProperty, *_nethttp.Response, error) {
	return r.ApiService.MeContactsGetSingleValueExtendedPropertiesExecute(r)
}

/*
MeContactsGetSingleValueExtendedProperties Get singleValueExtendedProperties from me

The collection of single-value extended properties defined for the contact. Read-only. Nullable.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param contactId key: id of contact
 @param singleValueLegacyExtendedPropertyId key: id of singleValueLegacyExtendedProperty
 @return ApiMeContactsGetSingleValueExtendedPropertiesRequest
*/
func (a *MeContactApiService) MeContactsGetSingleValueExtendedProperties(ctx _context.Context, contactId string, singleValueLegacyExtendedPropertyId string) ApiMeContactsGetSingleValueExtendedPropertiesRequest {
	return ApiMeContactsGetSingleValueExtendedPropertiesRequest{
		ApiService: a,
		ctx: ctx,
		contactId: contactId,
		singleValueLegacyExtendedPropertyId: singleValueLegacyExtendedPropertyId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphSingleValueLegacyExtendedProperty
func (a *MeContactApiService) MeContactsGetSingleValueExtendedPropertiesExecute(r ApiMeContactsGetSingleValueExtendedPropertiesRequest) (MicrosoftGraphSingleValueLegacyExtendedProperty, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphSingleValueLegacyExtendedProperty
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MeContactApiService.MeContactsGetSingleValueExtendedProperties")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/contacts/{contact-id}/singleValueExtendedProperties/{singleValueLegacyExtendedProperty-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"contact-id"+"}", _neturl.PathEscape(parameterToString(r.contactId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"singleValueLegacyExtendedProperty-id"+"}", _neturl.PathEscape(parameterToString(r.singleValueLegacyExtendedPropertyId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMeContactsListExtensionsRequest struct {
	ctx _context.Context
	ApiService *MeContactApiService
	contactId string
	top *int32
	skip *int32
	filter *string
	count *bool
	orderby *[]string
	select_ *[]string
	expand *[]string
}

// Show only the first n items
func (r ApiMeContactsListExtensionsRequest) Top(top int32) ApiMeContactsListExtensionsRequest {
	r.top = &top
	return r
}
// Skip the first n items
func (r ApiMeContactsListExtensionsRequest) Skip(skip int32) ApiMeContactsListExtensionsRequest {
	r.skip = &skip
	return r
}
// Filter items by property values
func (r ApiMeContactsListExtensionsRequest) Filter(filter string) ApiMeContactsListExtensionsRequest {
	r.filter = &filter
	return r
}
// Include count of items
func (r ApiMeContactsListExtensionsRequest) Count(count bool) ApiMeContactsListExtensionsRequest {
	r.count = &count
	return r
}
// Order items by property values
func (r ApiMeContactsListExtensionsRequest) Orderby(orderby []string) ApiMeContactsListExtensionsRequest {
	r.orderby = &orderby
	return r
}
// Select properties to be returned
func (r ApiMeContactsListExtensionsRequest) Select_(select_ []string) ApiMeContactsListExtensionsRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiMeContactsListExtensionsRequest) Expand(expand []string) ApiMeContactsListExtensionsRequest {
	r.expand = &expand
	return r
}

func (r ApiMeContactsListExtensionsRequest) Execute() (CollectionOfExtension, *_nethttp.Response, error) {
	return r.ApiService.MeContactsListExtensionsExecute(r)
}

/*
MeContactsListExtensions Get extensions from me

The collection of open extensions defined for the contact. Read-only. Nullable.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param contactId key: id of contact
 @return ApiMeContactsListExtensionsRequest
*/
func (a *MeContactApiService) MeContactsListExtensions(ctx _context.Context, contactId string) ApiMeContactsListExtensionsRequest {
	return ApiMeContactsListExtensionsRequest{
		ApiService: a,
		ctx: ctx,
		contactId: contactId,
	}
}

// Execute executes the request
//  @return CollectionOfExtension
func (a *MeContactApiService) MeContactsListExtensionsExecute(r ApiMeContactsListExtensionsRequest) (CollectionOfExtension, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  CollectionOfExtension
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MeContactApiService.MeContactsListExtensions")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/contacts/{contact-id}/extensions"
	localVarPath = strings.Replace(localVarPath, "{"+"contact-id"+"}", _neturl.PathEscape(parameterToString(r.contactId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.top != nil {
		localVarQueryParams.Add("$top", parameterToString(*r.top, ""))
	}
	if r.skip != nil {
		localVarQueryParams.Add("$skip", parameterToString(*r.skip, ""))
	}
	if r.filter != nil {
		localVarQueryParams.Add("$filter", parameterToString(*r.filter, ""))
	}
	if r.count != nil {
		localVarQueryParams.Add("$count", parameterToString(*r.count, ""))
	}
	if r.orderby != nil {
		localVarQueryParams.Add("$orderby", parameterToString(*r.orderby, "csv"))
	}
	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMeContactsListMultiValueExtendedPropertiesRequest struct {
	ctx _context.Context
	ApiService *MeContactApiService
	contactId string
	top *int32
	skip *int32
	search *string
	filter *string
	count *bool
	orderby *[]string
	select_ *[]string
	expand *[]string
}

// Show only the first n items
func (r ApiMeContactsListMultiValueExtendedPropertiesRequest) Top(top int32) ApiMeContactsListMultiValueExtendedPropertiesRequest {
	r.top = &top
	return r
}
// Skip the first n items
func (r ApiMeContactsListMultiValueExtendedPropertiesRequest) Skip(skip int32) ApiMeContactsListMultiValueExtendedPropertiesRequest {
	r.skip = &skip
	return r
}
// Search items by search phrases
func (r ApiMeContactsListMultiValueExtendedPropertiesRequest) Search(search string) ApiMeContactsListMultiValueExtendedPropertiesRequest {
	r.search = &search
	return r
}
// Filter items by property values
func (r ApiMeContactsListMultiValueExtendedPropertiesRequest) Filter(filter string) ApiMeContactsListMultiValueExtendedPropertiesRequest {
	r.filter = &filter
	return r
}
// Include count of items
func (r ApiMeContactsListMultiValueExtendedPropertiesRequest) Count(count bool) ApiMeContactsListMultiValueExtendedPropertiesRequest {
	r.count = &count
	return r
}
// Order items by property values
func (r ApiMeContactsListMultiValueExtendedPropertiesRequest) Orderby(orderby []string) ApiMeContactsListMultiValueExtendedPropertiesRequest {
	r.orderby = &orderby
	return r
}
// Select properties to be returned
func (r ApiMeContactsListMultiValueExtendedPropertiesRequest) Select_(select_ []string) ApiMeContactsListMultiValueExtendedPropertiesRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiMeContactsListMultiValueExtendedPropertiesRequest) Expand(expand []string) ApiMeContactsListMultiValueExtendedPropertiesRequest {
	r.expand = &expand
	return r
}

func (r ApiMeContactsListMultiValueExtendedPropertiesRequest) Execute() (CollectionOfMultiValueLegacyExtendedProperty, *_nethttp.Response, error) {
	return r.ApiService.MeContactsListMultiValueExtendedPropertiesExecute(r)
}

/*
MeContactsListMultiValueExtendedProperties Get multiValueExtendedProperties from me

The collection of multi-value extended properties defined for the contact. Read-only. Nullable.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param contactId key: id of contact
 @return ApiMeContactsListMultiValueExtendedPropertiesRequest
*/
func (a *MeContactApiService) MeContactsListMultiValueExtendedProperties(ctx _context.Context, contactId string) ApiMeContactsListMultiValueExtendedPropertiesRequest {
	return ApiMeContactsListMultiValueExtendedPropertiesRequest{
		ApiService: a,
		ctx: ctx,
		contactId: contactId,
	}
}

// Execute executes the request
//  @return CollectionOfMultiValueLegacyExtendedProperty
func (a *MeContactApiService) MeContactsListMultiValueExtendedPropertiesExecute(r ApiMeContactsListMultiValueExtendedPropertiesRequest) (CollectionOfMultiValueLegacyExtendedProperty, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  CollectionOfMultiValueLegacyExtendedProperty
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MeContactApiService.MeContactsListMultiValueExtendedProperties")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/contacts/{contact-id}/multiValueExtendedProperties"
	localVarPath = strings.Replace(localVarPath, "{"+"contact-id"+"}", _neturl.PathEscape(parameterToString(r.contactId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.top != nil {
		localVarQueryParams.Add("$top", parameterToString(*r.top, ""))
	}
	if r.skip != nil {
		localVarQueryParams.Add("$skip", parameterToString(*r.skip, ""))
	}
	if r.search != nil {
		localVarQueryParams.Add("$search", parameterToString(*r.search, ""))
	}
	if r.filter != nil {
		localVarQueryParams.Add("$filter", parameterToString(*r.filter, ""))
	}
	if r.count != nil {
		localVarQueryParams.Add("$count", parameterToString(*r.count, ""))
	}
	if r.orderby != nil {
		localVarQueryParams.Add("$orderby", parameterToString(*r.orderby, "csv"))
	}
	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMeContactsListSingleValueExtendedPropertiesRequest struct {
	ctx _context.Context
	ApiService *MeContactApiService
	contactId string
	top *int32
	skip *int32
	search *string
	filter *string
	count *bool
	orderby *[]string
	select_ *[]string
	expand *[]string
}

// Show only the first n items
func (r ApiMeContactsListSingleValueExtendedPropertiesRequest) Top(top int32) ApiMeContactsListSingleValueExtendedPropertiesRequest {
	r.top = &top
	return r
}
// Skip the first n items
func (r ApiMeContactsListSingleValueExtendedPropertiesRequest) Skip(skip int32) ApiMeContactsListSingleValueExtendedPropertiesRequest {
	r.skip = &skip
	return r
}
// Search items by search phrases
func (r ApiMeContactsListSingleValueExtendedPropertiesRequest) Search(search string) ApiMeContactsListSingleValueExtendedPropertiesRequest {
	r.search = &search
	return r
}
// Filter items by property values
func (r ApiMeContactsListSingleValueExtendedPropertiesRequest) Filter(filter string) ApiMeContactsListSingleValueExtendedPropertiesRequest {
	r.filter = &filter
	return r
}
// Include count of items
func (r ApiMeContactsListSingleValueExtendedPropertiesRequest) Count(count bool) ApiMeContactsListSingleValueExtendedPropertiesRequest {
	r.count = &count
	return r
}
// Order items by property values
func (r ApiMeContactsListSingleValueExtendedPropertiesRequest) Orderby(orderby []string) ApiMeContactsListSingleValueExtendedPropertiesRequest {
	r.orderby = &orderby
	return r
}
// Select properties to be returned
func (r ApiMeContactsListSingleValueExtendedPropertiesRequest) Select_(select_ []string) ApiMeContactsListSingleValueExtendedPropertiesRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiMeContactsListSingleValueExtendedPropertiesRequest) Expand(expand []string) ApiMeContactsListSingleValueExtendedPropertiesRequest {
	r.expand = &expand
	return r
}

func (r ApiMeContactsListSingleValueExtendedPropertiesRequest) Execute() (CollectionOfSingleValueLegacyExtendedProperty, *_nethttp.Response, error) {
	return r.ApiService.MeContactsListSingleValueExtendedPropertiesExecute(r)
}

/*
MeContactsListSingleValueExtendedProperties Get singleValueExtendedProperties from me

The collection of single-value extended properties defined for the contact. Read-only. Nullable.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param contactId key: id of contact
 @return ApiMeContactsListSingleValueExtendedPropertiesRequest
*/
func (a *MeContactApiService) MeContactsListSingleValueExtendedProperties(ctx _context.Context, contactId string) ApiMeContactsListSingleValueExtendedPropertiesRequest {
	return ApiMeContactsListSingleValueExtendedPropertiesRequest{
		ApiService: a,
		ctx: ctx,
		contactId: contactId,
	}
}

// Execute executes the request
//  @return CollectionOfSingleValueLegacyExtendedProperty
func (a *MeContactApiService) MeContactsListSingleValueExtendedPropertiesExecute(r ApiMeContactsListSingleValueExtendedPropertiesRequest) (CollectionOfSingleValueLegacyExtendedProperty, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  CollectionOfSingleValueLegacyExtendedProperty
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MeContactApiService.MeContactsListSingleValueExtendedProperties")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/contacts/{contact-id}/singleValueExtendedProperties"
	localVarPath = strings.Replace(localVarPath, "{"+"contact-id"+"}", _neturl.PathEscape(parameterToString(r.contactId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.top != nil {
		localVarQueryParams.Add("$top", parameterToString(*r.top, ""))
	}
	if r.skip != nil {
		localVarQueryParams.Add("$skip", parameterToString(*r.skip, ""))
	}
	if r.search != nil {
		localVarQueryParams.Add("$search", parameterToString(*r.search, ""))
	}
	if r.filter != nil {
		localVarQueryParams.Add("$filter", parameterToString(*r.filter, ""))
	}
	if r.count != nil {
		localVarQueryParams.Add("$count", parameterToString(*r.count, ""))
	}
	if r.orderby != nil {
		localVarQueryParams.Add("$orderby", parameterToString(*r.orderby, "csv"))
	}
	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMeContactsUpdateExtensionsRequest struct {
	ctx _context.Context
	ApiService *MeContactApiService
	contactId string
	extensionId string
	microsoftGraphExtension *MicrosoftGraphExtension
}

// New navigation property values
func (r ApiMeContactsUpdateExtensionsRequest) MicrosoftGraphExtension(microsoftGraphExtension MicrosoftGraphExtension) ApiMeContactsUpdateExtensionsRequest {
	r.microsoftGraphExtension = &microsoftGraphExtension
	return r
}

func (r ApiMeContactsUpdateExtensionsRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.MeContactsUpdateExtensionsExecute(r)
}

/*
MeContactsUpdateExtensions Update the navigation property extensions in me

The collection of open extensions defined for the contact. Read-only. Nullable.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param contactId key: id of contact
 @param extensionId key: id of extension
 @return ApiMeContactsUpdateExtensionsRequest
*/
func (a *MeContactApiService) MeContactsUpdateExtensions(ctx _context.Context, contactId string, extensionId string) ApiMeContactsUpdateExtensionsRequest {
	return ApiMeContactsUpdateExtensionsRequest{
		ApiService: a,
		ctx: ctx,
		contactId: contactId,
		extensionId: extensionId,
	}
}

// Execute executes the request
func (a *MeContactApiService) MeContactsUpdateExtensionsExecute(r ApiMeContactsUpdateExtensionsRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPatch
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MeContactApiService.MeContactsUpdateExtensions")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/contacts/{contact-id}/extensions/{extension-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"contact-id"+"}", _neturl.PathEscape(parameterToString(r.contactId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"extension-id"+"}", _neturl.PathEscape(parameterToString(r.extensionId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphExtension == nil {
		return nil, reportError("microsoftGraphExtension is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphExtension
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiMeContactsUpdateMultiValueExtendedPropertiesRequest struct {
	ctx _context.Context
	ApiService *MeContactApiService
	contactId string
	multiValueLegacyExtendedPropertyId string
	microsoftGraphMultiValueLegacyExtendedProperty *MicrosoftGraphMultiValueLegacyExtendedProperty
}

// New navigation property values
func (r ApiMeContactsUpdateMultiValueExtendedPropertiesRequest) MicrosoftGraphMultiValueLegacyExtendedProperty(microsoftGraphMultiValueLegacyExtendedProperty MicrosoftGraphMultiValueLegacyExtendedProperty) ApiMeContactsUpdateMultiValueExtendedPropertiesRequest {
	r.microsoftGraphMultiValueLegacyExtendedProperty = &microsoftGraphMultiValueLegacyExtendedProperty
	return r
}

func (r ApiMeContactsUpdateMultiValueExtendedPropertiesRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.MeContactsUpdateMultiValueExtendedPropertiesExecute(r)
}

/*
MeContactsUpdateMultiValueExtendedProperties Update the navigation property multiValueExtendedProperties in me

The collection of multi-value extended properties defined for the contact. Read-only. Nullable.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param contactId key: id of contact
 @param multiValueLegacyExtendedPropertyId key: id of multiValueLegacyExtendedProperty
 @return ApiMeContactsUpdateMultiValueExtendedPropertiesRequest
*/
func (a *MeContactApiService) MeContactsUpdateMultiValueExtendedProperties(ctx _context.Context, contactId string, multiValueLegacyExtendedPropertyId string) ApiMeContactsUpdateMultiValueExtendedPropertiesRequest {
	return ApiMeContactsUpdateMultiValueExtendedPropertiesRequest{
		ApiService: a,
		ctx: ctx,
		contactId: contactId,
		multiValueLegacyExtendedPropertyId: multiValueLegacyExtendedPropertyId,
	}
}

// Execute executes the request
func (a *MeContactApiService) MeContactsUpdateMultiValueExtendedPropertiesExecute(r ApiMeContactsUpdateMultiValueExtendedPropertiesRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPatch
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MeContactApiService.MeContactsUpdateMultiValueExtendedProperties")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/contacts/{contact-id}/multiValueExtendedProperties/{multiValueLegacyExtendedProperty-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"contact-id"+"}", _neturl.PathEscape(parameterToString(r.contactId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"multiValueLegacyExtendedProperty-id"+"}", _neturl.PathEscape(parameterToString(r.multiValueLegacyExtendedPropertyId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphMultiValueLegacyExtendedProperty == nil {
		return nil, reportError("microsoftGraphMultiValueLegacyExtendedProperty is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphMultiValueLegacyExtendedProperty
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiMeContactsUpdatePhotoRequest struct {
	ctx _context.Context
	ApiService *MeContactApiService
	contactId string
	microsoftGraphProfilePhoto *MicrosoftGraphProfilePhoto
}

// New navigation property values
func (r ApiMeContactsUpdatePhotoRequest) MicrosoftGraphProfilePhoto(microsoftGraphProfilePhoto MicrosoftGraphProfilePhoto) ApiMeContactsUpdatePhotoRequest {
	r.microsoftGraphProfilePhoto = &microsoftGraphProfilePhoto
	return r
}

func (r ApiMeContactsUpdatePhotoRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.MeContactsUpdatePhotoExecute(r)
}

/*
MeContactsUpdatePhoto Update the navigation property photo in me

Optional contact picture. You can get or set a photo for a contact.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param contactId key: id of contact
 @return ApiMeContactsUpdatePhotoRequest
*/
func (a *MeContactApiService) MeContactsUpdatePhoto(ctx _context.Context, contactId string) ApiMeContactsUpdatePhotoRequest {
	return ApiMeContactsUpdatePhotoRequest{
		ApiService: a,
		ctx: ctx,
		contactId: contactId,
	}
}

// Execute executes the request
func (a *MeContactApiService) MeContactsUpdatePhotoExecute(r ApiMeContactsUpdatePhotoRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPatch
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MeContactApiService.MeContactsUpdatePhoto")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/contacts/{contact-id}/photo"
	localVarPath = strings.Replace(localVarPath, "{"+"contact-id"+"}", _neturl.PathEscape(parameterToString(r.contactId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphProfilePhoto == nil {
		return nil, reportError("microsoftGraphProfilePhoto is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphProfilePhoto
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiMeContactsUpdatePhotoContentRequest struct {
	ctx _context.Context
	ApiService *MeContactApiService
	contactId string
	body **os.File
}

// New media content.
func (r ApiMeContactsUpdatePhotoContentRequest) Body(body *os.File) ApiMeContactsUpdatePhotoContentRequest {
	r.body = &body
	return r
}

func (r ApiMeContactsUpdatePhotoContentRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.MeContactsUpdatePhotoContentExecute(r)
}

/*
MeContactsUpdatePhotoContent Update media content for the navigation property photo in me

The user's profile photo. Read-only.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param contactId key: id of contact
 @return ApiMeContactsUpdatePhotoContentRequest
*/
func (a *MeContactApiService) MeContactsUpdatePhotoContent(ctx _context.Context, contactId string) ApiMeContactsUpdatePhotoContentRequest {
	return ApiMeContactsUpdatePhotoContentRequest{
		ApiService: a,
		ctx: ctx,
		contactId: contactId,
	}
}

// Execute executes the request
func (a *MeContactApiService) MeContactsUpdatePhotoContentExecute(r ApiMeContactsUpdatePhotoContentRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPut
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MeContactApiService.MeContactsUpdatePhotoContent")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/contacts/{contact-id}/photo/$value"
	localVarPath = strings.Replace(localVarPath, "{"+"contact-id"+"}", _neturl.PathEscape(parameterToString(r.contactId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.body == nil {
		return nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/octet-stream"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiMeContactsUpdateSingleValueExtendedPropertiesRequest struct {
	ctx _context.Context
	ApiService *MeContactApiService
	contactId string
	singleValueLegacyExtendedPropertyId string
	microsoftGraphSingleValueLegacyExtendedProperty *MicrosoftGraphSingleValueLegacyExtendedProperty
}

// New navigation property values
func (r ApiMeContactsUpdateSingleValueExtendedPropertiesRequest) MicrosoftGraphSingleValueLegacyExtendedProperty(microsoftGraphSingleValueLegacyExtendedProperty MicrosoftGraphSingleValueLegacyExtendedProperty) ApiMeContactsUpdateSingleValueExtendedPropertiesRequest {
	r.microsoftGraphSingleValueLegacyExtendedProperty = &microsoftGraphSingleValueLegacyExtendedProperty
	return r
}

func (r ApiMeContactsUpdateSingleValueExtendedPropertiesRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.MeContactsUpdateSingleValueExtendedPropertiesExecute(r)
}

/*
MeContactsUpdateSingleValueExtendedProperties Update the navigation property singleValueExtendedProperties in me

The collection of single-value extended properties defined for the contact. Read-only. Nullable.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param contactId key: id of contact
 @param singleValueLegacyExtendedPropertyId key: id of singleValueLegacyExtendedProperty
 @return ApiMeContactsUpdateSingleValueExtendedPropertiesRequest
*/
func (a *MeContactApiService) MeContactsUpdateSingleValueExtendedProperties(ctx _context.Context, contactId string, singleValueLegacyExtendedPropertyId string) ApiMeContactsUpdateSingleValueExtendedPropertiesRequest {
	return ApiMeContactsUpdateSingleValueExtendedPropertiesRequest{
		ApiService: a,
		ctx: ctx,
		contactId: contactId,
		singleValueLegacyExtendedPropertyId: singleValueLegacyExtendedPropertyId,
	}
}

// Execute executes the request
func (a *MeContactApiService) MeContactsUpdateSingleValueExtendedPropertiesExecute(r ApiMeContactsUpdateSingleValueExtendedPropertiesRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPatch
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MeContactApiService.MeContactsUpdateSingleValueExtendedProperties")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/contacts/{contact-id}/singleValueExtendedProperties/{singleValueLegacyExtendedProperty-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"contact-id"+"}", _neturl.PathEscape(parameterToString(r.contactId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"singleValueLegacyExtendedProperty-id"+"}", _neturl.PathEscape(parameterToString(r.singleValueLegacyExtendedPropertyId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphSingleValueLegacyExtendedProperty == nil {
		return nil, reportError("microsoftGraphSingleValueLegacyExtendedProperty is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphSingleValueLegacyExtendedProperty
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiMeCreateContactsRequest struct {
	ctx _context.Context
	ApiService *MeContactApiService
	microsoftGraphContact *MicrosoftGraphContact
}

// New navigation property
func (r ApiMeCreateContactsRequest) MicrosoftGraphContact(microsoftGraphContact MicrosoftGraphContact) ApiMeCreateContactsRequest {
	r.microsoftGraphContact = &microsoftGraphContact
	return r
}

func (r ApiMeCreateContactsRequest) Execute() (MicrosoftGraphContact, *_nethttp.Response, error) {
	return r.ApiService.MeCreateContactsExecute(r)
}

/*
MeCreateContacts Create new navigation property to contacts for me

The user's contacts. Read-only. Nullable.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiMeCreateContactsRequest
*/
func (a *MeContactApiService) MeCreateContacts(ctx _context.Context) ApiMeCreateContactsRequest {
	return ApiMeCreateContactsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return MicrosoftGraphContact
func (a *MeContactApiService) MeCreateContactsExecute(r ApiMeCreateContactsRequest) (MicrosoftGraphContact, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphContact
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MeContactApiService.MeCreateContacts")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/contacts"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphContact == nil {
		return localVarReturnValue, nil, reportError("microsoftGraphContact is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphContact
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMeDeleteContactsRequest struct {
	ctx _context.Context
	ApiService *MeContactApiService
	contactId string
	ifMatch *string
}

// ETag
func (r ApiMeDeleteContactsRequest) IfMatch(ifMatch string) ApiMeDeleteContactsRequest {
	r.ifMatch = &ifMatch
	return r
}

func (r ApiMeDeleteContactsRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.MeDeleteContactsExecute(r)
}

/*
MeDeleteContacts Delete navigation property contacts for me

The user's contacts. Read-only. Nullable.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param contactId key: id of contact
 @return ApiMeDeleteContactsRequest
*/
func (a *MeContactApiService) MeDeleteContacts(ctx _context.Context, contactId string) ApiMeDeleteContactsRequest {
	return ApiMeDeleteContactsRequest{
		ApiService: a,
		ctx: ctx,
		contactId: contactId,
	}
}

// Execute executes the request
func (a *MeContactApiService) MeDeleteContactsExecute(r ApiMeDeleteContactsRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MeContactApiService.MeDeleteContacts")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/contacts/{contact-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"contact-id"+"}", _neturl.PathEscape(parameterToString(r.contactId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ifMatch != nil {
		localVarHeaderParams["If-Match"] = parameterToString(*r.ifMatch, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiMeGetContactsRequest struct {
	ctx _context.Context
	ApiService *MeContactApiService
	contactId string
	select_ *[]string
}

// Select properties to be returned
func (r ApiMeGetContactsRequest) Select_(select_ []string) ApiMeGetContactsRequest {
	r.select_ = &select_
	return r
}

func (r ApiMeGetContactsRequest) Execute() (MicrosoftGraphContact, *_nethttp.Response, error) {
	return r.ApiService.MeGetContactsExecute(r)
}

/*
MeGetContacts Get contacts from me

The user's contacts. Read-only. Nullable.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param contactId key: id of contact
 @return ApiMeGetContactsRequest
*/
func (a *MeContactApiService) MeGetContacts(ctx _context.Context, contactId string) ApiMeGetContactsRequest {
	return ApiMeGetContactsRequest{
		ApiService: a,
		ctx: ctx,
		contactId: contactId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphContact
func (a *MeContactApiService) MeGetContactsExecute(r ApiMeGetContactsRequest) (MicrosoftGraphContact, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphContact
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MeContactApiService.MeGetContacts")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/contacts/{contact-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"contact-id"+"}", _neturl.PathEscape(parameterToString(r.contactId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMeListContactsRequest struct {
	ctx _context.Context
	ApiService *MeContactApiService
	top *int32
	skip *int32
	search *string
	filter *string
	count *bool
	orderby *[]string
	select_ *[]string
}

// Show only the first n items
func (r ApiMeListContactsRequest) Top(top int32) ApiMeListContactsRequest {
	r.top = &top
	return r
}
// Skip the first n items
func (r ApiMeListContactsRequest) Skip(skip int32) ApiMeListContactsRequest {
	r.skip = &skip
	return r
}
// Search items by search phrases
func (r ApiMeListContactsRequest) Search(search string) ApiMeListContactsRequest {
	r.search = &search
	return r
}
// Filter items by property values
func (r ApiMeListContactsRequest) Filter(filter string) ApiMeListContactsRequest {
	r.filter = &filter
	return r
}
// Include count of items
func (r ApiMeListContactsRequest) Count(count bool) ApiMeListContactsRequest {
	r.count = &count
	return r
}
// Order items by property values
func (r ApiMeListContactsRequest) Orderby(orderby []string) ApiMeListContactsRequest {
	r.orderby = &orderby
	return r
}
// Select properties to be returned
func (r ApiMeListContactsRequest) Select_(select_ []string) ApiMeListContactsRequest {
	r.select_ = &select_
	return r
}

func (r ApiMeListContactsRequest) Execute() (CollectionOfContact, *_nethttp.Response, error) {
	return r.ApiService.MeListContactsExecute(r)
}

/*
MeListContacts Get contacts from me

The user's contacts. Read-only. Nullable.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiMeListContactsRequest
*/
func (a *MeContactApiService) MeListContacts(ctx _context.Context) ApiMeListContactsRequest {
	return ApiMeListContactsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CollectionOfContact
func (a *MeContactApiService) MeListContactsExecute(r ApiMeListContactsRequest) (CollectionOfContact, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  CollectionOfContact
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MeContactApiService.MeListContacts")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/contacts"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.top != nil {
		localVarQueryParams.Add("$top", parameterToString(*r.top, ""))
	}
	if r.skip != nil {
		localVarQueryParams.Add("$skip", parameterToString(*r.skip, ""))
	}
	if r.search != nil {
		localVarQueryParams.Add("$search", parameterToString(*r.search, ""))
	}
	if r.filter != nil {
		localVarQueryParams.Add("$filter", parameterToString(*r.filter, ""))
	}
	if r.count != nil {
		localVarQueryParams.Add("$count", parameterToString(*r.count, ""))
	}
	if r.orderby != nil {
		localVarQueryParams.Add("$orderby", parameterToString(*r.orderby, "csv"))
	}
	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMeUpdateContactsRequest struct {
	ctx _context.Context
	ApiService *MeContactApiService
	contactId string
	microsoftGraphContact *MicrosoftGraphContact
}

// New navigation property values
func (r ApiMeUpdateContactsRequest) MicrosoftGraphContact(microsoftGraphContact MicrosoftGraphContact) ApiMeUpdateContactsRequest {
	r.microsoftGraphContact = &microsoftGraphContact
	return r
}

func (r ApiMeUpdateContactsRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.MeUpdateContactsExecute(r)
}

/*
MeUpdateContacts Update the navigation property contacts in me

The user's contacts. Read-only. Nullable.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param contactId key: id of contact
 @return ApiMeUpdateContactsRequest
*/
func (a *MeContactApiService) MeUpdateContacts(ctx _context.Context, contactId string) ApiMeUpdateContactsRequest {
	return ApiMeUpdateContactsRequest{
		ApiService: a,
		ctx: ctx,
		contactId: contactId,
	}
}

// Execute executes the request
func (a *MeContactApiService) MeUpdateContactsExecute(r ApiMeUpdateContactsRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPatch
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MeContactApiService.MeUpdateContacts")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/contacts/{contact-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"contact-id"+"}", _neturl.PathEscape(parameterToString(r.contactId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphContact == nil {
		return nil, reportError("microsoftGraphContact is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphContact
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}
