/*
Partial Graph API

No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

API version: v1.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package openapi

import (
	"bytes"
	_context "context"
	_ioutil "io/ioutil"
	_nethttp "net/http"
	_neturl "net/url"
	"strings"
)

// Linger please
var (
	_ _context.Context
)

// DomainsDomainDnsRecordApiService DomainsDomainDnsRecordApi service
type DomainsDomainDnsRecordApiService service

type ApiDomainsCreateServiceConfigurationRecordsRequest struct {
	ctx _context.Context
	ApiService *DomainsDomainDnsRecordApiService
	domainId string
	microsoftGraphDomainDnsRecord *MicrosoftGraphDomainDnsRecord
}

// New navigation property
func (r ApiDomainsCreateServiceConfigurationRecordsRequest) MicrosoftGraphDomainDnsRecord(microsoftGraphDomainDnsRecord MicrosoftGraphDomainDnsRecord) ApiDomainsCreateServiceConfigurationRecordsRequest {
	r.microsoftGraphDomainDnsRecord = &microsoftGraphDomainDnsRecord
	return r
}

func (r ApiDomainsCreateServiceConfigurationRecordsRequest) Execute() (MicrosoftGraphDomainDnsRecord, *_nethttp.Response, error) {
	return r.ApiService.DomainsCreateServiceConfigurationRecordsExecute(r)
}

/*
DomainsCreateServiceConfigurationRecords Create new navigation property to serviceConfigurationRecords for domains

DNS records the customer adds to the DNS zone file of the domain before the domain can be used by Microsoft Online services. Read-only, Nullable

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param domainId key: id of domain
 @return ApiDomainsCreateServiceConfigurationRecordsRequest
*/
func (a *DomainsDomainDnsRecordApiService) DomainsCreateServiceConfigurationRecords(ctx _context.Context, domainId string) ApiDomainsCreateServiceConfigurationRecordsRequest {
	return ApiDomainsCreateServiceConfigurationRecordsRequest{
		ApiService: a,
		ctx: ctx,
		domainId: domainId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphDomainDnsRecord
func (a *DomainsDomainDnsRecordApiService) DomainsCreateServiceConfigurationRecordsExecute(r ApiDomainsCreateServiceConfigurationRecordsRequest) (MicrosoftGraphDomainDnsRecord, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphDomainDnsRecord
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DomainsDomainDnsRecordApiService.DomainsCreateServiceConfigurationRecords")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/domains/{domain-id}/serviceConfigurationRecords"
	localVarPath = strings.Replace(localVarPath, "{"+"domain-id"+"}", _neturl.PathEscape(parameterToString(r.domainId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphDomainDnsRecord == nil {
		return localVarReturnValue, nil, reportError("microsoftGraphDomainDnsRecord is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphDomainDnsRecord
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDomainsCreateVerificationDnsRecordsRequest struct {
	ctx _context.Context
	ApiService *DomainsDomainDnsRecordApiService
	domainId string
	microsoftGraphDomainDnsRecord *MicrosoftGraphDomainDnsRecord
}

// New navigation property
func (r ApiDomainsCreateVerificationDnsRecordsRequest) MicrosoftGraphDomainDnsRecord(microsoftGraphDomainDnsRecord MicrosoftGraphDomainDnsRecord) ApiDomainsCreateVerificationDnsRecordsRequest {
	r.microsoftGraphDomainDnsRecord = &microsoftGraphDomainDnsRecord
	return r
}

func (r ApiDomainsCreateVerificationDnsRecordsRequest) Execute() (MicrosoftGraphDomainDnsRecord, *_nethttp.Response, error) {
	return r.ApiService.DomainsCreateVerificationDnsRecordsExecute(r)
}

/*
DomainsCreateVerificationDnsRecords Create new navigation property to verificationDnsRecords for domains

DNS records that the customer adds to the DNS zone file of the domain before the customer can complete domain ownership verification with Azure AD. Read-only, Nullable

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param domainId key: id of domain
 @return ApiDomainsCreateVerificationDnsRecordsRequest
*/
func (a *DomainsDomainDnsRecordApiService) DomainsCreateVerificationDnsRecords(ctx _context.Context, domainId string) ApiDomainsCreateVerificationDnsRecordsRequest {
	return ApiDomainsCreateVerificationDnsRecordsRequest{
		ApiService: a,
		ctx: ctx,
		domainId: domainId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphDomainDnsRecord
func (a *DomainsDomainDnsRecordApiService) DomainsCreateVerificationDnsRecordsExecute(r ApiDomainsCreateVerificationDnsRecordsRequest) (MicrosoftGraphDomainDnsRecord, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphDomainDnsRecord
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DomainsDomainDnsRecordApiService.DomainsCreateVerificationDnsRecords")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/domains/{domain-id}/verificationDnsRecords"
	localVarPath = strings.Replace(localVarPath, "{"+"domain-id"+"}", _neturl.PathEscape(parameterToString(r.domainId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphDomainDnsRecord == nil {
		return localVarReturnValue, nil, reportError("microsoftGraphDomainDnsRecord is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphDomainDnsRecord
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDomainsDeleteServiceConfigurationRecordsRequest struct {
	ctx _context.Context
	ApiService *DomainsDomainDnsRecordApiService
	domainId string
	domainDnsRecordId string
	ifMatch *string
}

// ETag
func (r ApiDomainsDeleteServiceConfigurationRecordsRequest) IfMatch(ifMatch string) ApiDomainsDeleteServiceConfigurationRecordsRequest {
	r.ifMatch = &ifMatch
	return r
}

func (r ApiDomainsDeleteServiceConfigurationRecordsRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.DomainsDeleteServiceConfigurationRecordsExecute(r)
}

/*
DomainsDeleteServiceConfigurationRecords Delete navigation property serviceConfigurationRecords for domains

DNS records the customer adds to the DNS zone file of the domain before the domain can be used by Microsoft Online services. Read-only, Nullable

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param domainId key: id of domain
 @param domainDnsRecordId key: id of domainDnsRecord
 @return ApiDomainsDeleteServiceConfigurationRecordsRequest
*/
func (a *DomainsDomainDnsRecordApiService) DomainsDeleteServiceConfigurationRecords(ctx _context.Context, domainId string, domainDnsRecordId string) ApiDomainsDeleteServiceConfigurationRecordsRequest {
	return ApiDomainsDeleteServiceConfigurationRecordsRequest{
		ApiService: a,
		ctx: ctx,
		domainId: domainId,
		domainDnsRecordId: domainDnsRecordId,
	}
}

// Execute executes the request
func (a *DomainsDomainDnsRecordApiService) DomainsDeleteServiceConfigurationRecordsExecute(r ApiDomainsDeleteServiceConfigurationRecordsRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DomainsDomainDnsRecordApiService.DomainsDeleteServiceConfigurationRecords")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/domains/{domain-id}/serviceConfigurationRecords/{domainDnsRecord-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"domain-id"+"}", _neturl.PathEscape(parameterToString(r.domainId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"domainDnsRecord-id"+"}", _neturl.PathEscape(parameterToString(r.domainDnsRecordId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ifMatch != nil {
		localVarHeaderParams["If-Match"] = parameterToString(*r.ifMatch, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDomainsDeleteVerificationDnsRecordsRequest struct {
	ctx _context.Context
	ApiService *DomainsDomainDnsRecordApiService
	domainId string
	domainDnsRecordId string
	ifMatch *string
}

// ETag
func (r ApiDomainsDeleteVerificationDnsRecordsRequest) IfMatch(ifMatch string) ApiDomainsDeleteVerificationDnsRecordsRequest {
	r.ifMatch = &ifMatch
	return r
}

func (r ApiDomainsDeleteVerificationDnsRecordsRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.DomainsDeleteVerificationDnsRecordsExecute(r)
}

/*
DomainsDeleteVerificationDnsRecords Delete navigation property verificationDnsRecords for domains

DNS records that the customer adds to the DNS zone file of the domain before the customer can complete domain ownership verification with Azure AD. Read-only, Nullable

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param domainId key: id of domain
 @param domainDnsRecordId key: id of domainDnsRecord
 @return ApiDomainsDeleteVerificationDnsRecordsRequest
*/
func (a *DomainsDomainDnsRecordApiService) DomainsDeleteVerificationDnsRecords(ctx _context.Context, domainId string, domainDnsRecordId string) ApiDomainsDeleteVerificationDnsRecordsRequest {
	return ApiDomainsDeleteVerificationDnsRecordsRequest{
		ApiService: a,
		ctx: ctx,
		domainId: domainId,
		domainDnsRecordId: domainDnsRecordId,
	}
}

// Execute executes the request
func (a *DomainsDomainDnsRecordApiService) DomainsDeleteVerificationDnsRecordsExecute(r ApiDomainsDeleteVerificationDnsRecordsRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DomainsDomainDnsRecordApiService.DomainsDeleteVerificationDnsRecords")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/domains/{domain-id}/verificationDnsRecords/{domainDnsRecord-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"domain-id"+"}", _neturl.PathEscape(parameterToString(r.domainId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"domainDnsRecord-id"+"}", _neturl.PathEscape(parameterToString(r.domainDnsRecordId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ifMatch != nil {
		localVarHeaderParams["If-Match"] = parameterToString(*r.ifMatch, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDomainsGetServiceConfigurationRecordsRequest struct {
	ctx _context.Context
	ApiService *DomainsDomainDnsRecordApiService
	domainId string
	domainDnsRecordId string
	select_ *[]string
	expand *[]string
}

// Select properties to be returned
func (r ApiDomainsGetServiceConfigurationRecordsRequest) Select_(select_ []string) ApiDomainsGetServiceConfigurationRecordsRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiDomainsGetServiceConfigurationRecordsRequest) Expand(expand []string) ApiDomainsGetServiceConfigurationRecordsRequest {
	r.expand = &expand
	return r
}

func (r ApiDomainsGetServiceConfigurationRecordsRequest) Execute() (MicrosoftGraphDomainDnsRecord, *_nethttp.Response, error) {
	return r.ApiService.DomainsGetServiceConfigurationRecordsExecute(r)
}

/*
DomainsGetServiceConfigurationRecords Get serviceConfigurationRecords from domains

DNS records the customer adds to the DNS zone file of the domain before the domain can be used by Microsoft Online services. Read-only, Nullable

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param domainId key: id of domain
 @param domainDnsRecordId key: id of domainDnsRecord
 @return ApiDomainsGetServiceConfigurationRecordsRequest
*/
func (a *DomainsDomainDnsRecordApiService) DomainsGetServiceConfigurationRecords(ctx _context.Context, domainId string, domainDnsRecordId string) ApiDomainsGetServiceConfigurationRecordsRequest {
	return ApiDomainsGetServiceConfigurationRecordsRequest{
		ApiService: a,
		ctx: ctx,
		domainId: domainId,
		domainDnsRecordId: domainDnsRecordId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphDomainDnsRecord
func (a *DomainsDomainDnsRecordApiService) DomainsGetServiceConfigurationRecordsExecute(r ApiDomainsGetServiceConfigurationRecordsRequest) (MicrosoftGraphDomainDnsRecord, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphDomainDnsRecord
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DomainsDomainDnsRecordApiService.DomainsGetServiceConfigurationRecords")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/domains/{domain-id}/serviceConfigurationRecords/{domainDnsRecord-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"domain-id"+"}", _neturl.PathEscape(parameterToString(r.domainId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"domainDnsRecord-id"+"}", _neturl.PathEscape(parameterToString(r.domainDnsRecordId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDomainsGetVerificationDnsRecordsRequest struct {
	ctx _context.Context
	ApiService *DomainsDomainDnsRecordApiService
	domainId string
	domainDnsRecordId string
	select_ *[]string
	expand *[]string
}

// Select properties to be returned
func (r ApiDomainsGetVerificationDnsRecordsRequest) Select_(select_ []string) ApiDomainsGetVerificationDnsRecordsRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiDomainsGetVerificationDnsRecordsRequest) Expand(expand []string) ApiDomainsGetVerificationDnsRecordsRequest {
	r.expand = &expand
	return r
}

func (r ApiDomainsGetVerificationDnsRecordsRequest) Execute() (MicrosoftGraphDomainDnsRecord, *_nethttp.Response, error) {
	return r.ApiService.DomainsGetVerificationDnsRecordsExecute(r)
}

/*
DomainsGetVerificationDnsRecords Get verificationDnsRecords from domains

DNS records that the customer adds to the DNS zone file of the domain before the customer can complete domain ownership verification with Azure AD. Read-only, Nullable

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param domainId key: id of domain
 @param domainDnsRecordId key: id of domainDnsRecord
 @return ApiDomainsGetVerificationDnsRecordsRequest
*/
func (a *DomainsDomainDnsRecordApiService) DomainsGetVerificationDnsRecords(ctx _context.Context, domainId string, domainDnsRecordId string) ApiDomainsGetVerificationDnsRecordsRequest {
	return ApiDomainsGetVerificationDnsRecordsRequest{
		ApiService: a,
		ctx: ctx,
		domainId: domainId,
		domainDnsRecordId: domainDnsRecordId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphDomainDnsRecord
func (a *DomainsDomainDnsRecordApiService) DomainsGetVerificationDnsRecordsExecute(r ApiDomainsGetVerificationDnsRecordsRequest) (MicrosoftGraphDomainDnsRecord, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphDomainDnsRecord
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DomainsDomainDnsRecordApiService.DomainsGetVerificationDnsRecords")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/domains/{domain-id}/verificationDnsRecords/{domainDnsRecord-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"domain-id"+"}", _neturl.PathEscape(parameterToString(r.domainId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"domainDnsRecord-id"+"}", _neturl.PathEscape(parameterToString(r.domainDnsRecordId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDomainsListServiceConfigurationRecordsRequest struct {
	ctx _context.Context
	ApiService *DomainsDomainDnsRecordApiService
	domainId string
	top *int32
	skip *int32
	search *string
	filter *string
	count *bool
	orderby *[]string
	select_ *[]string
	expand *[]string
}

// Show only the first n items
func (r ApiDomainsListServiceConfigurationRecordsRequest) Top(top int32) ApiDomainsListServiceConfigurationRecordsRequest {
	r.top = &top
	return r
}
// Skip the first n items
func (r ApiDomainsListServiceConfigurationRecordsRequest) Skip(skip int32) ApiDomainsListServiceConfigurationRecordsRequest {
	r.skip = &skip
	return r
}
// Search items by search phrases
func (r ApiDomainsListServiceConfigurationRecordsRequest) Search(search string) ApiDomainsListServiceConfigurationRecordsRequest {
	r.search = &search
	return r
}
// Filter items by property values
func (r ApiDomainsListServiceConfigurationRecordsRequest) Filter(filter string) ApiDomainsListServiceConfigurationRecordsRequest {
	r.filter = &filter
	return r
}
// Include count of items
func (r ApiDomainsListServiceConfigurationRecordsRequest) Count(count bool) ApiDomainsListServiceConfigurationRecordsRequest {
	r.count = &count
	return r
}
// Order items by property values
func (r ApiDomainsListServiceConfigurationRecordsRequest) Orderby(orderby []string) ApiDomainsListServiceConfigurationRecordsRequest {
	r.orderby = &orderby
	return r
}
// Select properties to be returned
func (r ApiDomainsListServiceConfigurationRecordsRequest) Select_(select_ []string) ApiDomainsListServiceConfigurationRecordsRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiDomainsListServiceConfigurationRecordsRequest) Expand(expand []string) ApiDomainsListServiceConfigurationRecordsRequest {
	r.expand = &expand
	return r
}

func (r ApiDomainsListServiceConfigurationRecordsRequest) Execute() (CollectionOfDomainDnsRecord, *_nethttp.Response, error) {
	return r.ApiService.DomainsListServiceConfigurationRecordsExecute(r)
}

/*
DomainsListServiceConfigurationRecords Get serviceConfigurationRecords from domains

DNS records the customer adds to the DNS zone file of the domain before the domain can be used by Microsoft Online services. Read-only, Nullable

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param domainId key: id of domain
 @return ApiDomainsListServiceConfigurationRecordsRequest
*/
func (a *DomainsDomainDnsRecordApiService) DomainsListServiceConfigurationRecords(ctx _context.Context, domainId string) ApiDomainsListServiceConfigurationRecordsRequest {
	return ApiDomainsListServiceConfigurationRecordsRequest{
		ApiService: a,
		ctx: ctx,
		domainId: domainId,
	}
}

// Execute executes the request
//  @return CollectionOfDomainDnsRecord
func (a *DomainsDomainDnsRecordApiService) DomainsListServiceConfigurationRecordsExecute(r ApiDomainsListServiceConfigurationRecordsRequest) (CollectionOfDomainDnsRecord, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  CollectionOfDomainDnsRecord
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DomainsDomainDnsRecordApiService.DomainsListServiceConfigurationRecords")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/domains/{domain-id}/serviceConfigurationRecords"
	localVarPath = strings.Replace(localVarPath, "{"+"domain-id"+"}", _neturl.PathEscape(parameterToString(r.domainId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.top != nil {
		localVarQueryParams.Add("$top", parameterToString(*r.top, ""))
	}
	if r.skip != nil {
		localVarQueryParams.Add("$skip", parameterToString(*r.skip, ""))
	}
	if r.search != nil {
		localVarQueryParams.Add("$search", parameterToString(*r.search, ""))
	}
	if r.filter != nil {
		localVarQueryParams.Add("$filter", parameterToString(*r.filter, ""))
	}
	if r.count != nil {
		localVarQueryParams.Add("$count", parameterToString(*r.count, ""))
	}
	if r.orderby != nil {
		localVarQueryParams.Add("$orderby", parameterToString(*r.orderby, "csv"))
	}
	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDomainsListVerificationDnsRecordsRequest struct {
	ctx _context.Context
	ApiService *DomainsDomainDnsRecordApiService
	domainId string
	top *int32
	skip *int32
	search *string
	filter *string
	count *bool
	orderby *[]string
	select_ *[]string
	expand *[]string
}

// Show only the first n items
func (r ApiDomainsListVerificationDnsRecordsRequest) Top(top int32) ApiDomainsListVerificationDnsRecordsRequest {
	r.top = &top
	return r
}
// Skip the first n items
func (r ApiDomainsListVerificationDnsRecordsRequest) Skip(skip int32) ApiDomainsListVerificationDnsRecordsRequest {
	r.skip = &skip
	return r
}
// Search items by search phrases
func (r ApiDomainsListVerificationDnsRecordsRequest) Search(search string) ApiDomainsListVerificationDnsRecordsRequest {
	r.search = &search
	return r
}
// Filter items by property values
func (r ApiDomainsListVerificationDnsRecordsRequest) Filter(filter string) ApiDomainsListVerificationDnsRecordsRequest {
	r.filter = &filter
	return r
}
// Include count of items
func (r ApiDomainsListVerificationDnsRecordsRequest) Count(count bool) ApiDomainsListVerificationDnsRecordsRequest {
	r.count = &count
	return r
}
// Order items by property values
func (r ApiDomainsListVerificationDnsRecordsRequest) Orderby(orderby []string) ApiDomainsListVerificationDnsRecordsRequest {
	r.orderby = &orderby
	return r
}
// Select properties to be returned
func (r ApiDomainsListVerificationDnsRecordsRequest) Select_(select_ []string) ApiDomainsListVerificationDnsRecordsRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiDomainsListVerificationDnsRecordsRequest) Expand(expand []string) ApiDomainsListVerificationDnsRecordsRequest {
	r.expand = &expand
	return r
}

func (r ApiDomainsListVerificationDnsRecordsRequest) Execute() (CollectionOfDomainDnsRecord, *_nethttp.Response, error) {
	return r.ApiService.DomainsListVerificationDnsRecordsExecute(r)
}

/*
DomainsListVerificationDnsRecords Get verificationDnsRecords from domains

DNS records that the customer adds to the DNS zone file of the domain before the customer can complete domain ownership verification with Azure AD. Read-only, Nullable

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param domainId key: id of domain
 @return ApiDomainsListVerificationDnsRecordsRequest
*/
func (a *DomainsDomainDnsRecordApiService) DomainsListVerificationDnsRecords(ctx _context.Context, domainId string) ApiDomainsListVerificationDnsRecordsRequest {
	return ApiDomainsListVerificationDnsRecordsRequest{
		ApiService: a,
		ctx: ctx,
		domainId: domainId,
	}
}

// Execute executes the request
//  @return CollectionOfDomainDnsRecord
func (a *DomainsDomainDnsRecordApiService) DomainsListVerificationDnsRecordsExecute(r ApiDomainsListVerificationDnsRecordsRequest) (CollectionOfDomainDnsRecord, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  CollectionOfDomainDnsRecord
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DomainsDomainDnsRecordApiService.DomainsListVerificationDnsRecords")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/domains/{domain-id}/verificationDnsRecords"
	localVarPath = strings.Replace(localVarPath, "{"+"domain-id"+"}", _neturl.PathEscape(parameterToString(r.domainId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.top != nil {
		localVarQueryParams.Add("$top", parameterToString(*r.top, ""))
	}
	if r.skip != nil {
		localVarQueryParams.Add("$skip", parameterToString(*r.skip, ""))
	}
	if r.search != nil {
		localVarQueryParams.Add("$search", parameterToString(*r.search, ""))
	}
	if r.filter != nil {
		localVarQueryParams.Add("$filter", parameterToString(*r.filter, ""))
	}
	if r.count != nil {
		localVarQueryParams.Add("$count", parameterToString(*r.count, ""))
	}
	if r.orderby != nil {
		localVarQueryParams.Add("$orderby", parameterToString(*r.orderby, "csv"))
	}
	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDomainsUpdateServiceConfigurationRecordsRequest struct {
	ctx _context.Context
	ApiService *DomainsDomainDnsRecordApiService
	domainId string
	domainDnsRecordId string
	microsoftGraphDomainDnsRecord *MicrosoftGraphDomainDnsRecord
}

// New navigation property values
func (r ApiDomainsUpdateServiceConfigurationRecordsRequest) MicrosoftGraphDomainDnsRecord(microsoftGraphDomainDnsRecord MicrosoftGraphDomainDnsRecord) ApiDomainsUpdateServiceConfigurationRecordsRequest {
	r.microsoftGraphDomainDnsRecord = &microsoftGraphDomainDnsRecord
	return r
}

func (r ApiDomainsUpdateServiceConfigurationRecordsRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.DomainsUpdateServiceConfigurationRecordsExecute(r)
}

/*
DomainsUpdateServiceConfigurationRecords Update the navigation property serviceConfigurationRecords in domains

DNS records the customer adds to the DNS zone file of the domain before the domain can be used by Microsoft Online services. Read-only, Nullable

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param domainId key: id of domain
 @param domainDnsRecordId key: id of domainDnsRecord
 @return ApiDomainsUpdateServiceConfigurationRecordsRequest
*/
func (a *DomainsDomainDnsRecordApiService) DomainsUpdateServiceConfigurationRecords(ctx _context.Context, domainId string, domainDnsRecordId string) ApiDomainsUpdateServiceConfigurationRecordsRequest {
	return ApiDomainsUpdateServiceConfigurationRecordsRequest{
		ApiService: a,
		ctx: ctx,
		domainId: domainId,
		domainDnsRecordId: domainDnsRecordId,
	}
}

// Execute executes the request
func (a *DomainsDomainDnsRecordApiService) DomainsUpdateServiceConfigurationRecordsExecute(r ApiDomainsUpdateServiceConfigurationRecordsRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPatch
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DomainsDomainDnsRecordApiService.DomainsUpdateServiceConfigurationRecords")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/domains/{domain-id}/serviceConfigurationRecords/{domainDnsRecord-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"domain-id"+"}", _neturl.PathEscape(parameterToString(r.domainId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"domainDnsRecord-id"+"}", _neturl.PathEscape(parameterToString(r.domainDnsRecordId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphDomainDnsRecord == nil {
		return nil, reportError("microsoftGraphDomainDnsRecord is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphDomainDnsRecord
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDomainsUpdateVerificationDnsRecordsRequest struct {
	ctx _context.Context
	ApiService *DomainsDomainDnsRecordApiService
	domainId string
	domainDnsRecordId string
	microsoftGraphDomainDnsRecord *MicrosoftGraphDomainDnsRecord
}

// New navigation property values
func (r ApiDomainsUpdateVerificationDnsRecordsRequest) MicrosoftGraphDomainDnsRecord(microsoftGraphDomainDnsRecord MicrosoftGraphDomainDnsRecord) ApiDomainsUpdateVerificationDnsRecordsRequest {
	r.microsoftGraphDomainDnsRecord = &microsoftGraphDomainDnsRecord
	return r
}

func (r ApiDomainsUpdateVerificationDnsRecordsRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.DomainsUpdateVerificationDnsRecordsExecute(r)
}

/*
DomainsUpdateVerificationDnsRecords Update the navigation property verificationDnsRecords in domains

DNS records that the customer adds to the DNS zone file of the domain before the customer can complete domain ownership verification with Azure AD. Read-only, Nullable

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param domainId key: id of domain
 @param domainDnsRecordId key: id of domainDnsRecord
 @return ApiDomainsUpdateVerificationDnsRecordsRequest
*/
func (a *DomainsDomainDnsRecordApiService) DomainsUpdateVerificationDnsRecords(ctx _context.Context, domainId string, domainDnsRecordId string) ApiDomainsUpdateVerificationDnsRecordsRequest {
	return ApiDomainsUpdateVerificationDnsRecordsRequest{
		ApiService: a,
		ctx: ctx,
		domainId: domainId,
		domainDnsRecordId: domainDnsRecordId,
	}
}

// Execute executes the request
func (a *DomainsDomainDnsRecordApiService) DomainsUpdateVerificationDnsRecordsExecute(r ApiDomainsUpdateVerificationDnsRecordsRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPatch
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DomainsDomainDnsRecordApiService.DomainsUpdateVerificationDnsRecords")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/domains/{domain-id}/verificationDnsRecords/{domainDnsRecord-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"domain-id"+"}", _neturl.PathEscape(parameterToString(r.domainId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"domainDnsRecord-id"+"}", _neturl.PathEscape(parameterToString(r.domainDnsRecordId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphDomainDnsRecord == nil {
		return nil, reportError("microsoftGraphDomainDnsRecord is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphDomainDnsRecord
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}
