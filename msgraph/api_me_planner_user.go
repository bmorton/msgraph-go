/*
Partial Graph API

No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

API version: v1.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package msgraph

import (
	"bytes"
	_context "context"
	_ioutil "io/ioutil"
	_nethttp "net/http"
	_neturl "net/url"
	"strings"
)

// Linger please
var (
	_ _context.Context
)

// MePlannerUserApiService MePlannerUserApi service
type MePlannerUserApiService service

type ApiMeDeletePlannerRequest struct {
	ctx _context.Context
	ApiService *MePlannerUserApiService
	ifMatch *string
}

// ETag
func (r ApiMeDeletePlannerRequest) IfMatch(ifMatch string) ApiMeDeletePlannerRequest {
	r.ifMatch = &ifMatch
	return r
}

func (r ApiMeDeletePlannerRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.MeDeletePlannerExecute(r)
}

/*
MeDeletePlanner Delete navigation property planner for me

Entry-point to the Planner resource that might exist for a user. Read-only.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiMeDeletePlannerRequest
*/
func (a *MePlannerUserApiService) MeDeletePlanner(ctx _context.Context) ApiMeDeletePlannerRequest {
	return ApiMeDeletePlannerRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *MePlannerUserApiService) MeDeletePlannerExecute(r ApiMeDeletePlannerRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MePlannerUserApiService.MeDeletePlanner")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/planner"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ifMatch != nil {
		localVarHeaderParams["If-Match"] = parameterToString(*r.ifMatch, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiMeGetPlannerRequest struct {
	ctx _context.Context
	ApiService *MePlannerUserApiService
	select_ *[]string
	expand *[]string
}

// Select properties to be returned
func (r ApiMeGetPlannerRequest) Select_(select_ []string) ApiMeGetPlannerRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiMeGetPlannerRequest) Expand(expand []string) ApiMeGetPlannerRequest {
	r.expand = &expand
	return r
}

func (r ApiMeGetPlannerRequest) Execute() (MicrosoftGraphPlannerUser, *_nethttp.Response, error) {
	return r.ApiService.MeGetPlannerExecute(r)
}

/*
MeGetPlanner Get planner from me

Entry-point to the Planner resource that might exist for a user. Read-only.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiMeGetPlannerRequest
*/
func (a *MePlannerUserApiService) MeGetPlanner(ctx _context.Context) ApiMeGetPlannerRequest {
	return ApiMeGetPlannerRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return MicrosoftGraphPlannerUser
func (a *MePlannerUserApiService) MeGetPlannerExecute(r ApiMeGetPlannerRequest) (MicrosoftGraphPlannerUser, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphPlannerUser
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MePlannerUserApiService.MeGetPlanner")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/planner"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMePlannerCreatePlansRequest struct {
	ctx _context.Context
	ApiService *MePlannerUserApiService
	microsoftGraphPlannerPlan *MicrosoftGraphPlannerPlan
}

// New navigation property
func (r ApiMePlannerCreatePlansRequest) MicrosoftGraphPlannerPlan(microsoftGraphPlannerPlan MicrosoftGraphPlannerPlan) ApiMePlannerCreatePlansRequest {
	r.microsoftGraphPlannerPlan = &microsoftGraphPlannerPlan
	return r
}

func (r ApiMePlannerCreatePlansRequest) Execute() (MicrosoftGraphPlannerPlan, *_nethttp.Response, error) {
	return r.ApiService.MePlannerCreatePlansExecute(r)
}

/*
MePlannerCreatePlans Create new navigation property to plans for me

Read-only. Nullable. Returns the plannerTasks assigned to the user.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiMePlannerCreatePlansRequest
*/
func (a *MePlannerUserApiService) MePlannerCreatePlans(ctx _context.Context) ApiMePlannerCreatePlansRequest {
	return ApiMePlannerCreatePlansRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return MicrosoftGraphPlannerPlan
func (a *MePlannerUserApiService) MePlannerCreatePlansExecute(r ApiMePlannerCreatePlansRequest) (MicrosoftGraphPlannerPlan, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphPlannerPlan
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MePlannerUserApiService.MePlannerCreatePlans")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/planner/plans"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphPlannerPlan == nil {
		return localVarReturnValue, nil, reportError("microsoftGraphPlannerPlan is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphPlannerPlan
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMePlannerCreateTasksRequest struct {
	ctx _context.Context
	ApiService *MePlannerUserApiService
	microsoftGraphPlannerTask *MicrosoftGraphPlannerTask
}

// New navigation property
func (r ApiMePlannerCreateTasksRequest) MicrosoftGraphPlannerTask(microsoftGraphPlannerTask MicrosoftGraphPlannerTask) ApiMePlannerCreateTasksRequest {
	r.microsoftGraphPlannerTask = &microsoftGraphPlannerTask
	return r
}

func (r ApiMePlannerCreateTasksRequest) Execute() (MicrosoftGraphPlannerTask, *_nethttp.Response, error) {
	return r.ApiService.MePlannerCreateTasksExecute(r)
}

/*
MePlannerCreateTasks Create new navigation property to tasks for me

Read-only. Nullable. Returns the plannerPlans shared with the user.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiMePlannerCreateTasksRequest
*/
func (a *MePlannerUserApiService) MePlannerCreateTasks(ctx _context.Context) ApiMePlannerCreateTasksRequest {
	return ApiMePlannerCreateTasksRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return MicrosoftGraphPlannerTask
func (a *MePlannerUserApiService) MePlannerCreateTasksExecute(r ApiMePlannerCreateTasksRequest) (MicrosoftGraphPlannerTask, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphPlannerTask
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MePlannerUserApiService.MePlannerCreateTasks")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/planner/tasks"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphPlannerTask == nil {
		return localVarReturnValue, nil, reportError("microsoftGraphPlannerTask is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphPlannerTask
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMePlannerDeletePlansRequest struct {
	ctx _context.Context
	ApiService *MePlannerUserApiService
	plannerPlanId string
	ifMatch *string
}

// ETag
func (r ApiMePlannerDeletePlansRequest) IfMatch(ifMatch string) ApiMePlannerDeletePlansRequest {
	r.ifMatch = &ifMatch
	return r
}

func (r ApiMePlannerDeletePlansRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.MePlannerDeletePlansExecute(r)
}

/*
MePlannerDeletePlans Delete navigation property plans for me

Read-only. Nullable. Returns the plannerTasks assigned to the user.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param plannerPlanId key: id of plannerPlan
 @return ApiMePlannerDeletePlansRequest
*/
func (a *MePlannerUserApiService) MePlannerDeletePlans(ctx _context.Context, plannerPlanId string) ApiMePlannerDeletePlansRequest {
	return ApiMePlannerDeletePlansRequest{
		ApiService: a,
		ctx: ctx,
		plannerPlanId: plannerPlanId,
	}
}

// Execute executes the request
func (a *MePlannerUserApiService) MePlannerDeletePlansExecute(r ApiMePlannerDeletePlansRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MePlannerUserApiService.MePlannerDeletePlans")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/planner/plans/{plannerPlan-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"plannerPlan-id"+"}", _neturl.PathEscape(parameterToString(r.plannerPlanId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ifMatch != nil {
		localVarHeaderParams["If-Match"] = parameterToString(*r.ifMatch, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiMePlannerDeleteTasksRequest struct {
	ctx _context.Context
	ApiService *MePlannerUserApiService
	plannerTaskId string
	ifMatch *string
}

// ETag
func (r ApiMePlannerDeleteTasksRequest) IfMatch(ifMatch string) ApiMePlannerDeleteTasksRequest {
	r.ifMatch = &ifMatch
	return r
}

func (r ApiMePlannerDeleteTasksRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.MePlannerDeleteTasksExecute(r)
}

/*
MePlannerDeleteTasks Delete navigation property tasks for me

Read-only. Nullable. Returns the plannerPlans shared with the user.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param plannerTaskId key: id of plannerTask
 @return ApiMePlannerDeleteTasksRequest
*/
func (a *MePlannerUserApiService) MePlannerDeleteTasks(ctx _context.Context, plannerTaskId string) ApiMePlannerDeleteTasksRequest {
	return ApiMePlannerDeleteTasksRequest{
		ApiService: a,
		ctx: ctx,
		plannerTaskId: plannerTaskId,
	}
}

// Execute executes the request
func (a *MePlannerUserApiService) MePlannerDeleteTasksExecute(r ApiMePlannerDeleteTasksRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MePlannerUserApiService.MePlannerDeleteTasks")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/planner/tasks/{plannerTask-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"plannerTask-id"+"}", _neturl.PathEscape(parameterToString(r.plannerTaskId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ifMatch != nil {
		localVarHeaderParams["If-Match"] = parameterToString(*r.ifMatch, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiMePlannerGetPlansRequest struct {
	ctx _context.Context
	ApiService *MePlannerUserApiService
	plannerPlanId string
	select_ *[]string
	expand *[]string
}

// Select properties to be returned
func (r ApiMePlannerGetPlansRequest) Select_(select_ []string) ApiMePlannerGetPlansRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiMePlannerGetPlansRequest) Expand(expand []string) ApiMePlannerGetPlansRequest {
	r.expand = &expand
	return r
}

func (r ApiMePlannerGetPlansRequest) Execute() (MicrosoftGraphPlannerPlan, *_nethttp.Response, error) {
	return r.ApiService.MePlannerGetPlansExecute(r)
}

/*
MePlannerGetPlans Get plans from me

Read-only. Nullable. Returns the plannerTasks assigned to the user.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param plannerPlanId key: id of plannerPlan
 @return ApiMePlannerGetPlansRequest
*/
func (a *MePlannerUserApiService) MePlannerGetPlans(ctx _context.Context, plannerPlanId string) ApiMePlannerGetPlansRequest {
	return ApiMePlannerGetPlansRequest{
		ApiService: a,
		ctx: ctx,
		plannerPlanId: plannerPlanId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphPlannerPlan
func (a *MePlannerUserApiService) MePlannerGetPlansExecute(r ApiMePlannerGetPlansRequest) (MicrosoftGraphPlannerPlan, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphPlannerPlan
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MePlannerUserApiService.MePlannerGetPlans")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/planner/plans/{plannerPlan-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"plannerPlan-id"+"}", _neturl.PathEscape(parameterToString(r.plannerPlanId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMePlannerGetTasksRequest struct {
	ctx _context.Context
	ApiService *MePlannerUserApiService
	plannerTaskId string
	select_ *[]string
	expand *[]string
}

// Select properties to be returned
func (r ApiMePlannerGetTasksRequest) Select_(select_ []string) ApiMePlannerGetTasksRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiMePlannerGetTasksRequest) Expand(expand []string) ApiMePlannerGetTasksRequest {
	r.expand = &expand
	return r
}

func (r ApiMePlannerGetTasksRequest) Execute() (MicrosoftGraphPlannerTask, *_nethttp.Response, error) {
	return r.ApiService.MePlannerGetTasksExecute(r)
}

/*
MePlannerGetTasks Get tasks from me

Read-only. Nullable. Returns the plannerPlans shared with the user.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param plannerTaskId key: id of plannerTask
 @return ApiMePlannerGetTasksRequest
*/
func (a *MePlannerUserApiService) MePlannerGetTasks(ctx _context.Context, plannerTaskId string) ApiMePlannerGetTasksRequest {
	return ApiMePlannerGetTasksRequest{
		ApiService: a,
		ctx: ctx,
		plannerTaskId: plannerTaskId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphPlannerTask
func (a *MePlannerUserApiService) MePlannerGetTasksExecute(r ApiMePlannerGetTasksRequest) (MicrosoftGraphPlannerTask, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphPlannerTask
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MePlannerUserApiService.MePlannerGetTasks")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/planner/tasks/{plannerTask-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"plannerTask-id"+"}", _neturl.PathEscape(parameterToString(r.plannerTaskId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMePlannerListPlansRequest struct {
	ctx _context.Context
	ApiService *MePlannerUserApiService
	top *int32
	skip *int32
	search *string
	filter *string
	count *bool
	orderby *[]string
	select_ *[]string
	expand *[]string
}

// Show only the first n items
func (r ApiMePlannerListPlansRequest) Top(top int32) ApiMePlannerListPlansRequest {
	r.top = &top
	return r
}
// Skip the first n items
func (r ApiMePlannerListPlansRequest) Skip(skip int32) ApiMePlannerListPlansRequest {
	r.skip = &skip
	return r
}
// Search items by search phrases
func (r ApiMePlannerListPlansRequest) Search(search string) ApiMePlannerListPlansRequest {
	r.search = &search
	return r
}
// Filter items by property values
func (r ApiMePlannerListPlansRequest) Filter(filter string) ApiMePlannerListPlansRequest {
	r.filter = &filter
	return r
}
// Include count of items
func (r ApiMePlannerListPlansRequest) Count(count bool) ApiMePlannerListPlansRequest {
	r.count = &count
	return r
}
// Order items by property values
func (r ApiMePlannerListPlansRequest) Orderby(orderby []string) ApiMePlannerListPlansRequest {
	r.orderby = &orderby
	return r
}
// Select properties to be returned
func (r ApiMePlannerListPlansRequest) Select_(select_ []string) ApiMePlannerListPlansRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiMePlannerListPlansRequest) Expand(expand []string) ApiMePlannerListPlansRequest {
	r.expand = &expand
	return r
}

func (r ApiMePlannerListPlansRequest) Execute() (CollectionOfPlannerPlan, *_nethttp.Response, error) {
	return r.ApiService.MePlannerListPlansExecute(r)
}

/*
MePlannerListPlans Get plans from me

Read-only. Nullable. Returns the plannerTasks assigned to the user.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiMePlannerListPlansRequest
*/
func (a *MePlannerUserApiService) MePlannerListPlans(ctx _context.Context) ApiMePlannerListPlansRequest {
	return ApiMePlannerListPlansRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CollectionOfPlannerPlan
func (a *MePlannerUserApiService) MePlannerListPlansExecute(r ApiMePlannerListPlansRequest) (CollectionOfPlannerPlan, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  CollectionOfPlannerPlan
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MePlannerUserApiService.MePlannerListPlans")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/planner/plans"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.top != nil {
		localVarQueryParams.Add("$top", parameterToString(*r.top, ""))
	}
	if r.skip != nil {
		localVarQueryParams.Add("$skip", parameterToString(*r.skip, ""))
	}
	if r.search != nil {
		localVarQueryParams.Add("$search", parameterToString(*r.search, ""))
	}
	if r.filter != nil {
		localVarQueryParams.Add("$filter", parameterToString(*r.filter, ""))
	}
	if r.count != nil {
		localVarQueryParams.Add("$count", parameterToString(*r.count, ""))
	}
	if r.orderby != nil {
		localVarQueryParams.Add("$orderby", parameterToString(*r.orderby, "csv"))
	}
	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMePlannerListTasksRequest struct {
	ctx _context.Context
	ApiService *MePlannerUserApiService
	top *int32
	skip *int32
	search *string
	filter *string
	count *bool
	orderby *[]string
	select_ *[]string
	expand *[]string
}

// Show only the first n items
func (r ApiMePlannerListTasksRequest) Top(top int32) ApiMePlannerListTasksRequest {
	r.top = &top
	return r
}
// Skip the first n items
func (r ApiMePlannerListTasksRequest) Skip(skip int32) ApiMePlannerListTasksRequest {
	r.skip = &skip
	return r
}
// Search items by search phrases
func (r ApiMePlannerListTasksRequest) Search(search string) ApiMePlannerListTasksRequest {
	r.search = &search
	return r
}
// Filter items by property values
func (r ApiMePlannerListTasksRequest) Filter(filter string) ApiMePlannerListTasksRequest {
	r.filter = &filter
	return r
}
// Include count of items
func (r ApiMePlannerListTasksRequest) Count(count bool) ApiMePlannerListTasksRequest {
	r.count = &count
	return r
}
// Order items by property values
func (r ApiMePlannerListTasksRequest) Orderby(orderby []string) ApiMePlannerListTasksRequest {
	r.orderby = &orderby
	return r
}
// Select properties to be returned
func (r ApiMePlannerListTasksRequest) Select_(select_ []string) ApiMePlannerListTasksRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiMePlannerListTasksRequest) Expand(expand []string) ApiMePlannerListTasksRequest {
	r.expand = &expand
	return r
}

func (r ApiMePlannerListTasksRequest) Execute() (CollectionOfPlannerTask, *_nethttp.Response, error) {
	return r.ApiService.MePlannerListTasksExecute(r)
}

/*
MePlannerListTasks Get tasks from me

Read-only. Nullable. Returns the plannerPlans shared with the user.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiMePlannerListTasksRequest
*/
func (a *MePlannerUserApiService) MePlannerListTasks(ctx _context.Context) ApiMePlannerListTasksRequest {
	return ApiMePlannerListTasksRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CollectionOfPlannerTask
func (a *MePlannerUserApiService) MePlannerListTasksExecute(r ApiMePlannerListTasksRequest) (CollectionOfPlannerTask, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  CollectionOfPlannerTask
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MePlannerUserApiService.MePlannerListTasks")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/planner/tasks"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.top != nil {
		localVarQueryParams.Add("$top", parameterToString(*r.top, ""))
	}
	if r.skip != nil {
		localVarQueryParams.Add("$skip", parameterToString(*r.skip, ""))
	}
	if r.search != nil {
		localVarQueryParams.Add("$search", parameterToString(*r.search, ""))
	}
	if r.filter != nil {
		localVarQueryParams.Add("$filter", parameterToString(*r.filter, ""))
	}
	if r.count != nil {
		localVarQueryParams.Add("$count", parameterToString(*r.count, ""))
	}
	if r.orderby != nil {
		localVarQueryParams.Add("$orderby", parameterToString(*r.orderby, "csv"))
	}
	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMePlannerPlansBucketsCreateTasksRequest struct {
	ctx _context.Context
	ApiService *MePlannerUserApiService
	plannerPlanId string
	plannerBucketId string
	microsoftGraphPlannerTask *MicrosoftGraphPlannerTask
}

// New navigation property
func (r ApiMePlannerPlansBucketsCreateTasksRequest) MicrosoftGraphPlannerTask(microsoftGraphPlannerTask MicrosoftGraphPlannerTask) ApiMePlannerPlansBucketsCreateTasksRequest {
	r.microsoftGraphPlannerTask = &microsoftGraphPlannerTask
	return r
}

func (r ApiMePlannerPlansBucketsCreateTasksRequest) Execute() (MicrosoftGraphPlannerTask, *_nethttp.Response, error) {
	return r.ApiService.MePlannerPlansBucketsCreateTasksExecute(r)
}

/*
MePlannerPlansBucketsCreateTasks Create new navigation property to tasks for me

Read-only. Nullable. The collection of tasks in the bucket.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param plannerPlanId key: id of plannerPlan
 @param plannerBucketId key: id of plannerBucket
 @return ApiMePlannerPlansBucketsCreateTasksRequest
*/
func (a *MePlannerUserApiService) MePlannerPlansBucketsCreateTasks(ctx _context.Context, plannerPlanId string, plannerBucketId string) ApiMePlannerPlansBucketsCreateTasksRequest {
	return ApiMePlannerPlansBucketsCreateTasksRequest{
		ApiService: a,
		ctx: ctx,
		plannerPlanId: plannerPlanId,
		plannerBucketId: plannerBucketId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphPlannerTask
func (a *MePlannerUserApiService) MePlannerPlansBucketsCreateTasksExecute(r ApiMePlannerPlansBucketsCreateTasksRequest) (MicrosoftGraphPlannerTask, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphPlannerTask
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MePlannerUserApiService.MePlannerPlansBucketsCreateTasks")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/planner/plans/{plannerPlan-id}/buckets/{plannerBucket-id}/tasks"
	localVarPath = strings.Replace(localVarPath, "{"+"plannerPlan-id"+"}", _neturl.PathEscape(parameterToString(r.plannerPlanId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"plannerBucket-id"+"}", _neturl.PathEscape(parameterToString(r.plannerBucketId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphPlannerTask == nil {
		return localVarReturnValue, nil, reportError("microsoftGraphPlannerTask is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphPlannerTask
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMePlannerPlansBucketsDeleteTasksRequest struct {
	ctx _context.Context
	ApiService *MePlannerUserApiService
	plannerPlanId string
	plannerBucketId string
	plannerTaskId string
	ifMatch *string
}

// ETag
func (r ApiMePlannerPlansBucketsDeleteTasksRequest) IfMatch(ifMatch string) ApiMePlannerPlansBucketsDeleteTasksRequest {
	r.ifMatch = &ifMatch
	return r
}

func (r ApiMePlannerPlansBucketsDeleteTasksRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.MePlannerPlansBucketsDeleteTasksExecute(r)
}

/*
MePlannerPlansBucketsDeleteTasks Delete navigation property tasks for me

Read-only. Nullable. The collection of tasks in the bucket.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param plannerPlanId key: id of plannerPlan
 @param plannerBucketId key: id of plannerBucket
 @param plannerTaskId key: id of plannerTask
 @return ApiMePlannerPlansBucketsDeleteTasksRequest
*/
func (a *MePlannerUserApiService) MePlannerPlansBucketsDeleteTasks(ctx _context.Context, plannerPlanId string, plannerBucketId string, plannerTaskId string) ApiMePlannerPlansBucketsDeleteTasksRequest {
	return ApiMePlannerPlansBucketsDeleteTasksRequest{
		ApiService: a,
		ctx: ctx,
		plannerPlanId: plannerPlanId,
		plannerBucketId: plannerBucketId,
		plannerTaskId: plannerTaskId,
	}
}

// Execute executes the request
func (a *MePlannerUserApiService) MePlannerPlansBucketsDeleteTasksExecute(r ApiMePlannerPlansBucketsDeleteTasksRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MePlannerUserApiService.MePlannerPlansBucketsDeleteTasks")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/planner/plans/{plannerPlan-id}/buckets/{plannerBucket-id}/tasks/{plannerTask-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"plannerPlan-id"+"}", _neturl.PathEscape(parameterToString(r.plannerPlanId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"plannerBucket-id"+"}", _neturl.PathEscape(parameterToString(r.plannerBucketId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"plannerTask-id"+"}", _neturl.PathEscape(parameterToString(r.plannerTaskId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ifMatch != nil {
		localVarHeaderParams["If-Match"] = parameterToString(*r.ifMatch, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiMePlannerPlansBucketsGetTasksRequest struct {
	ctx _context.Context
	ApiService *MePlannerUserApiService
	plannerPlanId string
	plannerBucketId string
	plannerTaskId string
	select_ *[]string
	expand *[]string
}

// Select properties to be returned
func (r ApiMePlannerPlansBucketsGetTasksRequest) Select_(select_ []string) ApiMePlannerPlansBucketsGetTasksRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiMePlannerPlansBucketsGetTasksRequest) Expand(expand []string) ApiMePlannerPlansBucketsGetTasksRequest {
	r.expand = &expand
	return r
}

func (r ApiMePlannerPlansBucketsGetTasksRequest) Execute() (MicrosoftGraphPlannerTask, *_nethttp.Response, error) {
	return r.ApiService.MePlannerPlansBucketsGetTasksExecute(r)
}

/*
MePlannerPlansBucketsGetTasks Get tasks from me

Read-only. Nullable. The collection of tasks in the bucket.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param plannerPlanId key: id of plannerPlan
 @param plannerBucketId key: id of plannerBucket
 @param plannerTaskId key: id of plannerTask
 @return ApiMePlannerPlansBucketsGetTasksRequest
*/
func (a *MePlannerUserApiService) MePlannerPlansBucketsGetTasks(ctx _context.Context, plannerPlanId string, plannerBucketId string, plannerTaskId string) ApiMePlannerPlansBucketsGetTasksRequest {
	return ApiMePlannerPlansBucketsGetTasksRequest{
		ApiService: a,
		ctx: ctx,
		plannerPlanId: plannerPlanId,
		plannerBucketId: plannerBucketId,
		plannerTaskId: plannerTaskId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphPlannerTask
func (a *MePlannerUserApiService) MePlannerPlansBucketsGetTasksExecute(r ApiMePlannerPlansBucketsGetTasksRequest) (MicrosoftGraphPlannerTask, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphPlannerTask
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MePlannerUserApiService.MePlannerPlansBucketsGetTasks")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/planner/plans/{plannerPlan-id}/buckets/{plannerBucket-id}/tasks/{plannerTask-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"plannerPlan-id"+"}", _neturl.PathEscape(parameterToString(r.plannerPlanId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"plannerBucket-id"+"}", _neturl.PathEscape(parameterToString(r.plannerBucketId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"plannerTask-id"+"}", _neturl.PathEscape(parameterToString(r.plannerTaskId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMePlannerPlansBucketsListTasksRequest struct {
	ctx _context.Context
	ApiService *MePlannerUserApiService
	plannerPlanId string
	plannerBucketId string
	top *int32
	skip *int32
	search *string
	filter *string
	count *bool
	orderby *[]string
	select_ *[]string
	expand *[]string
}

// Show only the first n items
func (r ApiMePlannerPlansBucketsListTasksRequest) Top(top int32) ApiMePlannerPlansBucketsListTasksRequest {
	r.top = &top
	return r
}
// Skip the first n items
func (r ApiMePlannerPlansBucketsListTasksRequest) Skip(skip int32) ApiMePlannerPlansBucketsListTasksRequest {
	r.skip = &skip
	return r
}
// Search items by search phrases
func (r ApiMePlannerPlansBucketsListTasksRequest) Search(search string) ApiMePlannerPlansBucketsListTasksRequest {
	r.search = &search
	return r
}
// Filter items by property values
func (r ApiMePlannerPlansBucketsListTasksRequest) Filter(filter string) ApiMePlannerPlansBucketsListTasksRequest {
	r.filter = &filter
	return r
}
// Include count of items
func (r ApiMePlannerPlansBucketsListTasksRequest) Count(count bool) ApiMePlannerPlansBucketsListTasksRequest {
	r.count = &count
	return r
}
// Order items by property values
func (r ApiMePlannerPlansBucketsListTasksRequest) Orderby(orderby []string) ApiMePlannerPlansBucketsListTasksRequest {
	r.orderby = &orderby
	return r
}
// Select properties to be returned
func (r ApiMePlannerPlansBucketsListTasksRequest) Select_(select_ []string) ApiMePlannerPlansBucketsListTasksRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiMePlannerPlansBucketsListTasksRequest) Expand(expand []string) ApiMePlannerPlansBucketsListTasksRequest {
	r.expand = &expand
	return r
}

func (r ApiMePlannerPlansBucketsListTasksRequest) Execute() (CollectionOfPlannerTask, *_nethttp.Response, error) {
	return r.ApiService.MePlannerPlansBucketsListTasksExecute(r)
}

/*
MePlannerPlansBucketsListTasks Get tasks from me

Read-only. Nullable. The collection of tasks in the bucket.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param plannerPlanId key: id of plannerPlan
 @param plannerBucketId key: id of plannerBucket
 @return ApiMePlannerPlansBucketsListTasksRequest
*/
func (a *MePlannerUserApiService) MePlannerPlansBucketsListTasks(ctx _context.Context, plannerPlanId string, plannerBucketId string) ApiMePlannerPlansBucketsListTasksRequest {
	return ApiMePlannerPlansBucketsListTasksRequest{
		ApiService: a,
		ctx: ctx,
		plannerPlanId: plannerPlanId,
		plannerBucketId: plannerBucketId,
	}
}

// Execute executes the request
//  @return CollectionOfPlannerTask
func (a *MePlannerUserApiService) MePlannerPlansBucketsListTasksExecute(r ApiMePlannerPlansBucketsListTasksRequest) (CollectionOfPlannerTask, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  CollectionOfPlannerTask
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MePlannerUserApiService.MePlannerPlansBucketsListTasks")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/planner/plans/{plannerPlan-id}/buckets/{plannerBucket-id}/tasks"
	localVarPath = strings.Replace(localVarPath, "{"+"plannerPlan-id"+"}", _neturl.PathEscape(parameterToString(r.plannerPlanId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"plannerBucket-id"+"}", _neturl.PathEscape(parameterToString(r.plannerBucketId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.top != nil {
		localVarQueryParams.Add("$top", parameterToString(*r.top, ""))
	}
	if r.skip != nil {
		localVarQueryParams.Add("$skip", parameterToString(*r.skip, ""))
	}
	if r.search != nil {
		localVarQueryParams.Add("$search", parameterToString(*r.search, ""))
	}
	if r.filter != nil {
		localVarQueryParams.Add("$filter", parameterToString(*r.filter, ""))
	}
	if r.count != nil {
		localVarQueryParams.Add("$count", parameterToString(*r.count, ""))
	}
	if r.orderby != nil {
		localVarQueryParams.Add("$orderby", parameterToString(*r.orderby, "csv"))
	}
	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMePlannerPlansBucketsTasksDeleteAssignedToTaskBoardFormatRequest struct {
	ctx _context.Context
	ApiService *MePlannerUserApiService
	plannerPlanId string
	plannerBucketId string
	plannerTaskId string
	ifMatch *string
}

// ETag
func (r ApiMePlannerPlansBucketsTasksDeleteAssignedToTaskBoardFormatRequest) IfMatch(ifMatch string) ApiMePlannerPlansBucketsTasksDeleteAssignedToTaskBoardFormatRequest {
	r.ifMatch = &ifMatch
	return r
}

func (r ApiMePlannerPlansBucketsTasksDeleteAssignedToTaskBoardFormatRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.MePlannerPlansBucketsTasksDeleteAssignedToTaskBoardFormatExecute(r)
}

/*
MePlannerPlansBucketsTasksDeleteAssignedToTaskBoardFormat Delete navigation property assignedToTaskBoardFormat for me

Read-only. Nullable. Used to render the task correctly in the task board view when grouped by assignedTo.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param plannerPlanId key: id of plannerPlan
 @param plannerBucketId key: id of plannerBucket
 @param plannerTaskId key: id of plannerTask
 @return ApiMePlannerPlansBucketsTasksDeleteAssignedToTaskBoardFormatRequest
*/
func (a *MePlannerUserApiService) MePlannerPlansBucketsTasksDeleteAssignedToTaskBoardFormat(ctx _context.Context, plannerPlanId string, plannerBucketId string, plannerTaskId string) ApiMePlannerPlansBucketsTasksDeleteAssignedToTaskBoardFormatRequest {
	return ApiMePlannerPlansBucketsTasksDeleteAssignedToTaskBoardFormatRequest{
		ApiService: a,
		ctx: ctx,
		plannerPlanId: plannerPlanId,
		plannerBucketId: plannerBucketId,
		plannerTaskId: plannerTaskId,
	}
}

// Execute executes the request
func (a *MePlannerUserApiService) MePlannerPlansBucketsTasksDeleteAssignedToTaskBoardFormatExecute(r ApiMePlannerPlansBucketsTasksDeleteAssignedToTaskBoardFormatRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MePlannerUserApiService.MePlannerPlansBucketsTasksDeleteAssignedToTaskBoardFormat")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/planner/plans/{plannerPlan-id}/buckets/{plannerBucket-id}/tasks/{plannerTask-id}/assignedToTaskBoardFormat"
	localVarPath = strings.Replace(localVarPath, "{"+"plannerPlan-id"+"}", _neturl.PathEscape(parameterToString(r.plannerPlanId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"plannerBucket-id"+"}", _neturl.PathEscape(parameterToString(r.plannerBucketId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"plannerTask-id"+"}", _neturl.PathEscape(parameterToString(r.plannerTaskId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ifMatch != nil {
		localVarHeaderParams["If-Match"] = parameterToString(*r.ifMatch, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiMePlannerPlansBucketsTasksDeleteBucketTaskBoardFormatRequest struct {
	ctx _context.Context
	ApiService *MePlannerUserApiService
	plannerPlanId string
	plannerBucketId string
	plannerTaskId string
	ifMatch *string
}

// ETag
func (r ApiMePlannerPlansBucketsTasksDeleteBucketTaskBoardFormatRequest) IfMatch(ifMatch string) ApiMePlannerPlansBucketsTasksDeleteBucketTaskBoardFormatRequest {
	r.ifMatch = &ifMatch
	return r
}

func (r ApiMePlannerPlansBucketsTasksDeleteBucketTaskBoardFormatRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.MePlannerPlansBucketsTasksDeleteBucketTaskBoardFormatExecute(r)
}

/*
MePlannerPlansBucketsTasksDeleteBucketTaskBoardFormat Delete navigation property bucketTaskBoardFormat for me

Read-only. Nullable. Used to render the task correctly in the task board view when grouped by bucket.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param plannerPlanId key: id of plannerPlan
 @param plannerBucketId key: id of plannerBucket
 @param plannerTaskId key: id of plannerTask
 @return ApiMePlannerPlansBucketsTasksDeleteBucketTaskBoardFormatRequest
*/
func (a *MePlannerUserApiService) MePlannerPlansBucketsTasksDeleteBucketTaskBoardFormat(ctx _context.Context, plannerPlanId string, plannerBucketId string, plannerTaskId string) ApiMePlannerPlansBucketsTasksDeleteBucketTaskBoardFormatRequest {
	return ApiMePlannerPlansBucketsTasksDeleteBucketTaskBoardFormatRequest{
		ApiService: a,
		ctx: ctx,
		plannerPlanId: plannerPlanId,
		plannerBucketId: plannerBucketId,
		plannerTaskId: plannerTaskId,
	}
}

// Execute executes the request
func (a *MePlannerUserApiService) MePlannerPlansBucketsTasksDeleteBucketTaskBoardFormatExecute(r ApiMePlannerPlansBucketsTasksDeleteBucketTaskBoardFormatRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MePlannerUserApiService.MePlannerPlansBucketsTasksDeleteBucketTaskBoardFormat")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/planner/plans/{plannerPlan-id}/buckets/{plannerBucket-id}/tasks/{plannerTask-id}/bucketTaskBoardFormat"
	localVarPath = strings.Replace(localVarPath, "{"+"plannerPlan-id"+"}", _neturl.PathEscape(parameterToString(r.plannerPlanId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"plannerBucket-id"+"}", _neturl.PathEscape(parameterToString(r.plannerBucketId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"plannerTask-id"+"}", _neturl.PathEscape(parameterToString(r.plannerTaskId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ifMatch != nil {
		localVarHeaderParams["If-Match"] = parameterToString(*r.ifMatch, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiMePlannerPlansBucketsTasksDeleteDetailsRequest struct {
	ctx _context.Context
	ApiService *MePlannerUserApiService
	plannerPlanId string
	plannerBucketId string
	plannerTaskId string
	ifMatch *string
}

// ETag
func (r ApiMePlannerPlansBucketsTasksDeleteDetailsRequest) IfMatch(ifMatch string) ApiMePlannerPlansBucketsTasksDeleteDetailsRequest {
	r.ifMatch = &ifMatch
	return r
}

func (r ApiMePlannerPlansBucketsTasksDeleteDetailsRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.MePlannerPlansBucketsTasksDeleteDetailsExecute(r)
}

/*
MePlannerPlansBucketsTasksDeleteDetails Delete navigation property details for me

Read-only. Nullable. Additional details about the task.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param plannerPlanId key: id of plannerPlan
 @param plannerBucketId key: id of plannerBucket
 @param plannerTaskId key: id of plannerTask
 @return ApiMePlannerPlansBucketsTasksDeleteDetailsRequest
*/
func (a *MePlannerUserApiService) MePlannerPlansBucketsTasksDeleteDetails(ctx _context.Context, plannerPlanId string, plannerBucketId string, plannerTaskId string) ApiMePlannerPlansBucketsTasksDeleteDetailsRequest {
	return ApiMePlannerPlansBucketsTasksDeleteDetailsRequest{
		ApiService: a,
		ctx: ctx,
		plannerPlanId: plannerPlanId,
		plannerBucketId: plannerBucketId,
		plannerTaskId: plannerTaskId,
	}
}

// Execute executes the request
func (a *MePlannerUserApiService) MePlannerPlansBucketsTasksDeleteDetailsExecute(r ApiMePlannerPlansBucketsTasksDeleteDetailsRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MePlannerUserApiService.MePlannerPlansBucketsTasksDeleteDetails")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/planner/plans/{plannerPlan-id}/buckets/{plannerBucket-id}/tasks/{plannerTask-id}/details"
	localVarPath = strings.Replace(localVarPath, "{"+"plannerPlan-id"+"}", _neturl.PathEscape(parameterToString(r.plannerPlanId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"plannerBucket-id"+"}", _neturl.PathEscape(parameterToString(r.plannerBucketId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"plannerTask-id"+"}", _neturl.PathEscape(parameterToString(r.plannerTaskId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ifMatch != nil {
		localVarHeaderParams["If-Match"] = parameterToString(*r.ifMatch, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiMePlannerPlansBucketsTasksDeleteProgressTaskBoardFormatRequest struct {
	ctx _context.Context
	ApiService *MePlannerUserApiService
	plannerPlanId string
	plannerBucketId string
	plannerTaskId string
	ifMatch *string
}

// ETag
func (r ApiMePlannerPlansBucketsTasksDeleteProgressTaskBoardFormatRequest) IfMatch(ifMatch string) ApiMePlannerPlansBucketsTasksDeleteProgressTaskBoardFormatRequest {
	r.ifMatch = &ifMatch
	return r
}

func (r ApiMePlannerPlansBucketsTasksDeleteProgressTaskBoardFormatRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.MePlannerPlansBucketsTasksDeleteProgressTaskBoardFormatExecute(r)
}

/*
MePlannerPlansBucketsTasksDeleteProgressTaskBoardFormat Delete navigation property progressTaskBoardFormat for me

Read-only. Nullable. Used to render the task correctly in the task board view when grouped by progress.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param plannerPlanId key: id of plannerPlan
 @param plannerBucketId key: id of plannerBucket
 @param plannerTaskId key: id of plannerTask
 @return ApiMePlannerPlansBucketsTasksDeleteProgressTaskBoardFormatRequest
*/
func (a *MePlannerUserApiService) MePlannerPlansBucketsTasksDeleteProgressTaskBoardFormat(ctx _context.Context, plannerPlanId string, plannerBucketId string, plannerTaskId string) ApiMePlannerPlansBucketsTasksDeleteProgressTaskBoardFormatRequest {
	return ApiMePlannerPlansBucketsTasksDeleteProgressTaskBoardFormatRequest{
		ApiService: a,
		ctx: ctx,
		plannerPlanId: plannerPlanId,
		plannerBucketId: plannerBucketId,
		plannerTaskId: plannerTaskId,
	}
}

// Execute executes the request
func (a *MePlannerUserApiService) MePlannerPlansBucketsTasksDeleteProgressTaskBoardFormatExecute(r ApiMePlannerPlansBucketsTasksDeleteProgressTaskBoardFormatRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MePlannerUserApiService.MePlannerPlansBucketsTasksDeleteProgressTaskBoardFormat")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/planner/plans/{plannerPlan-id}/buckets/{plannerBucket-id}/tasks/{plannerTask-id}/progressTaskBoardFormat"
	localVarPath = strings.Replace(localVarPath, "{"+"plannerPlan-id"+"}", _neturl.PathEscape(parameterToString(r.plannerPlanId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"plannerBucket-id"+"}", _neturl.PathEscape(parameterToString(r.plannerBucketId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"plannerTask-id"+"}", _neturl.PathEscape(parameterToString(r.plannerTaskId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ifMatch != nil {
		localVarHeaderParams["If-Match"] = parameterToString(*r.ifMatch, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiMePlannerPlansBucketsTasksGetAssignedToTaskBoardFormatRequest struct {
	ctx _context.Context
	ApiService *MePlannerUserApiService
	plannerPlanId string
	plannerBucketId string
	plannerTaskId string
	select_ *[]string
	expand *[]string
}

// Select properties to be returned
func (r ApiMePlannerPlansBucketsTasksGetAssignedToTaskBoardFormatRequest) Select_(select_ []string) ApiMePlannerPlansBucketsTasksGetAssignedToTaskBoardFormatRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiMePlannerPlansBucketsTasksGetAssignedToTaskBoardFormatRequest) Expand(expand []string) ApiMePlannerPlansBucketsTasksGetAssignedToTaskBoardFormatRequest {
	r.expand = &expand
	return r
}

func (r ApiMePlannerPlansBucketsTasksGetAssignedToTaskBoardFormatRequest) Execute() (MicrosoftGraphPlannerAssignedToTaskBoardTaskFormat, *_nethttp.Response, error) {
	return r.ApiService.MePlannerPlansBucketsTasksGetAssignedToTaskBoardFormatExecute(r)
}

/*
MePlannerPlansBucketsTasksGetAssignedToTaskBoardFormat Get assignedToTaskBoardFormat from me

Read-only. Nullable. Used to render the task correctly in the task board view when grouped by assignedTo.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param plannerPlanId key: id of plannerPlan
 @param plannerBucketId key: id of plannerBucket
 @param plannerTaskId key: id of plannerTask
 @return ApiMePlannerPlansBucketsTasksGetAssignedToTaskBoardFormatRequest
*/
func (a *MePlannerUserApiService) MePlannerPlansBucketsTasksGetAssignedToTaskBoardFormat(ctx _context.Context, plannerPlanId string, plannerBucketId string, plannerTaskId string) ApiMePlannerPlansBucketsTasksGetAssignedToTaskBoardFormatRequest {
	return ApiMePlannerPlansBucketsTasksGetAssignedToTaskBoardFormatRequest{
		ApiService: a,
		ctx: ctx,
		plannerPlanId: plannerPlanId,
		plannerBucketId: plannerBucketId,
		plannerTaskId: plannerTaskId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphPlannerAssignedToTaskBoardTaskFormat
func (a *MePlannerUserApiService) MePlannerPlansBucketsTasksGetAssignedToTaskBoardFormatExecute(r ApiMePlannerPlansBucketsTasksGetAssignedToTaskBoardFormatRequest) (MicrosoftGraphPlannerAssignedToTaskBoardTaskFormat, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphPlannerAssignedToTaskBoardTaskFormat
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MePlannerUserApiService.MePlannerPlansBucketsTasksGetAssignedToTaskBoardFormat")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/planner/plans/{plannerPlan-id}/buckets/{plannerBucket-id}/tasks/{plannerTask-id}/assignedToTaskBoardFormat"
	localVarPath = strings.Replace(localVarPath, "{"+"plannerPlan-id"+"}", _neturl.PathEscape(parameterToString(r.plannerPlanId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"plannerBucket-id"+"}", _neturl.PathEscape(parameterToString(r.plannerBucketId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"plannerTask-id"+"}", _neturl.PathEscape(parameterToString(r.plannerTaskId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMePlannerPlansBucketsTasksGetBucketTaskBoardFormatRequest struct {
	ctx _context.Context
	ApiService *MePlannerUserApiService
	plannerPlanId string
	plannerBucketId string
	plannerTaskId string
	select_ *[]string
	expand *[]string
}

// Select properties to be returned
func (r ApiMePlannerPlansBucketsTasksGetBucketTaskBoardFormatRequest) Select_(select_ []string) ApiMePlannerPlansBucketsTasksGetBucketTaskBoardFormatRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiMePlannerPlansBucketsTasksGetBucketTaskBoardFormatRequest) Expand(expand []string) ApiMePlannerPlansBucketsTasksGetBucketTaskBoardFormatRequest {
	r.expand = &expand
	return r
}

func (r ApiMePlannerPlansBucketsTasksGetBucketTaskBoardFormatRequest) Execute() (MicrosoftGraphPlannerBucketTaskBoardTaskFormat, *_nethttp.Response, error) {
	return r.ApiService.MePlannerPlansBucketsTasksGetBucketTaskBoardFormatExecute(r)
}

/*
MePlannerPlansBucketsTasksGetBucketTaskBoardFormat Get bucketTaskBoardFormat from me

Read-only. Nullable. Used to render the task correctly in the task board view when grouped by bucket.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param plannerPlanId key: id of plannerPlan
 @param plannerBucketId key: id of plannerBucket
 @param plannerTaskId key: id of plannerTask
 @return ApiMePlannerPlansBucketsTasksGetBucketTaskBoardFormatRequest
*/
func (a *MePlannerUserApiService) MePlannerPlansBucketsTasksGetBucketTaskBoardFormat(ctx _context.Context, plannerPlanId string, plannerBucketId string, plannerTaskId string) ApiMePlannerPlansBucketsTasksGetBucketTaskBoardFormatRequest {
	return ApiMePlannerPlansBucketsTasksGetBucketTaskBoardFormatRequest{
		ApiService: a,
		ctx: ctx,
		plannerPlanId: plannerPlanId,
		plannerBucketId: plannerBucketId,
		plannerTaskId: plannerTaskId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphPlannerBucketTaskBoardTaskFormat
func (a *MePlannerUserApiService) MePlannerPlansBucketsTasksGetBucketTaskBoardFormatExecute(r ApiMePlannerPlansBucketsTasksGetBucketTaskBoardFormatRequest) (MicrosoftGraphPlannerBucketTaskBoardTaskFormat, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphPlannerBucketTaskBoardTaskFormat
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MePlannerUserApiService.MePlannerPlansBucketsTasksGetBucketTaskBoardFormat")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/planner/plans/{plannerPlan-id}/buckets/{plannerBucket-id}/tasks/{plannerTask-id}/bucketTaskBoardFormat"
	localVarPath = strings.Replace(localVarPath, "{"+"plannerPlan-id"+"}", _neturl.PathEscape(parameterToString(r.plannerPlanId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"plannerBucket-id"+"}", _neturl.PathEscape(parameterToString(r.plannerBucketId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"plannerTask-id"+"}", _neturl.PathEscape(parameterToString(r.plannerTaskId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMePlannerPlansBucketsTasksGetDetailsRequest struct {
	ctx _context.Context
	ApiService *MePlannerUserApiService
	plannerPlanId string
	plannerBucketId string
	plannerTaskId string
	select_ *[]string
	expand *[]string
}

// Select properties to be returned
func (r ApiMePlannerPlansBucketsTasksGetDetailsRequest) Select_(select_ []string) ApiMePlannerPlansBucketsTasksGetDetailsRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiMePlannerPlansBucketsTasksGetDetailsRequest) Expand(expand []string) ApiMePlannerPlansBucketsTasksGetDetailsRequest {
	r.expand = &expand
	return r
}

func (r ApiMePlannerPlansBucketsTasksGetDetailsRequest) Execute() (MicrosoftGraphPlannerTaskDetails, *_nethttp.Response, error) {
	return r.ApiService.MePlannerPlansBucketsTasksGetDetailsExecute(r)
}

/*
MePlannerPlansBucketsTasksGetDetails Get details from me

Read-only. Nullable. Additional details about the task.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param plannerPlanId key: id of plannerPlan
 @param plannerBucketId key: id of plannerBucket
 @param plannerTaskId key: id of plannerTask
 @return ApiMePlannerPlansBucketsTasksGetDetailsRequest
*/
func (a *MePlannerUserApiService) MePlannerPlansBucketsTasksGetDetails(ctx _context.Context, plannerPlanId string, plannerBucketId string, plannerTaskId string) ApiMePlannerPlansBucketsTasksGetDetailsRequest {
	return ApiMePlannerPlansBucketsTasksGetDetailsRequest{
		ApiService: a,
		ctx: ctx,
		plannerPlanId: plannerPlanId,
		plannerBucketId: plannerBucketId,
		plannerTaskId: plannerTaskId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphPlannerTaskDetails
func (a *MePlannerUserApiService) MePlannerPlansBucketsTasksGetDetailsExecute(r ApiMePlannerPlansBucketsTasksGetDetailsRequest) (MicrosoftGraphPlannerTaskDetails, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphPlannerTaskDetails
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MePlannerUserApiService.MePlannerPlansBucketsTasksGetDetails")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/planner/plans/{plannerPlan-id}/buckets/{plannerBucket-id}/tasks/{plannerTask-id}/details"
	localVarPath = strings.Replace(localVarPath, "{"+"plannerPlan-id"+"}", _neturl.PathEscape(parameterToString(r.plannerPlanId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"plannerBucket-id"+"}", _neturl.PathEscape(parameterToString(r.plannerBucketId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"plannerTask-id"+"}", _neturl.PathEscape(parameterToString(r.plannerTaskId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMePlannerPlansBucketsTasksGetProgressTaskBoardFormatRequest struct {
	ctx _context.Context
	ApiService *MePlannerUserApiService
	plannerPlanId string
	plannerBucketId string
	plannerTaskId string
	select_ *[]string
	expand *[]string
}

// Select properties to be returned
func (r ApiMePlannerPlansBucketsTasksGetProgressTaskBoardFormatRequest) Select_(select_ []string) ApiMePlannerPlansBucketsTasksGetProgressTaskBoardFormatRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiMePlannerPlansBucketsTasksGetProgressTaskBoardFormatRequest) Expand(expand []string) ApiMePlannerPlansBucketsTasksGetProgressTaskBoardFormatRequest {
	r.expand = &expand
	return r
}

func (r ApiMePlannerPlansBucketsTasksGetProgressTaskBoardFormatRequest) Execute() (MicrosoftGraphPlannerProgressTaskBoardTaskFormat, *_nethttp.Response, error) {
	return r.ApiService.MePlannerPlansBucketsTasksGetProgressTaskBoardFormatExecute(r)
}

/*
MePlannerPlansBucketsTasksGetProgressTaskBoardFormat Get progressTaskBoardFormat from me

Read-only. Nullable. Used to render the task correctly in the task board view when grouped by progress.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param plannerPlanId key: id of plannerPlan
 @param plannerBucketId key: id of plannerBucket
 @param plannerTaskId key: id of plannerTask
 @return ApiMePlannerPlansBucketsTasksGetProgressTaskBoardFormatRequest
*/
func (a *MePlannerUserApiService) MePlannerPlansBucketsTasksGetProgressTaskBoardFormat(ctx _context.Context, plannerPlanId string, plannerBucketId string, plannerTaskId string) ApiMePlannerPlansBucketsTasksGetProgressTaskBoardFormatRequest {
	return ApiMePlannerPlansBucketsTasksGetProgressTaskBoardFormatRequest{
		ApiService: a,
		ctx: ctx,
		plannerPlanId: plannerPlanId,
		plannerBucketId: plannerBucketId,
		plannerTaskId: plannerTaskId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphPlannerProgressTaskBoardTaskFormat
func (a *MePlannerUserApiService) MePlannerPlansBucketsTasksGetProgressTaskBoardFormatExecute(r ApiMePlannerPlansBucketsTasksGetProgressTaskBoardFormatRequest) (MicrosoftGraphPlannerProgressTaskBoardTaskFormat, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphPlannerProgressTaskBoardTaskFormat
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MePlannerUserApiService.MePlannerPlansBucketsTasksGetProgressTaskBoardFormat")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/planner/plans/{plannerPlan-id}/buckets/{plannerBucket-id}/tasks/{plannerTask-id}/progressTaskBoardFormat"
	localVarPath = strings.Replace(localVarPath, "{"+"plannerPlan-id"+"}", _neturl.PathEscape(parameterToString(r.plannerPlanId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"plannerBucket-id"+"}", _neturl.PathEscape(parameterToString(r.plannerBucketId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"plannerTask-id"+"}", _neturl.PathEscape(parameterToString(r.plannerTaskId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMePlannerPlansBucketsTasksUpdateAssignedToTaskBoardFormatRequest struct {
	ctx _context.Context
	ApiService *MePlannerUserApiService
	plannerPlanId string
	plannerBucketId string
	plannerTaskId string
	microsoftGraphPlannerAssignedToTaskBoardTaskFormat *MicrosoftGraphPlannerAssignedToTaskBoardTaskFormat
}

// New navigation property values
func (r ApiMePlannerPlansBucketsTasksUpdateAssignedToTaskBoardFormatRequest) MicrosoftGraphPlannerAssignedToTaskBoardTaskFormat(microsoftGraphPlannerAssignedToTaskBoardTaskFormat MicrosoftGraphPlannerAssignedToTaskBoardTaskFormat) ApiMePlannerPlansBucketsTasksUpdateAssignedToTaskBoardFormatRequest {
	r.microsoftGraphPlannerAssignedToTaskBoardTaskFormat = &microsoftGraphPlannerAssignedToTaskBoardTaskFormat
	return r
}

func (r ApiMePlannerPlansBucketsTasksUpdateAssignedToTaskBoardFormatRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.MePlannerPlansBucketsTasksUpdateAssignedToTaskBoardFormatExecute(r)
}

/*
MePlannerPlansBucketsTasksUpdateAssignedToTaskBoardFormat Update the navigation property assignedToTaskBoardFormat in me

Read-only. Nullable. Used to render the task correctly in the task board view when grouped by assignedTo.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param plannerPlanId key: id of plannerPlan
 @param plannerBucketId key: id of plannerBucket
 @param plannerTaskId key: id of plannerTask
 @return ApiMePlannerPlansBucketsTasksUpdateAssignedToTaskBoardFormatRequest
*/
func (a *MePlannerUserApiService) MePlannerPlansBucketsTasksUpdateAssignedToTaskBoardFormat(ctx _context.Context, plannerPlanId string, plannerBucketId string, plannerTaskId string) ApiMePlannerPlansBucketsTasksUpdateAssignedToTaskBoardFormatRequest {
	return ApiMePlannerPlansBucketsTasksUpdateAssignedToTaskBoardFormatRequest{
		ApiService: a,
		ctx: ctx,
		plannerPlanId: plannerPlanId,
		plannerBucketId: plannerBucketId,
		plannerTaskId: plannerTaskId,
	}
}

// Execute executes the request
func (a *MePlannerUserApiService) MePlannerPlansBucketsTasksUpdateAssignedToTaskBoardFormatExecute(r ApiMePlannerPlansBucketsTasksUpdateAssignedToTaskBoardFormatRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPatch
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MePlannerUserApiService.MePlannerPlansBucketsTasksUpdateAssignedToTaskBoardFormat")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/planner/plans/{plannerPlan-id}/buckets/{plannerBucket-id}/tasks/{plannerTask-id}/assignedToTaskBoardFormat"
	localVarPath = strings.Replace(localVarPath, "{"+"plannerPlan-id"+"}", _neturl.PathEscape(parameterToString(r.plannerPlanId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"plannerBucket-id"+"}", _neturl.PathEscape(parameterToString(r.plannerBucketId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"plannerTask-id"+"}", _neturl.PathEscape(parameterToString(r.plannerTaskId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphPlannerAssignedToTaskBoardTaskFormat == nil {
		return nil, reportError("microsoftGraphPlannerAssignedToTaskBoardTaskFormat is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphPlannerAssignedToTaskBoardTaskFormat
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiMePlannerPlansBucketsTasksUpdateBucketTaskBoardFormatRequest struct {
	ctx _context.Context
	ApiService *MePlannerUserApiService
	plannerPlanId string
	plannerBucketId string
	plannerTaskId string
	microsoftGraphPlannerBucketTaskBoardTaskFormat *MicrosoftGraphPlannerBucketTaskBoardTaskFormat
}

// New navigation property values
func (r ApiMePlannerPlansBucketsTasksUpdateBucketTaskBoardFormatRequest) MicrosoftGraphPlannerBucketTaskBoardTaskFormat(microsoftGraphPlannerBucketTaskBoardTaskFormat MicrosoftGraphPlannerBucketTaskBoardTaskFormat) ApiMePlannerPlansBucketsTasksUpdateBucketTaskBoardFormatRequest {
	r.microsoftGraphPlannerBucketTaskBoardTaskFormat = &microsoftGraphPlannerBucketTaskBoardTaskFormat
	return r
}

func (r ApiMePlannerPlansBucketsTasksUpdateBucketTaskBoardFormatRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.MePlannerPlansBucketsTasksUpdateBucketTaskBoardFormatExecute(r)
}

/*
MePlannerPlansBucketsTasksUpdateBucketTaskBoardFormat Update the navigation property bucketTaskBoardFormat in me

Read-only. Nullable. Used to render the task correctly in the task board view when grouped by bucket.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param plannerPlanId key: id of plannerPlan
 @param plannerBucketId key: id of plannerBucket
 @param plannerTaskId key: id of plannerTask
 @return ApiMePlannerPlansBucketsTasksUpdateBucketTaskBoardFormatRequest
*/
func (a *MePlannerUserApiService) MePlannerPlansBucketsTasksUpdateBucketTaskBoardFormat(ctx _context.Context, plannerPlanId string, plannerBucketId string, plannerTaskId string) ApiMePlannerPlansBucketsTasksUpdateBucketTaskBoardFormatRequest {
	return ApiMePlannerPlansBucketsTasksUpdateBucketTaskBoardFormatRequest{
		ApiService: a,
		ctx: ctx,
		plannerPlanId: plannerPlanId,
		plannerBucketId: plannerBucketId,
		plannerTaskId: plannerTaskId,
	}
}

// Execute executes the request
func (a *MePlannerUserApiService) MePlannerPlansBucketsTasksUpdateBucketTaskBoardFormatExecute(r ApiMePlannerPlansBucketsTasksUpdateBucketTaskBoardFormatRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPatch
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MePlannerUserApiService.MePlannerPlansBucketsTasksUpdateBucketTaskBoardFormat")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/planner/plans/{plannerPlan-id}/buckets/{plannerBucket-id}/tasks/{plannerTask-id}/bucketTaskBoardFormat"
	localVarPath = strings.Replace(localVarPath, "{"+"plannerPlan-id"+"}", _neturl.PathEscape(parameterToString(r.plannerPlanId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"plannerBucket-id"+"}", _neturl.PathEscape(parameterToString(r.plannerBucketId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"plannerTask-id"+"}", _neturl.PathEscape(parameterToString(r.plannerTaskId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphPlannerBucketTaskBoardTaskFormat == nil {
		return nil, reportError("microsoftGraphPlannerBucketTaskBoardTaskFormat is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphPlannerBucketTaskBoardTaskFormat
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiMePlannerPlansBucketsTasksUpdateDetailsRequest struct {
	ctx _context.Context
	ApiService *MePlannerUserApiService
	plannerPlanId string
	plannerBucketId string
	plannerTaskId string
	microsoftGraphPlannerTaskDetails *MicrosoftGraphPlannerTaskDetails
}

// New navigation property values
func (r ApiMePlannerPlansBucketsTasksUpdateDetailsRequest) MicrosoftGraphPlannerTaskDetails(microsoftGraphPlannerTaskDetails MicrosoftGraphPlannerTaskDetails) ApiMePlannerPlansBucketsTasksUpdateDetailsRequest {
	r.microsoftGraphPlannerTaskDetails = &microsoftGraphPlannerTaskDetails
	return r
}

func (r ApiMePlannerPlansBucketsTasksUpdateDetailsRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.MePlannerPlansBucketsTasksUpdateDetailsExecute(r)
}

/*
MePlannerPlansBucketsTasksUpdateDetails Update the navigation property details in me

Read-only. Nullable. Additional details about the task.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param plannerPlanId key: id of plannerPlan
 @param plannerBucketId key: id of plannerBucket
 @param plannerTaskId key: id of plannerTask
 @return ApiMePlannerPlansBucketsTasksUpdateDetailsRequest
*/
func (a *MePlannerUserApiService) MePlannerPlansBucketsTasksUpdateDetails(ctx _context.Context, plannerPlanId string, plannerBucketId string, plannerTaskId string) ApiMePlannerPlansBucketsTasksUpdateDetailsRequest {
	return ApiMePlannerPlansBucketsTasksUpdateDetailsRequest{
		ApiService: a,
		ctx: ctx,
		plannerPlanId: plannerPlanId,
		plannerBucketId: plannerBucketId,
		plannerTaskId: plannerTaskId,
	}
}

// Execute executes the request
func (a *MePlannerUserApiService) MePlannerPlansBucketsTasksUpdateDetailsExecute(r ApiMePlannerPlansBucketsTasksUpdateDetailsRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPatch
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MePlannerUserApiService.MePlannerPlansBucketsTasksUpdateDetails")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/planner/plans/{plannerPlan-id}/buckets/{plannerBucket-id}/tasks/{plannerTask-id}/details"
	localVarPath = strings.Replace(localVarPath, "{"+"plannerPlan-id"+"}", _neturl.PathEscape(parameterToString(r.plannerPlanId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"plannerBucket-id"+"}", _neturl.PathEscape(parameterToString(r.plannerBucketId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"plannerTask-id"+"}", _neturl.PathEscape(parameterToString(r.plannerTaskId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphPlannerTaskDetails == nil {
		return nil, reportError("microsoftGraphPlannerTaskDetails is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphPlannerTaskDetails
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiMePlannerPlansBucketsTasksUpdateProgressTaskBoardFormatRequest struct {
	ctx _context.Context
	ApiService *MePlannerUserApiService
	plannerPlanId string
	plannerBucketId string
	plannerTaskId string
	microsoftGraphPlannerProgressTaskBoardTaskFormat *MicrosoftGraphPlannerProgressTaskBoardTaskFormat
}

// New navigation property values
func (r ApiMePlannerPlansBucketsTasksUpdateProgressTaskBoardFormatRequest) MicrosoftGraphPlannerProgressTaskBoardTaskFormat(microsoftGraphPlannerProgressTaskBoardTaskFormat MicrosoftGraphPlannerProgressTaskBoardTaskFormat) ApiMePlannerPlansBucketsTasksUpdateProgressTaskBoardFormatRequest {
	r.microsoftGraphPlannerProgressTaskBoardTaskFormat = &microsoftGraphPlannerProgressTaskBoardTaskFormat
	return r
}

func (r ApiMePlannerPlansBucketsTasksUpdateProgressTaskBoardFormatRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.MePlannerPlansBucketsTasksUpdateProgressTaskBoardFormatExecute(r)
}

/*
MePlannerPlansBucketsTasksUpdateProgressTaskBoardFormat Update the navigation property progressTaskBoardFormat in me

Read-only. Nullable. Used to render the task correctly in the task board view when grouped by progress.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param plannerPlanId key: id of plannerPlan
 @param plannerBucketId key: id of plannerBucket
 @param plannerTaskId key: id of plannerTask
 @return ApiMePlannerPlansBucketsTasksUpdateProgressTaskBoardFormatRequest
*/
func (a *MePlannerUserApiService) MePlannerPlansBucketsTasksUpdateProgressTaskBoardFormat(ctx _context.Context, plannerPlanId string, plannerBucketId string, plannerTaskId string) ApiMePlannerPlansBucketsTasksUpdateProgressTaskBoardFormatRequest {
	return ApiMePlannerPlansBucketsTasksUpdateProgressTaskBoardFormatRequest{
		ApiService: a,
		ctx: ctx,
		plannerPlanId: plannerPlanId,
		plannerBucketId: plannerBucketId,
		plannerTaskId: plannerTaskId,
	}
}

// Execute executes the request
func (a *MePlannerUserApiService) MePlannerPlansBucketsTasksUpdateProgressTaskBoardFormatExecute(r ApiMePlannerPlansBucketsTasksUpdateProgressTaskBoardFormatRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPatch
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MePlannerUserApiService.MePlannerPlansBucketsTasksUpdateProgressTaskBoardFormat")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/planner/plans/{plannerPlan-id}/buckets/{plannerBucket-id}/tasks/{plannerTask-id}/progressTaskBoardFormat"
	localVarPath = strings.Replace(localVarPath, "{"+"plannerPlan-id"+"}", _neturl.PathEscape(parameterToString(r.plannerPlanId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"plannerBucket-id"+"}", _neturl.PathEscape(parameterToString(r.plannerBucketId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"plannerTask-id"+"}", _neturl.PathEscape(parameterToString(r.plannerTaskId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphPlannerProgressTaskBoardTaskFormat == nil {
		return nil, reportError("microsoftGraphPlannerProgressTaskBoardTaskFormat is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphPlannerProgressTaskBoardTaskFormat
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiMePlannerPlansBucketsUpdateTasksRequest struct {
	ctx _context.Context
	ApiService *MePlannerUserApiService
	plannerPlanId string
	plannerBucketId string
	plannerTaskId string
	microsoftGraphPlannerTask *MicrosoftGraphPlannerTask
}

// New navigation property values
func (r ApiMePlannerPlansBucketsUpdateTasksRequest) MicrosoftGraphPlannerTask(microsoftGraphPlannerTask MicrosoftGraphPlannerTask) ApiMePlannerPlansBucketsUpdateTasksRequest {
	r.microsoftGraphPlannerTask = &microsoftGraphPlannerTask
	return r
}

func (r ApiMePlannerPlansBucketsUpdateTasksRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.MePlannerPlansBucketsUpdateTasksExecute(r)
}

/*
MePlannerPlansBucketsUpdateTasks Update the navigation property tasks in me

Read-only. Nullable. The collection of tasks in the bucket.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param plannerPlanId key: id of plannerPlan
 @param plannerBucketId key: id of plannerBucket
 @param plannerTaskId key: id of plannerTask
 @return ApiMePlannerPlansBucketsUpdateTasksRequest
*/
func (a *MePlannerUserApiService) MePlannerPlansBucketsUpdateTasks(ctx _context.Context, plannerPlanId string, plannerBucketId string, plannerTaskId string) ApiMePlannerPlansBucketsUpdateTasksRequest {
	return ApiMePlannerPlansBucketsUpdateTasksRequest{
		ApiService: a,
		ctx: ctx,
		plannerPlanId: plannerPlanId,
		plannerBucketId: plannerBucketId,
		plannerTaskId: plannerTaskId,
	}
}

// Execute executes the request
func (a *MePlannerUserApiService) MePlannerPlansBucketsUpdateTasksExecute(r ApiMePlannerPlansBucketsUpdateTasksRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPatch
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MePlannerUserApiService.MePlannerPlansBucketsUpdateTasks")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/planner/plans/{plannerPlan-id}/buckets/{plannerBucket-id}/tasks/{plannerTask-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"plannerPlan-id"+"}", _neturl.PathEscape(parameterToString(r.plannerPlanId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"plannerBucket-id"+"}", _neturl.PathEscape(parameterToString(r.plannerBucketId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"plannerTask-id"+"}", _neturl.PathEscape(parameterToString(r.plannerTaskId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphPlannerTask == nil {
		return nil, reportError("microsoftGraphPlannerTask is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphPlannerTask
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiMePlannerPlansCreateBucketsRequest struct {
	ctx _context.Context
	ApiService *MePlannerUserApiService
	plannerPlanId string
	microsoftGraphPlannerBucket *MicrosoftGraphPlannerBucket
}

// New navigation property
func (r ApiMePlannerPlansCreateBucketsRequest) MicrosoftGraphPlannerBucket(microsoftGraphPlannerBucket MicrosoftGraphPlannerBucket) ApiMePlannerPlansCreateBucketsRequest {
	r.microsoftGraphPlannerBucket = &microsoftGraphPlannerBucket
	return r
}

func (r ApiMePlannerPlansCreateBucketsRequest) Execute() (MicrosoftGraphPlannerBucket, *_nethttp.Response, error) {
	return r.ApiService.MePlannerPlansCreateBucketsExecute(r)
}

/*
MePlannerPlansCreateBuckets Create new navigation property to buckets for me

Read-only. Nullable. Collection of buckets in the plan.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param plannerPlanId key: id of plannerPlan
 @return ApiMePlannerPlansCreateBucketsRequest
*/
func (a *MePlannerUserApiService) MePlannerPlansCreateBuckets(ctx _context.Context, plannerPlanId string) ApiMePlannerPlansCreateBucketsRequest {
	return ApiMePlannerPlansCreateBucketsRequest{
		ApiService: a,
		ctx: ctx,
		plannerPlanId: plannerPlanId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphPlannerBucket
func (a *MePlannerUserApiService) MePlannerPlansCreateBucketsExecute(r ApiMePlannerPlansCreateBucketsRequest) (MicrosoftGraphPlannerBucket, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphPlannerBucket
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MePlannerUserApiService.MePlannerPlansCreateBuckets")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/planner/plans/{plannerPlan-id}/buckets"
	localVarPath = strings.Replace(localVarPath, "{"+"plannerPlan-id"+"}", _neturl.PathEscape(parameterToString(r.plannerPlanId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphPlannerBucket == nil {
		return localVarReturnValue, nil, reportError("microsoftGraphPlannerBucket is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphPlannerBucket
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMePlannerPlansCreateTasksRequest struct {
	ctx _context.Context
	ApiService *MePlannerUserApiService
	plannerPlanId string
	microsoftGraphPlannerTask *MicrosoftGraphPlannerTask
}

// New navigation property
func (r ApiMePlannerPlansCreateTasksRequest) MicrosoftGraphPlannerTask(microsoftGraphPlannerTask MicrosoftGraphPlannerTask) ApiMePlannerPlansCreateTasksRequest {
	r.microsoftGraphPlannerTask = &microsoftGraphPlannerTask
	return r
}

func (r ApiMePlannerPlansCreateTasksRequest) Execute() (MicrosoftGraphPlannerTask, *_nethttp.Response, error) {
	return r.ApiService.MePlannerPlansCreateTasksExecute(r)
}

/*
MePlannerPlansCreateTasks Create new navigation property to tasks for me

Read-only. Nullable. Collection of tasks in the plan.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param plannerPlanId key: id of plannerPlan
 @return ApiMePlannerPlansCreateTasksRequest
*/
func (a *MePlannerUserApiService) MePlannerPlansCreateTasks(ctx _context.Context, plannerPlanId string) ApiMePlannerPlansCreateTasksRequest {
	return ApiMePlannerPlansCreateTasksRequest{
		ApiService: a,
		ctx: ctx,
		plannerPlanId: plannerPlanId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphPlannerTask
func (a *MePlannerUserApiService) MePlannerPlansCreateTasksExecute(r ApiMePlannerPlansCreateTasksRequest) (MicrosoftGraphPlannerTask, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphPlannerTask
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MePlannerUserApiService.MePlannerPlansCreateTasks")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/planner/plans/{plannerPlan-id}/tasks"
	localVarPath = strings.Replace(localVarPath, "{"+"plannerPlan-id"+"}", _neturl.PathEscape(parameterToString(r.plannerPlanId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphPlannerTask == nil {
		return localVarReturnValue, nil, reportError("microsoftGraphPlannerTask is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphPlannerTask
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMePlannerPlansDeleteBucketsRequest struct {
	ctx _context.Context
	ApiService *MePlannerUserApiService
	plannerPlanId string
	plannerBucketId string
	ifMatch *string
}

// ETag
func (r ApiMePlannerPlansDeleteBucketsRequest) IfMatch(ifMatch string) ApiMePlannerPlansDeleteBucketsRequest {
	r.ifMatch = &ifMatch
	return r
}

func (r ApiMePlannerPlansDeleteBucketsRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.MePlannerPlansDeleteBucketsExecute(r)
}

/*
MePlannerPlansDeleteBuckets Delete navigation property buckets for me

Read-only. Nullable. Collection of buckets in the plan.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param plannerPlanId key: id of plannerPlan
 @param plannerBucketId key: id of plannerBucket
 @return ApiMePlannerPlansDeleteBucketsRequest
*/
func (a *MePlannerUserApiService) MePlannerPlansDeleteBuckets(ctx _context.Context, plannerPlanId string, plannerBucketId string) ApiMePlannerPlansDeleteBucketsRequest {
	return ApiMePlannerPlansDeleteBucketsRequest{
		ApiService: a,
		ctx: ctx,
		plannerPlanId: plannerPlanId,
		plannerBucketId: plannerBucketId,
	}
}

// Execute executes the request
func (a *MePlannerUserApiService) MePlannerPlansDeleteBucketsExecute(r ApiMePlannerPlansDeleteBucketsRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MePlannerUserApiService.MePlannerPlansDeleteBuckets")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/planner/plans/{plannerPlan-id}/buckets/{plannerBucket-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"plannerPlan-id"+"}", _neturl.PathEscape(parameterToString(r.plannerPlanId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"plannerBucket-id"+"}", _neturl.PathEscape(parameterToString(r.plannerBucketId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ifMatch != nil {
		localVarHeaderParams["If-Match"] = parameterToString(*r.ifMatch, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiMePlannerPlansDeleteDetailsRequest struct {
	ctx _context.Context
	ApiService *MePlannerUserApiService
	plannerPlanId string
	ifMatch *string
}

// ETag
func (r ApiMePlannerPlansDeleteDetailsRequest) IfMatch(ifMatch string) ApiMePlannerPlansDeleteDetailsRequest {
	r.ifMatch = &ifMatch
	return r
}

func (r ApiMePlannerPlansDeleteDetailsRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.MePlannerPlansDeleteDetailsExecute(r)
}

/*
MePlannerPlansDeleteDetails Delete navigation property details for me

Read-only. Nullable. Additional details about the plan.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param plannerPlanId key: id of plannerPlan
 @return ApiMePlannerPlansDeleteDetailsRequest
*/
func (a *MePlannerUserApiService) MePlannerPlansDeleteDetails(ctx _context.Context, plannerPlanId string) ApiMePlannerPlansDeleteDetailsRequest {
	return ApiMePlannerPlansDeleteDetailsRequest{
		ApiService: a,
		ctx: ctx,
		plannerPlanId: plannerPlanId,
	}
}

// Execute executes the request
func (a *MePlannerUserApiService) MePlannerPlansDeleteDetailsExecute(r ApiMePlannerPlansDeleteDetailsRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MePlannerUserApiService.MePlannerPlansDeleteDetails")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/planner/plans/{plannerPlan-id}/details"
	localVarPath = strings.Replace(localVarPath, "{"+"plannerPlan-id"+"}", _neturl.PathEscape(parameterToString(r.plannerPlanId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ifMatch != nil {
		localVarHeaderParams["If-Match"] = parameterToString(*r.ifMatch, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiMePlannerPlansDeleteTasksRequest struct {
	ctx _context.Context
	ApiService *MePlannerUserApiService
	plannerPlanId string
	plannerTaskId string
	ifMatch *string
}

// ETag
func (r ApiMePlannerPlansDeleteTasksRequest) IfMatch(ifMatch string) ApiMePlannerPlansDeleteTasksRequest {
	r.ifMatch = &ifMatch
	return r
}

func (r ApiMePlannerPlansDeleteTasksRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.MePlannerPlansDeleteTasksExecute(r)
}

/*
MePlannerPlansDeleteTasks Delete navigation property tasks for me

Read-only. Nullable. Collection of tasks in the plan.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param plannerPlanId key: id of plannerPlan
 @param plannerTaskId key: id of plannerTask
 @return ApiMePlannerPlansDeleteTasksRequest
*/
func (a *MePlannerUserApiService) MePlannerPlansDeleteTasks(ctx _context.Context, plannerPlanId string, plannerTaskId string) ApiMePlannerPlansDeleteTasksRequest {
	return ApiMePlannerPlansDeleteTasksRequest{
		ApiService: a,
		ctx: ctx,
		plannerPlanId: plannerPlanId,
		plannerTaskId: plannerTaskId,
	}
}

// Execute executes the request
func (a *MePlannerUserApiService) MePlannerPlansDeleteTasksExecute(r ApiMePlannerPlansDeleteTasksRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MePlannerUserApiService.MePlannerPlansDeleteTasks")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/planner/plans/{plannerPlan-id}/tasks/{plannerTask-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"plannerPlan-id"+"}", _neturl.PathEscape(parameterToString(r.plannerPlanId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"plannerTask-id"+"}", _neturl.PathEscape(parameterToString(r.plannerTaskId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ifMatch != nil {
		localVarHeaderParams["If-Match"] = parameterToString(*r.ifMatch, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiMePlannerPlansGetBucketsRequest struct {
	ctx _context.Context
	ApiService *MePlannerUserApiService
	plannerPlanId string
	plannerBucketId string
	select_ *[]string
	expand *[]string
}

// Select properties to be returned
func (r ApiMePlannerPlansGetBucketsRequest) Select_(select_ []string) ApiMePlannerPlansGetBucketsRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiMePlannerPlansGetBucketsRequest) Expand(expand []string) ApiMePlannerPlansGetBucketsRequest {
	r.expand = &expand
	return r
}

func (r ApiMePlannerPlansGetBucketsRequest) Execute() (MicrosoftGraphPlannerBucket, *_nethttp.Response, error) {
	return r.ApiService.MePlannerPlansGetBucketsExecute(r)
}

/*
MePlannerPlansGetBuckets Get buckets from me

Read-only. Nullable. Collection of buckets in the plan.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param plannerPlanId key: id of plannerPlan
 @param plannerBucketId key: id of plannerBucket
 @return ApiMePlannerPlansGetBucketsRequest
*/
func (a *MePlannerUserApiService) MePlannerPlansGetBuckets(ctx _context.Context, plannerPlanId string, plannerBucketId string) ApiMePlannerPlansGetBucketsRequest {
	return ApiMePlannerPlansGetBucketsRequest{
		ApiService: a,
		ctx: ctx,
		plannerPlanId: plannerPlanId,
		plannerBucketId: plannerBucketId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphPlannerBucket
func (a *MePlannerUserApiService) MePlannerPlansGetBucketsExecute(r ApiMePlannerPlansGetBucketsRequest) (MicrosoftGraphPlannerBucket, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphPlannerBucket
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MePlannerUserApiService.MePlannerPlansGetBuckets")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/planner/plans/{plannerPlan-id}/buckets/{plannerBucket-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"plannerPlan-id"+"}", _neturl.PathEscape(parameterToString(r.plannerPlanId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"plannerBucket-id"+"}", _neturl.PathEscape(parameterToString(r.plannerBucketId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMePlannerPlansGetDetailsRequest struct {
	ctx _context.Context
	ApiService *MePlannerUserApiService
	plannerPlanId string
	select_ *[]string
	expand *[]string
}

// Select properties to be returned
func (r ApiMePlannerPlansGetDetailsRequest) Select_(select_ []string) ApiMePlannerPlansGetDetailsRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiMePlannerPlansGetDetailsRequest) Expand(expand []string) ApiMePlannerPlansGetDetailsRequest {
	r.expand = &expand
	return r
}

func (r ApiMePlannerPlansGetDetailsRequest) Execute() (MicrosoftGraphPlannerPlanDetails, *_nethttp.Response, error) {
	return r.ApiService.MePlannerPlansGetDetailsExecute(r)
}

/*
MePlannerPlansGetDetails Get details from me

Read-only. Nullable. Additional details about the plan.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param plannerPlanId key: id of plannerPlan
 @return ApiMePlannerPlansGetDetailsRequest
*/
func (a *MePlannerUserApiService) MePlannerPlansGetDetails(ctx _context.Context, plannerPlanId string) ApiMePlannerPlansGetDetailsRequest {
	return ApiMePlannerPlansGetDetailsRequest{
		ApiService: a,
		ctx: ctx,
		plannerPlanId: plannerPlanId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphPlannerPlanDetails
func (a *MePlannerUserApiService) MePlannerPlansGetDetailsExecute(r ApiMePlannerPlansGetDetailsRequest) (MicrosoftGraphPlannerPlanDetails, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphPlannerPlanDetails
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MePlannerUserApiService.MePlannerPlansGetDetails")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/planner/plans/{plannerPlan-id}/details"
	localVarPath = strings.Replace(localVarPath, "{"+"plannerPlan-id"+"}", _neturl.PathEscape(parameterToString(r.plannerPlanId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMePlannerPlansGetTasksRequest struct {
	ctx _context.Context
	ApiService *MePlannerUserApiService
	plannerPlanId string
	plannerTaskId string
	select_ *[]string
	expand *[]string
}

// Select properties to be returned
func (r ApiMePlannerPlansGetTasksRequest) Select_(select_ []string) ApiMePlannerPlansGetTasksRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiMePlannerPlansGetTasksRequest) Expand(expand []string) ApiMePlannerPlansGetTasksRequest {
	r.expand = &expand
	return r
}

func (r ApiMePlannerPlansGetTasksRequest) Execute() (MicrosoftGraphPlannerTask, *_nethttp.Response, error) {
	return r.ApiService.MePlannerPlansGetTasksExecute(r)
}

/*
MePlannerPlansGetTasks Get tasks from me

Read-only. Nullable. Collection of tasks in the plan.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param plannerPlanId key: id of plannerPlan
 @param plannerTaskId key: id of plannerTask
 @return ApiMePlannerPlansGetTasksRequest
*/
func (a *MePlannerUserApiService) MePlannerPlansGetTasks(ctx _context.Context, plannerPlanId string, plannerTaskId string) ApiMePlannerPlansGetTasksRequest {
	return ApiMePlannerPlansGetTasksRequest{
		ApiService: a,
		ctx: ctx,
		plannerPlanId: plannerPlanId,
		plannerTaskId: plannerTaskId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphPlannerTask
func (a *MePlannerUserApiService) MePlannerPlansGetTasksExecute(r ApiMePlannerPlansGetTasksRequest) (MicrosoftGraphPlannerTask, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphPlannerTask
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MePlannerUserApiService.MePlannerPlansGetTasks")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/planner/plans/{plannerPlan-id}/tasks/{plannerTask-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"plannerPlan-id"+"}", _neturl.PathEscape(parameterToString(r.plannerPlanId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"plannerTask-id"+"}", _neturl.PathEscape(parameterToString(r.plannerTaskId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMePlannerPlansListBucketsRequest struct {
	ctx _context.Context
	ApiService *MePlannerUserApiService
	plannerPlanId string
	top *int32
	skip *int32
	search *string
	filter *string
	count *bool
	orderby *[]string
	select_ *[]string
	expand *[]string
}

// Show only the first n items
func (r ApiMePlannerPlansListBucketsRequest) Top(top int32) ApiMePlannerPlansListBucketsRequest {
	r.top = &top
	return r
}
// Skip the first n items
func (r ApiMePlannerPlansListBucketsRequest) Skip(skip int32) ApiMePlannerPlansListBucketsRequest {
	r.skip = &skip
	return r
}
// Search items by search phrases
func (r ApiMePlannerPlansListBucketsRequest) Search(search string) ApiMePlannerPlansListBucketsRequest {
	r.search = &search
	return r
}
// Filter items by property values
func (r ApiMePlannerPlansListBucketsRequest) Filter(filter string) ApiMePlannerPlansListBucketsRequest {
	r.filter = &filter
	return r
}
// Include count of items
func (r ApiMePlannerPlansListBucketsRequest) Count(count bool) ApiMePlannerPlansListBucketsRequest {
	r.count = &count
	return r
}
// Order items by property values
func (r ApiMePlannerPlansListBucketsRequest) Orderby(orderby []string) ApiMePlannerPlansListBucketsRequest {
	r.orderby = &orderby
	return r
}
// Select properties to be returned
func (r ApiMePlannerPlansListBucketsRequest) Select_(select_ []string) ApiMePlannerPlansListBucketsRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiMePlannerPlansListBucketsRequest) Expand(expand []string) ApiMePlannerPlansListBucketsRequest {
	r.expand = &expand
	return r
}

func (r ApiMePlannerPlansListBucketsRequest) Execute() (CollectionOfPlannerBucket, *_nethttp.Response, error) {
	return r.ApiService.MePlannerPlansListBucketsExecute(r)
}

/*
MePlannerPlansListBuckets Get buckets from me

Read-only. Nullable. Collection of buckets in the plan.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param plannerPlanId key: id of plannerPlan
 @return ApiMePlannerPlansListBucketsRequest
*/
func (a *MePlannerUserApiService) MePlannerPlansListBuckets(ctx _context.Context, plannerPlanId string) ApiMePlannerPlansListBucketsRequest {
	return ApiMePlannerPlansListBucketsRequest{
		ApiService: a,
		ctx: ctx,
		plannerPlanId: plannerPlanId,
	}
}

// Execute executes the request
//  @return CollectionOfPlannerBucket
func (a *MePlannerUserApiService) MePlannerPlansListBucketsExecute(r ApiMePlannerPlansListBucketsRequest) (CollectionOfPlannerBucket, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  CollectionOfPlannerBucket
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MePlannerUserApiService.MePlannerPlansListBuckets")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/planner/plans/{plannerPlan-id}/buckets"
	localVarPath = strings.Replace(localVarPath, "{"+"plannerPlan-id"+"}", _neturl.PathEscape(parameterToString(r.plannerPlanId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.top != nil {
		localVarQueryParams.Add("$top", parameterToString(*r.top, ""))
	}
	if r.skip != nil {
		localVarQueryParams.Add("$skip", parameterToString(*r.skip, ""))
	}
	if r.search != nil {
		localVarQueryParams.Add("$search", parameterToString(*r.search, ""))
	}
	if r.filter != nil {
		localVarQueryParams.Add("$filter", parameterToString(*r.filter, ""))
	}
	if r.count != nil {
		localVarQueryParams.Add("$count", parameterToString(*r.count, ""))
	}
	if r.orderby != nil {
		localVarQueryParams.Add("$orderby", parameterToString(*r.orderby, "csv"))
	}
	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMePlannerPlansListTasksRequest struct {
	ctx _context.Context
	ApiService *MePlannerUserApiService
	plannerPlanId string
	top *int32
	skip *int32
	search *string
	filter *string
	count *bool
	orderby *[]string
	select_ *[]string
	expand *[]string
}

// Show only the first n items
func (r ApiMePlannerPlansListTasksRequest) Top(top int32) ApiMePlannerPlansListTasksRequest {
	r.top = &top
	return r
}
// Skip the first n items
func (r ApiMePlannerPlansListTasksRequest) Skip(skip int32) ApiMePlannerPlansListTasksRequest {
	r.skip = &skip
	return r
}
// Search items by search phrases
func (r ApiMePlannerPlansListTasksRequest) Search(search string) ApiMePlannerPlansListTasksRequest {
	r.search = &search
	return r
}
// Filter items by property values
func (r ApiMePlannerPlansListTasksRequest) Filter(filter string) ApiMePlannerPlansListTasksRequest {
	r.filter = &filter
	return r
}
// Include count of items
func (r ApiMePlannerPlansListTasksRequest) Count(count bool) ApiMePlannerPlansListTasksRequest {
	r.count = &count
	return r
}
// Order items by property values
func (r ApiMePlannerPlansListTasksRequest) Orderby(orderby []string) ApiMePlannerPlansListTasksRequest {
	r.orderby = &orderby
	return r
}
// Select properties to be returned
func (r ApiMePlannerPlansListTasksRequest) Select_(select_ []string) ApiMePlannerPlansListTasksRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiMePlannerPlansListTasksRequest) Expand(expand []string) ApiMePlannerPlansListTasksRequest {
	r.expand = &expand
	return r
}

func (r ApiMePlannerPlansListTasksRequest) Execute() (CollectionOfPlannerTask, *_nethttp.Response, error) {
	return r.ApiService.MePlannerPlansListTasksExecute(r)
}

/*
MePlannerPlansListTasks Get tasks from me

Read-only. Nullable. Collection of tasks in the plan.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param plannerPlanId key: id of plannerPlan
 @return ApiMePlannerPlansListTasksRequest
*/
func (a *MePlannerUserApiService) MePlannerPlansListTasks(ctx _context.Context, plannerPlanId string) ApiMePlannerPlansListTasksRequest {
	return ApiMePlannerPlansListTasksRequest{
		ApiService: a,
		ctx: ctx,
		plannerPlanId: plannerPlanId,
	}
}

// Execute executes the request
//  @return CollectionOfPlannerTask
func (a *MePlannerUserApiService) MePlannerPlansListTasksExecute(r ApiMePlannerPlansListTasksRequest) (CollectionOfPlannerTask, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  CollectionOfPlannerTask
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MePlannerUserApiService.MePlannerPlansListTasks")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/planner/plans/{plannerPlan-id}/tasks"
	localVarPath = strings.Replace(localVarPath, "{"+"plannerPlan-id"+"}", _neturl.PathEscape(parameterToString(r.plannerPlanId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.top != nil {
		localVarQueryParams.Add("$top", parameterToString(*r.top, ""))
	}
	if r.skip != nil {
		localVarQueryParams.Add("$skip", parameterToString(*r.skip, ""))
	}
	if r.search != nil {
		localVarQueryParams.Add("$search", parameterToString(*r.search, ""))
	}
	if r.filter != nil {
		localVarQueryParams.Add("$filter", parameterToString(*r.filter, ""))
	}
	if r.count != nil {
		localVarQueryParams.Add("$count", parameterToString(*r.count, ""))
	}
	if r.orderby != nil {
		localVarQueryParams.Add("$orderby", parameterToString(*r.orderby, "csv"))
	}
	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMePlannerPlansTasksDeleteAssignedToTaskBoardFormatRequest struct {
	ctx _context.Context
	ApiService *MePlannerUserApiService
	plannerPlanId string
	plannerTaskId string
	ifMatch *string
}

// ETag
func (r ApiMePlannerPlansTasksDeleteAssignedToTaskBoardFormatRequest) IfMatch(ifMatch string) ApiMePlannerPlansTasksDeleteAssignedToTaskBoardFormatRequest {
	r.ifMatch = &ifMatch
	return r
}

func (r ApiMePlannerPlansTasksDeleteAssignedToTaskBoardFormatRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.MePlannerPlansTasksDeleteAssignedToTaskBoardFormatExecute(r)
}

/*
MePlannerPlansTasksDeleteAssignedToTaskBoardFormat Delete navigation property assignedToTaskBoardFormat for me

Read-only. Nullable. Used to render the task correctly in the task board view when grouped by assignedTo.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param plannerPlanId key: id of plannerPlan
 @param plannerTaskId key: id of plannerTask
 @return ApiMePlannerPlansTasksDeleteAssignedToTaskBoardFormatRequest
*/
func (a *MePlannerUserApiService) MePlannerPlansTasksDeleteAssignedToTaskBoardFormat(ctx _context.Context, plannerPlanId string, plannerTaskId string) ApiMePlannerPlansTasksDeleteAssignedToTaskBoardFormatRequest {
	return ApiMePlannerPlansTasksDeleteAssignedToTaskBoardFormatRequest{
		ApiService: a,
		ctx: ctx,
		plannerPlanId: plannerPlanId,
		plannerTaskId: plannerTaskId,
	}
}

// Execute executes the request
func (a *MePlannerUserApiService) MePlannerPlansTasksDeleteAssignedToTaskBoardFormatExecute(r ApiMePlannerPlansTasksDeleteAssignedToTaskBoardFormatRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MePlannerUserApiService.MePlannerPlansTasksDeleteAssignedToTaskBoardFormat")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/planner/plans/{plannerPlan-id}/tasks/{plannerTask-id}/assignedToTaskBoardFormat"
	localVarPath = strings.Replace(localVarPath, "{"+"plannerPlan-id"+"}", _neturl.PathEscape(parameterToString(r.plannerPlanId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"plannerTask-id"+"}", _neturl.PathEscape(parameterToString(r.plannerTaskId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ifMatch != nil {
		localVarHeaderParams["If-Match"] = parameterToString(*r.ifMatch, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiMePlannerPlansTasksDeleteBucketTaskBoardFormatRequest struct {
	ctx _context.Context
	ApiService *MePlannerUserApiService
	plannerPlanId string
	plannerTaskId string
	ifMatch *string
}

// ETag
func (r ApiMePlannerPlansTasksDeleteBucketTaskBoardFormatRequest) IfMatch(ifMatch string) ApiMePlannerPlansTasksDeleteBucketTaskBoardFormatRequest {
	r.ifMatch = &ifMatch
	return r
}

func (r ApiMePlannerPlansTasksDeleteBucketTaskBoardFormatRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.MePlannerPlansTasksDeleteBucketTaskBoardFormatExecute(r)
}

/*
MePlannerPlansTasksDeleteBucketTaskBoardFormat Delete navigation property bucketTaskBoardFormat for me

Read-only. Nullable. Used to render the task correctly in the task board view when grouped by bucket.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param plannerPlanId key: id of plannerPlan
 @param plannerTaskId key: id of plannerTask
 @return ApiMePlannerPlansTasksDeleteBucketTaskBoardFormatRequest
*/
func (a *MePlannerUserApiService) MePlannerPlansTasksDeleteBucketTaskBoardFormat(ctx _context.Context, plannerPlanId string, plannerTaskId string) ApiMePlannerPlansTasksDeleteBucketTaskBoardFormatRequest {
	return ApiMePlannerPlansTasksDeleteBucketTaskBoardFormatRequest{
		ApiService: a,
		ctx: ctx,
		plannerPlanId: plannerPlanId,
		plannerTaskId: plannerTaskId,
	}
}

// Execute executes the request
func (a *MePlannerUserApiService) MePlannerPlansTasksDeleteBucketTaskBoardFormatExecute(r ApiMePlannerPlansTasksDeleteBucketTaskBoardFormatRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MePlannerUserApiService.MePlannerPlansTasksDeleteBucketTaskBoardFormat")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/planner/plans/{plannerPlan-id}/tasks/{plannerTask-id}/bucketTaskBoardFormat"
	localVarPath = strings.Replace(localVarPath, "{"+"plannerPlan-id"+"}", _neturl.PathEscape(parameterToString(r.plannerPlanId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"plannerTask-id"+"}", _neturl.PathEscape(parameterToString(r.plannerTaskId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ifMatch != nil {
		localVarHeaderParams["If-Match"] = parameterToString(*r.ifMatch, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiMePlannerPlansTasksDeleteDetailsRequest struct {
	ctx _context.Context
	ApiService *MePlannerUserApiService
	plannerPlanId string
	plannerTaskId string
	ifMatch *string
}

// ETag
func (r ApiMePlannerPlansTasksDeleteDetailsRequest) IfMatch(ifMatch string) ApiMePlannerPlansTasksDeleteDetailsRequest {
	r.ifMatch = &ifMatch
	return r
}

func (r ApiMePlannerPlansTasksDeleteDetailsRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.MePlannerPlansTasksDeleteDetailsExecute(r)
}

/*
MePlannerPlansTasksDeleteDetails Delete navigation property details for me

Read-only. Nullable. Additional details about the task.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param plannerPlanId key: id of plannerPlan
 @param plannerTaskId key: id of plannerTask
 @return ApiMePlannerPlansTasksDeleteDetailsRequest
*/
func (a *MePlannerUserApiService) MePlannerPlansTasksDeleteDetails(ctx _context.Context, plannerPlanId string, plannerTaskId string) ApiMePlannerPlansTasksDeleteDetailsRequest {
	return ApiMePlannerPlansTasksDeleteDetailsRequest{
		ApiService: a,
		ctx: ctx,
		plannerPlanId: plannerPlanId,
		plannerTaskId: plannerTaskId,
	}
}

// Execute executes the request
func (a *MePlannerUserApiService) MePlannerPlansTasksDeleteDetailsExecute(r ApiMePlannerPlansTasksDeleteDetailsRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MePlannerUserApiService.MePlannerPlansTasksDeleteDetails")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/planner/plans/{plannerPlan-id}/tasks/{plannerTask-id}/details"
	localVarPath = strings.Replace(localVarPath, "{"+"plannerPlan-id"+"}", _neturl.PathEscape(parameterToString(r.plannerPlanId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"plannerTask-id"+"}", _neturl.PathEscape(parameterToString(r.plannerTaskId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ifMatch != nil {
		localVarHeaderParams["If-Match"] = parameterToString(*r.ifMatch, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiMePlannerPlansTasksDeleteProgressTaskBoardFormatRequest struct {
	ctx _context.Context
	ApiService *MePlannerUserApiService
	plannerPlanId string
	plannerTaskId string
	ifMatch *string
}

// ETag
func (r ApiMePlannerPlansTasksDeleteProgressTaskBoardFormatRequest) IfMatch(ifMatch string) ApiMePlannerPlansTasksDeleteProgressTaskBoardFormatRequest {
	r.ifMatch = &ifMatch
	return r
}

func (r ApiMePlannerPlansTasksDeleteProgressTaskBoardFormatRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.MePlannerPlansTasksDeleteProgressTaskBoardFormatExecute(r)
}

/*
MePlannerPlansTasksDeleteProgressTaskBoardFormat Delete navigation property progressTaskBoardFormat for me

Read-only. Nullable. Used to render the task correctly in the task board view when grouped by progress.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param plannerPlanId key: id of plannerPlan
 @param plannerTaskId key: id of plannerTask
 @return ApiMePlannerPlansTasksDeleteProgressTaskBoardFormatRequest
*/
func (a *MePlannerUserApiService) MePlannerPlansTasksDeleteProgressTaskBoardFormat(ctx _context.Context, plannerPlanId string, plannerTaskId string) ApiMePlannerPlansTasksDeleteProgressTaskBoardFormatRequest {
	return ApiMePlannerPlansTasksDeleteProgressTaskBoardFormatRequest{
		ApiService: a,
		ctx: ctx,
		plannerPlanId: plannerPlanId,
		plannerTaskId: plannerTaskId,
	}
}

// Execute executes the request
func (a *MePlannerUserApiService) MePlannerPlansTasksDeleteProgressTaskBoardFormatExecute(r ApiMePlannerPlansTasksDeleteProgressTaskBoardFormatRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MePlannerUserApiService.MePlannerPlansTasksDeleteProgressTaskBoardFormat")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/planner/plans/{plannerPlan-id}/tasks/{plannerTask-id}/progressTaskBoardFormat"
	localVarPath = strings.Replace(localVarPath, "{"+"plannerPlan-id"+"}", _neturl.PathEscape(parameterToString(r.plannerPlanId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"plannerTask-id"+"}", _neturl.PathEscape(parameterToString(r.plannerTaskId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ifMatch != nil {
		localVarHeaderParams["If-Match"] = parameterToString(*r.ifMatch, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiMePlannerPlansTasksGetAssignedToTaskBoardFormatRequest struct {
	ctx _context.Context
	ApiService *MePlannerUserApiService
	plannerPlanId string
	plannerTaskId string
	select_ *[]string
	expand *[]string
}

// Select properties to be returned
func (r ApiMePlannerPlansTasksGetAssignedToTaskBoardFormatRequest) Select_(select_ []string) ApiMePlannerPlansTasksGetAssignedToTaskBoardFormatRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiMePlannerPlansTasksGetAssignedToTaskBoardFormatRequest) Expand(expand []string) ApiMePlannerPlansTasksGetAssignedToTaskBoardFormatRequest {
	r.expand = &expand
	return r
}

func (r ApiMePlannerPlansTasksGetAssignedToTaskBoardFormatRequest) Execute() (MicrosoftGraphPlannerAssignedToTaskBoardTaskFormat, *_nethttp.Response, error) {
	return r.ApiService.MePlannerPlansTasksGetAssignedToTaskBoardFormatExecute(r)
}

/*
MePlannerPlansTasksGetAssignedToTaskBoardFormat Get assignedToTaskBoardFormat from me

Read-only. Nullable. Used to render the task correctly in the task board view when grouped by assignedTo.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param plannerPlanId key: id of plannerPlan
 @param plannerTaskId key: id of plannerTask
 @return ApiMePlannerPlansTasksGetAssignedToTaskBoardFormatRequest
*/
func (a *MePlannerUserApiService) MePlannerPlansTasksGetAssignedToTaskBoardFormat(ctx _context.Context, plannerPlanId string, plannerTaskId string) ApiMePlannerPlansTasksGetAssignedToTaskBoardFormatRequest {
	return ApiMePlannerPlansTasksGetAssignedToTaskBoardFormatRequest{
		ApiService: a,
		ctx: ctx,
		plannerPlanId: plannerPlanId,
		plannerTaskId: plannerTaskId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphPlannerAssignedToTaskBoardTaskFormat
func (a *MePlannerUserApiService) MePlannerPlansTasksGetAssignedToTaskBoardFormatExecute(r ApiMePlannerPlansTasksGetAssignedToTaskBoardFormatRequest) (MicrosoftGraphPlannerAssignedToTaskBoardTaskFormat, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphPlannerAssignedToTaskBoardTaskFormat
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MePlannerUserApiService.MePlannerPlansTasksGetAssignedToTaskBoardFormat")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/planner/plans/{plannerPlan-id}/tasks/{plannerTask-id}/assignedToTaskBoardFormat"
	localVarPath = strings.Replace(localVarPath, "{"+"plannerPlan-id"+"}", _neturl.PathEscape(parameterToString(r.plannerPlanId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"plannerTask-id"+"}", _neturl.PathEscape(parameterToString(r.plannerTaskId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMePlannerPlansTasksGetBucketTaskBoardFormatRequest struct {
	ctx _context.Context
	ApiService *MePlannerUserApiService
	plannerPlanId string
	plannerTaskId string
	select_ *[]string
	expand *[]string
}

// Select properties to be returned
func (r ApiMePlannerPlansTasksGetBucketTaskBoardFormatRequest) Select_(select_ []string) ApiMePlannerPlansTasksGetBucketTaskBoardFormatRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiMePlannerPlansTasksGetBucketTaskBoardFormatRequest) Expand(expand []string) ApiMePlannerPlansTasksGetBucketTaskBoardFormatRequest {
	r.expand = &expand
	return r
}

func (r ApiMePlannerPlansTasksGetBucketTaskBoardFormatRequest) Execute() (MicrosoftGraphPlannerBucketTaskBoardTaskFormat, *_nethttp.Response, error) {
	return r.ApiService.MePlannerPlansTasksGetBucketTaskBoardFormatExecute(r)
}

/*
MePlannerPlansTasksGetBucketTaskBoardFormat Get bucketTaskBoardFormat from me

Read-only. Nullable. Used to render the task correctly in the task board view when grouped by bucket.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param plannerPlanId key: id of plannerPlan
 @param plannerTaskId key: id of plannerTask
 @return ApiMePlannerPlansTasksGetBucketTaskBoardFormatRequest
*/
func (a *MePlannerUserApiService) MePlannerPlansTasksGetBucketTaskBoardFormat(ctx _context.Context, plannerPlanId string, plannerTaskId string) ApiMePlannerPlansTasksGetBucketTaskBoardFormatRequest {
	return ApiMePlannerPlansTasksGetBucketTaskBoardFormatRequest{
		ApiService: a,
		ctx: ctx,
		plannerPlanId: plannerPlanId,
		plannerTaskId: plannerTaskId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphPlannerBucketTaskBoardTaskFormat
func (a *MePlannerUserApiService) MePlannerPlansTasksGetBucketTaskBoardFormatExecute(r ApiMePlannerPlansTasksGetBucketTaskBoardFormatRequest) (MicrosoftGraphPlannerBucketTaskBoardTaskFormat, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphPlannerBucketTaskBoardTaskFormat
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MePlannerUserApiService.MePlannerPlansTasksGetBucketTaskBoardFormat")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/planner/plans/{plannerPlan-id}/tasks/{plannerTask-id}/bucketTaskBoardFormat"
	localVarPath = strings.Replace(localVarPath, "{"+"plannerPlan-id"+"}", _neturl.PathEscape(parameterToString(r.plannerPlanId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"plannerTask-id"+"}", _neturl.PathEscape(parameterToString(r.plannerTaskId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMePlannerPlansTasksGetDetailsRequest struct {
	ctx _context.Context
	ApiService *MePlannerUserApiService
	plannerPlanId string
	plannerTaskId string
	select_ *[]string
	expand *[]string
}

// Select properties to be returned
func (r ApiMePlannerPlansTasksGetDetailsRequest) Select_(select_ []string) ApiMePlannerPlansTasksGetDetailsRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiMePlannerPlansTasksGetDetailsRequest) Expand(expand []string) ApiMePlannerPlansTasksGetDetailsRequest {
	r.expand = &expand
	return r
}

func (r ApiMePlannerPlansTasksGetDetailsRequest) Execute() (MicrosoftGraphPlannerTaskDetails, *_nethttp.Response, error) {
	return r.ApiService.MePlannerPlansTasksGetDetailsExecute(r)
}

/*
MePlannerPlansTasksGetDetails Get details from me

Read-only. Nullable. Additional details about the task.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param plannerPlanId key: id of plannerPlan
 @param plannerTaskId key: id of plannerTask
 @return ApiMePlannerPlansTasksGetDetailsRequest
*/
func (a *MePlannerUserApiService) MePlannerPlansTasksGetDetails(ctx _context.Context, plannerPlanId string, plannerTaskId string) ApiMePlannerPlansTasksGetDetailsRequest {
	return ApiMePlannerPlansTasksGetDetailsRequest{
		ApiService: a,
		ctx: ctx,
		plannerPlanId: plannerPlanId,
		plannerTaskId: plannerTaskId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphPlannerTaskDetails
func (a *MePlannerUserApiService) MePlannerPlansTasksGetDetailsExecute(r ApiMePlannerPlansTasksGetDetailsRequest) (MicrosoftGraphPlannerTaskDetails, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphPlannerTaskDetails
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MePlannerUserApiService.MePlannerPlansTasksGetDetails")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/planner/plans/{plannerPlan-id}/tasks/{plannerTask-id}/details"
	localVarPath = strings.Replace(localVarPath, "{"+"plannerPlan-id"+"}", _neturl.PathEscape(parameterToString(r.plannerPlanId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"plannerTask-id"+"}", _neturl.PathEscape(parameterToString(r.plannerTaskId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMePlannerPlansTasksGetProgressTaskBoardFormatRequest struct {
	ctx _context.Context
	ApiService *MePlannerUserApiService
	plannerPlanId string
	plannerTaskId string
	select_ *[]string
	expand *[]string
}

// Select properties to be returned
func (r ApiMePlannerPlansTasksGetProgressTaskBoardFormatRequest) Select_(select_ []string) ApiMePlannerPlansTasksGetProgressTaskBoardFormatRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiMePlannerPlansTasksGetProgressTaskBoardFormatRequest) Expand(expand []string) ApiMePlannerPlansTasksGetProgressTaskBoardFormatRequest {
	r.expand = &expand
	return r
}

func (r ApiMePlannerPlansTasksGetProgressTaskBoardFormatRequest) Execute() (MicrosoftGraphPlannerProgressTaskBoardTaskFormat, *_nethttp.Response, error) {
	return r.ApiService.MePlannerPlansTasksGetProgressTaskBoardFormatExecute(r)
}

/*
MePlannerPlansTasksGetProgressTaskBoardFormat Get progressTaskBoardFormat from me

Read-only. Nullable. Used to render the task correctly in the task board view when grouped by progress.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param plannerPlanId key: id of plannerPlan
 @param plannerTaskId key: id of plannerTask
 @return ApiMePlannerPlansTasksGetProgressTaskBoardFormatRequest
*/
func (a *MePlannerUserApiService) MePlannerPlansTasksGetProgressTaskBoardFormat(ctx _context.Context, plannerPlanId string, plannerTaskId string) ApiMePlannerPlansTasksGetProgressTaskBoardFormatRequest {
	return ApiMePlannerPlansTasksGetProgressTaskBoardFormatRequest{
		ApiService: a,
		ctx: ctx,
		plannerPlanId: plannerPlanId,
		plannerTaskId: plannerTaskId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphPlannerProgressTaskBoardTaskFormat
func (a *MePlannerUserApiService) MePlannerPlansTasksGetProgressTaskBoardFormatExecute(r ApiMePlannerPlansTasksGetProgressTaskBoardFormatRequest) (MicrosoftGraphPlannerProgressTaskBoardTaskFormat, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphPlannerProgressTaskBoardTaskFormat
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MePlannerUserApiService.MePlannerPlansTasksGetProgressTaskBoardFormat")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/planner/plans/{plannerPlan-id}/tasks/{plannerTask-id}/progressTaskBoardFormat"
	localVarPath = strings.Replace(localVarPath, "{"+"plannerPlan-id"+"}", _neturl.PathEscape(parameterToString(r.plannerPlanId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"plannerTask-id"+"}", _neturl.PathEscape(parameterToString(r.plannerTaskId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMePlannerPlansTasksUpdateAssignedToTaskBoardFormatRequest struct {
	ctx _context.Context
	ApiService *MePlannerUserApiService
	plannerPlanId string
	plannerTaskId string
	microsoftGraphPlannerAssignedToTaskBoardTaskFormat *MicrosoftGraphPlannerAssignedToTaskBoardTaskFormat
}

// New navigation property values
func (r ApiMePlannerPlansTasksUpdateAssignedToTaskBoardFormatRequest) MicrosoftGraphPlannerAssignedToTaskBoardTaskFormat(microsoftGraphPlannerAssignedToTaskBoardTaskFormat MicrosoftGraphPlannerAssignedToTaskBoardTaskFormat) ApiMePlannerPlansTasksUpdateAssignedToTaskBoardFormatRequest {
	r.microsoftGraphPlannerAssignedToTaskBoardTaskFormat = &microsoftGraphPlannerAssignedToTaskBoardTaskFormat
	return r
}

func (r ApiMePlannerPlansTasksUpdateAssignedToTaskBoardFormatRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.MePlannerPlansTasksUpdateAssignedToTaskBoardFormatExecute(r)
}

/*
MePlannerPlansTasksUpdateAssignedToTaskBoardFormat Update the navigation property assignedToTaskBoardFormat in me

Read-only. Nullable. Used to render the task correctly in the task board view when grouped by assignedTo.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param plannerPlanId key: id of plannerPlan
 @param plannerTaskId key: id of plannerTask
 @return ApiMePlannerPlansTasksUpdateAssignedToTaskBoardFormatRequest
*/
func (a *MePlannerUserApiService) MePlannerPlansTasksUpdateAssignedToTaskBoardFormat(ctx _context.Context, plannerPlanId string, plannerTaskId string) ApiMePlannerPlansTasksUpdateAssignedToTaskBoardFormatRequest {
	return ApiMePlannerPlansTasksUpdateAssignedToTaskBoardFormatRequest{
		ApiService: a,
		ctx: ctx,
		plannerPlanId: plannerPlanId,
		plannerTaskId: plannerTaskId,
	}
}

// Execute executes the request
func (a *MePlannerUserApiService) MePlannerPlansTasksUpdateAssignedToTaskBoardFormatExecute(r ApiMePlannerPlansTasksUpdateAssignedToTaskBoardFormatRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPatch
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MePlannerUserApiService.MePlannerPlansTasksUpdateAssignedToTaskBoardFormat")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/planner/plans/{plannerPlan-id}/tasks/{plannerTask-id}/assignedToTaskBoardFormat"
	localVarPath = strings.Replace(localVarPath, "{"+"plannerPlan-id"+"}", _neturl.PathEscape(parameterToString(r.plannerPlanId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"plannerTask-id"+"}", _neturl.PathEscape(parameterToString(r.plannerTaskId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphPlannerAssignedToTaskBoardTaskFormat == nil {
		return nil, reportError("microsoftGraphPlannerAssignedToTaskBoardTaskFormat is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphPlannerAssignedToTaskBoardTaskFormat
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiMePlannerPlansTasksUpdateBucketTaskBoardFormatRequest struct {
	ctx _context.Context
	ApiService *MePlannerUserApiService
	plannerPlanId string
	plannerTaskId string
	microsoftGraphPlannerBucketTaskBoardTaskFormat *MicrosoftGraphPlannerBucketTaskBoardTaskFormat
}

// New navigation property values
func (r ApiMePlannerPlansTasksUpdateBucketTaskBoardFormatRequest) MicrosoftGraphPlannerBucketTaskBoardTaskFormat(microsoftGraphPlannerBucketTaskBoardTaskFormat MicrosoftGraphPlannerBucketTaskBoardTaskFormat) ApiMePlannerPlansTasksUpdateBucketTaskBoardFormatRequest {
	r.microsoftGraphPlannerBucketTaskBoardTaskFormat = &microsoftGraphPlannerBucketTaskBoardTaskFormat
	return r
}

func (r ApiMePlannerPlansTasksUpdateBucketTaskBoardFormatRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.MePlannerPlansTasksUpdateBucketTaskBoardFormatExecute(r)
}

/*
MePlannerPlansTasksUpdateBucketTaskBoardFormat Update the navigation property bucketTaskBoardFormat in me

Read-only. Nullable. Used to render the task correctly in the task board view when grouped by bucket.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param plannerPlanId key: id of plannerPlan
 @param plannerTaskId key: id of plannerTask
 @return ApiMePlannerPlansTasksUpdateBucketTaskBoardFormatRequest
*/
func (a *MePlannerUserApiService) MePlannerPlansTasksUpdateBucketTaskBoardFormat(ctx _context.Context, plannerPlanId string, plannerTaskId string) ApiMePlannerPlansTasksUpdateBucketTaskBoardFormatRequest {
	return ApiMePlannerPlansTasksUpdateBucketTaskBoardFormatRequest{
		ApiService: a,
		ctx: ctx,
		plannerPlanId: plannerPlanId,
		plannerTaskId: plannerTaskId,
	}
}

// Execute executes the request
func (a *MePlannerUserApiService) MePlannerPlansTasksUpdateBucketTaskBoardFormatExecute(r ApiMePlannerPlansTasksUpdateBucketTaskBoardFormatRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPatch
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MePlannerUserApiService.MePlannerPlansTasksUpdateBucketTaskBoardFormat")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/planner/plans/{plannerPlan-id}/tasks/{plannerTask-id}/bucketTaskBoardFormat"
	localVarPath = strings.Replace(localVarPath, "{"+"plannerPlan-id"+"}", _neturl.PathEscape(parameterToString(r.plannerPlanId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"plannerTask-id"+"}", _neturl.PathEscape(parameterToString(r.plannerTaskId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphPlannerBucketTaskBoardTaskFormat == nil {
		return nil, reportError("microsoftGraphPlannerBucketTaskBoardTaskFormat is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphPlannerBucketTaskBoardTaskFormat
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiMePlannerPlansTasksUpdateDetailsRequest struct {
	ctx _context.Context
	ApiService *MePlannerUserApiService
	plannerPlanId string
	plannerTaskId string
	microsoftGraphPlannerTaskDetails *MicrosoftGraphPlannerTaskDetails
}

// New navigation property values
func (r ApiMePlannerPlansTasksUpdateDetailsRequest) MicrosoftGraphPlannerTaskDetails(microsoftGraphPlannerTaskDetails MicrosoftGraphPlannerTaskDetails) ApiMePlannerPlansTasksUpdateDetailsRequest {
	r.microsoftGraphPlannerTaskDetails = &microsoftGraphPlannerTaskDetails
	return r
}

func (r ApiMePlannerPlansTasksUpdateDetailsRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.MePlannerPlansTasksUpdateDetailsExecute(r)
}

/*
MePlannerPlansTasksUpdateDetails Update the navigation property details in me

Read-only. Nullable. Additional details about the task.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param plannerPlanId key: id of plannerPlan
 @param plannerTaskId key: id of plannerTask
 @return ApiMePlannerPlansTasksUpdateDetailsRequest
*/
func (a *MePlannerUserApiService) MePlannerPlansTasksUpdateDetails(ctx _context.Context, plannerPlanId string, plannerTaskId string) ApiMePlannerPlansTasksUpdateDetailsRequest {
	return ApiMePlannerPlansTasksUpdateDetailsRequest{
		ApiService: a,
		ctx: ctx,
		plannerPlanId: plannerPlanId,
		plannerTaskId: plannerTaskId,
	}
}

// Execute executes the request
func (a *MePlannerUserApiService) MePlannerPlansTasksUpdateDetailsExecute(r ApiMePlannerPlansTasksUpdateDetailsRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPatch
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MePlannerUserApiService.MePlannerPlansTasksUpdateDetails")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/planner/plans/{plannerPlan-id}/tasks/{plannerTask-id}/details"
	localVarPath = strings.Replace(localVarPath, "{"+"plannerPlan-id"+"}", _neturl.PathEscape(parameterToString(r.plannerPlanId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"plannerTask-id"+"}", _neturl.PathEscape(parameterToString(r.plannerTaskId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphPlannerTaskDetails == nil {
		return nil, reportError("microsoftGraphPlannerTaskDetails is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphPlannerTaskDetails
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiMePlannerPlansTasksUpdateProgressTaskBoardFormatRequest struct {
	ctx _context.Context
	ApiService *MePlannerUserApiService
	plannerPlanId string
	plannerTaskId string
	microsoftGraphPlannerProgressTaskBoardTaskFormat *MicrosoftGraphPlannerProgressTaskBoardTaskFormat
}

// New navigation property values
func (r ApiMePlannerPlansTasksUpdateProgressTaskBoardFormatRequest) MicrosoftGraphPlannerProgressTaskBoardTaskFormat(microsoftGraphPlannerProgressTaskBoardTaskFormat MicrosoftGraphPlannerProgressTaskBoardTaskFormat) ApiMePlannerPlansTasksUpdateProgressTaskBoardFormatRequest {
	r.microsoftGraphPlannerProgressTaskBoardTaskFormat = &microsoftGraphPlannerProgressTaskBoardTaskFormat
	return r
}

func (r ApiMePlannerPlansTasksUpdateProgressTaskBoardFormatRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.MePlannerPlansTasksUpdateProgressTaskBoardFormatExecute(r)
}

/*
MePlannerPlansTasksUpdateProgressTaskBoardFormat Update the navigation property progressTaskBoardFormat in me

Read-only. Nullable. Used to render the task correctly in the task board view when grouped by progress.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param plannerPlanId key: id of plannerPlan
 @param plannerTaskId key: id of plannerTask
 @return ApiMePlannerPlansTasksUpdateProgressTaskBoardFormatRequest
*/
func (a *MePlannerUserApiService) MePlannerPlansTasksUpdateProgressTaskBoardFormat(ctx _context.Context, plannerPlanId string, plannerTaskId string) ApiMePlannerPlansTasksUpdateProgressTaskBoardFormatRequest {
	return ApiMePlannerPlansTasksUpdateProgressTaskBoardFormatRequest{
		ApiService: a,
		ctx: ctx,
		plannerPlanId: plannerPlanId,
		plannerTaskId: plannerTaskId,
	}
}

// Execute executes the request
func (a *MePlannerUserApiService) MePlannerPlansTasksUpdateProgressTaskBoardFormatExecute(r ApiMePlannerPlansTasksUpdateProgressTaskBoardFormatRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPatch
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MePlannerUserApiService.MePlannerPlansTasksUpdateProgressTaskBoardFormat")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/planner/plans/{plannerPlan-id}/tasks/{plannerTask-id}/progressTaskBoardFormat"
	localVarPath = strings.Replace(localVarPath, "{"+"plannerPlan-id"+"}", _neturl.PathEscape(parameterToString(r.plannerPlanId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"plannerTask-id"+"}", _neturl.PathEscape(parameterToString(r.plannerTaskId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphPlannerProgressTaskBoardTaskFormat == nil {
		return nil, reportError("microsoftGraphPlannerProgressTaskBoardTaskFormat is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphPlannerProgressTaskBoardTaskFormat
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiMePlannerPlansUpdateBucketsRequest struct {
	ctx _context.Context
	ApiService *MePlannerUserApiService
	plannerPlanId string
	plannerBucketId string
	microsoftGraphPlannerBucket *MicrosoftGraphPlannerBucket
}

// New navigation property values
func (r ApiMePlannerPlansUpdateBucketsRequest) MicrosoftGraphPlannerBucket(microsoftGraphPlannerBucket MicrosoftGraphPlannerBucket) ApiMePlannerPlansUpdateBucketsRequest {
	r.microsoftGraphPlannerBucket = &microsoftGraphPlannerBucket
	return r
}

func (r ApiMePlannerPlansUpdateBucketsRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.MePlannerPlansUpdateBucketsExecute(r)
}

/*
MePlannerPlansUpdateBuckets Update the navigation property buckets in me

Read-only. Nullable. Collection of buckets in the plan.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param plannerPlanId key: id of plannerPlan
 @param plannerBucketId key: id of plannerBucket
 @return ApiMePlannerPlansUpdateBucketsRequest
*/
func (a *MePlannerUserApiService) MePlannerPlansUpdateBuckets(ctx _context.Context, plannerPlanId string, plannerBucketId string) ApiMePlannerPlansUpdateBucketsRequest {
	return ApiMePlannerPlansUpdateBucketsRequest{
		ApiService: a,
		ctx: ctx,
		plannerPlanId: plannerPlanId,
		plannerBucketId: plannerBucketId,
	}
}

// Execute executes the request
func (a *MePlannerUserApiService) MePlannerPlansUpdateBucketsExecute(r ApiMePlannerPlansUpdateBucketsRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPatch
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MePlannerUserApiService.MePlannerPlansUpdateBuckets")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/planner/plans/{plannerPlan-id}/buckets/{plannerBucket-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"plannerPlan-id"+"}", _neturl.PathEscape(parameterToString(r.plannerPlanId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"plannerBucket-id"+"}", _neturl.PathEscape(parameterToString(r.plannerBucketId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphPlannerBucket == nil {
		return nil, reportError("microsoftGraphPlannerBucket is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphPlannerBucket
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiMePlannerPlansUpdateDetailsRequest struct {
	ctx _context.Context
	ApiService *MePlannerUserApiService
	plannerPlanId string
	microsoftGraphPlannerPlanDetails *MicrosoftGraphPlannerPlanDetails
}

// New navigation property values
func (r ApiMePlannerPlansUpdateDetailsRequest) MicrosoftGraphPlannerPlanDetails(microsoftGraphPlannerPlanDetails MicrosoftGraphPlannerPlanDetails) ApiMePlannerPlansUpdateDetailsRequest {
	r.microsoftGraphPlannerPlanDetails = &microsoftGraphPlannerPlanDetails
	return r
}

func (r ApiMePlannerPlansUpdateDetailsRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.MePlannerPlansUpdateDetailsExecute(r)
}

/*
MePlannerPlansUpdateDetails Update the navigation property details in me

Read-only. Nullable. Additional details about the plan.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param plannerPlanId key: id of plannerPlan
 @return ApiMePlannerPlansUpdateDetailsRequest
*/
func (a *MePlannerUserApiService) MePlannerPlansUpdateDetails(ctx _context.Context, plannerPlanId string) ApiMePlannerPlansUpdateDetailsRequest {
	return ApiMePlannerPlansUpdateDetailsRequest{
		ApiService: a,
		ctx: ctx,
		plannerPlanId: plannerPlanId,
	}
}

// Execute executes the request
func (a *MePlannerUserApiService) MePlannerPlansUpdateDetailsExecute(r ApiMePlannerPlansUpdateDetailsRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPatch
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MePlannerUserApiService.MePlannerPlansUpdateDetails")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/planner/plans/{plannerPlan-id}/details"
	localVarPath = strings.Replace(localVarPath, "{"+"plannerPlan-id"+"}", _neturl.PathEscape(parameterToString(r.plannerPlanId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphPlannerPlanDetails == nil {
		return nil, reportError("microsoftGraphPlannerPlanDetails is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphPlannerPlanDetails
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiMePlannerPlansUpdateTasksRequest struct {
	ctx _context.Context
	ApiService *MePlannerUserApiService
	plannerPlanId string
	plannerTaskId string
	microsoftGraphPlannerTask *MicrosoftGraphPlannerTask
}

// New navigation property values
func (r ApiMePlannerPlansUpdateTasksRequest) MicrosoftGraphPlannerTask(microsoftGraphPlannerTask MicrosoftGraphPlannerTask) ApiMePlannerPlansUpdateTasksRequest {
	r.microsoftGraphPlannerTask = &microsoftGraphPlannerTask
	return r
}

func (r ApiMePlannerPlansUpdateTasksRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.MePlannerPlansUpdateTasksExecute(r)
}

/*
MePlannerPlansUpdateTasks Update the navigation property tasks in me

Read-only. Nullable. Collection of tasks in the plan.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param plannerPlanId key: id of plannerPlan
 @param plannerTaskId key: id of plannerTask
 @return ApiMePlannerPlansUpdateTasksRequest
*/
func (a *MePlannerUserApiService) MePlannerPlansUpdateTasks(ctx _context.Context, plannerPlanId string, plannerTaskId string) ApiMePlannerPlansUpdateTasksRequest {
	return ApiMePlannerPlansUpdateTasksRequest{
		ApiService: a,
		ctx: ctx,
		plannerPlanId: plannerPlanId,
		plannerTaskId: plannerTaskId,
	}
}

// Execute executes the request
func (a *MePlannerUserApiService) MePlannerPlansUpdateTasksExecute(r ApiMePlannerPlansUpdateTasksRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPatch
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MePlannerUserApiService.MePlannerPlansUpdateTasks")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/planner/plans/{plannerPlan-id}/tasks/{plannerTask-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"plannerPlan-id"+"}", _neturl.PathEscape(parameterToString(r.plannerPlanId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"plannerTask-id"+"}", _neturl.PathEscape(parameterToString(r.plannerTaskId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphPlannerTask == nil {
		return nil, reportError("microsoftGraphPlannerTask is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphPlannerTask
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiMePlannerTasksDeleteAssignedToTaskBoardFormatRequest struct {
	ctx _context.Context
	ApiService *MePlannerUserApiService
	plannerTaskId string
	ifMatch *string
}

// ETag
func (r ApiMePlannerTasksDeleteAssignedToTaskBoardFormatRequest) IfMatch(ifMatch string) ApiMePlannerTasksDeleteAssignedToTaskBoardFormatRequest {
	r.ifMatch = &ifMatch
	return r
}

func (r ApiMePlannerTasksDeleteAssignedToTaskBoardFormatRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.MePlannerTasksDeleteAssignedToTaskBoardFormatExecute(r)
}

/*
MePlannerTasksDeleteAssignedToTaskBoardFormat Delete navigation property assignedToTaskBoardFormat for me

Read-only. Nullable. Used to render the task correctly in the task board view when grouped by assignedTo.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param plannerTaskId key: id of plannerTask
 @return ApiMePlannerTasksDeleteAssignedToTaskBoardFormatRequest
*/
func (a *MePlannerUserApiService) MePlannerTasksDeleteAssignedToTaskBoardFormat(ctx _context.Context, plannerTaskId string) ApiMePlannerTasksDeleteAssignedToTaskBoardFormatRequest {
	return ApiMePlannerTasksDeleteAssignedToTaskBoardFormatRequest{
		ApiService: a,
		ctx: ctx,
		plannerTaskId: plannerTaskId,
	}
}

// Execute executes the request
func (a *MePlannerUserApiService) MePlannerTasksDeleteAssignedToTaskBoardFormatExecute(r ApiMePlannerTasksDeleteAssignedToTaskBoardFormatRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MePlannerUserApiService.MePlannerTasksDeleteAssignedToTaskBoardFormat")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/planner/tasks/{plannerTask-id}/assignedToTaskBoardFormat"
	localVarPath = strings.Replace(localVarPath, "{"+"plannerTask-id"+"}", _neturl.PathEscape(parameterToString(r.plannerTaskId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ifMatch != nil {
		localVarHeaderParams["If-Match"] = parameterToString(*r.ifMatch, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiMePlannerTasksDeleteBucketTaskBoardFormatRequest struct {
	ctx _context.Context
	ApiService *MePlannerUserApiService
	plannerTaskId string
	ifMatch *string
}

// ETag
func (r ApiMePlannerTasksDeleteBucketTaskBoardFormatRequest) IfMatch(ifMatch string) ApiMePlannerTasksDeleteBucketTaskBoardFormatRequest {
	r.ifMatch = &ifMatch
	return r
}

func (r ApiMePlannerTasksDeleteBucketTaskBoardFormatRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.MePlannerTasksDeleteBucketTaskBoardFormatExecute(r)
}

/*
MePlannerTasksDeleteBucketTaskBoardFormat Delete navigation property bucketTaskBoardFormat for me

Read-only. Nullable. Used to render the task correctly in the task board view when grouped by bucket.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param plannerTaskId key: id of plannerTask
 @return ApiMePlannerTasksDeleteBucketTaskBoardFormatRequest
*/
func (a *MePlannerUserApiService) MePlannerTasksDeleteBucketTaskBoardFormat(ctx _context.Context, plannerTaskId string) ApiMePlannerTasksDeleteBucketTaskBoardFormatRequest {
	return ApiMePlannerTasksDeleteBucketTaskBoardFormatRequest{
		ApiService: a,
		ctx: ctx,
		plannerTaskId: plannerTaskId,
	}
}

// Execute executes the request
func (a *MePlannerUserApiService) MePlannerTasksDeleteBucketTaskBoardFormatExecute(r ApiMePlannerTasksDeleteBucketTaskBoardFormatRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MePlannerUserApiService.MePlannerTasksDeleteBucketTaskBoardFormat")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/planner/tasks/{plannerTask-id}/bucketTaskBoardFormat"
	localVarPath = strings.Replace(localVarPath, "{"+"plannerTask-id"+"}", _neturl.PathEscape(parameterToString(r.plannerTaskId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ifMatch != nil {
		localVarHeaderParams["If-Match"] = parameterToString(*r.ifMatch, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiMePlannerTasksDeleteDetailsRequest struct {
	ctx _context.Context
	ApiService *MePlannerUserApiService
	plannerTaskId string
	ifMatch *string
}

// ETag
func (r ApiMePlannerTasksDeleteDetailsRequest) IfMatch(ifMatch string) ApiMePlannerTasksDeleteDetailsRequest {
	r.ifMatch = &ifMatch
	return r
}

func (r ApiMePlannerTasksDeleteDetailsRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.MePlannerTasksDeleteDetailsExecute(r)
}

/*
MePlannerTasksDeleteDetails Delete navigation property details for me

Read-only. Nullable. Additional details about the task.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param plannerTaskId key: id of plannerTask
 @return ApiMePlannerTasksDeleteDetailsRequest
*/
func (a *MePlannerUserApiService) MePlannerTasksDeleteDetails(ctx _context.Context, plannerTaskId string) ApiMePlannerTasksDeleteDetailsRequest {
	return ApiMePlannerTasksDeleteDetailsRequest{
		ApiService: a,
		ctx: ctx,
		plannerTaskId: plannerTaskId,
	}
}

// Execute executes the request
func (a *MePlannerUserApiService) MePlannerTasksDeleteDetailsExecute(r ApiMePlannerTasksDeleteDetailsRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MePlannerUserApiService.MePlannerTasksDeleteDetails")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/planner/tasks/{plannerTask-id}/details"
	localVarPath = strings.Replace(localVarPath, "{"+"plannerTask-id"+"}", _neturl.PathEscape(parameterToString(r.plannerTaskId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ifMatch != nil {
		localVarHeaderParams["If-Match"] = parameterToString(*r.ifMatch, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiMePlannerTasksDeleteProgressTaskBoardFormatRequest struct {
	ctx _context.Context
	ApiService *MePlannerUserApiService
	plannerTaskId string
	ifMatch *string
}

// ETag
func (r ApiMePlannerTasksDeleteProgressTaskBoardFormatRequest) IfMatch(ifMatch string) ApiMePlannerTasksDeleteProgressTaskBoardFormatRequest {
	r.ifMatch = &ifMatch
	return r
}

func (r ApiMePlannerTasksDeleteProgressTaskBoardFormatRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.MePlannerTasksDeleteProgressTaskBoardFormatExecute(r)
}

/*
MePlannerTasksDeleteProgressTaskBoardFormat Delete navigation property progressTaskBoardFormat for me

Read-only. Nullable. Used to render the task correctly in the task board view when grouped by progress.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param plannerTaskId key: id of plannerTask
 @return ApiMePlannerTasksDeleteProgressTaskBoardFormatRequest
*/
func (a *MePlannerUserApiService) MePlannerTasksDeleteProgressTaskBoardFormat(ctx _context.Context, plannerTaskId string) ApiMePlannerTasksDeleteProgressTaskBoardFormatRequest {
	return ApiMePlannerTasksDeleteProgressTaskBoardFormatRequest{
		ApiService: a,
		ctx: ctx,
		plannerTaskId: plannerTaskId,
	}
}

// Execute executes the request
func (a *MePlannerUserApiService) MePlannerTasksDeleteProgressTaskBoardFormatExecute(r ApiMePlannerTasksDeleteProgressTaskBoardFormatRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MePlannerUserApiService.MePlannerTasksDeleteProgressTaskBoardFormat")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/planner/tasks/{plannerTask-id}/progressTaskBoardFormat"
	localVarPath = strings.Replace(localVarPath, "{"+"plannerTask-id"+"}", _neturl.PathEscape(parameterToString(r.plannerTaskId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ifMatch != nil {
		localVarHeaderParams["If-Match"] = parameterToString(*r.ifMatch, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiMePlannerTasksGetAssignedToTaskBoardFormatRequest struct {
	ctx _context.Context
	ApiService *MePlannerUserApiService
	plannerTaskId string
	select_ *[]string
	expand *[]string
}

// Select properties to be returned
func (r ApiMePlannerTasksGetAssignedToTaskBoardFormatRequest) Select_(select_ []string) ApiMePlannerTasksGetAssignedToTaskBoardFormatRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiMePlannerTasksGetAssignedToTaskBoardFormatRequest) Expand(expand []string) ApiMePlannerTasksGetAssignedToTaskBoardFormatRequest {
	r.expand = &expand
	return r
}

func (r ApiMePlannerTasksGetAssignedToTaskBoardFormatRequest) Execute() (MicrosoftGraphPlannerAssignedToTaskBoardTaskFormat, *_nethttp.Response, error) {
	return r.ApiService.MePlannerTasksGetAssignedToTaskBoardFormatExecute(r)
}

/*
MePlannerTasksGetAssignedToTaskBoardFormat Get assignedToTaskBoardFormat from me

Read-only. Nullable. Used to render the task correctly in the task board view when grouped by assignedTo.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param plannerTaskId key: id of plannerTask
 @return ApiMePlannerTasksGetAssignedToTaskBoardFormatRequest
*/
func (a *MePlannerUserApiService) MePlannerTasksGetAssignedToTaskBoardFormat(ctx _context.Context, plannerTaskId string) ApiMePlannerTasksGetAssignedToTaskBoardFormatRequest {
	return ApiMePlannerTasksGetAssignedToTaskBoardFormatRequest{
		ApiService: a,
		ctx: ctx,
		plannerTaskId: plannerTaskId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphPlannerAssignedToTaskBoardTaskFormat
func (a *MePlannerUserApiService) MePlannerTasksGetAssignedToTaskBoardFormatExecute(r ApiMePlannerTasksGetAssignedToTaskBoardFormatRequest) (MicrosoftGraphPlannerAssignedToTaskBoardTaskFormat, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphPlannerAssignedToTaskBoardTaskFormat
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MePlannerUserApiService.MePlannerTasksGetAssignedToTaskBoardFormat")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/planner/tasks/{plannerTask-id}/assignedToTaskBoardFormat"
	localVarPath = strings.Replace(localVarPath, "{"+"plannerTask-id"+"}", _neturl.PathEscape(parameterToString(r.plannerTaskId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMePlannerTasksGetBucketTaskBoardFormatRequest struct {
	ctx _context.Context
	ApiService *MePlannerUserApiService
	plannerTaskId string
	select_ *[]string
	expand *[]string
}

// Select properties to be returned
func (r ApiMePlannerTasksGetBucketTaskBoardFormatRequest) Select_(select_ []string) ApiMePlannerTasksGetBucketTaskBoardFormatRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiMePlannerTasksGetBucketTaskBoardFormatRequest) Expand(expand []string) ApiMePlannerTasksGetBucketTaskBoardFormatRequest {
	r.expand = &expand
	return r
}

func (r ApiMePlannerTasksGetBucketTaskBoardFormatRequest) Execute() (MicrosoftGraphPlannerBucketTaskBoardTaskFormat, *_nethttp.Response, error) {
	return r.ApiService.MePlannerTasksGetBucketTaskBoardFormatExecute(r)
}

/*
MePlannerTasksGetBucketTaskBoardFormat Get bucketTaskBoardFormat from me

Read-only. Nullable. Used to render the task correctly in the task board view when grouped by bucket.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param plannerTaskId key: id of plannerTask
 @return ApiMePlannerTasksGetBucketTaskBoardFormatRequest
*/
func (a *MePlannerUserApiService) MePlannerTasksGetBucketTaskBoardFormat(ctx _context.Context, plannerTaskId string) ApiMePlannerTasksGetBucketTaskBoardFormatRequest {
	return ApiMePlannerTasksGetBucketTaskBoardFormatRequest{
		ApiService: a,
		ctx: ctx,
		plannerTaskId: plannerTaskId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphPlannerBucketTaskBoardTaskFormat
func (a *MePlannerUserApiService) MePlannerTasksGetBucketTaskBoardFormatExecute(r ApiMePlannerTasksGetBucketTaskBoardFormatRequest) (MicrosoftGraphPlannerBucketTaskBoardTaskFormat, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphPlannerBucketTaskBoardTaskFormat
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MePlannerUserApiService.MePlannerTasksGetBucketTaskBoardFormat")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/planner/tasks/{plannerTask-id}/bucketTaskBoardFormat"
	localVarPath = strings.Replace(localVarPath, "{"+"plannerTask-id"+"}", _neturl.PathEscape(parameterToString(r.plannerTaskId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMePlannerTasksGetDetailsRequest struct {
	ctx _context.Context
	ApiService *MePlannerUserApiService
	plannerTaskId string
	select_ *[]string
	expand *[]string
}

// Select properties to be returned
func (r ApiMePlannerTasksGetDetailsRequest) Select_(select_ []string) ApiMePlannerTasksGetDetailsRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiMePlannerTasksGetDetailsRequest) Expand(expand []string) ApiMePlannerTasksGetDetailsRequest {
	r.expand = &expand
	return r
}

func (r ApiMePlannerTasksGetDetailsRequest) Execute() (MicrosoftGraphPlannerTaskDetails, *_nethttp.Response, error) {
	return r.ApiService.MePlannerTasksGetDetailsExecute(r)
}

/*
MePlannerTasksGetDetails Get details from me

Read-only. Nullable. Additional details about the task.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param plannerTaskId key: id of plannerTask
 @return ApiMePlannerTasksGetDetailsRequest
*/
func (a *MePlannerUserApiService) MePlannerTasksGetDetails(ctx _context.Context, plannerTaskId string) ApiMePlannerTasksGetDetailsRequest {
	return ApiMePlannerTasksGetDetailsRequest{
		ApiService: a,
		ctx: ctx,
		plannerTaskId: plannerTaskId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphPlannerTaskDetails
func (a *MePlannerUserApiService) MePlannerTasksGetDetailsExecute(r ApiMePlannerTasksGetDetailsRequest) (MicrosoftGraphPlannerTaskDetails, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphPlannerTaskDetails
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MePlannerUserApiService.MePlannerTasksGetDetails")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/planner/tasks/{plannerTask-id}/details"
	localVarPath = strings.Replace(localVarPath, "{"+"plannerTask-id"+"}", _neturl.PathEscape(parameterToString(r.plannerTaskId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMePlannerTasksGetProgressTaskBoardFormatRequest struct {
	ctx _context.Context
	ApiService *MePlannerUserApiService
	plannerTaskId string
	select_ *[]string
	expand *[]string
}

// Select properties to be returned
func (r ApiMePlannerTasksGetProgressTaskBoardFormatRequest) Select_(select_ []string) ApiMePlannerTasksGetProgressTaskBoardFormatRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiMePlannerTasksGetProgressTaskBoardFormatRequest) Expand(expand []string) ApiMePlannerTasksGetProgressTaskBoardFormatRequest {
	r.expand = &expand
	return r
}

func (r ApiMePlannerTasksGetProgressTaskBoardFormatRequest) Execute() (MicrosoftGraphPlannerProgressTaskBoardTaskFormat, *_nethttp.Response, error) {
	return r.ApiService.MePlannerTasksGetProgressTaskBoardFormatExecute(r)
}

/*
MePlannerTasksGetProgressTaskBoardFormat Get progressTaskBoardFormat from me

Read-only. Nullable. Used to render the task correctly in the task board view when grouped by progress.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param plannerTaskId key: id of plannerTask
 @return ApiMePlannerTasksGetProgressTaskBoardFormatRequest
*/
func (a *MePlannerUserApiService) MePlannerTasksGetProgressTaskBoardFormat(ctx _context.Context, plannerTaskId string) ApiMePlannerTasksGetProgressTaskBoardFormatRequest {
	return ApiMePlannerTasksGetProgressTaskBoardFormatRequest{
		ApiService: a,
		ctx: ctx,
		plannerTaskId: plannerTaskId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphPlannerProgressTaskBoardTaskFormat
func (a *MePlannerUserApiService) MePlannerTasksGetProgressTaskBoardFormatExecute(r ApiMePlannerTasksGetProgressTaskBoardFormatRequest) (MicrosoftGraphPlannerProgressTaskBoardTaskFormat, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphPlannerProgressTaskBoardTaskFormat
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MePlannerUserApiService.MePlannerTasksGetProgressTaskBoardFormat")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/planner/tasks/{plannerTask-id}/progressTaskBoardFormat"
	localVarPath = strings.Replace(localVarPath, "{"+"plannerTask-id"+"}", _neturl.PathEscape(parameterToString(r.plannerTaskId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMePlannerTasksUpdateAssignedToTaskBoardFormatRequest struct {
	ctx _context.Context
	ApiService *MePlannerUserApiService
	plannerTaskId string
	microsoftGraphPlannerAssignedToTaskBoardTaskFormat *MicrosoftGraphPlannerAssignedToTaskBoardTaskFormat
}

// New navigation property values
func (r ApiMePlannerTasksUpdateAssignedToTaskBoardFormatRequest) MicrosoftGraphPlannerAssignedToTaskBoardTaskFormat(microsoftGraphPlannerAssignedToTaskBoardTaskFormat MicrosoftGraphPlannerAssignedToTaskBoardTaskFormat) ApiMePlannerTasksUpdateAssignedToTaskBoardFormatRequest {
	r.microsoftGraphPlannerAssignedToTaskBoardTaskFormat = &microsoftGraphPlannerAssignedToTaskBoardTaskFormat
	return r
}

func (r ApiMePlannerTasksUpdateAssignedToTaskBoardFormatRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.MePlannerTasksUpdateAssignedToTaskBoardFormatExecute(r)
}

/*
MePlannerTasksUpdateAssignedToTaskBoardFormat Update the navigation property assignedToTaskBoardFormat in me

Read-only. Nullable. Used to render the task correctly in the task board view when grouped by assignedTo.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param plannerTaskId key: id of plannerTask
 @return ApiMePlannerTasksUpdateAssignedToTaskBoardFormatRequest
*/
func (a *MePlannerUserApiService) MePlannerTasksUpdateAssignedToTaskBoardFormat(ctx _context.Context, plannerTaskId string) ApiMePlannerTasksUpdateAssignedToTaskBoardFormatRequest {
	return ApiMePlannerTasksUpdateAssignedToTaskBoardFormatRequest{
		ApiService: a,
		ctx: ctx,
		plannerTaskId: plannerTaskId,
	}
}

// Execute executes the request
func (a *MePlannerUserApiService) MePlannerTasksUpdateAssignedToTaskBoardFormatExecute(r ApiMePlannerTasksUpdateAssignedToTaskBoardFormatRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPatch
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MePlannerUserApiService.MePlannerTasksUpdateAssignedToTaskBoardFormat")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/planner/tasks/{plannerTask-id}/assignedToTaskBoardFormat"
	localVarPath = strings.Replace(localVarPath, "{"+"plannerTask-id"+"}", _neturl.PathEscape(parameterToString(r.plannerTaskId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphPlannerAssignedToTaskBoardTaskFormat == nil {
		return nil, reportError("microsoftGraphPlannerAssignedToTaskBoardTaskFormat is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphPlannerAssignedToTaskBoardTaskFormat
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiMePlannerTasksUpdateBucketTaskBoardFormatRequest struct {
	ctx _context.Context
	ApiService *MePlannerUserApiService
	plannerTaskId string
	microsoftGraphPlannerBucketTaskBoardTaskFormat *MicrosoftGraphPlannerBucketTaskBoardTaskFormat
}

// New navigation property values
func (r ApiMePlannerTasksUpdateBucketTaskBoardFormatRequest) MicrosoftGraphPlannerBucketTaskBoardTaskFormat(microsoftGraphPlannerBucketTaskBoardTaskFormat MicrosoftGraphPlannerBucketTaskBoardTaskFormat) ApiMePlannerTasksUpdateBucketTaskBoardFormatRequest {
	r.microsoftGraphPlannerBucketTaskBoardTaskFormat = &microsoftGraphPlannerBucketTaskBoardTaskFormat
	return r
}

func (r ApiMePlannerTasksUpdateBucketTaskBoardFormatRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.MePlannerTasksUpdateBucketTaskBoardFormatExecute(r)
}

/*
MePlannerTasksUpdateBucketTaskBoardFormat Update the navigation property bucketTaskBoardFormat in me

Read-only. Nullable. Used to render the task correctly in the task board view when grouped by bucket.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param plannerTaskId key: id of plannerTask
 @return ApiMePlannerTasksUpdateBucketTaskBoardFormatRequest
*/
func (a *MePlannerUserApiService) MePlannerTasksUpdateBucketTaskBoardFormat(ctx _context.Context, plannerTaskId string) ApiMePlannerTasksUpdateBucketTaskBoardFormatRequest {
	return ApiMePlannerTasksUpdateBucketTaskBoardFormatRequest{
		ApiService: a,
		ctx: ctx,
		plannerTaskId: plannerTaskId,
	}
}

// Execute executes the request
func (a *MePlannerUserApiService) MePlannerTasksUpdateBucketTaskBoardFormatExecute(r ApiMePlannerTasksUpdateBucketTaskBoardFormatRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPatch
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MePlannerUserApiService.MePlannerTasksUpdateBucketTaskBoardFormat")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/planner/tasks/{plannerTask-id}/bucketTaskBoardFormat"
	localVarPath = strings.Replace(localVarPath, "{"+"plannerTask-id"+"}", _neturl.PathEscape(parameterToString(r.plannerTaskId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphPlannerBucketTaskBoardTaskFormat == nil {
		return nil, reportError("microsoftGraphPlannerBucketTaskBoardTaskFormat is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphPlannerBucketTaskBoardTaskFormat
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiMePlannerTasksUpdateDetailsRequest struct {
	ctx _context.Context
	ApiService *MePlannerUserApiService
	plannerTaskId string
	microsoftGraphPlannerTaskDetails *MicrosoftGraphPlannerTaskDetails
}

// New navigation property values
func (r ApiMePlannerTasksUpdateDetailsRequest) MicrosoftGraphPlannerTaskDetails(microsoftGraphPlannerTaskDetails MicrosoftGraphPlannerTaskDetails) ApiMePlannerTasksUpdateDetailsRequest {
	r.microsoftGraphPlannerTaskDetails = &microsoftGraphPlannerTaskDetails
	return r
}

func (r ApiMePlannerTasksUpdateDetailsRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.MePlannerTasksUpdateDetailsExecute(r)
}

/*
MePlannerTasksUpdateDetails Update the navigation property details in me

Read-only. Nullable. Additional details about the task.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param plannerTaskId key: id of plannerTask
 @return ApiMePlannerTasksUpdateDetailsRequest
*/
func (a *MePlannerUserApiService) MePlannerTasksUpdateDetails(ctx _context.Context, plannerTaskId string) ApiMePlannerTasksUpdateDetailsRequest {
	return ApiMePlannerTasksUpdateDetailsRequest{
		ApiService: a,
		ctx: ctx,
		plannerTaskId: plannerTaskId,
	}
}

// Execute executes the request
func (a *MePlannerUserApiService) MePlannerTasksUpdateDetailsExecute(r ApiMePlannerTasksUpdateDetailsRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPatch
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MePlannerUserApiService.MePlannerTasksUpdateDetails")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/planner/tasks/{plannerTask-id}/details"
	localVarPath = strings.Replace(localVarPath, "{"+"plannerTask-id"+"}", _neturl.PathEscape(parameterToString(r.plannerTaskId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphPlannerTaskDetails == nil {
		return nil, reportError("microsoftGraphPlannerTaskDetails is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphPlannerTaskDetails
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiMePlannerTasksUpdateProgressTaskBoardFormatRequest struct {
	ctx _context.Context
	ApiService *MePlannerUserApiService
	plannerTaskId string
	microsoftGraphPlannerProgressTaskBoardTaskFormat *MicrosoftGraphPlannerProgressTaskBoardTaskFormat
}

// New navigation property values
func (r ApiMePlannerTasksUpdateProgressTaskBoardFormatRequest) MicrosoftGraphPlannerProgressTaskBoardTaskFormat(microsoftGraphPlannerProgressTaskBoardTaskFormat MicrosoftGraphPlannerProgressTaskBoardTaskFormat) ApiMePlannerTasksUpdateProgressTaskBoardFormatRequest {
	r.microsoftGraphPlannerProgressTaskBoardTaskFormat = &microsoftGraphPlannerProgressTaskBoardTaskFormat
	return r
}

func (r ApiMePlannerTasksUpdateProgressTaskBoardFormatRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.MePlannerTasksUpdateProgressTaskBoardFormatExecute(r)
}

/*
MePlannerTasksUpdateProgressTaskBoardFormat Update the navigation property progressTaskBoardFormat in me

Read-only. Nullable. Used to render the task correctly in the task board view when grouped by progress.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param plannerTaskId key: id of plannerTask
 @return ApiMePlannerTasksUpdateProgressTaskBoardFormatRequest
*/
func (a *MePlannerUserApiService) MePlannerTasksUpdateProgressTaskBoardFormat(ctx _context.Context, plannerTaskId string) ApiMePlannerTasksUpdateProgressTaskBoardFormatRequest {
	return ApiMePlannerTasksUpdateProgressTaskBoardFormatRequest{
		ApiService: a,
		ctx: ctx,
		plannerTaskId: plannerTaskId,
	}
}

// Execute executes the request
func (a *MePlannerUserApiService) MePlannerTasksUpdateProgressTaskBoardFormatExecute(r ApiMePlannerTasksUpdateProgressTaskBoardFormatRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPatch
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MePlannerUserApiService.MePlannerTasksUpdateProgressTaskBoardFormat")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/planner/tasks/{plannerTask-id}/progressTaskBoardFormat"
	localVarPath = strings.Replace(localVarPath, "{"+"plannerTask-id"+"}", _neturl.PathEscape(parameterToString(r.plannerTaskId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphPlannerProgressTaskBoardTaskFormat == nil {
		return nil, reportError("microsoftGraphPlannerProgressTaskBoardTaskFormat is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphPlannerProgressTaskBoardTaskFormat
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiMePlannerUpdatePlansRequest struct {
	ctx _context.Context
	ApiService *MePlannerUserApiService
	plannerPlanId string
	microsoftGraphPlannerPlan *MicrosoftGraphPlannerPlan
}

// New navigation property values
func (r ApiMePlannerUpdatePlansRequest) MicrosoftGraphPlannerPlan(microsoftGraphPlannerPlan MicrosoftGraphPlannerPlan) ApiMePlannerUpdatePlansRequest {
	r.microsoftGraphPlannerPlan = &microsoftGraphPlannerPlan
	return r
}

func (r ApiMePlannerUpdatePlansRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.MePlannerUpdatePlansExecute(r)
}

/*
MePlannerUpdatePlans Update the navigation property plans in me

Read-only. Nullable. Returns the plannerTasks assigned to the user.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param plannerPlanId key: id of plannerPlan
 @return ApiMePlannerUpdatePlansRequest
*/
func (a *MePlannerUserApiService) MePlannerUpdatePlans(ctx _context.Context, plannerPlanId string) ApiMePlannerUpdatePlansRequest {
	return ApiMePlannerUpdatePlansRequest{
		ApiService: a,
		ctx: ctx,
		plannerPlanId: plannerPlanId,
	}
}

// Execute executes the request
func (a *MePlannerUserApiService) MePlannerUpdatePlansExecute(r ApiMePlannerUpdatePlansRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPatch
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MePlannerUserApiService.MePlannerUpdatePlans")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/planner/plans/{plannerPlan-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"plannerPlan-id"+"}", _neturl.PathEscape(parameterToString(r.plannerPlanId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphPlannerPlan == nil {
		return nil, reportError("microsoftGraphPlannerPlan is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphPlannerPlan
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiMePlannerUpdateTasksRequest struct {
	ctx _context.Context
	ApiService *MePlannerUserApiService
	plannerTaskId string
	microsoftGraphPlannerTask *MicrosoftGraphPlannerTask
}

// New navigation property values
func (r ApiMePlannerUpdateTasksRequest) MicrosoftGraphPlannerTask(microsoftGraphPlannerTask MicrosoftGraphPlannerTask) ApiMePlannerUpdateTasksRequest {
	r.microsoftGraphPlannerTask = &microsoftGraphPlannerTask
	return r
}

func (r ApiMePlannerUpdateTasksRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.MePlannerUpdateTasksExecute(r)
}

/*
MePlannerUpdateTasks Update the navigation property tasks in me

Read-only. Nullable. Returns the plannerPlans shared with the user.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param plannerTaskId key: id of plannerTask
 @return ApiMePlannerUpdateTasksRequest
*/
func (a *MePlannerUserApiService) MePlannerUpdateTasks(ctx _context.Context, plannerTaskId string) ApiMePlannerUpdateTasksRequest {
	return ApiMePlannerUpdateTasksRequest{
		ApiService: a,
		ctx: ctx,
		plannerTaskId: plannerTaskId,
	}
}

// Execute executes the request
func (a *MePlannerUserApiService) MePlannerUpdateTasksExecute(r ApiMePlannerUpdateTasksRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPatch
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MePlannerUserApiService.MePlannerUpdateTasks")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/planner/tasks/{plannerTask-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"plannerTask-id"+"}", _neturl.PathEscape(parameterToString(r.plannerTaskId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphPlannerTask == nil {
		return nil, reportError("microsoftGraphPlannerTask is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphPlannerTask
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiMeUpdatePlannerRequest struct {
	ctx _context.Context
	ApiService *MePlannerUserApiService
	microsoftGraphPlannerUser *MicrosoftGraphPlannerUser
}

// New navigation property values
func (r ApiMeUpdatePlannerRequest) MicrosoftGraphPlannerUser(microsoftGraphPlannerUser MicrosoftGraphPlannerUser) ApiMeUpdatePlannerRequest {
	r.microsoftGraphPlannerUser = &microsoftGraphPlannerUser
	return r
}

func (r ApiMeUpdatePlannerRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.MeUpdatePlannerExecute(r)
}

/*
MeUpdatePlanner Update the navigation property planner in me

Entry-point to the Planner resource that might exist for a user. Read-only.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiMeUpdatePlannerRequest
*/
func (a *MePlannerUserApiService) MeUpdatePlanner(ctx _context.Context) ApiMeUpdatePlannerRequest {
	return ApiMeUpdatePlannerRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *MePlannerUserApiService) MeUpdatePlannerExecute(r ApiMeUpdatePlannerRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPatch
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MePlannerUserApiService.MeUpdatePlanner")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/planner"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphPlannerUser == nil {
		return nil, reportError("microsoftGraphPlannerUser is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphPlannerUser
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}
