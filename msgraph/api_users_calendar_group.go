/*
Partial Graph API

No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

API version: v1.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package openapi

import (
	"bytes"
	_context "context"
	_ioutil "io/ioutil"
	_nethttp "net/http"
	_neturl "net/url"
	"strings"
)

// Linger please
var (
	_ _context.Context
)

// UsersCalendarGroupApiService UsersCalendarGroupApi service
type UsersCalendarGroupApiService service

type ApiUsersCalendarGroupsCalendarsCalendarViewCreateAttachmentsRequest struct {
	ctx _context.Context
	ApiService *UsersCalendarGroupApiService
	userId string
	calendarGroupId string
	calendarId string
	eventId string
	microsoftGraphAttachment *MicrosoftGraphAttachment
}

// New navigation property
func (r ApiUsersCalendarGroupsCalendarsCalendarViewCreateAttachmentsRequest) MicrosoftGraphAttachment(microsoftGraphAttachment MicrosoftGraphAttachment) ApiUsersCalendarGroupsCalendarsCalendarViewCreateAttachmentsRequest {
	r.microsoftGraphAttachment = &microsoftGraphAttachment
	return r
}

func (r ApiUsersCalendarGroupsCalendarsCalendarViewCreateAttachmentsRequest) Execute() (MicrosoftGraphAttachment, *_nethttp.Response, error) {
	return r.ApiService.UsersCalendarGroupsCalendarsCalendarViewCreateAttachmentsExecute(r)
}

/*
UsersCalendarGroupsCalendarsCalendarViewCreateAttachments Create new navigation property to attachments for users

The collection of FileAttachment, ItemAttachment, and referenceAttachment attachments for the event. Navigation property. Read-only. Nullable.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @param calendarGroupId key: id of calendarGroup
 @param calendarId key: id of calendar
 @param eventId key: id of event
 @return ApiUsersCalendarGroupsCalendarsCalendarViewCreateAttachmentsRequest
*/
func (a *UsersCalendarGroupApiService) UsersCalendarGroupsCalendarsCalendarViewCreateAttachments(ctx _context.Context, userId string, calendarGroupId string, calendarId string, eventId string) ApiUsersCalendarGroupsCalendarsCalendarViewCreateAttachmentsRequest {
	return ApiUsersCalendarGroupsCalendarsCalendarViewCreateAttachmentsRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		calendarGroupId: calendarGroupId,
		calendarId: calendarId,
		eventId: eventId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphAttachment
func (a *UsersCalendarGroupApiService) UsersCalendarGroupsCalendarsCalendarViewCreateAttachmentsExecute(r ApiUsersCalendarGroupsCalendarsCalendarViewCreateAttachmentsRequest) (MicrosoftGraphAttachment, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphAttachment
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersCalendarGroupApiService.UsersCalendarGroupsCalendarsCalendarViewCreateAttachments")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/calendarGroups/{calendarGroup-id}/calendars/{calendar-id}/calendarView/{event-id}/attachments"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"calendarGroup-id"+"}", _neturl.PathEscape(parameterToString(r.calendarGroupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"calendar-id"+"}", _neturl.PathEscape(parameterToString(r.calendarId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphAttachment == nil {
		return localVarReturnValue, nil, reportError("microsoftGraphAttachment is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphAttachment
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUsersCalendarGroupsCalendarsCalendarViewCreateExtensionsRequest struct {
	ctx _context.Context
	ApiService *UsersCalendarGroupApiService
	userId string
	calendarGroupId string
	calendarId string
	eventId string
	microsoftGraphExtension *MicrosoftGraphExtension
}

// New navigation property
func (r ApiUsersCalendarGroupsCalendarsCalendarViewCreateExtensionsRequest) MicrosoftGraphExtension(microsoftGraphExtension MicrosoftGraphExtension) ApiUsersCalendarGroupsCalendarsCalendarViewCreateExtensionsRequest {
	r.microsoftGraphExtension = &microsoftGraphExtension
	return r
}

func (r ApiUsersCalendarGroupsCalendarsCalendarViewCreateExtensionsRequest) Execute() (MicrosoftGraphExtension, *_nethttp.Response, error) {
	return r.ApiService.UsersCalendarGroupsCalendarsCalendarViewCreateExtensionsExecute(r)
}

/*
UsersCalendarGroupsCalendarsCalendarViewCreateExtensions Create new navigation property to extensions for users

The collection of open extensions defined for the event. Nullable.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @param calendarGroupId key: id of calendarGroup
 @param calendarId key: id of calendar
 @param eventId key: id of event
 @return ApiUsersCalendarGroupsCalendarsCalendarViewCreateExtensionsRequest
*/
func (a *UsersCalendarGroupApiService) UsersCalendarGroupsCalendarsCalendarViewCreateExtensions(ctx _context.Context, userId string, calendarGroupId string, calendarId string, eventId string) ApiUsersCalendarGroupsCalendarsCalendarViewCreateExtensionsRequest {
	return ApiUsersCalendarGroupsCalendarsCalendarViewCreateExtensionsRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		calendarGroupId: calendarGroupId,
		calendarId: calendarId,
		eventId: eventId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphExtension
func (a *UsersCalendarGroupApiService) UsersCalendarGroupsCalendarsCalendarViewCreateExtensionsExecute(r ApiUsersCalendarGroupsCalendarsCalendarViewCreateExtensionsRequest) (MicrosoftGraphExtension, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphExtension
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersCalendarGroupApiService.UsersCalendarGroupsCalendarsCalendarViewCreateExtensions")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/calendarGroups/{calendarGroup-id}/calendars/{calendar-id}/calendarView/{event-id}/extensions"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"calendarGroup-id"+"}", _neturl.PathEscape(parameterToString(r.calendarGroupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"calendar-id"+"}", _neturl.PathEscape(parameterToString(r.calendarId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphExtension == nil {
		return localVarReturnValue, nil, reportError("microsoftGraphExtension is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphExtension
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUsersCalendarGroupsCalendarsCalendarViewCreateInstancesRequest struct {
	ctx _context.Context
	ApiService *UsersCalendarGroupApiService
	userId string
	calendarGroupId string
	calendarId string
	eventId string
	microsoftGraphEvent *MicrosoftGraphEvent
}

// New navigation property
func (r ApiUsersCalendarGroupsCalendarsCalendarViewCreateInstancesRequest) MicrosoftGraphEvent(microsoftGraphEvent MicrosoftGraphEvent) ApiUsersCalendarGroupsCalendarsCalendarViewCreateInstancesRequest {
	r.microsoftGraphEvent = &microsoftGraphEvent
	return r
}

func (r ApiUsersCalendarGroupsCalendarsCalendarViewCreateInstancesRequest) Execute() (MicrosoftGraphEvent, *_nethttp.Response, error) {
	return r.ApiService.UsersCalendarGroupsCalendarsCalendarViewCreateInstancesExecute(r)
}

/*
UsersCalendarGroupsCalendarsCalendarViewCreateInstances Create new navigation property to instances for users

The occurrences of a recurring series, if the event is a series master. This property includes occurrences that are part of the recurrence pattern, and exceptions that have been modified, but does not include occurrences that have been cancelled from the series. Navigation property. Read-only. Nullable.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @param calendarGroupId key: id of calendarGroup
 @param calendarId key: id of calendar
 @param eventId key: id of event
 @return ApiUsersCalendarGroupsCalendarsCalendarViewCreateInstancesRequest
*/
func (a *UsersCalendarGroupApiService) UsersCalendarGroupsCalendarsCalendarViewCreateInstances(ctx _context.Context, userId string, calendarGroupId string, calendarId string, eventId string) ApiUsersCalendarGroupsCalendarsCalendarViewCreateInstancesRequest {
	return ApiUsersCalendarGroupsCalendarsCalendarViewCreateInstancesRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		calendarGroupId: calendarGroupId,
		calendarId: calendarId,
		eventId: eventId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphEvent
func (a *UsersCalendarGroupApiService) UsersCalendarGroupsCalendarsCalendarViewCreateInstancesExecute(r ApiUsersCalendarGroupsCalendarsCalendarViewCreateInstancesRequest) (MicrosoftGraphEvent, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphEvent
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersCalendarGroupApiService.UsersCalendarGroupsCalendarsCalendarViewCreateInstances")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/calendarGroups/{calendarGroup-id}/calendars/{calendar-id}/calendarView/{event-id}/instances"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"calendarGroup-id"+"}", _neturl.PathEscape(parameterToString(r.calendarGroupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"calendar-id"+"}", _neturl.PathEscape(parameterToString(r.calendarId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphEvent == nil {
		return localVarReturnValue, nil, reportError("microsoftGraphEvent is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphEvent
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUsersCalendarGroupsCalendarsCalendarViewCreateMultiValueExtendedPropertiesRequest struct {
	ctx _context.Context
	ApiService *UsersCalendarGroupApiService
	userId string
	calendarGroupId string
	calendarId string
	eventId string
	microsoftGraphMultiValueLegacyExtendedProperty *MicrosoftGraphMultiValueLegacyExtendedProperty
}

// New navigation property
func (r ApiUsersCalendarGroupsCalendarsCalendarViewCreateMultiValueExtendedPropertiesRequest) MicrosoftGraphMultiValueLegacyExtendedProperty(microsoftGraphMultiValueLegacyExtendedProperty MicrosoftGraphMultiValueLegacyExtendedProperty) ApiUsersCalendarGroupsCalendarsCalendarViewCreateMultiValueExtendedPropertiesRequest {
	r.microsoftGraphMultiValueLegacyExtendedProperty = &microsoftGraphMultiValueLegacyExtendedProperty
	return r
}

func (r ApiUsersCalendarGroupsCalendarsCalendarViewCreateMultiValueExtendedPropertiesRequest) Execute() (MicrosoftGraphMultiValueLegacyExtendedProperty, *_nethttp.Response, error) {
	return r.ApiService.UsersCalendarGroupsCalendarsCalendarViewCreateMultiValueExtendedPropertiesExecute(r)
}

/*
UsersCalendarGroupsCalendarsCalendarViewCreateMultiValueExtendedProperties Create new navigation property to multiValueExtendedProperties for users

The collection of multi-value extended properties defined for the event. Read-only. Nullable.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @param calendarGroupId key: id of calendarGroup
 @param calendarId key: id of calendar
 @param eventId key: id of event
 @return ApiUsersCalendarGroupsCalendarsCalendarViewCreateMultiValueExtendedPropertiesRequest
*/
func (a *UsersCalendarGroupApiService) UsersCalendarGroupsCalendarsCalendarViewCreateMultiValueExtendedProperties(ctx _context.Context, userId string, calendarGroupId string, calendarId string, eventId string) ApiUsersCalendarGroupsCalendarsCalendarViewCreateMultiValueExtendedPropertiesRequest {
	return ApiUsersCalendarGroupsCalendarsCalendarViewCreateMultiValueExtendedPropertiesRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		calendarGroupId: calendarGroupId,
		calendarId: calendarId,
		eventId: eventId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphMultiValueLegacyExtendedProperty
func (a *UsersCalendarGroupApiService) UsersCalendarGroupsCalendarsCalendarViewCreateMultiValueExtendedPropertiesExecute(r ApiUsersCalendarGroupsCalendarsCalendarViewCreateMultiValueExtendedPropertiesRequest) (MicrosoftGraphMultiValueLegacyExtendedProperty, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphMultiValueLegacyExtendedProperty
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersCalendarGroupApiService.UsersCalendarGroupsCalendarsCalendarViewCreateMultiValueExtendedProperties")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/calendarGroups/{calendarGroup-id}/calendars/{calendar-id}/calendarView/{event-id}/multiValueExtendedProperties"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"calendarGroup-id"+"}", _neturl.PathEscape(parameterToString(r.calendarGroupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"calendar-id"+"}", _neturl.PathEscape(parameterToString(r.calendarId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphMultiValueLegacyExtendedProperty == nil {
		return localVarReturnValue, nil, reportError("microsoftGraphMultiValueLegacyExtendedProperty is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphMultiValueLegacyExtendedProperty
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUsersCalendarGroupsCalendarsCalendarViewCreateSingleValueExtendedPropertiesRequest struct {
	ctx _context.Context
	ApiService *UsersCalendarGroupApiService
	userId string
	calendarGroupId string
	calendarId string
	eventId string
	microsoftGraphSingleValueLegacyExtendedProperty *MicrosoftGraphSingleValueLegacyExtendedProperty
}

// New navigation property
func (r ApiUsersCalendarGroupsCalendarsCalendarViewCreateSingleValueExtendedPropertiesRequest) MicrosoftGraphSingleValueLegacyExtendedProperty(microsoftGraphSingleValueLegacyExtendedProperty MicrosoftGraphSingleValueLegacyExtendedProperty) ApiUsersCalendarGroupsCalendarsCalendarViewCreateSingleValueExtendedPropertiesRequest {
	r.microsoftGraphSingleValueLegacyExtendedProperty = &microsoftGraphSingleValueLegacyExtendedProperty
	return r
}

func (r ApiUsersCalendarGroupsCalendarsCalendarViewCreateSingleValueExtendedPropertiesRequest) Execute() (MicrosoftGraphSingleValueLegacyExtendedProperty, *_nethttp.Response, error) {
	return r.ApiService.UsersCalendarGroupsCalendarsCalendarViewCreateSingleValueExtendedPropertiesExecute(r)
}

/*
UsersCalendarGroupsCalendarsCalendarViewCreateSingleValueExtendedProperties Create new navigation property to singleValueExtendedProperties for users

The collection of single-value extended properties defined for the event. Read-only. Nullable.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @param calendarGroupId key: id of calendarGroup
 @param calendarId key: id of calendar
 @param eventId key: id of event
 @return ApiUsersCalendarGroupsCalendarsCalendarViewCreateSingleValueExtendedPropertiesRequest
*/
func (a *UsersCalendarGroupApiService) UsersCalendarGroupsCalendarsCalendarViewCreateSingleValueExtendedProperties(ctx _context.Context, userId string, calendarGroupId string, calendarId string, eventId string) ApiUsersCalendarGroupsCalendarsCalendarViewCreateSingleValueExtendedPropertiesRequest {
	return ApiUsersCalendarGroupsCalendarsCalendarViewCreateSingleValueExtendedPropertiesRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		calendarGroupId: calendarGroupId,
		calendarId: calendarId,
		eventId: eventId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphSingleValueLegacyExtendedProperty
func (a *UsersCalendarGroupApiService) UsersCalendarGroupsCalendarsCalendarViewCreateSingleValueExtendedPropertiesExecute(r ApiUsersCalendarGroupsCalendarsCalendarViewCreateSingleValueExtendedPropertiesRequest) (MicrosoftGraphSingleValueLegacyExtendedProperty, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphSingleValueLegacyExtendedProperty
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersCalendarGroupApiService.UsersCalendarGroupsCalendarsCalendarViewCreateSingleValueExtendedProperties")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/calendarGroups/{calendarGroup-id}/calendars/{calendar-id}/calendarView/{event-id}/singleValueExtendedProperties"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"calendarGroup-id"+"}", _neturl.PathEscape(parameterToString(r.calendarGroupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"calendar-id"+"}", _neturl.PathEscape(parameterToString(r.calendarId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphSingleValueLegacyExtendedProperty == nil {
		return localVarReturnValue, nil, reportError("microsoftGraphSingleValueLegacyExtendedProperty is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphSingleValueLegacyExtendedProperty
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUsersCalendarGroupsCalendarsCalendarViewDeleteAttachmentsRequest struct {
	ctx _context.Context
	ApiService *UsersCalendarGroupApiService
	userId string
	calendarGroupId string
	calendarId string
	eventId string
	attachmentId string
	ifMatch *string
}

// ETag
func (r ApiUsersCalendarGroupsCalendarsCalendarViewDeleteAttachmentsRequest) IfMatch(ifMatch string) ApiUsersCalendarGroupsCalendarsCalendarViewDeleteAttachmentsRequest {
	r.ifMatch = &ifMatch
	return r
}

func (r ApiUsersCalendarGroupsCalendarsCalendarViewDeleteAttachmentsRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.UsersCalendarGroupsCalendarsCalendarViewDeleteAttachmentsExecute(r)
}

/*
UsersCalendarGroupsCalendarsCalendarViewDeleteAttachments Delete navigation property attachments for users

The collection of FileAttachment, ItemAttachment, and referenceAttachment attachments for the event. Navigation property. Read-only. Nullable.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @param calendarGroupId key: id of calendarGroup
 @param calendarId key: id of calendar
 @param eventId key: id of event
 @param attachmentId key: id of attachment
 @return ApiUsersCalendarGroupsCalendarsCalendarViewDeleteAttachmentsRequest
*/
func (a *UsersCalendarGroupApiService) UsersCalendarGroupsCalendarsCalendarViewDeleteAttachments(ctx _context.Context, userId string, calendarGroupId string, calendarId string, eventId string, attachmentId string) ApiUsersCalendarGroupsCalendarsCalendarViewDeleteAttachmentsRequest {
	return ApiUsersCalendarGroupsCalendarsCalendarViewDeleteAttachmentsRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		calendarGroupId: calendarGroupId,
		calendarId: calendarId,
		eventId: eventId,
		attachmentId: attachmentId,
	}
}

// Execute executes the request
func (a *UsersCalendarGroupApiService) UsersCalendarGroupsCalendarsCalendarViewDeleteAttachmentsExecute(r ApiUsersCalendarGroupsCalendarsCalendarViewDeleteAttachmentsRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersCalendarGroupApiService.UsersCalendarGroupsCalendarsCalendarViewDeleteAttachments")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/calendarGroups/{calendarGroup-id}/calendars/{calendar-id}/calendarView/{event-id}/attachments/{attachment-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"calendarGroup-id"+"}", _neturl.PathEscape(parameterToString(r.calendarGroupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"calendar-id"+"}", _neturl.PathEscape(parameterToString(r.calendarId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"attachment-id"+"}", _neturl.PathEscape(parameterToString(r.attachmentId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ifMatch != nil {
		localVarHeaderParams["If-Match"] = parameterToString(*r.ifMatch, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUsersCalendarGroupsCalendarsCalendarViewDeleteCalendarRequest struct {
	ctx _context.Context
	ApiService *UsersCalendarGroupApiService
	userId string
	calendarGroupId string
	calendarId string
	eventId string
	ifMatch *string
}

// ETag
func (r ApiUsersCalendarGroupsCalendarsCalendarViewDeleteCalendarRequest) IfMatch(ifMatch string) ApiUsersCalendarGroupsCalendarsCalendarViewDeleteCalendarRequest {
	r.ifMatch = &ifMatch
	return r
}

func (r ApiUsersCalendarGroupsCalendarsCalendarViewDeleteCalendarRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.UsersCalendarGroupsCalendarsCalendarViewDeleteCalendarExecute(r)
}

/*
UsersCalendarGroupsCalendarsCalendarViewDeleteCalendar Delete navigation property calendar for users

The calendar that contains the event. Navigation property. Read-only.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @param calendarGroupId key: id of calendarGroup
 @param calendarId key: id of calendar
 @param eventId key: id of event
 @return ApiUsersCalendarGroupsCalendarsCalendarViewDeleteCalendarRequest
*/
func (a *UsersCalendarGroupApiService) UsersCalendarGroupsCalendarsCalendarViewDeleteCalendar(ctx _context.Context, userId string, calendarGroupId string, calendarId string, eventId string) ApiUsersCalendarGroupsCalendarsCalendarViewDeleteCalendarRequest {
	return ApiUsersCalendarGroupsCalendarsCalendarViewDeleteCalendarRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		calendarGroupId: calendarGroupId,
		calendarId: calendarId,
		eventId: eventId,
	}
}

// Execute executes the request
func (a *UsersCalendarGroupApiService) UsersCalendarGroupsCalendarsCalendarViewDeleteCalendarExecute(r ApiUsersCalendarGroupsCalendarsCalendarViewDeleteCalendarRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersCalendarGroupApiService.UsersCalendarGroupsCalendarsCalendarViewDeleteCalendar")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/calendarGroups/{calendarGroup-id}/calendars/{calendar-id}/calendarView/{event-id}/calendar"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"calendarGroup-id"+"}", _neturl.PathEscape(parameterToString(r.calendarGroupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"calendar-id"+"}", _neturl.PathEscape(parameterToString(r.calendarId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ifMatch != nil {
		localVarHeaderParams["If-Match"] = parameterToString(*r.ifMatch, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUsersCalendarGroupsCalendarsCalendarViewDeleteExtensionsRequest struct {
	ctx _context.Context
	ApiService *UsersCalendarGroupApiService
	userId string
	calendarGroupId string
	calendarId string
	eventId string
	extensionId string
	ifMatch *string
}

// ETag
func (r ApiUsersCalendarGroupsCalendarsCalendarViewDeleteExtensionsRequest) IfMatch(ifMatch string) ApiUsersCalendarGroupsCalendarsCalendarViewDeleteExtensionsRequest {
	r.ifMatch = &ifMatch
	return r
}

func (r ApiUsersCalendarGroupsCalendarsCalendarViewDeleteExtensionsRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.UsersCalendarGroupsCalendarsCalendarViewDeleteExtensionsExecute(r)
}

/*
UsersCalendarGroupsCalendarsCalendarViewDeleteExtensions Delete navigation property extensions for users

The collection of open extensions defined for the event. Nullable.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @param calendarGroupId key: id of calendarGroup
 @param calendarId key: id of calendar
 @param eventId key: id of event
 @param extensionId key: id of extension
 @return ApiUsersCalendarGroupsCalendarsCalendarViewDeleteExtensionsRequest
*/
func (a *UsersCalendarGroupApiService) UsersCalendarGroupsCalendarsCalendarViewDeleteExtensions(ctx _context.Context, userId string, calendarGroupId string, calendarId string, eventId string, extensionId string) ApiUsersCalendarGroupsCalendarsCalendarViewDeleteExtensionsRequest {
	return ApiUsersCalendarGroupsCalendarsCalendarViewDeleteExtensionsRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		calendarGroupId: calendarGroupId,
		calendarId: calendarId,
		eventId: eventId,
		extensionId: extensionId,
	}
}

// Execute executes the request
func (a *UsersCalendarGroupApiService) UsersCalendarGroupsCalendarsCalendarViewDeleteExtensionsExecute(r ApiUsersCalendarGroupsCalendarsCalendarViewDeleteExtensionsRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersCalendarGroupApiService.UsersCalendarGroupsCalendarsCalendarViewDeleteExtensions")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/calendarGroups/{calendarGroup-id}/calendars/{calendar-id}/calendarView/{event-id}/extensions/{extension-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"calendarGroup-id"+"}", _neturl.PathEscape(parameterToString(r.calendarGroupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"calendar-id"+"}", _neturl.PathEscape(parameterToString(r.calendarId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"extension-id"+"}", _neturl.PathEscape(parameterToString(r.extensionId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ifMatch != nil {
		localVarHeaderParams["If-Match"] = parameterToString(*r.ifMatch, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUsersCalendarGroupsCalendarsCalendarViewDeleteInstancesRequest struct {
	ctx _context.Context
	ApiService *UsersCalendarGroupApiService
	userId string
	calendarGroupId string
	calendarId string
	eventId string
	eventId1 string
	ifMatch *string
}

// ETag
func (r ApiUsersCalendarGroupsCalendarsCalendarViewDeleteInstancesRequest) IfMatch(ifMatch string) ApiUsersCalendarGroupsCalendarsCalendarViewDeleteInstancesRequest {
	r.ifMatch = &ifMatch
	return r
}

func (r ApiUsersCalendarGroupsCalendarsCalendarViewDeleteInstancesRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.UsersCalendarGroupsCalendarsCalendarViewDeleteInstancesExecute(r)
}

/*
UsersCalendarGroupsCalendarsCalendarViewDeleteInstances Delete navigation property instances for users

The occurrences of a recurring series, if the event is a series master. This property includes occurrences that are part of the recurrence pattern, and exceptions that have been modified, but does not include occurrences that have been cancelled from the series. Navigation property. Read-only. Nullable.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @param calendarGroupId key: id of calendarGroup
 @param calendarId key: id of calendar
 @param eventId key: id of event
 @param eventId1 key: id of event
 @return ApiUsersCalendarGroupsCalendarsCalendarViewDeleteInstancesRequest
*/
func (a *UsersCalendarGroupApiService) UsersCalendarGroupsCalendarsCalendarViewDeleteInstances(ctx _context.Context, userId string, calendarGroupId string, calendarId string, eventId string, eventId1 string) ApiUsersCalendarGroupsCalendarsCalendarViewDeleteInstancesRequest {
	return ApiUsersCalendarGroupsCalendarsCalendarViewDeleteInstancesRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		calendarGroupId: calendarGroupId,
		calendarId: calendarId,
		eventId: eventId,
		eventId1: eventId1,
	}
}

// Execute executes the request
func (a *UsersCalendarGroupApiService) UsersCalendarGroupsCalendarsCalendarViewDeleteInstancesExecute(r ApiUsersCalendarGroupsCalendarsCalendarViewDeleteInstancesRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersCalendarGroupApiService.UsersCalendarGroupsCalendarsCalendarViewDeleteInstances")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/calendarGroups/{calendarGroup-id}/calendars/{calendar-id}/calendarView/{event-id}/instances/{event-id1}"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"calendarGroup-id"+"}", _neturl.PathEscape(parameterToString(r.calendarGroupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"calendar-id"+"}", _neturl.PathEscape(parameterToString(r.calendarId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id1"+"}", _neturl.PathEscape(parameterToString(r.eventId1, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ifMatch != nil {
		localVarHeaderParams["If-Match"] = parameterToString(*r.ifMatch, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUsersCalendarGroupsCalendarsCalendarViewDeleteMultiValueExtendedPropertiesRequest struct {
	ctx _context.Context
	ApiService *UsersCalendarGroupApiService
	userId string
	calendarGroupId string
	calendarId string
	eventId string
	multiValueLegacyExtendedPropertyId string
	ifMatch *string
}

// ETag
func (r ApiUsersCalendarGroupsCalendarsCalendarViewDeleteMultiValueExtendedPropertiesRequest) IfMatch(ifMatch string) ApiUsersCalendarGroupsCalendarsCalendarViewDeleteMultiValueExtendedPropertiesRequest {
	r.ifMatch = &ifMatch
	return r
}

func (r ApiUsersCalendarGroupsCalendarsCalendarViewDeleteMultiValueExtendedPropertiesRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.UsersCalendarGroupsCalendarsCalendarViewDeleteMultiValueExtendedPropertiesExecute(r)
}

/*
UsersCalendarGroupsCalendarsCalendarViewDeleteMultiValueExtendedProperties Delete navigation property multiValueExtendedProperties for users

The collection of multi-value extended properties defined for the event. Read-only. Nullable.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @param calendarGroupId key: id of calendarGroup
 @param calendarId key: id of calendar
 @param eventId key: id of event
 @param multiValueLegacyExtendedPropertyId key: id of multiValueLegacyExtendedProperty
 @return ApiUsersCalendarGroupsCalendarsCalendarViewDeleteMultiValueExtendedPropertiesRequest
*/
func (a *UsersCalendarGroupApiService) UsersCalendarGroupsCalendarsCalendarViewDeleteMultiValueExtendedProperties(ctx _context.Context, userId string, calendarGroupId string, calendarId string, eventId string, multiValueLegacyExtendedPropertyId string) ApiUsersCalendarGroupsCalendarsCalendarViewDeleteMultiValueExtendedPropertiesRequest {
	return ApiUsersCalendarGroupsCalendarsCalendarViewDeleteMultiValueExtendedPropertiesRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		calendarGroupId: calendarGroupId,
		calendarId: calendarId,
		eventId: eventId,
		multiValueLegacyExtendedPropertyId: multiValueLegacyExtendedPropertyId,
	}
}

// Execute executes the request
func (a *UsersCalendarGroupApiService) UsersCalendarGroupsCalendarsCalendarViewDeleteMultiValueExtendedPropertiesExecute(r ApiUsersCalendarGroupsCalendarsCalendarViewDeleteMultiValueExtendedPropertiesRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersCalendarGroupApiService.UsersCalendarGroupsCalendarsCalendarViewDeleteMultiValueExtendedProperties")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/calendarGroups/{calendarGroup-id}/calendars/{calendar-id}/calendarView/{event-id}/multiValueExtendedProperties/{multiValueLegacyExtendedProperty-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"calendarGroup-id"+"}", _neturl.PathEscape(parameterToString(r.calendarGroupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"calendar-id"+"}", _neturl.PathEscape(parameterToString(r.calendarId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"multiValueLegacyExtendedProperty-id"+"}", _neturl.PathEscape(parameterToString(r.multiValueLegacyExtendedPropertyId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ifMatch != nil {
		localVarHeaderParams["If-Match"] = parameterToString(*r.ifMatch, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUsersCalendarGroupsCalendarsCalendarViewDeleteSingleValueExtendedPropertiesRequest struct {
	ctx _context.Context
	ApiService *UsersCalendarGroupApiService
	userId string
	calendarGroupId string
	calendarId string
	eventId string
	singleValueLegacyExtendedPropertyId string
	ifMatch *string
}

// ETag
func (r ApiUsersCalendarGroupsCalendarsCalendarViewDeleteSingleValueExtendedPropertiesRequest) IfMatch(ifMatch string) ApiUsersCalendarGroupsCalendarsCalendarViewDeleteSingleValueExtendedPropertiesRequest {
	r.ifMatch = &ifMatch
	return r
}

func (r ApiUsersCalendarGroupsCalendarsCalendarViewDeleteSingleValueExtendedPropertiesRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.UsersCalendarGroupsCalendarsCalendarViewDeleteSingleValueExtendedPropertiesExecute(r)
}

/*
UsersCalendarGroupsCalendarsCalendarViewDeleteSingleValueExtendedProperties Delete navigation property singleValueExtendedProperties for users

The collection of single-value extended properties defined for the event. Read-only. Nullable.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @param calendarGroupId key: id of calendarGroup
 @param calendarId key: id of calendar
 @param eventId key: id of event
 @param singleValueLegacyExtendedPropertyId key: id of singleValueLegacyExtendedProperty
 @return ApiUsersCalendarGroupsCalendarsCalendarViewDeleteSingleValueExtendedPropertiesRequest
*/
func (a *UsersCalendarGroupApiService) UsersCalendarGroupsCalendarsCalendarViewDeleteSingleValueExtendedProperties(ctx _context.Context, userId string, calendarGroupId string, calendarId string, eventId string, singleValueLegacyExtendedPropertyId string) ApiUsersCalendarGroupsCalendarsCalendarViewDeleteSingleValueExtendedPropertiesRequest {
	return ApiUsersCalendarGroupsCalendarsCalendarViewDeleteSingleValueExtendedPropertiesRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		calendarGroupId: calendarGroupId,
		calendarId: calendarId,
		eventId: eventId,
		singleValueLegacyExtendedPropertyId: singleValueLegacyExtendedPropertyId,
	}
}

// Execute executes the request
func (a *UsersCalendarGroupApiService) UsersCalendarGroupsCalendarsCalendarViewDeleteSingleValueExtendedPropertiesExecute(r ApiUsersCalendarGroupsCalendarsCalendarViewDeleteSingleValueExtendedPropertiesRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersCalendarGroupApiService.UsersCalendarGroupsCalendarsCalendarViewDeleteSingleValueExtendedProperties")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/calendarGroups/{calendarGroup-id}/calendars/{calendar-id}/calendarView/{event-id}/singleValueExtendedProperties/{singleValueLegacyExtendedProperty-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"calendarGroup-id"+"}", _neturl.PathEscape(parameterToString(r.calendarGroupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"calendar-id"+"}", _neturl.PathEscape(parameterToString(r.calendarId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"singleValueLegacyExtendedProperty-id"+"}", _neturl.PathEscape(parameterToString(r.singleValueLegacyExtendedPropertyId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ifMatch != nil {
		localVarHeaderParams["If-Match"] = parameterToString(*r.ifMatch, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUsersCalendarGroupsCalendarsCalendarViewGetAttachmentsRequest struct {
	ctx _context.Context
	ApiService *UsersCalendarGroupApiService
	userId string
	calendarGroupId string
	calendarId string
	eventId string
	attachmentId string
	select_ *[]string
	expand *[]string
}

// Select properties to be returned
func (r ApiUsersCalendarGroupsCalendarsCalendarViewGetAttachmentsRequest) Select_(select_ []string) ApiUsersCalendarGroupsCalendarsCalendarViewGetAttachmentsRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiUsersCalendarGroupsCalendarsCalendarViewGetAttachmentsRequest) Expand(expand []string) ApiUsersCalendarGroupsCalendarsCalendarViewGetAttachmentsRequest {
	r.expand = &expand
	return r
}

func (r ApiUsersCalendarGroupsCalendarsCalendarViewGetAttachmentsRequest) Execute() (MicrosoftGraphAttachment, *_nethttp.Response, error) {
	return r.ApiService.UsersCalendarGroupsCalendarsCalendarViewGetAttachmentsExecute(r)
}

/*
UsersCalendarGroupsCalendarsCalendarViewGetAttachments Get attachments from users

The collection of FileAttachment, ItemAttachment, and referenceAttachment attachments for the event. Navigation property. Read-only. Nullable.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @param calendarGroupId key: id of calendarGroup
 @param calendarId key: id of calendar
 @param eventId key: id of event
 @param attachmentId key: id of attachment
 @return ApiUsersCalendarGroupsCalendarsCalendarViewGetAttachmentsRequest
*/
func (a *UsersCalendarGroupApiService) UsersCalendarGroupsCalendarsCalendarViewGetAttachments(ctx _context.Context, userId string, calendarGroupId string, calendarId string, eventId string, attachmentId string) ApiUsersCalendarGroupsCalendarsCalendarViewGetAttachmentsRequest {
	return ApiUsersCalendarGroupsCalendarsCalendarViewGetAttachmentsRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		calendarGroupId: calendarGroupId,
		calendarId: calendarId,
		eventId: eventId,
		attachmentId: attachmentId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphAttachment
func (a *UsersCalendarGroupApiService) UsersCalendarGroupsCalendarsCalendarViewGetAttachmentsExecute(r ApiUsersCalendarGroupsCalendarsCalendarViewGetAttachmentsRequest) (MicrosoftGraphAttachment, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphAttachment
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersCalendarGroupApiService.UsersCalendarGroupsCalendarsCalendarViewGetAttachments")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/calendarGroups/{calendarGroup-id}/calendars/{calendar-id}/calendarView/{event-id}/attachments/{attachment-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"calendarGroup-id"+"}", _neturl.PathEscape(parameterToString(r.calendarGroupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"calendar-id"+"}", _neturl.PathEscape(parameterToString(r.calendarId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"attachment-id"+"}", _neturl.PathEscape(parameterToString(r.attachmentId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUsersCalendarGroupsCalendarsCalendarViewGetCalendarRequest struct {
	ctx _context.Context
	ApiService *UsersCalendarGroupApiService
	userId string
	calendarGroupId string
	calendarId string
	eventId string
	select_ *[]string
}

// Select properties to be returned
func (r ApiUsersCalendarGroupsCalendarsCalendarViewGetCalendarRequest) Select_(select_ []string) ApiUsersCalendarGroupsCalendarsCalendarViewGetCalendarRequest {
	r.select_ = &select_
	return r
}

func (r ApiUsersCalendarGroupsCalendarsCalendarViewGetCalendarRequest) Execute() (MicrosoftGraphCalendar, *_nethttp.Response, error) {
	return r.ApiService.UsersCalendarGroupsCalendarsCalendarViewGetCalendarExecute(r)
}

/*
UsersCalendarGroupsCalendarsCalendarViewGetCalendar Get calendar from users

The calendar that contains the event. Navigation property. Read-only.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @param calendarGroupId key: id of calendarGroup
 @param calendarId key: id of calendar
 @param eventId key: id of event
 @return ApiUsersCalendarGroupsCalendarsCalendarViewGetCalendarRequest
*/
func (a *UsersCalendarGroupApiService) UsersCalendarGroupsCalendarsCalendarViewGetCalendar(ctx _context.Context, userId string, calendarGroupId string, calendarId string, eventId string) ApiUsersCalendarGroupsCalendarsCalendarViewGetCalendarRequest {
	return ApiUsersCalendarGroupsCalendarsCalendarViewGetCalendarRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		calendarGroupId: calendarGroupId,
		calendarId: calendarId,
		eventId: eventId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphCalendar
func (a *UsersCalendarGroupApiService) UsersCalendarGroupsCalendarsCalendarViewGetCalendarExecute(r ApiUsersCalendarGroupsCalendarsCalendarViewGetCalendarRequest) (MicrosoftGraphCalendar, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphCalendar
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersCalendarGroupApiService.UsersCalendarGroupsCalendarsCalendarViewGetCalendar")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/calendarGroups/{calendarGroup-id}/calendars/{calendar-id}/calendarView/{event-id}/calendar"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"calendarGroup-id"+"}", _neturl.PathEscape(parameterToString(r.calendarGroupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"calendar-id"+"}", _neturl.PathEscape(parameterToString(r.calendarId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUsersCalendarGroupsCalendarsCalendarViewGetExtensionsRequest struct {
	ctx _context.Context
	ApiService *UsersCalendarGroupApiService
	userId string
	calendarGroupId string
	calendarId string
	eventId string
	extensionId string
	select_ *[]string
	expand *[]string
}

// Select properties to be returned
func (r ApiUsersCalendarGroupsCalendarsCalendarViewGetExtensionsRequest) Select_(select_ []string) ApiUsersCalendarGroupsCalendarsCalendarViewGetExtensionsRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiUsersCalendarGroupsCalendarsCalendarViewGetExtensionsRequest) Expand(expand []string) ApiUsersCalendarGroupsCalendarsCalendarViewGetExtensionsRequest {
	r.expand = &expand
	return r
}

func (r ApiUsersCalendarGroupsCalendarsCalendarViewGetExtensionsRequest) Execute() (MicrosoftGraphExtension, *_nethttp.Response, error) {
	return r.ApiService.UsersCalendarGroupsCalendarsCalendarViewGetExtensionsExecute(r)
}

/*
UsersCalendarGroupsCalendarsCalendarViewGetExtensions Get extensions from users

The collection of open extensions defined for the event. Nullable.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @param calendarGroupId key: id of calendarGroup
 @param calendarId key: id of calendar
 @param eventId key: id of event
 @param extensionId key: id of extension
 @return ApiUsersCalendarGroupsCalendarsCalendarViewGetExtensionsRequest
*/
func (a *UsersCalendarGroupApiService) UsersCalendarGroupsCalendarsCalendarViewGetExtensions(ctx _context.Context, userId string, calendarGroupId string, calendarId string, eventId string, extensionId string) ApiUsersCalendarGroupsCalendarsCalendarViewGetExtensionsRequest {
	return ApiUsersCalendarGroupsCalendarsCalendarViewGetExtensionsRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		calendarGroupId: calendarGroupId,
		calendarId: calendarId,
		eventId: eventId,
		extensionId: extensionId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphExtension
func (a *UsersCalendarGroupApiService) UsersCalendarGroupsCalendarsCalendarViewGetExtensionsExecute(r ApiUsersCalendarGroupsCalendarsCalendarViewGetExtensionsRequest) (MicrosoftGraphExtension, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphExtension
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersCalendarGroupApiService.UsersCalendarGroupsCalendarsCalendarViewGetExtensions")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/calendarGroups/{calendarGroup-id}/calendars/{calendar-id}/calendarView/{event-id}/extensions/{extension-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"calendarGroup-id"+"}", _neturl.PathEscape(parameterToString(r.calendarGroupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"calendar-id"+"}", _neturl.PathEscape(parameterToString(r.calendarId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"extension-id"+"}", _neturl.PathEscape(parameterToString(r.extensionId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUsersCalendarGroupsCalendarsCalendarViewGetInstancesRequest struct {
	ctx _context.Context
	ApiService *UsersCalendarGroupApiService
	userId string
	calendarGroupId string
	calendarId string
	eventId string
	eventId1 string
	select_ *[]string
}

// Select properties to be returned
func (r ApiUsersCalendarGroupsCalendarsCalendarViewGetInstancesRequest) Select_(select_ []string) ApiUsersCalendarGroupsCalendarsCalendarViewGetInstancesRequest {
	r.select_ = &select_
	return r
}

func (r ApiUsersCalendarGroupsCalendarsCalendarViewGetInstancesRequest) Execute() (MicrosoftGraphEvent, *_nethttp.Response, error) {
	return r.ApiService.UsersCalendarGroupsCalendarsCalendarViewGetInstancesExecute(r)
}

/*
UsersCalendarGroupsCalendarsCalendarViewGetInstances Get instances from users

The occurrences of a recurring series, if the event is a series master. This property includes occurrences that are part of the recurrence pattern, and exceptions that have been modified, but does not include occurrences that have been cancelled from the series. Navigation property. Read-only. Nullable.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @param calendarGroupId key: id of calendarGroup
 @param calendarId key: id of calendar
 @param eventId key: id of event
 @param eventId1 key: id of event
 @return ApiUsersCalendarGroupsCalendarsCalendarViewGetInstancesRequest
*/
func (a *UsersCalendarGroupApiService) UsersCalendarGroupsCalendarsCalendarViewGetInstances(ctx _context.Context, userId string, calendarGroupId string, calendarId string, eventId string, eventId1 string) ApiUsersCalendarGroupsCalendarsCalendarViewGetInstancesRequest {
	return ApiUsersCalendarGroupsCalendarsCalendarViewGetInstancesRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		calendarGroupId: calendarGroupId,
		calendarId: calendarId,
		eventId: eventId,
		eventId1: eventId1,
	}
}

// Execute executes the request
//  @return MicrosoftGraphEvent
func (a *UsersCalendarGroupApiService) UsersCalendarGroupsCalendarsCalendarViewGetInstancesExecute(r ApiUsersCalendarGroupsCalendarsCalendarViewGetInstancesRequest) (MicrosoftGraphEvent, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphEvent
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersCalendarGroupApiService.UsersCalendarGroupsCalendarsCalendarViewGetInstances")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/calendarGroups/{calendarGroup-id}/calendars/{calendar-id}/calendarView/{event-id}/instances/{event-id1}"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"calendarGroup-id"+"}", _neturl.PathEscape(parameterToString(r.calendarGroupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"calendar-id"+"}", _neturl.PathEscape(parameterToString(r.calendarId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id1"+"}", _neturl.PathEscape(parameterToString(r.eventId1, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUsersCalendarGroupsCalendarsCalendarViewGetMultiValueExtendedPropertiesRequest struct {
	ctx _context.Context
	ApiService *UsersCalendarGroupApiService
	userId string
	calendarGroupId string
	calendarId string
	eventId string
	multiValueLegacyExtendedPropertyId string
	select_ *[]string
	expand *[]string
}

// Select properties to be returned
func (r ApiUsersCalendarGroupsCalendarsCalendarViewGetMultiValueExtendedPropertiesRequest) Select_(select_ []string) ApiUsersCalendarGroupsCalendarsCalendarViewGetMultiValueExtendedPropertiesRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiUsersCalendarGroupsCalendarsCalendarViewGetMultiValueExtendedPropertiesRequest) Expand(expand []string) ApiUsersCalendarGroupsCalendarsCalendarViewGetMultiValueExtendedPropertiesRequest {
	r.expand = &expand
	return r
}

func (r ApiUsersCalendarGroupsCalendarsCalendarViewGetMultiValueExtendedPropertiesRequest) Execute() (MicrosoftGraphMultiValueLegacyExtendedProperty, *_nethttp.Response, error) {
	return r.ApiService.UsersCalendarGroupsCalendarsCalendarViewGetMultiValueExtendedPropertiesExecute(r)
}

/*
UsersCalendarGroupsCalendarsCalendarViewGetMultiValueExtendedProperties Get multiValueExtendedProperties from users

The collection of multi-value extended properties defined for the event. Read-only. Nullable.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @param calendarGroupId key: id of calendarGroup
 @param calendarId key: id of calendar
 @param eventId key: id of event
 @param multiValueLegacyExtendedPropertyId key: id of multiValueLegacyExtendedProperty
 @return ApiUsersCalendarGroupsCalendarsCalendarViewGetMultiValueExtendedPropertiesRequest
*/
func (a *UsersCalendarGroupApiService) UsersCalendarGroupsCalendarsCalendarViewGetMultiValueExtendedProperties(ctx _context.Context, userId string, calendarGroupId string, calendarId string, eventId string, multiValueLegacyExtendedPropertyId string) ApiUsersCalendarGroupsCalendarsCalendarViewGetMultiValueExtendedPropertiesRequest {
	return ApiUsersCalendarGroupsCalendarsCalendarViewGetMultiValueExtendedPropertiesRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		calendarGroupId: calendarGroupId,
		calendarId: calendarId,
		eventId: eventId,
		multiValueLegacyExtendedPropertyId: multiValueLegacyExtendedPropertyId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphMultiValueLegacyExtendedProperty
func (a *UsersCalendarGroupApiService) UsersCalendarGroupsCalendarsCalendarViewGetMultiValueExtendedPropertiesExecute(r ApiUsersCalendarGroupsCalendarsCalendarViewGetMultiValueExtendedPropertiesRequest) (MicrosoftGraphMultiValueLegacyExtendedProperty, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphMultiValueLegacyExtendedProperty
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersCalendarGroupApiService.UsersCalendarGroupsCalendarsCalendarViewGetMultiValueExtendedProperties")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/calendarGroups/{calendarGroup-id}/calendars/{calendar-id}/calendarView/{event-id}/multiValueExtendedProperties/{multiValueLegacyExtendedProperty-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"calendarGroup-id"+"}", _neturl.PathEscape(parameterToString(r.calendarGroupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"calendar-id"+"}", _neturl.PathEscape(parameterToString(r.calendarId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"multiValueLegacyExtendedProperty-id"+"}", _neturl.PathEscape(parameterToString(r.multiValueLegacyExtendedPropertyId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUsersCalendarGroupsCalendarsCalendarViewGetSingleValueExtendedPropertiesRequest struct {
	ctx _context.Context
	ApiService *UsersCalendarGroupApiService
	userId string
	calendarGroupId string
	calendarId string
	eventId string
	singleValueLegacyExtendedPropertyId string
	select_ *[]string
	expand *[]string
}

// Select properties to be returned
func (r ApiUsersCalendarGroupsCalendarsCalendarViewGetSingleValueExtendedPropertiesRequest) Select_(select_ []string) ApiUsersCalendarGroupsCalendarsCalendarViewGetSingleValueExtendedPropertiesRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiUsersCalendarGroupsCalendarsCalendarViewGetSingleValueExtendedPropertiesRequest) Expand(expand []string) ApiUsersCalendarGroupsCalendarsCalendarViewGetSingleValueExtendedPropertiesRequest {
	r.expand = &expand
	return r
}

func (r ApiUsersCalendarGroupsCalendarsCalendarViewGetSingleValueExtendedPropertiesRequest) Execute() (MicrosoftGraphSingleValueLegacyExtendedProperty, *_nethttp.Response, error) {
	return r.ApiService.UsersCalendarGroupsCalendarsCalendarViewGetSingleValueExtendedPropertiesExecute(r)
}

/*
UsersCalendarGroupsCalendarsCalendarViewGetSingleValueExtendedProperties Get singleValueExtendedProperties from users

The collection of single-value extended properties defined for the event. Read-only. Nullable.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @param calendarGroupId key: id of calendarGroup
 @param calendarId key: id of calendar
 @param eventId key: id of event
 @param singleValueLegacyExtendedPropertyId key: id of singleValueLegacyExtendedProperty
 @return ApiUsersCalendarGroupsCalendarsCalendarViewGetSingleValueExtendedPropertiesRequest
*/
func (a *UsersCalendarGroupApiService) UsersCalendarGroupsCalendarsCalendarViewGetSingleValueExtendedProperties(ctx _context.Context, userId string, calendarGroupId string, calendarId string, eventId string, singleValueLegacyExtendedPropertyId string) ApiUsersCalendarGroupsCalendarsCalendarViewGetSingleValueExtendedPropertiesRequest {
	return ApiUsersCalendarGroupsCalendarsCalendarViewGetSingleValueExtendedPropertiesRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		calendarGroupId: calendarGroupId,
		calendarId: calendarId,
		eventId: eventId,
		singleValueLegacyExtendedPropertyId: singleValueLegacyExtendedPropertyId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphSingleValueLegacyExtendedProperty
func (a *UsersCalendarGroupApiService) UsersCalendarGroupsCalendarsCalendarViewGetSingleValueExtendedPropertiesExecute(r ApiUsersCalendarGroupsCalendarsCalendarViewGetSingleValueExtendedPropertiesRequest) (MicrosoftGraphSingleValueLegacyExtendedProperty, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphSingleValueLegacyExtendedProperty
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersCalendarGroupApiService.UsersCalendarGroupsCalendarsCalendarViewGetSingleValueExtendedProperties")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/calendarGroups/{calendarGroup-id}/calendars/{calendar-id}/calendarView/{event-id}/singleValueExtendedProperties/{singleValueLegacyExtendedProperty-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"calendarGroup-id"+"}", _neturl.PathEscape(parameterToString(r.calendarGroupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"calendar-id"+"}", _neturl.PathEscape(parameterToString(r.calendarId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"singleValueLegacyExtendedProperty-id"+"}", _neturl.PathEscape(parameterToString(r.singleValueLegacyExtendedPropertyId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUsersCalendarGroupsCalendarsCalendarViewListAttachmentsRequest struct {
	ctx _context.Context
	ApiService *UsersCalendarGroupApiService
	userId string
	calendarGroupId string
	calendarId string
	eventId string
	top *int32
	skip *int32
	filter *string
	count *bool
	orderby *[]string
	select_ *[]string
	expand *[]string
}

// Show only the first n items
func (r ApiUsersCalendarGroupsCalendarsCalendarViewListAttachmentsRequest) Top(top int32) ApiUsersCalendarGroupsCalendarsCalendarViewListAttachmentsRequest {
	r.top = &top
	return r
}
// Skip the first n items
func (r ApiUsersCalendarGroupsCalendarsCalendarViewListAttachmentsRequest) Skip(skip int32) ApiUsersCalendarGroupsCalendarsCalendarViewListAttachmentsRequest {
	r.skip = &skip
	return r
}
// Filter items by property values
func (r ApiUsersCalendarGroupsCalendarsCalendarViewListAttachmentsRequest) Filter(filter string) ApiUsersCalendarGroupsCalendarsCalendarViewListAttachmentsRequest {
	r.filter = &filter
	return r
}
// Include count of items
func (r ApiUsersCalendarGroupsCalendarsCalendarViewListAttachmentsRequest) Count(count bool) ApiUsersCalendarGroupsCalendarsCalendarViewListAttachmentsRequest {
	r.count = &count
	return r
}
// Order items by property values
func (r ApiUsersCalendarGroupsCalendarsCalendarViewListAttachmentsRequest) Orderby(orderby []string) ApiUsersCalendarGroupsCalendarsCalendarViewListAttachmentsRequest {
	r.orderby = &orderby
	return r
}
// Select properties to be returned
func (r ApiUsersCalendarGroupsCalendarsCalendarViewListAttachmentsRequest) Select_(select_ []string) ApiUsersCalendarGroupsCalendarsCalendarViewListAttachmentsRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiUsersCalendarGroupsCalendarsCalendarViewListAttachmentsRequest) Expand(expand []string) ApiUsersCalendarGroupsCalendarsCalendarViewListAttachmentsRequest {
	r.expand = &expand
	return r
}

func (r ApiUsersCalendarGroupsCalendarsCalendarViewListAttachmentsRequest) Execute() (CollectionOfAttachment, *_nethttp.Response, error) {
	return r.ApiService.UsersCalendarGroupsCalendarsCalendarViewListAttachmentsExecute(r)
}

/*
UsersCalendarGroupsCalendarsCalendarViewListAttachments Get attachments from users

The collection of FileAttachment, ItemAttachment, and referenceAttachment attachments for the event. Navigation property. Read-only. Nullable.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @param calendarGroupId key: id of calendarGroup
 @param calendarId key: id of calendar
 @param eventId key: id of event
 @return ApiUsersCalendarGroupsCalendarsCalendarViewListAttachmentsRequest
*/
func (a *UsersCalendarGroupApiService) UsersCalendarGroupsCalendarsCalendarViewListAttachments(ctx _context.Context, userId string, calendarGroupId string, calendarId string, eventId string) ApiUsersCalendarGroupsCalendarsCalendarViewListAttachmentsRequest {
	return ApiUsersCalendarGroupsCalendarsCalendarViewListAttachmentsRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		calendarGroupId: calendarGroupId,
		calendarId: calendarId,
		eventId: eventId,
	}
}

// Execute executes the request
//  @return CollectionOfAttachment
func (a *UsersCalendarGroupApiService) UsersCalendarGroupsCalendarsCalendarViewListAttachmentsExecute(r ApiUsersCalendarGroupsCalendarsCalendarViewListAttachmentsRequest) (CollectionOfAttachment, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  CollectionOfAttachment
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersCalendarGroupApiService.UsersCalendarGroupsCalendarsCalendarViewListAttachments")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/calendarGroups/{calendarGroup-id}/calendars/{calendar-id}/calendarView/{event-id}/attachments"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"calendarGroup-id"+"}", _neturl.PathEscape(parameterToString(r.calendarGroupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"calendar-id"+"}", _neturl.PathEscape(parameterToString(r.calendarId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.top != nil {
		localVarQueryParams.Add("$top", parameterToString(*r.top, ""))
	}
	if r.skip != nil {
		localVarQueryParams.Add("$skip", parameterToString(*r.skip, ""))
	}
	if r.filter != nil {
		localVarQueryParams.Add("$filter", parameterToString(*r.filter, ""))
	}
	if r.count != nil {
		localVarQueryParams.Add("$count", parameterToString(*r.count, ""))
	}
	if r.orderby != nil {
		localVarQueryParams.Add("$orderby", parameterToString(*r.orderby, "csv"))
	}
	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUsersCalendarGroupsCalendarsCalendarViewListExtensionsRequest struct {
	ctx _context.Context
	ApiService *UsersCalendarGroupApiService
	userId string
	calendarGroupId string
	calendarId string
	eventId string
	top *int32
	skip *int32
	filter *string
	count *bool
	orderby *[]string
	select_ *[]string
	expand *[]string
}

// Show only the first n items
func (r ApiUsersCalendarGroupsCalendarsCalendarViewListExtensionsRequest) Top(top int32) ApiUsersCalendarGroupsCalendarsCalendarViewListExtensionsRequest {
	r.top = &top
	return r
}
// Skip the first n items
func (r ApiUsersCalendarGroupsCalendarsCalendarViewListExtensionsRequest) Skip(skip int32) ApiUsersCalendarGroupsCalendarsCalendarViewListExtensionsRequest {
	r.skip = &skip
	return r
}
// Filter items by property values
func (r ApiUsersCalendarGroupsCalendarsCalendarViewListExtensionsRequest) Filter(filter string) ApiUsersCalendarGroupsCalendarsCalendarViewListExtensionsRequest {
	r.filter = &filter
	return r
}
// Include count of items
func (r ApiUsersCalendarGroupsCalendarsCalendarViewListExtensionsRequest) Count(count bool) ApiUsersCalendarGroupsCalendarsCalendarViewListExtensionsRequest {
	r.count = &count
	return r
}
// Order items by property values
func (r ApiUsersCalendarGroupsCalendarsCalendarViewListExtensionsRequest) Orderby(orderby []string) ApiUsersCalendarGroupsCalendarsCalendarViewListExtensionsRequest {
	r.orderby = &orderby
	return r
}
// Select properties to be returned
func (r ApiUsersCalendarGroupsCalendarsCalendarViewListExtensionsRequest) Select_(select_ []string) ApiUsersCalendarGroupsCalendarsCalendarViewListExtensionsRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiUsersCalendarGroupsCalendarsCalendarViewListExtensionsRequest) Expand(expand []string) ApiUsersCalendarGroupsCalendarsCalendarViewListExtensionsRequest {
	r.expand = &expand
	return r
}

func (r ApiUsersCalendarGroupsCalendarsCalendarViewListExtensionsRequest) Execute() (CollectionOfExtension, *_nethttp.Response, error) {
	return r.ApiService.UsersCalendarGroupsCalendarsCalendarViewListExtensionsExecute(r)
}

/*
UsersCalendarGroupsCalendarsCalendarViewListExtensions Get extensions from users

The collection of open extensions defined for the event. Nullable.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @param calendarGroupId key: id of calendarGroup
 @param calendarId key: id of calendar
 @param eventId key: id of event
 @return ApiUsersCalendarGroupsCalendarsCalendarViewListExtensionsRequest
*/
func (a *UsersCalendarGroupApiService) UsersCalendarGroupsCalendarsCalendarViewListExtensions(ctx _context.Context, userId string, calendarGroupId string, calendarId string, eventId string) ApiUsersCalendarGroupsCalendarsCalendarViewListExtensionsRequest {
	return ApiUsersCalendarGroupsCalendarsCalendarViewListExtensionsRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		calendarGroupId: calendarGroupId,
		calendarId: calendarId,
		eventId: eventId,
	}
}

// Execute executes the request
//  @return CollectionOfExtension
func (a *UsersCalendarGroupApiService) UsersCalendarGroupsCalendarsCalendarViewListExtensionsExecute(r ApiUsersCalendarGroupsCalendarsCalendarViewListExtensionsRequest) (CollectionOfExtension, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  CollectionOfExtension
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersCalendarGroupApiService.UsersCalendarGroupsCalendarsCalendarViewListExtensions")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/calendarGroups/{calendarGroup-id}/calendars/{calendar-id}/calendarView/{event-id}/extensions"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"calendarGroup-id"+"}", _neturl.PathEscape(parameterToString(r.calendarGroupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"calendar-id"+"}", _neturl.PathEscape(parameterToString(r.calendarId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.top != nil {
		localVarQueryParams.Add("$top", parameterToString(*r.top, ""))
	}
	if r.skip != nil {
		localVarQueryParams.Add("$skip", parameterToString(*r.skip, ""))
	}
	if r.filter != nil {
		localVarQueryParams.Add("$filter", parameterToString(*r.filter, ""))
	}
	if r.count != nil {
		localVarQueryParams.Add("$count", parameterToString(*r.count, ""))
	}
	if r.orderby != nil {
		localVarQueryParams.Add("$orderby", parameterToString(*r.orderby, "csv"))
	}
	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUsersCalendarGroupsCalendarsCalendarViewListInstancesRequest struct {
	ctx _context.Context
	ApiService *UsersCalendarGroupApiService
	userId string
	calendarGroupId string
	calendarId string
	eventId string
	top *int32
	skip *int32
	filter *string
	count *bool
	orderby *[]string
	select_ *[]string
}

// Show only the first n items
func (r ApiUsersCalendarGroupsCalendarsCalendarViewListInstancesRequest) Top(top int32) ApiUsersCalendarGroupsCalendarsCalendarViewListInstancesRequest {
	r.top = &top
	return r
}
// Skip the first n items
func (r ApiUsersCalendarGroupsCalendarsCalendarViewListInstancesRequest) Skip(skip int32) ApiUsersCalendarGroupsCalendarsCalendarViewListInstancesRequest {
	r.skip = &skip
	return r
}
// Filter items by property values
func (r ApiUsersCalendarGroupsCalendarsCalendarViewListInstancesRequest) Filter(filter string) ApiUsersCalendarGroupsCalendarsCalendarViewListInstancesRequest {
	r.filter = &filter
	return r
}
// Include count of items
func (r ApiUsersCalendarGroupsCalendarsCalendarViewListInstancesRequest) Count(count bool) ApiUsersCalendarGroupsCalendarsCalendarViewListInstancesRequest {
	r.count = &count
	return r
}
// Order items by property values
func (r ApiUsersCalendarGroupsCalendarsCalendarViewListInstancesRequest) Orderby(orderby []string) ApiUsersCalendarGroupsCalendarsCalendarViewListInstancesRequest {
	r.orderby = &orderby
	return r
}
// Select properties to be returned
func (r ApiUsersCalendarGroupsCalendarsCalendarViewListInstancesRequest) Select_(select_ []string) ApiUsersCalendarGroupsCalendarsCalendarViewListInstancesRequest {
	r.select_ = &select_
	return r
}

func (r ApiUsersCalendarGroupsCalendarsCalendarViewListInstancesRequest) Execute() (CollectionOfEvent, *_nethttp.Response, error) {
	return r.ApiService.UsersCalendarGroupsCalendarsCalendarViewListInstancesExecute(r)
}

/*
UsersCalendarGroupsCalendarsCalendarViewListInstances Get instances from users

The occurrences of a recurring series, if the event is a series master. This property includes occurrences that are part of the recurrence pattern, and exceptions that have been modified, but does not include occurrences that have been cancelled from the series. Navigation property. Read-only. Nullable.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @param calendarGroupId key: id of calendarGroup
 @param calendarId key: id of calendar
 @param eventId key: id of event
 @return ApiUsersCalendarGroupsCalendarsCalendarViewListInstancesRequest
*/
func (a *UsersCalendarGroupApiService) UsersCalendarGroupsCalendarsCalendarViewListInstances(ctx _context.Context, userId string, calendarGroupId string, calendarId string, eventId string) ApiUsersCalendarGroupsCalendarsCalendarViewListInstancesRequest {
	return ApiUsersCalendarGroupsCalendarsCalendarViewListInstancesRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		calendarGroupId: calendarGroupId,
		calendarId: calendarId,
		eventId: eventId,
	}
}

// Execute executes the request
//  @return CollectionOfEvent
func (a *UsersCalendarGroupApiService) UsersCalendarGroupsCalendarsCalendarViewListInstancesExecute(r ApiUsersCalendarGroupsCalendarsCalendarViewListInstancesRequest) (CollectionOfEvent, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  CollectionOfEvent
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersCalendarGroupApiService.UsersCalendarGroupsCalendarsCalendarViewListInstances")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/calendarGroups/{calendarGroup-id}/calendars/{calendar-id}/calendarView/{event-id}/instances"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"calendarGroup-id"+"}", _neturl.PathEscape(parameterToString(r.calendarGroupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"calendar-id"+"}", _neturl.PathEscape(parameterToString(r.calendarId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.top != nil {
		localVarQueryParams.Add("$top", parameterToString(*r.top, ""))
	}
	if r.skip != nil {
		localVarQueryParams.Add("$skip", parameterToString(*r.skip, ""))
	}
	if r.filter != nil {
		localVarQueryParams.Add("$filter", parameterToString(*r.filter, ""))
	}
	if r.count != nil {
		localVarQueryParams.Add("$count", parameterToString(*r.count, ""))
	}
	if r.orderby != nil {
		localVarQueryParams.Add("$orderby", parameterToString(*r.orderby, "csv"))
	}
	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUsersCalendarGroupsCalendarsCalendarViewListMultiValueExtendedPropertiesRequest struct {
	ctx _context.Context
	ApiService *UsersCalendarGroupApiService
	userId string
	calendarGroupId string
	calendarId string
	eventId string
	top *int32
	skip *int32
	search *string
	filter *string
	count *bool
	orderby *[]string
	select_ *[]string
	expand *[]string
}

// Show only the first n items
func (r ApiUsersCalendarGroupsCalendarsCalendarViewListMultiValueExtendedPropertiesRequest) Top(top int32) ApiUsersCalendarGroupsCalendarsCalendarViewListMultiValueExtendedPropertiesRequest {
	r.top = &top
	return r
}
// Skip the first n items
func (r ApiUsersCalendarGroupsCalendarsCalendarViewListMultiValueExtendedPropertiesRequest) Skip(skip int32) ApiUsersCalendarGroupsCalendarsCalendarViewListMultiValueExtendedPropertiesRequest {
	r.skip = &skip
	return r
}
// Search items by search phrases
func (r ApiUsersCalendarGroupsCalendarsCalendarViewListMultiValueExtendedPropertiesRequest) Search(search string) ApiUsersCalendarGroupsCalendarsCalendarViewListMultiValueExtendedPropertiesRequest {
	r.search = &search
	return r
}
// Filter items by property values
func (r ApiUsersCalendarGroupsCalendarsCalendarViewListMultiValueExtendedPropertiesRequest) Filter(filter string) ApiUsersCalendarGroupsCalendarsCalendarViewListMultiValueExtendedPropertiesRequest {
	r.filter = &filter
	return r
}
// Include count of items
func (r ApiUsersCalendarGroupsCalendarsCalendarViewListMultiValueExtendedPropertiesRequest) Count(count bool) ApiUsersCalendarGroupsCalendarsCalendarViewListMultiValueExtendedPropertiesRequest {
	r.count = &count
	return r
}
// Order items by property values
func (r ApiUsersCalendarGroupsCalendarsCalendarViewListMultiValueExtendedPropertiesRequest) Orderby(orderby []string) ApiUsersCalendarGroupsCalendarsCalendarViewListMultiValueExtendedPropertiesRequest {
	r.orderby = &orderby
	return r
}
// Select properties to be returned
func (r ApiUsersCalendarGroupsCalendarsCalendarViewListMultiValueExtendedPropertiesRequest) Select_(select_ []string) ApiUsersCalendarGroupsCalendarsCalendarViewListMultiValueExtendedPropertiesRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiUsersCalendarGroupsCalendarsCalendarViewListMultiValueExtendedPropertiesRequest) Expand(expand []string) ApiUsersCalendarGroupsCalendarsCalendarViewListMultiValueExtendedPropertiesRequest {
	r.expand = &expand
	return r
}

func (r ApiUsersCalendarGroupsCalendarsCalendarViewListMultiValueExtendedPropertiesRequest) Execute() (CollectionOfMultiValueLegacyExtendedProperty, *_nethttp.Response, error) {
	return r.ApiService.UsersCalendarGroupsCalendarsCalendarViewListMultiValueExtendedPropertiesExecute(r)
}

/*
UsersCalendarGroupsCalendarsCalendarViewListMultiValueExtendedProperties Get multiValueExtendedProperties from users

The collection of multi-value extended properties defined for the event. Read-only. Nullable.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @param calendarGroupId key: id of calendarGroup
 @param calendarId key: id of calendar
 @param eventId key: id of event
 @return ApiUsersCalendarGroupsCalendarsCalendarViewListMultiValueExtendedPropertiesRequest
*/
func (a *UsersCalendarGroupApiService) UsersCalendarGroupsCalendarsCalendarViewListMultiValueExtendedProperties(ctx _context.Context, userId string, calendarGroupId string, calendarId string, eventId string) ApiUsersCalendarGroupsCalendarsCalendarViewListMultiValueExtendedPropertiesRequest {
	return ApiUsersCalendarGroupsCalendarsCalendarViewListMultiValueExtendedPropertiesRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		calendarGroupId: calendarGroupId,
		calendarId: calendarId,
		eventId: eventId,
	}
}

// Execute executes the request
//  @return CollectionOfMultiValueLegacyExtendedProperty
func (a *UsersCalendarGroupApiService) UsersCalendarGroupsCalendarsCalendarViewListMultiValueExtendedPropertiesExecute(r ApiUsersCalendarGroupsCalendarsCalendarViewListMultiValueExtendedPropertiesRequest) (CollectionOfMultiValueLegacyExtendedProperty, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  CollectionOfMultiValueLegacyExtendedProperty
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersCalendarGroupApiService.UsersCalendarGroupsCalendarsCalendarViewListMultiValueExtendedProperties")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/calendarGroups/{calendarGroup-id}/calendars/{calendar-id}/calendarView/{event-id}/multiValueExtendedProperties"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"calendarGroup-id"+"}", _neturl.PathEscape(parameterToString(r.calendarGroupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"calendar-id"+"}", _neturl.PathEscape(parameterToString(r.calendarId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.top != nil {
		localVarQueryParams.Add("$top", parameterToString(*r.top, ""))
	}
	if r.skip != nil {
		localVarQueryParams.Add("$skip", parameterToString(*r.skip, ""))
	}
	if r.search != nil {
		localVarQueryParams.Add("$search", parameterToString(*r.search, ""))
	}
	if r.filter != nil {
		localVarQueryParams.Add("$filter", parameterToString(*r.filter, ""))
	}
	if r.count != nil {
		localVarQueryParams.Add("$count", parameterToString(*r.count, ""))
	}
	if r.orderby != nil {
		localVarQueryParams.Add("$orderby", parameterToString(*r.orderby, "csv"))
	}
	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUsersCalendarGroupsCalendarsCalendarViewListSingleValueExtendedPropertiesRequest struct {
	ctx _context.Context
	ApiService *UsersCalendarGroupApiService
	userId string
	calendarGroupId string
	calendarId string
	eventId string
	top *int32
	skip *int32
	search *string
	filter *string
	count *bool
	orderby *[]string
	select_ *[]string
	expand *[]string
}

// Show only the first n items
func (r ApiUsersCalendarGroupsCalendarsCalendarViewListSingleValueExtendedPropertiesRequest) Top(top int32) ApiUsersCalendarGroupsCalendarsCalendarViewListSingleValueExtendedPropertiesRequest {
	r.top = &top
	return r
}
// Skip the first n items
func (r ApiUsersCalendarGroupsCalendarsCalendarViewListSingleValueExtendedPropertiesRequest) Skip(skip int32) ApiUsersCalendarGroupsCalendarsCalendarViewListSingleValueExtendedPropertiesRequest {
	r.skip = &skip
	return r
}
// Search items by search phrases
func (r ApiUsersCalendarGroupsCalendarsCalendarViewListSingleValueExtendedPropertiesRequest) Search(search string) ApiUsersCalendarGroupsCalendarsCalendarViewListSingleValueExtendedPropertiesRequest {
	r.search = &search
	return r
}
// Filter items by property values
func (r ApiUsersCalendarGroupsCalendarsCalendarViewListSingleValueExtendedPropertiesRequest) Filter(filter string) ApiUsersCalendarGroupsCalendarsCalendarViewListSingleValueExtendedPropertiesRequest {
	r.filter = &filter
	return r
}
// Include count of items
func (r ApiUsersCalendarGroupsCalendarsCalendarViewListSingleValueExtendedPropertiesRequest) Count(count bool) ApiUsersCalendarGroupsCalendarsCalendarViewListSingleValueExtendedPropertiesRequest {
	r.count = &count
	return r
}
// Order items by property values
func (r ApiUsersCalendarGroupsCalendarsCalendarViewListSingleValueExtendedPropertiesRequest) Orderby(orderby []string) ApiUsersCalendarGroupsCalendarsCalendarViewListSingleValueExtendedPropertiesRequest {
	r.orderby = &orderby
	return r
}
// Select properties to be returned
func (r ApiUsersCalendarGroupsCalendarsCalendarViewListSingleValueExtendedPropertiesRequest) Select_(select_ []string) ApiUsersCalendarGroupsCalendarsCalendarViewListSingleValueExtendedPropertiesRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiUsersCalendarGroupsCalendarsCalendarViewListSingleValueExtendedPropertiesRequest) Expand(expand []string) ApiUsersCalendarGroupsCalendarsCalendarViewListSingleValueExtendedPropertiesRequest {
	r.expand = &expand
	return r
}

func (r ApiUsersCalendarGroupsCalendarsCalendarViewListSingleValueExtendedPropertiesRequest) Execute() (CollectionOfSingleValueLegacyExtendedProperty, *_nethttp.Response, error) {
	return r.ApiService.UsersCalendarGroupsCalendarsCalendarViewListSingleValueExtendedPropertiesExecute(r)
}

/*
UsersCalendarGroupsCalendarsCalendarViewListSingleValueExtendedProperties Get singleValueExtendedProperties from users

The collection of single-value extended properties defined for the event. Read-only. Nullable.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @param calendarGroupId key: id of calendarGroup
 @param calendarId key: id of calendar
 @param eventId key: id of event
 @return ApiUsersCalendarGroupsCalendarsCalendarViewListSingleValueExtendedPropertiesRequest
*/
func (a *UsersCalendarGroupApiService) UsersCalendarGroupsCalendarsCalendarViewListSingleValueExtendedProperties(ctx _context.Context, userId string, calendarGroupId string, calendarId string, eventId string) ApiUsersCalendarGroupsCalendarsCalendarViewListSingleValueExtendedPropertiesRequest {
	return ApiUsersCalendarGroupsCalendarsCalendarViewListSingleValueExtendedPropertiesRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		calendarGroupId: calendarGroupId,
		calendarId: calendarId,
		eventId: eventId,
	}
}

// Execute executes the request
//  @return CollectionOfSingleValueLegacyExtendedProperty
func (a *UsersCalendarGroupApiService) UsersCalendarGroupsCalendarsCalendarViewListSingleValueExtendedPropertiesExecute(r ApiUsersCalendarGroupsCalendarsCalendarViewListSingleValueExtendedPropertiesRequest) (CollectionOfSingleValueLegacyExtendedProperty, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  CollectionOfSingleValueLegacyExtendedProperty
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersCalendarGroupApiService.UsersCalendarGroupsCalendarsCalendarViewListSingleValueExtendedProperties")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/calendarGroups/{calendarGroup-id}/calendars/{calendar-id}/calendarView/{event-id}/singleValueExtendedProperties"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"calendarGroup-id"+"}", _neturl.PathEscape(parameterToString(r.calendarGroupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"calendar-id"+"}", _neturl.PathEscape(parameterToString(r.calendarId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.top != nil {
		localVarQueryParams.Add("$top", parameterToString(*r.top, ""))
	}
	if r.skip != nil {
		localVarQueryParams.Add("$skip", parameterToString(*r.skip, ""))
	}
	if r.search != nil {
		localVarQueryParams.Add("$search", parameterToString(*r.search, ""))
	}
	if r.filter != nil {
		localVarQueryParams.Add("$filter", parameterToString(*r.filter, ""))
	}
	if r.count != nil {
		localVarQueryParams.Add("$count", parameterToString(*r.count, ""))
	}
	if r.orderby != nil {
		localVarQueryParams.Add("$orderby", parameterToString(*r.orderby, "csv"))
	}
	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUsersCalendarGroupsCalendarsCalendarViewUpdateAttachmentsRequest struct {
	ctx _context.Context
	ApiService *UsersCalendarGroupApiService
	userId string
	calendarGroupId string
	calendarId string
	eventId string
	attachmentId string
	microsoftGraphAttachment *MicrosoftGraphAttachment
}

// New navigation property values
func (r ApiUsersCalendarGroupsCalendarsCalendarViewUpdateAttachmentsRequest) MicrosoftGraphAttachment(microsoftGraphAttachment MicrosoftGraphAttachment) ApiUsersCalendarGroupsCalendarsCalendarViewUpdateAttachmentsRequest {
	r.microsoftGraphAttachment = &microsoftGraphAttachment
	return r
}

func (r ApiUsersCalendarGroupsCalendarsCalendarViewUpdateAttachmentsRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.UsersCalendarGroupsCalendarsCalendarViewUpdateAttachmentsExecute(r)
}

/*
UsersCalendarGroupsCalendarsCalendarViewUpdateAttachments Update the navigation property attachments in users

The collection of FileAttachment, ItemAttachment, and referenceAttachment attachments for the event. Navigation property. Read-only. Nullable.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @param calendarGroupId key: id of calendarGroup
 @param calendarId key: id of calendar
 @param eventId key: id of event
 @param attachmentId key: id of attachment
 @return ApiUsersCalendarGroupsCalendarsCalendarViewUpdateAttachmentsRequest
*/
func (a *UsersCalendarGroupApiService) UsersCalendarGroupsCalendarsCalendarViewUpdateAttachments(ctx _context.Context, userId string, calendarGroupId string, calendarId string, eventId string, attachmentId string) ApiUsersCalendarGroupsCalendarsCalendarViewUpdateAttachmentsRequest {
	return ApiUsersCalendarGroupsCalendarsCalendarViewUpdateAttachmentsRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		calendarGroupId: calendarGroupId,
		calendarId: calendarId,
		eventId: eventId,
		attachmentId: attachmentId,
	}
}

// Execute executes the request
func (a *UsersCalendarGroupApiService) UsersCalendarGroupsCalendarsCalendarViewUpdateAttachmentsExecute(r ApiUsersCalendarGroupsCalendarsCalendarViewUpdateAttachmentsRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPatch
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersCalendarGroupApiService.UsersCalendarGroupsCalendarsCalendarViewUpdateAttachments")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/calendarGroups/{calendarGroup-id}/calendars/{calendar-id}/calendarView/{event-id}/attachments/{attachment-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"calendarGroup-id"+"}", _neturl.PathEscape(parameterToString(r.calendarGroupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"calendar-id"+"}", _neturl.PathEscape(parameterToString(r.calendarId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"attachment-id"+"}", _neturl.PathEscape(parameterToString(r.attachmentId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphAttachment == nil {
		return nil, reportError("microsoftGraphAttachment is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphAttachment
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUsersCalendarGroupsCalendarsCalendarViewUpdateCalendarRequest struct {
	ctx _context.Context
	ApiService *UsersCalendarGroupApiService
	userId string
	calendarGroupId string
	calendarId string
	eventId string
	microsoftGraphCalendar *MicrosoftGraphCalendar
}

// New navigation property values
func (r ApiUsersCalendarGroupsCalendarsCalendarViewUpdateCalendarRequest) MicrosoftGraphCalendar(microsoftGraphCalendar MicrosoftGraphCalendar) ApiUsersCalendarGroupsCalendarsCalendarViewUpdateCalendarRequest {
	r.microsoftGraphCalendar = &microsoftGraphCalendar
	return r
}

func (r ApiUsersCalendarGroupsCalendarsCalendarViewUpdateCalendarRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.UsersCalendarGroupsCalendarsCalendarViewUpdateCalendarExecute(r)
}

/*
UsersCalendarGroupsCalendarsCalendarViewUpdateCalendar Update the navigation property calendar in users

The calendar that contains the event. Navigation property. Read-only.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @param calendarGroupId key: id of calendarGroup
 @param calendarId key: id of calendar
 @param eventId key: id of event
 @return ApiUsersCalendarGroupsCalendarsCalendarViewUpdateCalendarRequest
*/
func (a *UsersCalendarGroupApiService) UsersCalendarGroupsCalendarsCalendarViewUpdateCalendar(ctx _context.Context, userId string, calendarGroupId string, calendarId string, eventId string) ApiUsersCalendarGroupsCalendarsCalendarViewUpdateCalendarRequest {
	return ApiUsersCalendarGroupsCalendarsCalendarViewUpdateCalendarRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		calendarGroupId: calendarGroupId,
		calendarId: calendarId,
		eventId: eventId,
	}
}

// Execute executes the request
func (a *UsersCalendarGroupApiService) UsersCalendarGroupsCalendarsCalendarViewUpdateCalendarExecute(r ApiUsersCalendarGroupsCalendarsCalendarViewUpdateCalendarRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPatch
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersCalendarGroupApiService.UsersCalendarGroupsCalendarsCalendarViewUpdateCalendar")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/calendarGroups/{calendarGroup-id}/calendars/{calendar-id}/calendarView/{event-id}/calendar"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"calendarGroup-id"+"}", _neturl.PathEscape(parameterToString(r.calendarGroupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"calendar-id"+"}", _neturl.PathEscape(parameterToString(r.calendarId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphCalendar == nil {
		return nil, reportError("microsoftGraphCalendar is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphCalendar
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUsersCalendarGroupsCalendarsCalendarViewUpdateExtensionsRequest struct {
	ctx _context.Context
	ApiService *UsersCalendarGroupApiService
	userId string
	calendarGroupId string
	calendarId string
	eventId string
	extensionId string
	microsoftGraphExtension *MicrosoftGraphExtension
}

// New navigation property values
func (r ApiUsersCalendarGroupsCalendarsCalendarViewUpdateExtensionsRequest) MicrosoftGraphExtension(microsoftGraphExtension MicrosoftGraphExtension) ApiUsersCalendarGroupsCalendarsCalendarViewUpdateExtensionsRequest {
	r.microsoftGraphExtension = &microsoftGraphExtension
	return r
}

func (r ApiUsersCalendarGroupsCalendarsCalendarViewUpdateExtensionsRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.UsersCalendarGroupsCalendarsCalendarViewUpdateExtensionsExecute(r)
}

/*
UsersCalendarGroupsCalendarsCalendarViewUpdateExtensions Update the navigation property extensions in users

The collection of open extensions defined for the event. Nullable.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @param calendarGroupId key: id of calendarGroup
 @param calendarId key: id of calendar
 @param eventId key: id of event
 @param extensionId key: id of extension
 @return ApiUsersCalendarGroupsCalendarsCalendarViewUpdateExtensionsRequest
*/
func (a *UsersCalendarGroupApiService) UsersCalendarGroupsCalendarsCalendarViewUpdateExtensions(ctx _context.Context, userId string, calendarGroupId string, calendarId string, eventId string, extensionId string) ApiUsersCalendarGroupsCalendarsCalendarViewUpdateExtensionsRequest {
	return ApiUsersCalendarGroupsCalendarsCalendarViewUpdateExtensionsRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		calendarGroupId: calendarGroupId,
		calendarId: calendarId,
		eventId: eventId,
		extensionId: extensionId,
	}
}

// Execute executes the request
func (a *UsersCalendarGroupApiService) UsersCalendarGroupsCalendarsCalendarViewUpdateExtensionsExecute(r ApiUsersCalendarGroupsCalendarsCalendarViewUpdateExtensionsRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPatch
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersCalendarGroupApiService.UsersCalendarGroupsCalendarsCalendarViewUpdateExtensions")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/calendarGroups/{calendarGroup-id}/calendars/{calendar-id}/calendarView/{event-id}/extensions/{extension-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"calendarGroup-id"+"}", _neturl.PathEscape(parameterToString(r.calendarGroupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"calendar-id"+"}", _neturl.PathEscape(parameterToString(r.calendarId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"extension-id"+"}", _neturl.PathEscape(parameterToString(r.extensionId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphExtension == nil {
		return nil, reportError("microsoftGraphExtension is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphExtension
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUsersCalendarGroupsCalendarsCalendarViewUpdateInstancesRequest struct {
	ctx _context.Context
	ApiService *UsersCalendarGroupApiService
	userId string
	calendarGroupId string
	calendarId string
	eventId string
	eventId1 string
	microsoftGraphEvent *MicrosoftGraphEvent
}

// New navigation property values
func (r ApiUsersCalendarGroupsCalendarsCalendarViewUpdateInstancesRequest) MicrosoftGraphEvent(microsoftGraphEvent MicrosoftGraphEvent) ApiUsersCalendarGroupsCalendarsCalendarViewUpdateInstancesRequest {
	r.microsoftGraphEvent = &microsoftGraphEvent
	return r
}

func (r ApiUsersCalendarGroupsCalendarsCalendarViewUpdateInstancesRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.UsersCalendarGroupsCalendarsCalendarViewUpdateInstancesExecute(r)
}

/*
UsersCalendarGroupsCalendarsCalendarViewUpdateInstances Update the navigation property instances in users

The occurrences of a recurring series, if the event is a series master. This property includes occurrences that are part of the recurrence pattern, and exceptions that have been modified, but does not include occurrences that have been cancelled from the series. Navigation property. Read-only. Nullable.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @param calendarGroupId key: id of calendarGroup
 @param calendarId key: id of calendar
 @param eventId key: id of event
 @param eventId1 key: id of event
 @return ApiUsersCalendarGroupsCalendarsCalendarViewUpdateInstancesRequest
*/
func (a *UsersCalendarGroupApiService) UsersCalendarGroupsCalendarsCalendarViewUpdateInstances(ctx _context.Context, userId string, calendarGroupId string, calendarId string, eventId string, eventId1 string) ApiUsersCalendarGroupsCalendarsCalendarViewUpdateInstancesRequest {
	return ApiUsersCalendarGroupsCalendarsCalendarViewUpdateInstancesRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		calendarGroupId: calendarGroupId,
		calendarId: calendarId,
		eventId: eventId,
		eventId1: eventId1,
	}
}

// Execute executes the request
func (a *UsersCalendarGroupApiService) UsersCalendarGroupsCalendarsCalendarViewUpdateInstancesExecute(r ApiUsersCalendarGroupsCalendarsCalendarViewUpdateInstancesRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPatch
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersCalendarGroupApiService.UsersCalendarGroupsCalendarsCalendarViewUpdateInstances")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/calendarGroups/{calendarGroup-id}/calendars/{calendar-id}/calendarView/{event-id}/instances/{event-id1}"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"calendarGroup-id"+"}", _neturl.PathEscape(parameterToString(r.calendarGroupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"calendar-id"+"}", _neturl.PathEscape(parameterToString(r.calendarId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id1"+"}", _neturl.PathEscape(parameterToString(r.eventId1, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphEvent == nil {
		return nil, reportError("microsoftGraphEvent is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphEvent
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUsersCalendarGroupsCalendarsCalendarViewUpdateMultiValueExtendedPropertiesRequest struct {
	ctx _context.Context
	ApiService *UsersCalendarGroupApiService
	userId string
	calendarGroupId string
	calendarId string
	eventId string
	multiValueLegacyExtendedPropertyId string
	microsoftGraphMultiValueLegacyExtendedProperty *MicrosoftGraphMultiValueLegacyExtendedProperty
}

// New navigation property values
func (r ApiUsersCalendarGroupsCalendarsCalendarViewUpdateMultiValueExtendedPropertiesRequest) MicrosoftGraphMultiValueLegacyExtendedProperty(microsoftGraphMultiValueLegacyExtendedProperty MicrosoftGraphMultiValueLegacyExtendedProperty) ApiUsersCalendarGroupsCalendarsCalendarViewUpdateMultiValueExtendedPropertiesRequest {
	r.microsoftGraphMultiValueLegacyExtendedProperty = &microsoftGraphMultiValueLegacyExtendedProperty
	return r
}

func (r ApiUsersCalendarGroupsCalendarsCalendarViewUpdateMultiValueExtendedPropertiesRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.UsersCalendarGroupsCalendarsCalendarViewUpdateMultiValueExtendedPropertiesExecute(r)
}

/*
UsersCalendarGroupsCalendarsCalendarViewUpdateMultiValueExtendedProperties Update the navigation property multiValueExtendedProperties in users

The collection of multi-value extended properties defined for the event. Read-only. Nullable.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @param calendarGroupId key: id of calendarGroup
 @param calendarId key: id of calendar
 @param eventId key: id of event
 @param multiValueLegacyExtendedPropertyId key: id of multiValueLegacyExtendedProperty
 @return ApiUsersCalendarGroupsCalendarsCalendarViewUpdateMultiValueExtendedPropertiesRequest
*/
func (a *UsersCalendarGroupApiService) UsersCalendarGroupsCalendarsCalendarViewUpdateMultiValueExtendedProperties(ctx _context.Context, userId string, calendarGroupId string, calendarId string, eventId string, multiValueLegacyExtendedPropertyId string) ApiUsersCalendarGroupsCalendarsCalendarViewUpdateMultiValueExtendedPropertiesRequest {
	return ApiUsersCalendarGroupsCalendarsCalendarViewUpdateMultiValueExtendedPropertiesRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		calendarGroupId: calendarGroupId,
		calendarId: calendarId,
		eventId: eventId,
		multiValueLegacyExtendedPropertyId: multiValueLegacyExtendedPropertyId,
	}
}

// Execute executes the request
func (a *UsersCalendarGroupApiService) UsersCalendarGroupsCalendarsCalendarViewUpdateMultiValueExtendedPropertiesExecute(r ApiUsersCalendarGroupsCalendarsCalendarViewUpdateMultiValueExtendedPropertiesRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPatch
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersCalendarGroupApiService.UsersCalendarGroupsCalendarsCalendarViewUpdateMultiValueExtendedProperties")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/calendarGroups/{calendarGroup-id}/calendars/{calendar-id}/calendarView/{event-id}/multiValueExtendedProperties/{multiValueLegacyExtendedProperty-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"calendarGroup-id"+"}", _neturl.PathEscape(parameterToString(r.calendarGroupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"calendar-id"+"}", _neturl.PathEscape(parameterToString(r.calendarId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"multiValueLegacyExtendedProperty-id"+"}", _neturl.PathEscape(parameterToString(r.multiValueLegacyExtendedPropertyId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphMultiValueLegacyExtendedProperty == nil {
		return nil, reportError("microsoftGraphMultiValueLegacyExtendedProperty is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphMultiValueLegacyExtendedProperty
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUsersCalendarGroupsCalendarsCalendarViewUpdateSingleValueExtendedPropertiesRequest struct {
	ctx _context.Context
	ApiService *UsersCalendarGroupApiService
	userId string
	calendarGroupId string
	calendarId string
	eventId string
	singleValueLegacyExtendedPropertyId string
	microsoftGraphSingleValueLegacyExtendedProperty *MicrosoftGraphSingleValueLegacyExtendedProperty
}

// New navigation property values
func (r ApiUsersCalendarGroupsCalendarsCalendarViewUpdateSingleValueExtendedPropertiesRequest) MicrosoftGraphSingleValueLegacyExtendedProperty(microsoftGraphSingleValueLegacyExtendedProperty MicrosoftGraphSingleValueLegacyExtendedProperty) ApiUsersCalendarGroupsCalendarsCalendarViewUpdateSingleValueExtendedPropertiesRequest {
	r.microsoftGraphSingleValueLegacyExtendedProperty = &microsoftGraphSingleValueLegacyExtendedProperty
	return r
}

func (r ApiUsersCalendarGroupsCalendarsCalendarViewUpdateSingleValueExtendedPropertiesRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.UsersCalendarGroupsCalendarsCalendarViewUpdateSingleValueExtendedPropertiesExecute(r)
}

/*
UsersCalendarGroupsCalendarsCalendarViewUpdateSingleValueExtendedProperties Update the navigation property singleValueExtendedProperties in users

The collection of single-value extended properties defined for the event. Read-only. Nullable.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @param calendarGroupId key: id of calendarGroup
 @param calendarId key: id of calendar
 @param eventId key: id of event
 @param singleValueLegacyExtendedPropertyId key: id of singleValueLegacyExtendedProperty
 @return ApiUsersCalendarGroupsCalendarsCalendarViewUpdateSingleValueExtendedPropertiesRequest
*/
func (a *UsersCalendarGroupApiService) UsersCalendarGroupsCalendarsCalendarViewUpdateSingleValueExtendedProperties(ctx _context.Context, userId string, calendarGroupId string, calendarId string, eventId string, singleValueLegacyExtendedPropertyId string) ApiUsersCalendarGroupsCalendarsCalendarViewUpdateSingleValueExtendedPropertiesRequest {
	return ApiUsersCalendarGroupsCalendarsCalendarViewUpdateSingleValueExtendedPropertiesRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		calendarGroupId: calendarGroupId,
		calendarId: calendarId,
		eventId: eventId,
		singleValueLegacyExtendedPropertyId: singleValueLegacyExtendedPropertyId,
	}
}

// Execute executes the request
func (a *UsersCalendarGroupApiService) UsersCalendarGroupsCalendarsCalendarViewUpdateSingleValueExtendedPropertiesExecute(r ApiUsersCalendarGroupsCalendarsCalendarViewUpdateSingleValueExtendedPropertiesRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPatch
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersCalendarGroupApiService.UsersCalendarGroupsCalendarsCalendarViewUpdateSingleValueExtendedProperties")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/calendarGroups/{calendarGroup-id}/calendars/{calendar-id}/calendarView/{event-id}/singleValueExtendedProperties/{singleValueLegacyExtendedProperty-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"calendarGroup-id"+"}", _neturl.PathEscape(parameterToString(r.calendarGroupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"calendar-id"+"}", _neturl.PathEscape(parameterToString(r.calendarId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"singleValueLegacyExtendedProperty-id"+"}", _neturl.PathEscape(parameterToString(r.singleValueLegacyExtendedPropertyId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphSingleValueLegacyExtendedProperty == nil {
		return nil, reportError("microsoftGraphSingleValueLegacyExtendedProperty is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphSingleValueLegacyExtendedProperty
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUsersCalendarGroupsCalendarsCreateCalendarPermissionsRequest struct {
	ctx _context.Context
	ApiService *UsersCalendarGroupApiService
	userId string
	calendarGroupId string
	calendarId string
	microsoftGraphCalendarPermission *MicrosoftGraphCalendarPermission
}

// New navigation property
func (r ApiUsersCalendarGroupsCalendarsCreateCalendarPermissionsRequest) MicrosoftGraphCalendarPermission(microsoftGraphCalendarPermission MicrosoftGraphCalendarPermission) ApiUsersCalendarGroupsCalendarsCreateCalendarPermissionsRequest {
	r.microsoftGraphCalendarPermission = &microsoftGraphCalendarPermission
	return r
}

func (r ApiUsersCalendarGroupsCalendarsCreateCalendarPermissionsRequest) Execute() (MicrosoftGraphCalendarPermission, *_nethttp.Response, error) {
	return r.ApiService.UsersCalendarGroupsCalendarsCreateCalendarPermissionsExecute(r)
}

/*
UsersCalendarGroupsCalendarsCreateCalendarPermissions Create new navigation property to calendarPermissions for users

The permissions of the users with whom the calendar is shared.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @param calendarGroupId key: id of calendarGroup
 @param calendarId key: id of calendar
 @return ApiUsersCalendarGroupsCalendarsCreateCalendarPermissionsRequest
*/
func (a *UsersCalendarGroupApiService) UsersCalendarGroupsCalendarsCreateCalendarPermissions(ctx _context.Context, userId string, calendarGroupId string, calendarId string) ApiUsersCalendarGroupsCalendarsCreateCalendarPermissionsRequest {
	return ApiUsersCalendarGroupsCalendarsCreateCalendarPermissionsRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		calendarGroupId: calendarGroupId,
		calendarId: calendarId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphCalendarPermission
func (a *UsersCalendarGroupApiService) UsersCalendarGroupsCalendarsCreateCalendarPermissionsExecute(r ApiUsersCalendarGroupsCalendarsCreateCalendarPermissionsRequest) (MicrosoftGraphCalendarPermission, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphCalendarPermission
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersCalendarGroupApiService.UsersCalendarGroupsCalendarsCreateCalendarPermissions")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/calendarGroups/{calendarGroup-id}/calendars/{calendar-id}/calendarPermissions"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"calendarGroup-id"+"}", _neturl.PathEscape(parameterToString(r.calendarGroupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"calendar-id"+"}", _neturl.PathEscape(parameterToString(r.calendarId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphCalendarPermission == nil {
		return localVarReturnValue, nil, reportError("microsoftGraphCalendarPermission is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphCalendarPermission
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUsersCalendarGroupsCalendarsCreateCalendarViewRequest struct {
	ctx _context.Context
	ApiService *UsersCalendarGroupApiService
	userId string
	calendarGroupId string
	calendarId string
	microsoftGraphEvent *MicrosoftGraphEvent
}

// New navigation property
func (r ApiUsersCalendarGroupsCalendarsCreateCalendarViewRequest) MicrosoftGraphEvent(microsoftGraphEvent MicrosoftGraphEvent) ApiUsersCalendarGroupsCalendarsCreateCalendarViewRequest {
	r.microsoftGraphEvent = &microsoftGraphEvent
	return r
}

func (r ApiUsersCalendarGroupsCalendarsCreateCalendarViewRequest) Execute() (MicrosoftGraphEvent, *_nethttp.Response, error) {
	return r.ApiService.UsersCalendarGroupsCalendarsCreateCalendarViewExecute(r)
}

/*
UsersCalendarGroupsCalendarsCreateCalendarView Create new navigation property to calendarView for users

The calendar view for the calendar. Navigation property. Read-only.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @param calendarGroupId key: id of calendarGroup
 @param calendarId key: id of calendar
 @return ApiUsersCalendarGroupsCalendarsCreateCalendarViewRequest
*/
func (a *UsersCalendarGroupApiService) UsersCalendarGroupsCalendarsCreateCalendarView(ctx _context.Context, userId string, calendarGroupId string, calendarId string) ApiUsersCalendarGroupsCalendarsCreateCalendarViewRequest {
	return ApiUsersCalendarGroupsCalendarsCreateCalendarViewRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		calendarGroupId: calendarGroupId,
		calendarId: calendarId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphEvent
func (a *UsersCalendarGroupApiService) UsersCalendarGroupsCalendarsCreateCalendarViewExecute(r ApiUsersCalendarGroupsCalendarsCreateCalendarViewRequest) (MicrosoftGraphEvent, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphEvent
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersCalendarGroupApiService.UsersCalendarGroupsCalendarsCreateCalendarView")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/calendarGroups/{calendarGroup-id}/calendars/{calendar-id}/calendarView"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"calendarGroup-id"+"}", _neturl.PathEscape(parameterToString(r.calendarGroupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"calendar-id"+"}", _neturl.PathEscape(parameterToString(r.calendarId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphEvent == nil {
		return localVarReturnValue, nil, reportError("microsoftGraphEvent is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphEvent
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUsersCalendarGroupsCalendarsCreateEventsRequest struct {
	ctx _context.Context
	ApiService *UsersCalendarGroupApiService
	userId string
	calendarGroupId string
	calendarId string
	microsoftGraphEvent *MicrosoftGraphEvent
}

// New navigation property
func (r ApiUsersCalendarGroupsCalendarsCreateEventsRequest) MicrosoftGraphEvent(microsoftGraphEvent MicrosoftGraphEvent) ApiUsersCalendarGroupsCalendarsCreateEventsRequest {
	r.microsoftGraphEvent = &microsoftGraphEvent
	return r
}

func (r ApiUsersCalendarGroupsCalendarsCreateEventsRequest) Execute() (MicrosoftGraphEvent, *_nethttp.Response, error) {
	return r.ApiService.UsersCalendarGroupsCalendarsCreateEventsExecute(r)
}

/*
UsersCalendarGroupsCalendarsCreateEvents Create new navigation property to events for users

The events in the calendar. Navigation property. Read-only.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @param calendarGroupId key: id of calendarGroup
 @param calendarId key: id of calendar
 @return ApiUsersCalendarGroupsCalendarsCreateEventsRequest
*/
func (a *UsersCalendarGroupApiService) UsersCalendarGroupsCalendarsCreateEvents(ctx _context.Context, userId string, calendarGroupId string, calendarId string) ApiUsersCalendarGroupsCalendarsCreateEventsRequest {
	return ApiUsersCalendarGroupsCalendarsCreateEventsRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		calendarGroupId: calendarGroupId,
		calendarId: calendarId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphEvent
func (a *UsersCalendarGroupApiService) UsersCalendarGroupsCalendarsCreateEventsExecute(r ApiUsersCalendarGroupsCalendarsCreateEventsRequest) (MicrosoftGraphEvent, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphEvent
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersCalendarGroupApiService.UsersCalendarGroupsCalendarsCreateEvents")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/calendarGroups/{calendarGroup-id}/calendars/{calendar-id}/events"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"calendarGroup-id"+"}", _neturl.PathEscape(parameterToString(r.calendarGroupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"calendar-id"+"}", _neturl.PathEscape(parameterToString(r.calendarId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphEvent == nil {
		return localVarReturnValue, nil, reportError("microsoftGraphEvent is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphEvent
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUsersCalendarGroupsCalendarsCreateMultiValueExtendedPropertiesRequest struct {
	ctx _context.Context
	ApiService *UsersCalendarGroupApiService
	userId string
	calendarGroupId string
	calendarId string
	microsoftGraphMultiValueLegacyExtendedProperty *MicrosoftGraphMultiValueLegacyExtendedProperty
}

// New navigation property
func (r ApiUsersCalendarGroupsCalendarsCreateMultiValueExtendedPropertiesRequest) MicrosoftGraphMultiValueLegacyExtendedProperty(microsoftGraphMultiValueLegacyExtendedProperty MicrosoftGraphMultiValueLegacyExtendedProperty) ApiUsersCalendarGroupsCalendarsCreateMultiValueExtendedPropertiesRequest {
	r.microsoftGraphMultiValueLegacyExtendedProperty = &microsoftGraphMultiValueLegacyExtendedProperty
	return r
}

func (r ApiUsersCalendarGroupsCalendarsCreateMultiValueExtendedPropertiesRequest) Execute() (MicrosoftGraphMultiValueLegacyExtendedProperty, *_nethttp.Response, error) {
	return r.ApiService.UsersCalendarGroupsCalendarsCreateMultiValueExtendedPropertiesExecute(r)
}

/*
UsersCalendarGroupsCalendarsCreateMultiValueExtendedProperties Create new navigation property to multiValueExtendedProperties for users

The collection of multi-value extended properties defined for the calendar. Read-only. Nullable.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @param calendarGroupId key: id of calendarGroup
 @param calendarId key: id of calendar
 @return ApiUsersCalendarGroupsCalendarsCreateMultiValueExtendedPropertiesRequest
*/
func (a *UsersCalendarGroupApiService) UsersCalendarGroupsCalendarsCreateMultiValueExtendedProperties(ctx _context.Context, userId string, calendarGroupId string, calendarId string) ApiUsersCalendarGroupsCalendarsCreateMultiValueExtendedPropertiesRequest {
	return ApiUsersCalendarGroupsCalendarsCreateMultiValueExtendedPropertiesRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		calendarGroupId: calendarGroupId,
		calendarId: calendarId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphMultiValueLegacyExtendedProperty
func (a *UsersCalendarGroupApiService) UsersCalendarGroupsCalendarsCreateMultiValueExtendedPropertiesExecute(r ApiUsersCalendarGroupsCalendarsCreateMultiValueExtendedPropertiesRequest) (MicrosoftGraphMultiValueLegacyExtendedProperty, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphMultiValueLegacyExtendedProperty
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersCalendarGroupApiService.UsersCalendarGroupsCalendarsCreateMultiValueExtendedProperties")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/calendarGroups/{calendarGroup-id}/calendars/{calendar-id}/multiValueExtendedProperties"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"calendarGroup-id"+"}", _neturl.PathEscape(parameterToString(r.calendarGroupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"calendar-id"+"}", _neturl.PathEscape(parameterToString(r.calendarId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphMultiValueLegacyExtendedProperty == nil {
		return localVarReturnValue, nil, reportError("microsoftGraphMultiValueLegacyExtendedProperty is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphMultiValueLegacyExtendedProperty
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUsersCalendarGroupsCalendarsCreateSingleValueExtendedPropertiesRequest struct {
	ctx _context.Context
	ApiService *UsersCalendarGroupApiService
	userId string
	calendarGroupId string
	calendarId string
	microsoftGraphSingleValueLegacyExtendedProperty *MicrosoftGraphSingleValueLegacyExtendedProperty
}

// New navigation property
func (r ApiUsersCalendarGroupsCalendarsCreateSingleValueExtendedPropertiesRequest) MicrosoftGraphSingleValueLegacyExtendedProperty(microsoftGraphSingleValueLegacyExtendedProperty MicrosoftGraphSingleValueLegacyExtendedProperty) ApiUsersCalendarGroupsCalendarsCreateSingleValueExtendedPropertiesRequest {
	r.microsoftGraphSingleValueLegacyExtendedProperty = &microsoftGraphSingleValueLegacyExtendedProperty
	return r
}

func (r ApiUsersCalendarGroupsCalendarsCreateSingleValueExtendedPropertiesRequest) Execute() (MicrosoftGraphSingleValueLegacyExtendedProperty, *_nethttp.Response, error) {
	return r.ApiService.UsersCalendarGroupsCalendarsCreateSingleValueExtendedPropertiesExecute(r)
}

/*
UsersCalendarGroupsCalendarsCreateSingleValueExtendedProperties Create new navigation property to singleValueExtendedProperties for users

The collection of single-value extended properties defined for the calendar. Read-only. Nullable.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @param calendarGroupId key: id of calendarGroup
 @param calendarId key: id of calendar
 @return ApiUsersCalendarGroupsCalendarsCreateSingleValueExtendedPropertiesRequest
*/
func (a *UsersCalendarGroupApiService) UsersCalendarGroupsCalendarsCreateSingleValueExtendedProperties(ctx _context.Context, userId string, calendarGroupId string, calendarId string) ApiUsersCalendarGroupsCalendarsCreateSingleValueExtendedPropertiesRequest {
	return ApiUsersCalendarGroupsCalendarsCreateSingleValueExtendedPropertiesRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		calendarGroupId: calendarGroupId,
		calendarId: calendarId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphSingleValueLegacyExtendedProperty
func (a *UsersCalendarGroupApiService) UsersCalendarGroupsCalendarsCreateSingleValueExtendedPropertiesExecute(r ApiUsersCalendarGroupsCalendarsCreateSingleValueExtendedPropertiesRequest) (MicrosoftGraphSingleValueLegacyExtendedProperty, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphSingleValueLegacyExtendedProperty
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersCalendarGroupApiService.UsersCalendarGroupsCalendarsCreateSingleValueExtendedProperties")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/calendarGroups/{calendarGroup-id}/calendars/{calendar-id}/singleValueExtendedProperties"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"calendarGroup-id"+"}", _neturl.PathEscape(parameterToString(r.calendarGroupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"calendar-id"+"}", _neturl.PathEscape(parameterToString(r.calendarId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphSingleValueLegacyExtendedProperty == nil {
		return localVarReturnValue, nil, reportError("microsoftGraphSingleValueLegacyExtendedProperty is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphSingleValueLegacyExtendedProperty
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUsersCalendarGroupsCalendarsDeleteCalendarPermissionsRequest struct {
	ctx _context.Context
	ApiService *UsersCalendarGroupApiService
	userId string
	calendarGroupId string
	calendarId string
	calendarPermissionId string
	ifMatch *string
}

// ETag
func (r ApiUsersCalendarGroupsCalendarsDeleteCalendarPermissionsRequest) IfMatch(ifMatch string) ApiUsersCalendarGroupsCalendarsDeleteCalendarPermissionsRequest {
	r.ifMatch = &ifMatch
	return r
}

func (r ApiUsersCalendarGroupsCalendarsDeleteCalendarPermissionsRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.UsersCalendarGroupsCalendarsDeleteCalendarPermissionsExecute(r)
}

/*
UsersCalendarGroupsCalendarsDeleteCalendarPermissions Delete navigation property calendarPermissions for users

The permissions of the users with whom the calendar is shared.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @param calendarGroupId key: id of calendarGroup
 @param calendarId key: id of calendar
 @param calendarPermissionId key: id of calendarPermission
 @return ApiUsersCalendarGroupsCalendarsDeleteCalendarPermissionsRequest
*/
func (a *UsersCalendarGroupApiService) UsersCalendarGroupsCalendarsDeleteCalendarPermissions(ctx _context.Context, userId string, calendarGroupId string, calendarId string, calendarPermissionId string) ApiUsersCalendarGroupsCalendarsDeleteCalendarPermissionsRequest {
	return ApiUsersCalendarGroupsCalendarsDeleteCalendarPermissionsRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		calendarGroupId: calendarGroupId,
		calendarId: calendarId,
		calendarPermissionId: calendarPermissionId,
	}
}

// Execute executes the request
func (a *UsersCalendarGroupApiService) UsersCalendarGroupsCalendarsDeleteCalendarPermissionsExecute(r ApiUsersCalendarGroupsCalendarsDeleteCalendarPermissionsRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersCalendarGroupApiService.UsersCalendarGroupsCalendarsDeleteCalendarPermissions")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/calendarGroups/{calendarGroup-id}/calendars/{calendar-id}/calendarPermissions/{calendarPermission-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"calendarGroup-id"+"}", _neturl.PathEscape(parameterToString(r.calendarGroupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"calendar-id"+"}", _neturl.PathEscape(parameterToString(r.calendarId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"calendarPermission-id"+"}", _neturl.PathEscape(parameterToString(r.calendarPermissionId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ifMatch != nil {
		localVarHeaderParams["If-Match"] = parameterToString(*r.ifMatch, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUsersCalendarGroupsCalendarsDeleteCalendarViewRequest struct {
	ctx _context.Context
	ApiService *UsersCalendarGroupApiService
	userId string
	calendarGroupId string
	calendarId string
	eventId string
	ifMatch *string
}

// ETag
func (r ApiUsersCalendarGroupsCalendarsDeleteCalendarViewRequest) IfMatch(ifMatch string) ApiUsersCalendarGroupsCalendarsDeleteCalendarViewRequest {
	r.ifMatch = &ifMatch
	return r
}

func (r ApiUsersCalendarGroupsCalendarsDeleteCalendarViewRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.UsersCalendarGroupsCalendarsDeleteCalendarViewExecute(r)
}

/*
UsersCalendarGroupsCalendarsDeleteCalendarView Delete navigation property calendarView for users

The calendar view for the calendar. Navigation property. Read-only.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @param calendarGroupId key: id of calendarGroup
 @param calendarId key: id of calendar
 @param eventId key: id of event
 @return ApiUsersCalendarGroupsCalendarsDeleteCalendarViewRequest
*/
func (a *UsersCalendarGroupApiService) UsersCalendarGroupsCalendarsDeleteCalendarView(ctx _context.Context, userId string, calendarGroupId string, calendarId string, eventId string) ApiUsersCalendarGroupsCalendarsDeleteCalendarViewRequest {
	return ApiUsersCalendarGroupsCalendarsDeleteCalendarViewRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		calendarGroupId: calendarGroupId,
		calendarId: calendarId,
		eventId: eventId,
	}
}

// Execute executes the request
func (a *UsersCalendarGroupApiService) UsersCalendarGroupsCalendarsDeleteCalendarViewExecute(r ApiUsersCalendarGroupsCalendarsDeleteCalendarViewRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersCalendarGroupApiService.UsersCalendarGroupsCalendarsDeleteCalendarView")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/calendarGroups/{calendarGroup-id}/calendars/{calendar-id}/calendarView/{event-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"calendarGroup-id"+"}", _neturl.PathEscape(parameterToString(r.calendarGroupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"calendar-id"+"}", _neturl.PathEscape(parameterToString(r.calendarId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ifMatch != nil {
		localVarHeaderParams["If-Match"] = parameterToString(*r.ifMatch, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUsersCalendarGroupsCalendarsDeleteEventsRequest struct {
	ctx _context.Context
	ApiService *UsersCalendarGroupApiService
	userId string
	calendarGroupId string
	calendarId string
	eventId string
	ifMatch *string
}

// ETag
func (r ApiUsersCalendarGroupsCalendarsDeleteEventsRequest) IfMatch(ifMatch string) ApiUsersCalendarGroupsCalendarsDeleteEventsRequest {
	r.ifMatch = &ifMatch
	return r
}

func (r ApiUsersCalendarGroupsCalendarsDeleteEventsRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.UsersCalendarGroupsCalendarsDeleteEventsExecute(r)
}

/*
UsersCalendarGroupsCalendarsDeleteEvents Delete navigation property events for users

The events in the calendar. Navigation property. Read-only.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @param calendarGroupId key: id of calendarGroup
 @param calendarId key: id of calendar
 @param eventId key: id of event
 @return ApiUsersCalendarGroupsCalendarsDeleteEventsRequest
*/
func (a *UsersCalendarGroupApiService) UsersCalendarGroupsCalendarsDeleteEvents(ctx _context.Context, userId string, calendarGroupId string, calendarId string, eventId string) ApiUsersCalendarGroupsCalendarsDeleteEventsRequest {
	return ApiUsersCalendarGroupsCalendarsDeleteEventsRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		calendarGroupId: calendarGroupId,
		calendarId: calendarId,
		eventId: eventId,
	}
}

// Execute executes the request
func (a *UsersCalendarGroupApiService) UsersCalendarGroupsCalendarsDeleteEventsExecute(r ApiUsersCalendarGroupsCalendarsDeleteEventsRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersCalendarGroupApiService.UsersCalendarGroupsCalendarsDeleteEvents")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/calendarGroups/{calendarGroup-id}/calendars/{calendar-id}/events/{event-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"calendarGroup-id"+"}", _neturl.PathEscape(parameterToString(r.calendarGroupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"calendar-id"+"}", _neturl.PathEscape(parameterToString(r.calendarId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ifMatch != nil {
		localVarHeaderParams["If-Match"] = parameterToString(*r.ifMatch, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUsersCalendarGroupsCalendarsDeleteMultiValueExtendedPropertiesRequest struct {
	ctx _context.Context
	ApiService *UsersCalendarGroupApiService
	userId string
	calendarGroupId string
	calendarId string
	multiValueLegacyExtendedPropertyId string
	ifMatch *string
}

// ETag
func (r ApiUsersCalendarGroupsCalendarsDeleteMultiValueExtendedPropertiesRequest) IfMatch(ifMatch string) ApiUsersCalendarGroupsCalendarsDeleteMultiValueExtendedPropertiesRequest {
	r.ifMatch = &ifMatch
	return r
}

func (r ApiUsersCalendarGroupsCalendarsDeleteMultiValueExtendedPropertiesRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.UsersCalendarGroupsCalendarsDeleteMultiValueExtendedPropertiesExecute(r)
}

/*
UsersCalendarGroupsCalendarsDeleteMultiValueExtendedProperties Delete navigation property multiValueExtendedProperties for users

The collection of multi-value extended properties defined for the calendar. Read-only. Nullable.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @param calendarGroupId key: id of calendarGroup
 @param calendarId key: id of calendar
 @param multiValueLegacyExtendedPropertyId key: id of multiValueLegacyExtendedProperty
 @return ApiUsersCalendarGroupsCalendarsDeleteMultiValueExtendedPropertiesRequest
*/
func (a *UsersCalendarGroupApiService) UsersCalendarGroupsCalendarsDeleteMultiValueExtendedProperties(ctx _context.Context, userId string, calendarGroupId string, calendarId string, multiValueLegacyExtendedPropertyId string) ApiUsersCalendarGroupsCalendarsDeleteMultiValueExtendedPropertiesRequest {
	return ApiUsersCalendarGroupsCalendarsDeleteMultiValueExtendedPropertiesRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		calendarGroupId: calendarGroupId,
		calendarId: calendarId,
		multiValueLegacyExtendedPropertyId: multiValueLegacyExtendedPropertyId,
	}
}

// Execute executes the request
func (a *UsersCalendarGroupApiService) UsersCalendarGroupsCalendarsDeleteMultiValueExtendedPropertiesExecute(r ApiUsersCalendarGroupsCalendarsDeleteMultiValueExtendedPropertiesRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersCalendarGroupApiService.UsersCalendarGroupsCalendarsDeleteMultiValueExtendedProperties")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/calendarGroups/{calendarGroup-id}/calendars/{calendar-id}/multiValueExtendedProperties/{multiValueLegacyExtendedProperty-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"calendarGroup-id"+"}", _neturl.PathEscape(parameterToString(r.calendarGroupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"calendar-id"+"}", _neturl.PathEscape(parameterToString(r.calendarId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"multiValueLegacyExtendedProperty-id"+"}", _neturl.PathEscape(parameterToString(r.multiValueLegacyExtendedPropertyId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ifMatch != nil {
		localVarHeaderParams["If-Match"] = parameterToString(*r.ifMatch, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUsersCalendarGroupsCalendarsDeleteSingleValueExtendedPropertiesRequest struct {
	ctx _context.Context
	ApiService *UsersCalendarGroupApiService
	userId string
	calendarGroupId string
	calendarId string
	singleValueLegacyExtendedPropertyId string
	ifMatch *string
}

// ETag
func (r ApiUsersCalendarGroupsCalendarsDeleteSingleValueExtendedPropertiesRequest) IfMatch(ifMatch string) ApiUsersCalendarGroupsCalendarsDeleteSingleValueExtendedPropertiesRequest {
	r.ifMatch = &ifMatch
	return r
}

func (r ApiUsersCalendarGroupsCalendarsDeleteSingleValueExtendedPropertiesRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.UsersCalendarGroupsCalendarsDeleteSingleValueExtendedPropertiesExecute(r)
}

/*
UsersCalendarGroupsCalendarsDeleteSingleValueExtendedProperties Delete navigation property singleValueExtendedProperties for users

The collection of single-value extended properties defined for the calendar. Read-only. Nullable.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @param calendarGroupId key: id of calendarGroup
 @param calendarId key: id of calendar
 @param singleValueLegacyExtendedPropertyId key: id of singleValueLegacyExtendedProperty
 @return ApiUsersCalendarGroupsCalendarsDeleteSingleValueExtendedPropertiesRequest
*/
func (a *UsersCalendarGroupApiService) UsersCalendarGroupsCalendarsDeleteSingleValueExtendedProperties(ctx _context.Context, userId string, calendarGroupId string, calendarId string, singleValueLegacyExtendedPropertyId string) ApiUsersCalendarGroupsCalendarsDeleteSingleValueExtendedPropertiesRequest {
	return ApiUsersCalendarGroupsCalendarsDeleteSingleValueExtendedPropertiesRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		calendarGroupId: calendarGroupId,
		calendarId: calendarId,
		singleValueLegacyExtendedPropertyId: singleValueLegacyExtendedPropertyId,
	}
}

// Execute executes the request
func (a *UsersCalendarGroupApiService) UsersCalendarGroupsCalendarsDeleteSingleValueExtendedPropertiesExecute(r ApiUsersCalendarGroupsCalendarsDeleteSingleValueExtendedPropertiesRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersCalendarGroupApiService.UsersCalendarGroupsCalendarsDeleteSingleValueExtendedProperties")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/calendarGroups/{calendarGroup-id}/calendars/{calendar-id}/singleValueExtendedProperties/{singleValueLegacyExtendedProperty-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"calendarGroup-id"+"}", _neturl.PathEscape(parameterToString(r.calendarGroupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"calendar-id"+"}", _neturl.PathEscape(parameterToString(r.calendarId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"singleValueLegacyExtendedProperty-id"+"}", _neturl.PathEscape(parameterToString(r.singleValueLegacyExtendedPropertyId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ifMatch != nil {
		localVarHeaderParams["If-Match"] = parameterToString(*r.ifMatch, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUsersCalendarGroupsCalendarsEventsCreateAttachmentsRequest struct {
	ctx _context.Context
	ApiService *UsersCalendarGroupApiService
	userId string
	calendarGroupId string
	calendarId string
	eventId string
	microsoftGraphAttachment *MicrosoftGraphAttachment
}

// New navigation property
func (r ApiUsersCalendarGroupsCalendarsEventsCreateAttachmentsRequest) MicrosoftGraphAttachment(microsoftGraphAttachment MicrosoftGraphAttachment) ApiUsersCalendarGroupsCalendarsEventsCreateAttachmentsRequest {
	r.microsoftGraphAttachment = &microsoftGraphAttachment
	return r
}

func (r ApiUsersCalendarGroupsCalendarsEventsCreateAttachmentsRequest) Execute() (MicrosoftGraphAttachment, *_nethttp.Response, error) {
	return r.ApiService.UsersCalendarGroupsCalendarsEventsCreateAttachmentsExecute(r)
}

/*
UsersCalendarGroupsCalendarsEventsCreateAttachments Create new navigation property to attachments for users

The collection of FileAttachment, ItemAttachment, and referenceAttachment attachments for the event. Navigation property. Read-only. Nullable.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @param calendarGroupId key: id of calendarGroup
 @param calendarId key: id of calendar
 @param eventId key: id of event
 @return ApiUsersCalendarGroupsCalendarsEventsCreateAttachmentsRequest
*/
func (a *UsersCalendarGroupApiService) UsersCalendarGroupsCalendarsEventsCreateAttachments(ctx _context.Context, userId string, calendarGroupId string, calendarId string, eventId string) ApiUsersCalendarGroupsCalendarsEventsCreateAttachmentsRequest {
	return ApiUsersCalendarGroupsCalendarsEventsCreateAttachmentsRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		calendarGroupId: calendarGroupId,
		calendarId: calendarId,
		eventId: eventId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphAttachment
func (a *UsersCalendarGroupApiService) UsersCalendarGroupsCalendarsEventsCreateAttachmentsExecute(r ApiUsersCalendarGroupsCalendarsEventsCreateAttachmentsRequest) (MicrosoftGraphAttachment, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphAttachment
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersCalendarGroupApiService.UsersCalendarGroupsCalendarsEventsCreateAttachments")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/calendarGroups/{calendarGroup-id}/calendars/{calendar-id}/events/{event-id}/attachments"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"calendarGroup-id"+"}", _neturl.PathEscape(parameterToString(r.calendarGroupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"calendar-id"+"}", _neturl.PathEscape(parameterToString(r.calendarId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphAttachment == nil {
		return localVarReturnValue, nil, reportError("microsoftGraphAttachment is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphAttachment
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUsersCalendarGroupsCalendarsEventsCreateExtensionsRequest struct {
	ctx _context.Context
	ApiService *UsersCalendarGroupApiService
	userId string
	calendarGroupId string
	calendarId string
	eventId string
	microsoftGraphExtension *MicrosoftGraphExtension
}

// New navigation property
func (r ApiUsersCalendarGroupsCalendarsEventsCreateExtensionsRequest) MicrosoftGraphExtension(microsoftGraphExtension MicrosoftGraphExtension) ApiUsersCalendarGroupsCalendarsEventsCreateExtensionsRequest {
	r.microsoftGraphExtension = &microsoftGraphExtension
	return r
}

func (r ApiUsersCalendarGroupsCalendarsEventsCreateExtensionsRequest) Execute() (MicrosoftGraphExtension, *_nethttp.Response, error) {
	return r.ApiService.UsersCalendarGroupsCalendarsEventsCreateExtensionsExecute(r)
}

/*
UsersCalendarGroupsCalendarsEventsCreateExtensions Create new navigation property to extensions for users

The collection of open extensions defined for the event. Nullable.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @param calendarGroupId key: id of calendarGroup
 @param calendarId key: id of calendar
 @param eventId key: id of event
 @return ApiUsersCalendarGroupsCalendarsEventsCreateExtensionsRequest
*/
func (a *UsersCalendarGroupApiService) UsersCalendarGroupsCalendarsEventsCreateExtensions(ctx _context.Context, userId string, calendarGroupId string, calendarId string, eventId string) ApiUsersCalendarGroupsCalendarsEventsCreateExtensionsRequest {
	return ApiUsersCalendarGroupsCalendarsEventsCreateExtensionsRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		calendarGroupId: calendarGroupId,
		calendarId: calendarId,
		eventId: eventId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphExtension
func (a *UsersCalendarGroupApiService) UsersCalendarGroupsCalendarsEventsCreateExtensionsExecute(r ApiUsersCalendarGroupsCalendarsEventsCreateExtensionsRequest) (MicrosoftGraphExtension, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphExtension
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersCalendarGroupApiService.UsersCalendarGroupsCalendarsEventsCreateExtensions")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/calendarGroups/{calendarGroup-id}/calendars/{calendar-id}/events/{event-id}/extensions"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"calendarGroup-id"+"}", _neturl.PathEscape(parameterToString(r.calendarGroupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"calendar-id"+"}", _neturl.PathEscape(parameterToString(r.calendarId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphExtension == nil {
		return localVarReturnValue, nil, reportError("microsoftGraphExtension is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphExtension
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUsersCalendarGroupsCalendarsEventsCreateInstancesRequest struct {
	ctx _context.Context
	ApiService *UsersCalendarGroupApiService
	userId string
	calendarGroupId string
	calendarId string
	eventId string
	microsoftGraphEvent *MicrosoftGraphEvent
}

// New navigation property
func (r ApiUsersCalendarGroupsCalendarsEventsCreateInstancesRequest) MicrosoftGraphEvent(microsoftGraphEvent MicrosoftGraphEvent) ApiUsersCalendarGroupsCalendarsEventsCreateInstancesRequest {
	r.microsoftGraphEvent = &microsoftGraphEvent
	return r
}

func (r ApiUsersCalendarGroupsCalendarsEventsCreateInstancesRequest) Execute() (MicrosoftGraphEvent, *_nethttp.Response, error) {
	return r.ApiService.UsersCalendarGroupsCalendarsEventsCreateInstancesExecute(r)
}

/*
UsersCalendarGroupsCalendarsEventsCreateInstances Create new navigation property to instances for users

The occurrences of a recurring series, if the event is a series master. This property includes occurrences that are part of the recurrence pattern, and exceptions that have been modified, but does not include occurrences that have been cancelled from the series. Navigation property. Read-only. Nullable.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @param calendarGroupId key: id of calendarGroup
 @param calendarId key: id of calendar
 @param eventId key: id of event
 @return ApiUsersCalendarGroupsCalendarsEventsCreateInstancesRequest
*/
func (a *UsersCalendarGroupApiService) UsersCalendarGroupsCalendarsEventsCreateInstances(ctx _context.Context, userId string, calendarGroupId string, calendarId string, eventId string) ApiUsersCalendarGroupsCalendarsEventsCreateInstancesRequest {
	return ApiUsersCalendarGroupsCalendarsEventsCreateInstancesRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		calendarGroupId: calendarGroupId,
		calendarId: calendarId,
		eventId: eventId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphEvent
func (a *UsersCalendarGroupApiService) UsersCalendarGroupsCalendarsEventsCreateInstancesExecute(r ApiUsersCalendarGroupsCalendarsEventsCreateInstancesRequest) (MicrosoftGraphEvent, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphEvent
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersCalendarGroupApiService.UsersCalendarGroupsCalendarsEventsCreateInstances")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/calendarGroups/{calendarGroup-id}/calendars/{calendar-id}/events/{event-id}/instances"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"calendarGroup-id"+"}", _neturl.PathEscape(parameterToString(r.calendarGroupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"calendar-id"+"}", _neturl.PathEscape(parameterToString(r.calendarId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphEvent == nil {
		return localVarReturnValue, nil, reportError("microsoftGraphEvent is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphEvent
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUsersCalendarGroupsCalendarsEventsCreateMultiValueExtendedPropertiesRequest struct {
	ctx _context.Context
	ApiService *UsersCalendarGroupApiService
	userId string
	calendarGroupId string
	calendarId string
	eventId string
	microsoftGraphMultiValueLegacyExtendedProperty *MicrosoftGraphMultiValueLegacyExtendedProperty
}

// New navigation property
func (r ApiUsersCalendarGroupsCalendarsEventsCreateMultiValueExtendedPropertiesRequest) MicrosoftGraphMultiValueLegacyExtendedProperty(microsoftGraphMultiValueLegacyExtendedProperty MicrosoftGraphMultiValueLegacyExtendedProperty) ApiUsersCalendarGroupsCalendarsEventsCreateMultiValueExtendedPropertiesRequest {
	r.microsoftGraphMultiValueLegacyExtendedProperty = &microsoftGraphMultiValueLegacyExtendedProperty
	return r
}

func (r ApiUsersCalendarGroupsCalendarsEventsCreateMultiValueExtendedPropertiesRequest) Execute() (MicrosoftGraphMultiValueLegacyExtendedProperty, *_nethttp.Response, error) {
	return r.ApiService.UsersCalendarGroupsCalendarsEventsCreateMultiValueExtendedPropertiesExecute(r)
}

/*
UsersCalendarGroupsCalendarsEventsCreateMultiValueExtendedProperties Create new navigation property to multiValueExtendedProperties for users

The collection of multi-value extended properties defined for the event. Read-only. Nullable.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @param calendarGroupId key: id of calendarGroup
 @param calendarId key: id of calendar
 @param eventId key: id of event
 @return ApiUsersCalendarGroupsCalendarsEventsCreateMultiValueExtendedPropertiesRequest
*/
func (a *UsersCalendarGroupApiService) UsersCalendarGroupsCalendarsEventsCreateMultiValueExtendedProperties(ctx _context.Context, userId string, calendarGroupId string, calendarId string, eventId string) ApiUsersCalendarGroupsCalendarsEventsCreateMultiValueExtendedPropertiesRequest {
	return ApiUsersCalendarGroupsCalendarsEventsCreateMultiValueExtendedPropertiesRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		calendarGroupId: calendarGroupId,
		calendarId: calendarId,
		eventId: eventId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphMultiValueLegacyExtendedProperty
func (a *UsersCalendarGroupApiService) UsersCalendarGroupsCalendarsEventsCreateMultiValueExtendedPropertiesExecute(r ApiUsersCalendarGroupsCalendarsEventsCreateMultiValueExtendedPropertiesRequest) (MicrosoftGraphMultiValueLegacyExtendedProperty, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphMultiValueLegacyExtendedProperty
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersCalendarGroupApiService.UsersCalendarGroupsCalendarsEventsCreateMultiValueExtendedProperties")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/calendarGroups/{calendarGroup-id}/calendars/{calendar-id}/events/{event-id}/multiValueExtendedProperties"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"calendarGroup-id"+"}", _neturl.PathEscape(parameterToString(r.calendarGroupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"calendar-id"+"}", _neturl.PathEscape(parameterToString(r.calendarId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphMultiValueLegacyExtendedProperty == nil {
		return localVarReturnValue, nil, reportError("microsoftGraphMultiValueLegacyExtendedProperty is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphMultiValueLegacyExtendedProperty
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUsersCalendarGroupsCalendarsEventsCreateSingleValueExtendedPropertiesRequest struct {
	ctx _context.Context
	ApiService *UsersCalendarGroupApiService
	userId string
	calendarGroupId string
	calendarId string
	eventId string
	microsoftGraphSingleValueLegacyExtendedProperty *MicrosoftGraphSingleValueLegacyExtendedProperty
}

// New navigation property
func (r ApiUsersCalendarGroupsCalendarsEventsCreateSingleValueExtendedPropertiesRequest) MicrosoftGraphSingleValueLegacyExtendedProperty(microsoftGraphSingleValueLegacyExtendedProperty MicrosoftGraphSingleValueLegacyExtendedProperty) ApiUsersCalendarGroupsCalendarsEventsCreateSingleValueExtendedPropertiesRequest {
	r.microsoftGraphSingleValueLegacyExtendedProperty = &microsoftGraphSingleValueLegacyExtendedProperty
	return r
}

func (r ApiUsersCalendarGroupsCalendarsEventsCreateSingleValueExtendedPropertiesRequest) Execute() (MicrosoftGraphSingleValueLegacyExtendedProperty, *_nethttp.Response, error) {
	return r.ApiService.UsersCalendarGroupsCalendarsEventsCreateSingleValueExtendedPropertiesExecute(r)
}

/*
UsersCalendarGroupsCalendarsEventsCreateSingleValueExtendedProperties Create new navigation property to singleValueExtendedProperties for users

The collection of single-value extended properties defined for the event. Read-only. Nullable.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @param calendarGroupId key: id of calendarGroup
 @param calendarId key: id of calendar
 @param eventId key: id of event
 @return ApiUsersCalendarGroupsCalendarsEventsCreateSingleValueExtendedPropertiesRequest
*/
func (a *UsersCalendarGroupApiService) UsersCalendarGroupsCalendarsEventsCreateSingleValueExtendedProperties(ctx _context.Context, userId string, calendarGroupId string, calendarId string, eventId string) ApiUsersCalendarGroupsCalendarsEventsCreateSingleValueExtendedPropertiesRequest {
	return ApiUsersCalendarGroupsCalendarsEventsCreateSingleValueExtendedPropertiesRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		calendarGroupId: calendarGroupId,
		calendarId: calendarId,
		eventId: eventId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphSingleValueLegacyExtendedProperty
func (a *UsersCalendarGroupApiService) UsersCalendarGroupsCalendarsEventsCreateSingleValueExtendedPropertiesExecute(r ApiUsersCalendarGroupsCalendarsEventsCreateSingleValueExtendedPropertiesRequest) (MicrosoftGraphSingleValueLegacyExtendedProperty, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphSingleValueLegacyExtendedProperty
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersCalendarGroupApiService.UsersCalendarGroupsCalendarsEventsCreateSingleValueExtendedProperties")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/calendarGroups/{calendarGroup-id}/calendars/{calendar-id}/events/{event-id}/singleValueExtendedProperties"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"calendarGroup-id"+"}", _neturl.PathEscape(parameterToString(r.calendarGroupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"calendar-id"+"}", _neturl.PathEscape(parameterToString(r.calendarId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphSingleValueLegacyExtendedProperty == nil {
		return localVarReturnValue, nil, reportError("microsoftGraphSingleValueLegacyExtendedProperty is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphSingleValueLegacyExtendedProperty
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUsersCalendarGroupsCalendarsEventsDeleteAttachmentsRequest struct {
	ctx _context.Context
	ApiService *UsersCalendarGroupApiService
	userId string
	calendarGroupId string
	calendarId string
	eventId string
	attachmentId string
	ifMatch *string
}

// ETag
func (r ApiUsersCalendarGroupsCalendarsEventsDeleteAttachmentsRequest) IfMatch(ifMatch string) ApiUsersCalendarGroupsCalendarsEventsDeleteAttachmentsRequest {
	r.ifMatch = &ifMatch
	return r
}

func (r ApiUsersCalendarGroupsCalendarsEventsDeleteAttachmentsRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.UsersCalendarGroupsCalendarsEventsDeleteAttachmentsExecute(r)
}

/*
UsersCalendarGroupsCalendarsEventsDeleteAttachments Delete navigation property attachments for users

The collection of FileAttachment, ItemAttachment, and referenceAttachment attachments for the event. Navigation property. Read-only. Nullable.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @param calendarGroupId key: id of calendarGroup
 @param calendarId key: id of calendar
 @param eventId key: id of event
 @param attachmentId key: id of attachment
 @return ApiUsersCalendarGroupsCalendarsEventsDeleteAttachmentsRequest
*/
func (a *UsersCalendarGroupApiService) UsersCalendarGroupsCalendarsEventsDeleteAttachments(ctx _context.Context, userId string, calendarGroupId string, calendarId string, eventId string, attachmentId string) ApiUsersCalendarGroupsCalendarsEventsDeleteAttachmentsRequest {
	return ApiUsersCalendarGroupsCalendarsEventsDeleteAttachmentsRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		calendarGroupId: calendarGroupId,
		calendarId: calendarId,
		eventId: eventId,
		attachmentId: attachmentId,
	}
}

// Execute executes the request
func (a *UsersCalendarGroupApiService) UsersCalendarGroupsCalendarsEventsDeleteAttachmentsExecute(r ApiUsersCalendarGroupsCalendarsEventsDeleteAttachmentsRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersCalendarGroupApiService.UsersCalendarGroupsCalendarsEventsDeleteAttachments")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/calendarGroups/{calendarGroup-id}/calendars/{calendar-id}/events/{event-id}/attachments/{attachment-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"calendarGroup-id"+"}", _neturl.PathEscape(parameterToString(r.calendarGroupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"calendar-id"+"}", _neturl.PathEscape(parameterToString(r.calendarId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"attachment-id"+"}", _neturl.PathEscape(parameterToString(r.attachmentId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ifMatch != nil {
		localVarHeaderParams["If-Match"] = parameterToString(*r.ifMatch, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUsersCalendarGroupsCalendarsEventsDeleteCalendarRequest struct {
	ctx _context.Context
	ApiService *UsersCalendarGroupApiService
	userId string
	calendarGroupId string
	calendarId string
	eventId string
	ifMatch *string
}

// ETag
func (r ApiUsersCalendarGroupsCalendarsEventsDeleteCalendarRequest) IfMatch(ifMatch string) ApiUsersCalendarGroupsCalendarsEventsDeleteCalendarRequest {
	r.ifMatch = &ifMatch
	return r
}

func (r ApiUsersCalendarGroupsCalendarsEventsDeleteCalendarRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.UsersCalendarGroupsCalendarsEventsDeleteCalendarExecute(r)
}

/*
UsersCalendarGroupsCalendarsEventsDeleteCalendar Delete navigation property calendar for users

The calendar that contains the event. Navigation property. Read-only.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @param calendarGroupId key: id of calendarGroup
 @param calendarId key: id of calendar
 @param eventId key: id of event
 @return ApiUsersCalendarGroupsCalendarsEventsDeleteCalendarRequest
*/
func (a *UsersCalendarGroupApiService) UsersCalendarGroupsCalendarsEventsDeleteCalendar(ctx _context.Context, userId string, calendarGroupId string, calendarId string, eventId string) ApiUsersCalendarGroupsCalendarsEventsDeleteCalendarRequest {
	return ApiUsersCalendarGroupsCalendarsEventsDeleteCalendarRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		calendarGroupId: calendarGroupId,
		calendarId: calendarId,
		eventId: eventId,
	}
}

// Execute executes the request
func (a *UsersCalendarGroupApiService) UsersCalendarGroupsCalendarsEventsDeleteCalendarExecute(r ApiUsersCalendarGroupsCalendarsEventsDeleteCalendarRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersCalendarGroupApiService.UsersCalendarGroupsCalendarsEventsDeleteCalendar")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/calendarGroups/{calendarGroup-id}/calendars/{calendar-id}/events/{event-id}/calendar"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"calendarGroup-id"+"}", _neturl.PathEscape(parameterToString(r.calendarGroupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"calendar-id"+"}", _neturl.PathEscape(parameterToString(r.calendarId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ifMatch != nil {
		localVarHeaderParams["If-Match"] = parameterToString(*r.ifMatch, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUsersCalendarGroupsCalendarsEventsDeleteExtensionsRequest struct {
	ctx _context.Context
	ApiService *UsersCalendarGroupApiService
	userId string
	calendarGroupId string
	calendarId string
	eventId string
	extensionId string
	ifMatch *string
}

// ETag
func (r ApiUsersCalendarGroupsCalendarsEventsDeleteExtensionsRequest) IfMatch(ifMatch string) ApiUsersCalendarGroupsCalendarsEventsDeleteExtensionsRequest {
	r.ifMatch = &ifMatch
	return r
}

func (r ApiUsersCalendarGroupsCalendarsEventsDeleteExtensionsRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.UsersCalendarGroupsCalendarsEventsDeleteExtensionsExecute(r)
}

/*
UsersCalendarGroupsCalendarsEventsDeleteExtensions Delete navigation property extensions for users

The collection of open extensions defined for the event. Nullable.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @param calendarGroupId key: id of calendarGroup
 @param calendarId key: id of calendar
 @param eventId key: id of event
 @param extensionId key: id of extension
 @return ApiUsersCalendarGroupsCalendarsEventsDeleteExtensionsRequest
*/
func (a *UsersCalendarGroupApiService) UsersCalendarGroupsCalendarsEventsDeleteExtensions(ctx _context.Context, userId string, calendarGroupId string, calendarId string, eventId string, extensionId string) ApiUsersCalendarGroupsCalendarsEventsDeleteExtensionsRequest {
	return ApiUsersCalendarGroupsCalendarsEventsDeleteExtensionsRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		calendarGroupId: calendarGroupId,
		calendarId: calendarId,
		eventId: eventId,
		extensionId: extensionId,
	}
}

// Execute executes the request
func (a *UsersCalendarGroupApiService) UsersCalendarGroupsCalendarsEventsDeleteExtensionsExecute(r ApiUsersCalendarGroupsCalendarsEventsDeleteExtensionsRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersCalendarGroupApiService.UsersCalendarGroupsCalendarsEventsDeleteExtensions")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/calendarGroups/{calendarGroup-id}/calendars/{calendar-id}/events/{event-id}/extensions/{extension-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"calendarGroup-id"+"}", _neturl.PathEscape(parameterToString(r.calendarGroupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"calendar-id"+"}", _neturl.PathEscape(parameterToString(r.calendarId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"extension-id"+"}", _neturl.PathEscape(parameterToString(r.extensionId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ifMatch != nil {
		localVarHeaderParams["If-Match"] = parameterToString(*r.ifMatch, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUsersCalendarGroupsCalendarsEventsDeleteInstancesRequest struct {
	ctx _context.Context
	ApiService *UsersCalendarGroupApiService
	userId string
	calendarGroupId string
	calendarId string
	eventId string
	eventId1 string
	ifMatch *string
}

// ETag
func (r ApiUsersCalendarGroupsCalendarsEventsDeleteInstancesRequest) IfMatch(ifMatch string) ApiUsersCalendarGroupsCalendarsEventsDeleteInstancesRequest {
	r.ifMatch = &ifMatch
	return r
}

func (r ApiUsersCalendarGroupsCalendarsEventsDeleteInstancesRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.UsersCalendarGroupsCalendarsEventsDeleteInstancesExecute(r)
}

/*
UsersCalendarGroupsCalendarsEventsDeleteInstances Delete navigation property instances for users

The occurrences of a recurring series, if the event is a series master. This property includes occurrences that are part of the recurrence pattern, and exceptions that have been modified, but does not include occurrences that have been cancelled from the series. Navigation property. Read-only. Nullable.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @param calendarGroupId key: id of calendarGroup
 @param calendarId key: id of calendar
 @param eventId key: id of event
 @param eventId1 key: id of event
 @return ApiUsersCalendarGroupsCalendarsEventsDeleteInstancesRequest
*/
func (a *UsersCalendarGroupApiService) UsersCalendarGroupsCalendarsEventsDeleteInstances(ctx _context.Context, userId string, calendarGroupId string, calendarId string, eventId string, eventId1 string) ApiUsersCalendarGroupsCalendarsEventsDeleteInstancesRequest {
	return ApiUsersCalendarGroupsCalendarsEventsDeleteInstancesRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		calendarGroupId: calendarGroupId,
		calendarId: calendarId,
		eventId: eventId,
		eventId1: eventId1,
	}
}

// Execute executes the request
func (a *UsersCalendarGroupApiService) UsersCalendarGroupsCalendarsEventsDeleteInstancesExecute(r ApiUsersCalendarGroupsCalendarsEventsDeleteInstancesRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersCalendarGroupApiService.UsersCalendarGroupsCalendarsEventsDeleteInstances")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/calendarGroups/{calendarGroup-id}/calendars/{calendar-id}/events/{event-id}/instances/{event-id1}"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"calendarGroup-id"+"}", _neturl.PathEscape(parameterToString(r.calendarGroupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"calendar-id"+"}", _neturl.PathEscape(parameterToString(r.calendarId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id1"+"}", _neturl.PathEscape(parameterToString(r.eventId1, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ifMatch != nil {
		localVarHeaderParams["If-Match"] = parameterToString(*r.ifMatch, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUsersCalendarGroupsCalendarsEventsDeleteMultiValueExtendedPropertiesRequest struct {
	ctx _context.Context
	ApiService *UsersCalendarGroupApiService
	userId string
	calendarGroupId string
	calendarId string
	eventId string
	multiValueLegacyExtendedPropertyId string
	ifMatch *string
}

// ETag
func (r ApiUsersCalendarGroupsCalendarsEventsDeleteMultiValueExtendedPropertiesRequest) IfMatch(ifMatch string) ApiUsersCalendarGroupsCalendarsEventsDeleteMultiValueExtendedPropertiesRequest {
	r.ifMatch = &ifMatch
	return r
}

func (r ApiUsersCalendarGroupsCalendarsEventsDeleteMultiValueExtendedPropertiesRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.UsersCalendarGroupsCalendarsEventsDeleteMultiValueExtendedPropertiesExecute(r)
}

/*
UsersCalendarGroupsCalendarsEventsDeleteMultiValueExtendedProperties Delete navigation property multiValueExtendedProperties for users

The collection of multi-value extended properties defined for the event. Read-only. Nullable.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @param calendarGroupId key: id of calendarGroup
 @param calendarId key: id of calendar
 @param eventId key: id of event
 @param multiValueLegacyExtendedPropertyId key: id of multiValueLegacyExtendedProperty
 @return ApiUsersCalendarGroupsCalendarsEventsDeleteMultiValueExtendedPropertiesRequest
*/
func (a *UsersCalendarGroupApiService) UsersCalendarGroupsCalendarsEventsDeleteMultiValueExtendedProperties(ctx _context.Context, userId string, calendarGroupId string, calendarId string, eventId string, multiValueLegacyExtendedPropertyId string) ApiUsersCalendarGroupsCalendarsEventsDeleteMultiValueExtendedPropertiesRequest {
	return ApiUsersCalendarGroupsCalendarsEventsDeleteMultiValueExtendedPropertiesRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		calendarGroupId: calendarGroupId,
		calendarId: calendarId,
		eventId: eventId,
		multiValueLegacyExtendedPropertyId: multiValueLegacyExtendedPropertyId,
	}
}

// Execute executes the request
func (a *UsersCalendarGroupApiService) UsersCalendarGroupsCalendarsEventsDeleteMultiValueExtendedPropertiesExecute(r ApiUsersCalendarGroupsCalendarsEventsDeleteMultiValueExtendedPropertiesRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersCalendarGroupApiService.UsersCalendarGroupsCalendarsEventsDeleteMultiValueExtendedProperties")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/calendarGroups/{calendarGroup-id}/calendars/{calendar-id}/events/{event-id}/multiValueExtendedProperties/{multiValueLegacyExtendedProperty-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"calendarGroup-id"+"}", _neturl.PathEscape(parameterToString(r.calendarGroupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"calendar-id"+"}", _neturl.PathEscape(parameterToString(r.calendarId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"multiValueLegacyExtendedProperty-id"+"}", _neturl.PathEscape(parameterToString(r.multiValueLegacyExtendedPropertyId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ifMatch != nil {
		localVarHeaderParams["If-Match"] = parameterToString(*r.ifMatch, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUsersCalendarGroupsCalendarsEventsDeleteSingleValueExtendedPropertiesRequest struct {
	ctx _context.Context
	ApiService *UsersCalendarGroupApiService
	userId string
	calendarGroupId string
	calendarId string
	eventId string
	singleValueLegacyExtendedPropertyId string
	ifMatch *string
}

// ETag
func (r ApiUsersCalendarGroupsCalendarsEventsDeleteSingleValueExtendedPropertiesRequest) IfMatch(ifMatch string) ApiUsersCalendarGroupsCalendarsEventsDeleteSingleValueExtendedPropertiesRequest {
	r.ifMatch = &ifMatch
	return r
}

func (r ApiUsersCalendarGroupsCalendarsEventsDeleteSingleValueExtendedPropertiesRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.UsersCalendarGroupsCalendarsEventsDeleteSingleValueExtendedPropertiesExecute(r)
}

/*
UsersCalendarGroupsCalendarsEventsDeleteSingleValueExtendedProperties Delete navigation property singleValueExtendedProperties for users

The collection of single-value extended properties defined for the event. Read-only. Nullable.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @param calendarGroupId key: id of calendarGroup
 @param calendarId key: id of calendar
 @param eventId key: id of event
 @param singleValueLegacyExtendedPropertyId key: id of singleValueLegacyExtendedProperty
 @return ApiUsersCalendarGroupsCalendarsEventsDeleteSingleValueExtendedPropertiesRequest
*/
func (a *UsersCalendarGroupApiService) UsersCalendarGroupsCalendarsEventsDeleteSingleValueExtendedProperties(ctx _context.Context, userId string, calendarGroupId string, calendarId string, eventId string, singleValueLegacyExtendedPropertyId string) ApiUsersCalendarGroupsCalendarsEventsDeleteSingleValueExtendedPropertiesRequest {
	return ApiUsersCalendarGroupsCalendarsEventsDeleteSingleValueExtendedPropertiesRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		calendarGroupId: calendarGroupId,
		calendarId: calendarId,
		eventId: eventId,
		singleValueLegacyExtendedPropertyId: singleValueLegacyExtendedPropertyId,
	}
}

// Execute executes the request
func (a *UsersCalendarGroupApiService) UsersCalendarGroupsCalendarsEventsDeleteSingleValueExtendedPropertiesExecute(r ApiUsersCalendarGroupsCalendarsEventsDeleteSingleValueExtendedPropertiesRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersCalendarGroupApiService.UsersCalendarGroupsCalendarsEventsDeleteSingleValueExtendedProperties")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/calendarGroups/{calendarGroup-id}/calendars/{calendar-id}/events/{event-id}/singleValueExtendedProperties/{singleValueLegacyExtendedProperty-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"calendarGroup-id"+"}", _neturl.PathEscape(parameterToString(r.calendarGroupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"calendar-id"+"}", _neturl.PathEscape(parameterToString(r.calendarId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"singleValueLegacyExtendedProperty-id"+"}", _neturl.PathEscape(parameterToString(r.singleValueLegacyExtendedPropertyId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ifMatch != nil {
		localVarHeaderParams["If-Match"] = parameterToString(*r.ifMatch, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUsersCalendarGroupsCalendarsEventsGetAttachmentsRequest struct {
	ctx _context.Context
	ApiService *UsersCalendarGroupApiService
	userId string
	calendarGroupId string
	calendarId string
	eventId string
	attachmentId string
	select_ *[]string
	expand *[]string
}

// Select properties to be returned
func (r ApiUsersCalendarGroupsCalendarsEventsGetAttachmentsRequest) Select_(select_ []string) ApiUsersCalendarGroupsCalendarsEventsGetAttachmentsRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiUsersCalendarGroupsCalendarsEventsGetAttachmentsRequest) Expand(expand []string) ApiUsersCalendarGroupsCalendarsEventsGetAttachmentsRequest {
	r.expand = &expand
	return r
}

func (r ApiUsersCalendarGroupsCalendarsEventsGetAttachmentsRequest) Execute() (MicrosoftGraphAttachment, *_nethttp.Response, error) {
	return r.ApiService.UsersCalendarGroupsCalendarsEventsGetAttachmentsExecute(r)
}

/*
UsersCalendarGroupsCalendarsEventsGetAttachments Get attachments from users

The collection of FileAttachment, ItemAttachment, and referenceAttachment attachments for the event. Navigation property. Read-only. Nullable.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @param calendarGroupId key: id of calendarGroup
 @param calendarId key: id of calendar
 @param eventId key: id of event
 @param attachmentId key: id of attachment
 @return ApiUsersCalendarGroupsCalendarsEventsGetAttachmentsRequest
*/
func (a *UsersCalendarGroupApiService) UsersCalendarGroupsCalendarsEventsGetAttachments(ctx _context.Context, userId string, calendarGroupId string, calendarId string, eventId string, attachmentId string) ApiUsersCalendarGroupsCalendarsEventsGetAttachmentsRequest {
	return ApiUsersCalendarGroupsCalendarsEventsGetAttachmentsRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		calendarGroupId: calendarGroupId,
		calendarId: calendarId,
		eventId: eventId,
		attachmentId: attachmentId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphAttachment
func (a *UsersCalendarGroupApiService) UsersCalendarGroupsCalendarsEventsGetAttachmentsExecute(r ApiUsersCalendarGroupsCalendarsEventsGetAttachmentsRequest) (MicrosoftGraphAttachment, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphAttachment
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersCalendarGroupApiService.UsersCalendarGroupsCalendarsEventsGetAttachments")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/calendarGroups/{calendarGroup-id}/calendars/{calendar-id}/events/{event-id}/attachments/{attachment-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"calendarGroup-id"+"}", _neturl.PathEscape(parameterToString(r.calendarGroupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"calendar-id"+"}", _neturl.PathEscape(parameterToString(r.calendarId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"attachment-id"+"}", _neturl.PathEscape(parameterToString(r.attachmentId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUsersCalendarGroupsCalendarsEventsGetCalendarRequest struct {
	ctx _context.Context
	ApiService *UsersCalendarGroupApiService
	userId string
	calendarGroupId string
	calendarId string
	eventId string
	select_ *[]string
}

// Select properties to be returned
func (r ApiUsersCalendarGroupsCalendarsEventsGetCalendarRequest) Select_(select_ []string) ApiUsersCalendarGroupsCalendarsEventsGetCalendarRequest {
	r.select_ = &select_
	return r
}

func (r ApiUsersCalendarGroupsCalendarsEventsGetCalendarRequest) Execute() (MicrosoftGraphCalendar, *_nethttp.Response, error) {
	return r.ApiService.UsersCalendarGroupsCalendarsEventsGetCalendarExecute(r)
}

/*
UsersCalendarGroupsCalendarsEventsGetCalendar Get calendar from users

The calendar that contains the event. Navigation property. Read-only.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @param calendarGroupId key: id of calendarGroup
 @param calendarId key: id of calendar
 @param eventId key: id of event
 @return ApiUsersCalendarGroupsCalendarsEventsGetCalendarRequest
*/
func (a *UsersCalendarGroupApiService) UsersCalendarGroupsCalendarsEventsGetCalendar(ctx _context.Context, userId string, calendarGroupId string, calendarId string, eventId string) ApiUsersCalendarGroupsCalendarsEventsGetCalendarRequest {
	return ApiUsersCalendarGroupsCalendarsEventsGetCalendarRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		calendarGroupId: calendarGroupId,
		calendarId: calendarId,
		eventId: eventId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphCalendar
func (a *UsersCalendarGroupApiService) UsersCalendarGroupsCalendarsEventsGetCalendarExecute(r ApiUsersCalendarGroupsCalendarsEventsGetCalendarRequest) (MicrosoftGraphCalendar, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphCalendar
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersCalendarGroupApiService.UsersCalendarGroupsCalendarsEventsGetCalendar")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/calendarGroups/{calendarGroup-id}/calendars/{calendar-id}/events/{event-id}/calendar"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"calendarGroup-id"+"}", _neturl.PathEscape(parameterToString(r.calendarGroupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"calendar-id"+"}", _neturl.PathEscape(parameterToString(r.calendarId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUsersCalendarGroupsCalendarsEventsGetExtensionsRequest struct {
	ctx _context.Context
	ApiService *UsersCalendarGroupApiService
	userId string
	calendarGroupId string
	calendarId string
	eventId string
	extensionId string
	select_ *[]string
	expand *[]string
}

// Select properties to be returned
func (r ApiUsersCalendarGroupsCalendarsEventsGetExtensionsRequest) Select_(select_ []string) ApiUsersCalendarGroupsCalendarsEventsGetExtensionsRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiUsersCalendarGroupsCalendarsEventsGetExtensionsRequest) Expand(expand []string) ApiUsersCalendarGroupsCalendarsEventsGetExtensionsRequest {
	r.expand = &expand
	return r
}

func (r ApiUsersCalendarGroupsCalendarsEventsGetExtensionsRequest) Execute() (MicrosoftGraphExtension, *_nethttp.Response, error) {
	return r.ApiService.UsersCalendarGroupsCalendarsEventsGetExtensionsExecute(r)
}

/*
UsersCalendarGroupsCalendarsEventsGetExtensions Get extensions from users

The collection of open extensions defined for the event. Nullable.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @param calendarGroupId key: id of calendarGroup
 @param calendarId key: id of calendar
 @param eventId key: id of event
 @param extensionId key: id of extension
 @return ApiUsersCalendarGroupsCalendarsEventsGetExtensionsRequest
*/
func (a *UsersCalendarGroupApiService) UsersCalendarGroupsCalendarsEventsGetExtensions(ctx _context.Context, userId string, calendarGroupId string, calendarId string, eventId string, extensionId string) ApiUsersCalendarGroupsCalendarsEventsGetExtensionsRequest {
	return ApiUsersCalendarGroupsCalendarsEventsGetExtensionsRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		calendarGroupId: calendarGroupId,
		calendarId: calendarId,
		eventId: eventId,
		extensionId: extensionId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphExtension
func (a *UsersCalendarGroupApiService) UsersCalendarGroupsCalendarsEventsGetExtensionsExecute(r ApiUsersCalendarGroupsCalendarsEventsGetExtensionsRequest) (MicrosoftGraphExtension, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphExtension
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersCalendarGroupApiService.UsersCalendarGroupsCalendarsEventsGetExtensions")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/calendarGroups/{calendarGroup-id}/calendars/{calendar-id}/events/{event-id}/extensions/{extension-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"calendarGroup-id"+"}", _neturl.PathEscape(parameterToString(r.calendarGroupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"calendar-id"+"}", _neturl.PathEscape(parameterToString(r.calendarId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"extension-id"+"}", _neturl.PathEscape(parameterToString(r.extensionId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUsersCalendarGroupsCalendarsEventsGetInstancesRequest struct {
	ctx _context.Context
	ApiService *UsersCalendarGroupApiService
	userId string
	calendarGroupId string
	calendarId string
	eventId string
	eventId1 string
	select_ *[]string
}

// Select properties to be returned
func (r ApiUsersCalendarGroupsCalendarsEventsGetInstancesRequest) Select_(select_ []string) ApiUsersCalendarGroupsCalendarsEventsGetInstancesRequest {
	r.select_ = &select_
	return r
}

func (r ApiUsersCalendarGroupsCalendarsEventsGetInstancesRequest) Execute() (MicrosoftGraphEvent, *_nethttp.Response, error) {
	return r.ApiService.UsersCalendarGroupsCalendarsEventsGetInstancesExecute(r)
}

/*
UsersCalendarGroupsCalendarsEventsGetInstances Get instances from users

The occurrences of a recurring series, if the event is a series master. This property includes occurrences that are part of the recurrence pattern, and exceptions that have been modified, but does not include occurrences that have been cancelled from the series. Navigation property. Read-only. Nullable.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @param calendarGroupId key: id of calendarGroup
 @param calendarId key: id of calendar
 @param eventId key: id of event
 @param eventId1 key: id of event
 @return ApiUsersCalendarGroupsCalendarsEventsGetInstancesRequest
*/
func (a *UsersCalendarGroupApiService) UsersCalendarGroupsCalendarsEventsGetInstances(ctx _context.Context, userId string, calendarGroupId string, calendarId string, eventId string, eventId1 string) ApiUsersCalendarGroupsCalendarsEventsGetInstancesRequest {
	return ApiUsersCalendarGroupsCalendarsEventsGetInstancesRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		calendarGroupId: calendarGroupId,
		calendarId: calendarId,
		eventId: eventId,
		eventId1: eventId1,
	}
}

// Execute executes the request
//  @return MicrosoftGraphEvent
func (a *UsersCalendarGroupApiService) UsersCalendarGroupsCalendarsEventsGetInstancesExecute(r ApiUsersCalendarGroupsCalendarsEventsGetInstancesRequest) (MicrosoftGraphEvent, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphEvent
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersCalendarGroupApiService.UsersCalendarGroupsCalendarsEventsGetInstances")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/calendarGroups/{calendarGroup-id}/calendars/{calendar-id}/events/{event-id}/instances/{event-id1}"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"calendarGroup-id"+"}", _neturl.PathEscape(parameterToString(r.calendarGroupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"calendar-id"+"}", _neturl.PathEscape(parameterToString(r.calendarId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id1"+"}", _neturl.PathEscape(parameterToString(r.eventId1, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUsersCalendarGroupsCalendarsEventsGetMultiValueExtendedPropertiesRequest struct {
	ctx _context.Context
	ApiService *UsersCalendarGroupApiService
	userId string
	calendarGroupId string
	calendarId string
	eventId string
	multiValueLegacyExtendedPropertyId string
	select_ *[]string
	expand *[]string
}

// Select properties to be returned
func (r ApiUsersCalendarGroupsCalendarsEventsGetMultiValueExtendedPropertiesRequest) Select_(select_ []string) ApiUsersCalendarGroupsCalendarsEventsGetMultiValueExtendedPropertiesRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiUsersCalendarGroupsCalendarsEventsGetMultiValueExtendedPropertiesRequest) Expand(expand []string) ApiUsersCalendarGroupsCalendarsEventsGetMultiValueExtendedPropertiesRequest {
	r.expand = &expand
	return r
}

func (r ApiUsersCalendarGroupsCalendarsEventsGetMultiValueExtendedPropertiesRequest) Execute() (MicrosoftGraphMultiValueLegacyExtendedProperty, *_nethttp.Response, error) {
	return r.ApiService.UsersCalendarGroupsCalendarsEventsGetMultiValueExtendedPropertiesExecute(r)
}

/*
UsersCalendarGroupsCalendarsEventsGetMultiValueExtendedProperties Get multiValueExtendedProperties from users

The collection of multi-value extended properties defined for the event. Read-only. Nullable.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @param calendarGroupId key: id of calendarGroup
 @param calendarId key: id of calendar
 @param eventId key: id of event
 @param multiValueLegacyExtendedPropertyId key: id of multiValueLegacyExtendedProperty
 @return ApiUsersCalendarGroupsCalendarsEventsGetMultiValueExtendedPropertiesRequest
*/
func (a *UsersCalendarGroupApiService) UsersCalendarGroupsCalendarsEventsGetMultiValueExtendedProperties(ctx _context.Context, userId string, calendarGroupId string, calendarId string, eventId string, multiValueLegacyExtendedPropertyId string) ApiUsersCalendarGroupsCalendarsEventsGetMultiValueExtendedPropertiesRequest {
	return ApiUsersCalendarGroupsCalendarsEventsGetMultiValueExtendedPropertiesRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		calendarGroupId: calendarGroupId,
		calendarId: calendarId,
		eventId: eventId,
		multiValueLegacyExtendedPropertyId: multiValueLegacyExtendedPropertyId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphMultiValueLegacyExtendedProperty
func (a *UsersCalendarGroupApiService) UsersCalendarGroupsCalendarsEventsGetMultiValueExtendedPropertiesExecute(r ApiUsersCalendarGroupsCalendarsEventsGetMultiValueExtendedPropertiesRequest) (MicrosoftGraphMultiValueLegacyExtendedProperty, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphMultiValueLegacyExtendedProperty
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersCalendarGroupApiService.UsersCalendarGroupsCalendarsEventsGetMultiValueExtendedProperties")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/calendarGroups/{calendarGroup-id}/calendars/{calendar-id}/events/{event-id}/multiValueExtendedProperties/{multiValueLegacyExtendedProperty-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"calendarGroup-id"+"}", _neturl.PathEscape(parameterToString(r.calendarGroupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"calendar-id"+"}", _neturl.PathEscape(parameterToString(r.calendarId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"multiValueLegacyExtendedProperty-id"+"}", _neturl.PathEscape(parameterToString(r.multiValueLegacyExtendedPropertyId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUsersCalendarGroupsCalendarsEventsGetSingleValueExtendedPropertiesRequest struct {
	ctx _context.Context
	ApiService *UsersCalendarGroupApiService
	userId string
	calendarGroupId string
	calendarId string
	eventId string
	singleValueLegacyExtendedPropertyId string
	select_ *[]string
	expand *[]string
}

// Select properties to be returned
func (r ApiUsersCalendarGroupsCalendarsEventsGetSingleValueExtendedPropertiesRequest) Select_(select_ []string) ApiUsersCalendarGroupsCalendarsEventsGetSingleValueExtendedPropertiesRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiUsersCalendarGroupsCalendarsEventsGetSingleValueExtendedPropertiesRequest) Expand(expand []string) ApiUsersCalendarGroupsCalendarsEventsGetSingleValueExtendedPropertiesRequest {
	r.expand = &expand
	return r
}

func (r ApiUsersCalendarGroupsCalendarsEventsGetSingleValueExtendedPropertiesRequest) Execute() (MicrosoftGraphSingleValueLegacyExtendedProperty, *_nethttp.Response, error) {
	return r.ApiService.UsersCalendarGroupsCalendarsEventsGetSingleValueExtendedPropertiesExecute(r)
}

/*
UsersCalendarGroupsCalendarsEventsGetSingleValueExtendedProperties Get singleValueExtendedProperties from users

The collection of single-value extended properties defined for the event. Read-only. Nullable.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @param calendarGroupId key: id of calendarGroup
 @param calendarId key: id of calendar
 @param eventId key: id of event
 @param singleValueLegacyExtendedPropertyId key: id of singleValueLegacyExtendedProperty
 @return ApiUsersCalendarGroupsCalendarsEventsGetSingleValueExtendedPropertiesRequest
*/
func (a *UsersCalendarGroupApiService) UsersCalendarGroupsCalendarsEventsGetSingleValueExtendedProperties(ctx _context.Context, userId string, calendarGroupId string, calendarId string, eventId string, singleValueLegacyExtendedPropertyId string) ApiUsersCalendarGroupsCalendarsEventsGetSingleValueExtendedPropertiesRequest {
	return ApiUsersCalendarGroupsCalendarsEventsGetSingleValueExtendedPropertiesRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		calendarGroupId: calendarGroupId,
		calendarId: calendarId,
		eventId: eventId,
		singleValueLegacyExtendedPropertyId: singleValueLegacyExtendedPropertyId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphSingleValueLegacyExtendedProperty
func (a *UsersCalendarGroupApiService) UsersCalendarGroupsCalendarsEventsGetSingleValueExtendedPropertiesExecute(r ApiUsersCalendarGroupsCalendarsEventsGetSingleValueExtendedPropertiesRequest) (MicrosoftGraphSingleValueLegacyExtendedProperty, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphSingleValueLegacyExtendedProperty
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersCalendarGroupApiService.UsersCalendarGroupsCalendarsEventsGetSingleValueExtendedProperties")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/calendarGroups/{calendarGroup-id}/calendars/{calendar-id}/events/{event-id}/singleValueExtendedProperties/{singleValueLegacyExtendedProperty-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"calendarGroup-id"+"}", _neturl.PathEscape(parameterToString(r.calendarGroupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"calendar-id"+"}", _neturl.PathEscape(parameterToString(r.calendarId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"singleValueLegacyExtendedProperty-id"+"}", _neturl.PathEscape(parameterToString(r.singleValueLegacyExtendedPropertyId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUsersCalendarGroupsCalendarsEventsListAttachmentsRequest struct {
	ctx _context.Context
	ApiService *UsersCalendarGroupApiService
	userId string
	calendarGroupId string
	calendarId string
	eventId string
	top *int32
	skip *int32
	filter *string
	count *bool
	orderby *[]string
	select_ *[]string
	expand *[]string
}

// Show only the first n items
func (r ApiUsersCalendarGroupsCalendarsEventsListAttachmentsRequest) Top(top int32) ApiUsersCalendarGroupsCalendarsEventsListAttachmentsRequest {
	r.top = &top
	return r
}
// Skip the first n items
func (r ApiUsersCalendarGroupsCalendarsEventsListAttachmentsRequest) Skip(skip int32) ApiUsersCalendarGroupsCalendarsEventsListAttachmentsRequest {
	r.skip = &skip
	return r
}
// Filter items by property values
func (r ApiUsersCalendarGroupsCalendarsEventsListAttachmentsRequest) Filter(filter string) ApiUsersCalendarGroupsCalendarsEventsListAttachmentsRequest {
	r.filter = &filter
	return r
}
// Include count of items
func (r ApiUsersCalendarGroupsCalendarsEventsListAttachmentsRequest) Count(count bool) ApiUsersCalendarGroupsCalendarsEventsListAttachmentsRequest {
	r.count = &count
	return r
}
// Order items by property values
func (r ApiUsersCalendarGroupsCalendarsEventsListAttachmentsRequest) Orderby(orderby []string) ApiUsersCalendarGroupsCalendarsEventsListAttachmentsRequest {
	r.orderby = &orderby
	return r
}
// Select properties to be returned
func (r ApiUsersCalendarGroupsCalendarsEventsListAttachmentsRequest) Select_(select_ []string) ApiUsersCalendarGroupsCalendarsEventsListAttachmentsRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiUsersCalendarGroupsCalendarsEventsListAttachmentsRequest) Expand(expand []string) ApiUsersCalendarGroupsCalendarsEventsListAttachmentsRequest {
	r.expand = &expand
	return r
}

func (r ApiUsersCalendarGroupsCalendarsEventsListAttachmentsRequest) Execute() (CollectionOfAttachment, *_nethttp.Response, error) {
	return r.ApiService.UsersCalendarGroupsCalendarsEventsListAttachmentsExecute(r)
}

/*
UsersCalendarGroupsCalendarsEventsListAttachments Get attachments from users

The collection of FileAttachment, ItemAttachment, and referenceAttachment attachments for the event. Navigation property. Read-only. Nullable.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @param calendarGroupId key: id of calendarGroup
 @param calendarId key: id of calendar
 @param eventId key: id of event
 @return ApiUsersCalendarGroupsCalendarsEventsListAttachmentsRequest
*/
func (a *UsersCalendarGroupApiService) UsersCalendarGroupsCalendarsEventsListAttachments(ctx _context.Context, userId string, calendarGroupId string, calendarId string, eventId string) ApiUsersCalendarGroupsCalendarsEventsListAttachmentsRequest {
	return ApiUsersCalendarGroupsCalendarsEventsListAttachmentsRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		calendarGroupId: calendarGroupId,
		calendarId: calendarId,
		eventId: eventId,
	}
}

// Execute executes the request
//  @return CollectionOfAttachment
func (a *UsersCalendarGroupApiService) UsersCalendarGroupsCalendarsEventsListAttachmentsExecute(r ApiUsersCalendarGroupsCalendarsEventsListAttachmentsRequest) (CollectionOfAttachment, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  CollectionOfAttachment
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersCalendarGroupApiService.UsersCalendarGroupsCalendarsEventsListAttachments")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/calendarGroups/{calendarGroup-id}/calendars/{calendar-id}/events/{event-id}/attachments"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"calendarGroup-id"+"}", _neturl.PathEscape(parameterToString(r.calendarGroupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"calendar-id"+"}", _neturl.PathEscape(parameterToString(r.calendarId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.top != nil {
		localVarQueryParams.Add("$top", parameterToString(*r.top, ""))
	}
	if r.skip != nil {
		localVarQueryParams.Add("$skip", parameterToString(*r.skip, ""))
	}
	if r.filter != nil {
		localVarQueryParams.Add("$filter", parameterToString(*r.filter, ""))
	}
	if r.count != nil {
		localVarQueryParams.Add("$count", parameterToString(*r.count, ""))
	}
	if r.orderby != nil {
		localVarQueryParams.Add("$orderby", parameterToString(*r.orderby, "csv"))
	}
	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUsersCalendarGroupsCalendarsEventsListExtensionsRequest struct {
	ctx _context.Context
	ApiService *UsersCalendarGroupApiService
	userId string
	calendarGroupId string
	calendarId string
	eventId string
	top *int32
	skip *int32
	filter *string
	count *bool
	orderby *[]string
	select_ *[]string
	expand *[]string
}

// Show only the first n items
func (r ApiUsersCalendarGroupsCalendarsEventsListExtensionsRequest) Top(top int32) ApiUsersCalendarGroupsCalendarsEventsListExtensionsRequest {
	r.top = &top
	return r
}
// Skip the first n items
func (r ApiUsersCalendarGroupsCalendarsEventsListExtensionsRequest) Skip(skip int32) ApiUsersCalendarGroupsCalendarsEventsListExtensionsRequest {
	r.skip = &skip
	return r
}
// Filter items by property values
func (r ApiUsersCalendarGroupsCalendarsEventsListExtensionsRequest) Filter(filter string) ApiUsersCalendarGroupsCalendarsEventsListExtensionsRequest {
	r.filter = &filter
	return r
}
// Include count of items
func (r ApiUsersCalendarGroupsCalendarsEventsListExtensionsRequest) Count(count bool) ApiUsersCalendarGroupsCalendarsEventsListExtensionsRequest {
	r.count = &count
	return r
}
// Order items by property values
func (r ApiUsersCalendarGroupsCalendarsEventsListExtensionsRequest) Orderby(orderby []string) ApiUsersCalendarGroupsCalendarsEventsListExtensionsRequest {
	r.orderby = &orderby
	return r
}
// Select properties to be returned
func (r ApiUsersCalendarGroupsCalendarsEventsListExtensionsRequest) Select_(select_ []string) ApiUsersCalendarGroupsCalendarsEventsListExtensionsRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiUsersCalendarGroupsCalendarsEventsListExtensionsRequest) Expand(expand []string) ApiUsersCalendarGroupsCalendarsEventsListExtensionsRequest {
	r.expand = &expand
	return r
}

func (r ApiUsersCalendarGroupsCalendarsEventsListExtensionsRequest) Execute() (CollectionOfExtension, *_nethttp.Response, error) {
	return r.ApiService.UsersCalendarGroupsCalendarsEventsListExtensionsExecute(r)
}

/*
UsersCalendarGroupsCalendarsEventsListExtensions Get extensions from users

The collection of open extensions defined for the event. Nullable.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @param calendarGroupId key: id of calendarGroup
 @param calendarId key: id of calendar
 @param eventId key: id of event
 @return ApiUsersCalendarGroupsCalendarsEventsListExtensionsRequest
*/
func (a *UsersCalendarGroupApiService) UsersCalendarGroupsCalendarsEventsListExtensions(ctx _context.Context, userId string, calendarGroupId string, calendarId string, eventId string) ApiUsersCalendarGroupsCalendarsEventsListExtensionsRequest {
	return ApiUsersCalendarGroupsCalendarsEventsListExtensionsRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		calendarGroupId: calendarGroupId,
		calendarId: calendarId,
		eventId: eventId,
	}
}

// Execute executes the request
//  @return CollectionOfExtension
func (a *UsersCalendarGroupApiService) UsersCalendarGroupsCalendarsEventsListExtensionsExecute(r ApiUsersCalendarGroupsCalendarsEventsListExtensionsRequest) (CollectionOfExtension, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  CollectionOfExtension
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersCalendarGroupApiService.UsersCalendarGroupsCalendarsEventsListExtensions")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/calendarGroups/{calendarGroup-id}/calendars/{calendar-id}/events/{event-id}/extensions"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"calendarGroup-id"+"}", _neturl.PathEscape(parameterToString(r.calendarGroupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"calendar-id"+"}", _neturl.PathEscape(parameterToString(r.calendarId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.top != nil {
		localVarQueryParams.Add("$top", parameterToString(*r.top, ""))
	}
	if r.skip != nil {
		localVarQueryParams.Add("$skip", parameterToString(*r.skip, ""))
	}
	if r.filter != nil {
		localVarQueryParams.Add("$filter", parameterToString(*r.filter, ""))
	}
	if r.count != nil {
		localVarQueryParams.Add("$count", parameterToString(*r.count, ""))
	}
	if r.orderby != nil {
		localVarQueryParams.Add("$orderby", parameterToString(*r.orderby, "csv"))
	}
	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUsersCalendarGroupsCalendarsEventsListInstancesRequest struct {
	ctx _context.Context
	ApiService *UsersCalendarGroupApiService
	userId string
	calendarGroupId string
	calendarId string
	eventId string
	top *int32
	skip *int32
	filter *string
	count *bool
	orderby *[]string
	select_ *[]string
}

// Show only the first n items
func (r ApiUsersCalendarGroupsCalendarsEventsListInstancesRequest) Top(top int32) ApiUsersCalendarGroupsCalendarsEventsListInstancesRequest {
	r.top = &top
	return r
}
// Skip the first n items
func (r ApiUsersCalendarGroupsCalendarsEventsListInstancesRequest) Skip(skip int32) ApiUsersCalendarGroupsCalendarsEventsListInstancesRequest {
	r.skip = &skip
	return r
}
// Filter items by property values
func (r ApiUsersCalendarGroupsCalendarsEventsListInstancesRequest) Filter(filter string) ApiUsersCalendarGroupsCalendarsEventsListInstancesRequest {
	r.filter = &filter
	return r
}
// Include count of items
func (r ApiUsersCalendarGroupsCalendarsEventsListInstancesRequest) Count(count bool) ApiUsersCalendarGroupsCalendarsEventsListInstancesRequest {
	r.count = &count
	return r
}
// Order items by property values
func (r ApiUsersCalendarGroupsCalendarsEventsListInstancesRequest) Orderby(orderby []string) ApiUsersCalendarGroupsCalendarsEventsListInstancesRequest {
	r.orderby = &orderby
	return r
}
// Select properties to be returned
func (r ApiUsersCalendarGroupsCalendarsEventsListInstancesRequest) Select_(select_ []string) ApiUsersCalendarGroupsCalendarsEventsListInstancesRequest {
	r.select_ = &select_
	return r
}

func (r ApiUsersCalendarGroupsCalendarsEventsListInstancesRequest) Execute() (CollectionOfEvent, *_nethttp.Response, error) {
	return r.ApiService.UsersCalendarGroupsCalendarsEventsListInstancesExecute(r)
}

/*
UsersCalendarGroupsCalendarsEventsListInstances Get instances from users

The occurrences of a recurring series, if the event is a series master. This property includes occurrences that are part of the recurrence pattern, and exceptions that have been modified, but does not include occurrences that have been cancelled from the series. Navigation property. Read-only. Nullable.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @param calendarGroupId key: id of calendarGroup
 @param calendarId key: id of calendar
 @param eventId key: id of event
 @return ApiUsersCalendarGroupsCalendarsEventsListInstancesRequest
*/
func (a *UsersCalendarGroupApiService) UsersCalendarGroupsCalendarsEventsListInstances(ctx _context.Context, userId string, calendarGroupId string, calendarId string, eventId string) ApiUsersCalendarGroupsCalendarsEventsListInstancesRequest {
	return ApiUsersCalendarGroupsCalendarsEventsListInstancesRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		calendarGroupId: calendarGroupId,
		calendarId: calendarId,
		eventId: eventId,
	}
}

// Execute executes the request
//  @return CollectionOfEvent
func (a *UsersCalendarGroupApiService) UsersCalendarGroupsCalendarsEventsListInstancesExecute(r ApiUsersCalendarGroupsCalendarsEventsListInstancesRequest) (CollectionOfEvent, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  CollectionOfEvent
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersCalendarGroupApiService.UsersCalendarGroupsCalendarsEventsListInstances")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/calendarGroups/{calendarGroup-id}/calendars/{calendar-id}/events/{event-id}/instances"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"calendarGroup-id"+"}", _neturl.PathEscape(parameterToString(r.calendarGroupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"calendar-id"+"}", _neturl.PathEscape(parameterToString(r.calendarId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.top != nil {
		localVarQueryParams.Add("$top", parameterToString(*r.top, ""))
	}
	if r.skip != nil {
		localVarQueryParams.Add("$skip", parameterToString(*r.skip, ""))
	}
	if r.filter != nil {
		localVarQueryParams.Add("$filter", parameterToString(*r.filter, ""))
	}
	if r.count != nil {
		localVarQueryParams.Add("$count", parameterToString(*r.count, ""))
	}
	if r.orderby != nil {
		localVarQueryParams.Add("$orderby", parameterToString(*r.orderby, "csv"))
	}
	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUsersCalendarGroupsCalendarsEventsListMultiValueExtendedPropertiesRequest struct {
	ctx _context.Context
	ApiService *UsersCalendarGroupApiService
	userId string
	calendarGroupId string
	calendarId string
	eventId string
	top *int32
	skip *int32
	search *string
	filter *string
	count *bool
	orderby *[]string
	select_ *[]string
	expand *[]string
}

// Show only the first n items
func (r ApiUsersCalendarGroupsCalendarsEventsListMultiValueExtendedPropertiesRequest) Top(top int32) ApiUsersCalendarGroupsCalendarsEventsListMultiValueExtendedPropertiesRequest {
	r.top = &top
	return r
}
// Skip the first n items
func (r ApiUsersCalendarGroupsCalendarsEventsListMultiValueExtendedPropertiesRequest) Skip(skip int32) ApiUsersCalendarGroupsCalendarsEventsListMultiValueExtendedPropertiesRequest {
	r.skip = &skip
	return r
}
// Search items by search phrases
func (r ApiUsersCalendarGroupsCalendarsEventsListMultiValueExtendedPropertiesRequest) Search(search string) ApiUsersCalendarGroupsCalendarsEventsListMultiValueExtendedPropertiesRequest {
	r.search = &search
	return r
}
// Filter items by property values
func (r ApiUsersCalendarGroupsCalendarsEventsListMultiValueExtendedPropertiesRequest) Filter(filter string) ApiUsersCalendarGroupsCalendarsEventsListMultiValueExtendedPropertiesRequest {
	r.filter = &filter
	return r
}
// Include count of items
func (r ApiUsersCalendarGroupsCalendarsEventsListMultiValueExtendedPropertiesRequest) Count(count bool) ApiUsersCalendarGroupsCalendarsEventsListMultiValueExtendedPropertiesRequest {
	r.count = &count
	return r
}
// Order items by property values
func (r ApiUsersCalendarGroupsCalendarsEventsListMultiValueExtendedPropertiesRequest) Orderby(orderby []string) ApiUsersCalendarGroupsCalendarsEventsListMultiValueExtendedPropertiesRequest {
	r.orderby = &orderby
	return r
}
// Select properties to be returned
func (r ApiUsersCalendarGroupsCalendarsEventsListMultiValueExtendedPropertiesRequest) Select_(select_ []string) ApiUsersCalendarGroupsCalendarsEventsListMultiValueExtendedPropertiesRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiUsersCalendarGroupsCalendarsEventsListMultiValueExtendedPropertiesRequest) Expand(expand []string) ApiUsersCalendarGroupsCalendarsEventsListMultiValueExtendedPropertiesRequest {
	r.expand = &expand
	return r
}

func (r ApiUsersCalendarGroupsCalendarsEventsListMultiValueExtendedPropertiesRequest) Execute() (CollectionOfMultiValueLegacyExtendedProperty, *_nethttp.Response, error) {
	return r.ApiService.UsersCalendarGroupsCalendarsEventsListMultiValueExtendedPropertiesExecute(r)
}

/*
UsersCalendarGroupsCalendarsEventsListMultiValueExtendedProperties Get multiValueExtendedProperties from users

The collection of multi-value extended properties defined for the event. Read-only. Nullable.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @param calendarGroupId key: id of calendarGroup
 @param calendarId key: id of calendar
 @param eventId key: id of event
 @return ApiUsersCalendarGroupsCalendarsEventsListMultiValueExtendedPropertiesRequest
*/
func (a *UsersCalendarGroupApiService) UsersCalendarGroupsCalendarsEventsListMultiValueExtendedProperties(ctx _context.Context, userId string, calendarGroupId string, calendarId string, eventId string) ApiUsersCalendarGroupsCalendarsEventsListMultiValueExtendedPropertiesRequest {
	return ApiUsersCalendarGroupsCalendarsEventsListMultiValueExtendedPropertiesRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		calendarGroupId: calendarGroupId,
		calendarId: calendarId,
		eventId: eventId,
	}
}

// Execute executes the request
//  @return CollectionOfMultiValueLegacyExtendedProperty
func (a *UsersCalendarGroupApiService) UsersCalendarGroupsCalendarsEventsListMultiValueExtendedPropertiesExecute(r ApiUsersCalendarGroupsCalendarsEventsListMultiValueExtendedPropertiesRequest) (CollectionOfMultiValueLegacyExtendedProperty, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  CollectionOfMultiValueLegacyExtendedProperty
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersCalendarGroupApiService.UsersCalendarGroupsCalendarsEventsListMultiValueExtendedProperties")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/calendarGroups/{calendarGroup-id}/calendars/{calendar-id}/events/{event-id}/multiValueExtendedProperties"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"calendarGroup-id"+"}", _neturl.PathEscape(parameterToString(r.calendarGroupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"calendar-id"+"}", _neturl.PathEscape(parameterToString(r.calendarId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.top != nil {
		localVarQueryParams.Add("$top", parameterToString(*r.top, ""))
	}
	if r.skip != nil {
		localVarQueryParams.Add("$skip", parameterToString(*r.skip, ""))
	}
	if r.search != nil {
		localVarQueryParams.Add("$search", parameterToString(*r.search, ""))
	}
	if r.filter != nil {
		localVarQueryParams.Add("$filter", parameterToString(*r.filter, ""))
	}
	if r.count != nil {
		localVarQueryParams.Add("$count", parameterToString(*r.count, ""))
	}
	if r.orderby != nil {
		localVarQueryParams.Add("$orderby", parameterToString(*r.orderby, "csv"))
	}
	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUsersCalendarGroupsCalendarsEventsListSingleValueExtendedPropertiesRequest struct {
	ctx _context.Context
	ApiService *UsersCalendarGroupApiService
	userId string
	calendarGroupId string
	calendarId string
	eventId string
	top *int32
	skip *int32
	search *string
	filter *string
	count *bool
	orderby *[]string
	select_ *[]string
	expand *[]string
}

// Show only the first n items
func (r ApiUsersCalendarGroupsCalendarsEventsListSingleValueExtendedPropertiesRequest) Top(top int32) ApiUsersCalendarGroupsCalendarsEventsListSingleValueExtendedPropertiesRequest {
	r.top = &top
	return r
}
// Skip the first n items
func (r ApiUsersCalendarGroupsCalendarsEventsListSingleValueExtendedPropertiesRequest) Skip(skip int32) ApiUsersCalendarGroupsCalendarsEventsListSingleValueExtendedPropertiesRequest {
	r.skip = &skip
	return r
}
// Search items by search phrases
func (r ApiUsersCalendarGroupsCalendarsEventsListSingleValueExtendedPropertiesRequest) Search(search string) ApiUsersCalendarGroupsCalendarsEventsListSingleValueExtendedPropertiesRequest {
	r.search = &search
	return r
}
// Filter items by property values
func (r ApiUsersCalendarGroupsCalendarsEventsListSingleValueExtendedPropertiesRequest) Filter(filter string) ApiUsersCalendarGroupsCalendarsEventsListSingleValueExtendedPropertiesRequest {
	r.filter = &filter
	return r
}
// Include count of items
func (r ApiUsersCalendarGroupsCalendarsEventsListSingleValueExtendedPropertiesRequest) Count(count bool) ApiUsersCalendarGroupsCalendarsEventsListSingleValueExtendedPropertiesRequest {
	r.count = &count
	return r
}
// Order items by property values
func (r ApiUsersCalendarGroupsCalendarsEventsListSingleValueExtendedPropertiesRequest) Orderby(orderby []string) ApiUsersCalendarGroupsCalendarsEventsListSingleValueExtendedPropertiesRequest {
	r.orderby = &orderby
	return r
}
// Select properties to be returned
func (r ApiUsersCalendarGroupsCalendarsEventsListSingleValueExtendedPropertiesRequest) Select_(select_ []string) ApiUsersCalendarGroupsCalendarsEventsListSingleValueExtendedPropertiesRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiUsersCalendarGroupsCalendarsEventsListSingleValueExtendedPropertiesRequest) Expand(expand []string) ApiUsersCalendarGroupsCalendarsEventsListSingleValueExtendedPropertiesRequest {
	r.expand = &expand
	return r
}

func (r ApiUsersCalendarGroupsCalendarsEventsListSingleValueExtendedPropertiesRequest) Execute() (CollectionOfSingleValueLegacyExtendedProperty, *_nethttp.Response, error) {
	return r.ApiService.UsersCalendarGroupsCalendarsEventsListSingleValueExtendedPropertiesExecute(r)
}

/*
UsersCalendarGroupsCalendarsEventsListSingleValueExtendedProperties Get singleValueExtendedProperties from users

The collection of single-value extended properties defined for the event. Read-only. Nullable.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @param calendarGroupId key: id of calendarGroup
 @param calendarId key: id of calendar
 @param eventId key: id of event
 @return ApiUsersCalendarGroupsCalendarsEventsListSingleValueExtendedPropertiesRequest
*/
func (a *UsersCalendarGroupApiService) UsersCalendarGroupsCalendarsEventsListSingleValueExtendedProperties(ctx _context.Context, userId string, calendarGroupId string, calendarId string, eventId string) ApiUsersCalendarGroupsCalendarsEventsListSingleValueExtendedPropertiesRequest {
	return ApiUsersCalendarGroupsCalendarsEventsListSingleValueExtendedPropertiesRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		calendarGroupId: calendarGroupId,
		calendarId: calendarId,
		eventId: eventId,
	}
}

// Execute executes the request
//  @return CollectionOfSingleValueLegacyExtendedProperty
func (a *UsersCalendarGroupApiService) UsersCalendarGroupsCalendarsEventsListSingleValueExtendedPropertiesExecute(r ApiUsersCalendarGroupsCalendarsEventsListSingleValueExtendedPropertiesRequest) (CollectionOfSingleValueLegacyExtendedProperty, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  CollectionOfSingleValueLegacyExtendedProperty
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersCalendarGroupApiService.UsersCalendarGroupsCalendarsEventsListSingleValueExtendedProperties")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/calendarGroups/{calendarGroup-id}/calendars/{calendar-id}/events/{event-id}/singleValueExtendedProperties"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"calendarGroup-id"+"}", _neturl.PathEscape(parameterToString(r.calendarGroupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"calendar-id"+"}", _neturl.PathEscape(parameterToString(r.calendarId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.top != nil {
		localVarQueryParams.Add("$top", parameterToString(*r.top, ""))
	}
	if r.skip != nil {
		localVarQueryParams.Add("$skip", parameterToString(*r.skip, ""))
	}
	if r.search != nil {
		localVarQueryParams.Add("$search", parameterToString(*r.search, ""))
	}
	if r.filter != nil {
		localVarQueryParams.Add("$filter", parameterToString(*r.filter, ""))
	}
	if r.count != nil {
		localVarQueryParams.Add("$count", parameterToString(*r.count, ""))
	}
	if r.orderby != nil {
		localVarQueryParams.Add("$orderby", parameterToString(*r.orderby, "csv"))
	}
	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUsersCalendarGroupsCalendarsEventsUpdateAttachmentsRequest struct {
	ctx _context.Context
	ApiService *UsersCalendarGroupApiService
	userId string
	calendarGroupId string
	calendarId string
	eventId string
	attachmentId string
	microsoftGraphAttachment *MicrosoftGraphAttachment
}

// New navigation property values
func (r ApiUsersCalendarGroupsCalendarsEventsUpdateAttachmentsRequest) MicrosoftGraphAttachment(microsoftGraphAttachment MicrosoftGraphAttachment) ApiUsersCalendarGroupsCalendarsEventsUpdateAttachmentsRequest {
	r.microsoftGraphAttachment = &microsoftGraphAttachment
	return r
}

func (r ApiUsersCalendarGroupsCalendarsEventsUpdateAttachmentsRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.UsersCalendarGroupsCalendarsEventsUpdateAttachmentsExecute(r)
}

/*
UsersCalendarGroupsCalendarsEventsUpdateAttachments Update the navigation property attachments in users

The collection of FileAttachment, ItemAttachment, and referenceAttachment attachments for the event. Navigation property. Read-only. Nullable.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @param calendarGroupId key: id of calendarGroup
 @param calendarId key: id of calendar
 @param eventId key: id of event
 @param attachmentId key: id of attachment
 @return ApiUsersCalendarGroupsCalendarsEventsUpdateAttachmentsRequest
*/
func (a *UsersCalendarGroupApiService) UsersCalendarGroupsCalendarsEventsUpdateAttachments(ctx _context.Context, userId string, calendarGroupId string, calendarId string, eventId string, attachmentId string) ApiUsersCalendarGroupsCalendarsEventsUpdateAttachmentsRequest {
	return ApiUsersCalendarGroupsCalendarsEventsUpdateAttachmentsRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		calendarGroupId: calendarGroupId,
		calendarId: calendarId,
		eventId: eventId,
		attachmentId: attachmentId,
	}
}

// Execute executes the request
func (a *UsersCalendarGroupApiService) UsersCalendarGroupsCalendarsEventsUpdateAttachmentsExecute(r ApiUsersCalendarGroupsCalendarsEventsUpdateAttachmentsRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPatch
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersCalendarGroupApiService.UsersCalendarGroupsCalendarsEventsUpdateAttachments")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/calendarGroups/{calendarGroup-id}/calendars/{calendar-id}/events/{event-id}/attachments/{attachment-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"calendarGroup-id"+"}", _neturl.PathEscape(parameterToString(r.calendarGroupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"calendar-id"+"}", _neturl.PathEscape(parameterToString(r.calendarId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"attachment-id"+"}", _neturl.PathEscape(parameterToString(r.attachmentId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphAttachment == nil {
		return nil, reportError("microsoftGraphAttachment is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphAttachment
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUsersCalendarGroupsCalendarsEventsUpdateCalendarRequest struct {
	ctx _context.Context
	ApiService *UsersCalendarGroupApiService
	userId string
	calendarGroupId string
	calendarId string
	eventId string
	microsoftGraphCalendar *MicrosoftGraphCalendar
}

// New navigation property values
func (r ApiUsersCalendarGroupsCalendarsEventsUpdateCalendarRequest) MicrosoftGraphCalendar(microsoftGraphCalendar MicrosoftGraphCalendar) ApiUsersCalendarGroupsCalendarsEventsUpdateCalendarRequest {
	r.microsoftGraphCalendar = &microsoftGraphCalendar
	return r
}

func (r ApiUsersCalendarGroupsCalendarsEventsUpdateCalendarRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.UsersCalendarGroupsCalendarsEventsUpdateCalendarExecute(r)
}

/*
UsersCalendarGroupsCalendarsEventsUpdateCalendar Update the navigation property calendar in users

The calendar that contains the event. Navigation property. Read-only.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @param calendarGroupId key: id of calendarGroup
 @param calendarId key: id of calendar
 @param eventId key: id of event
 @return ApiUsersCalendarGroupsCalendarsEventsUpdateCalendarRequest
*/
func (a *UsersCalendarGroupApiService) UsersCalendarGroupsCalendarsEventsUpdateCalendar(ctx _context.Context, userId string, calendarGroupId string, calendarId string, eventId string) ApiUsersCalendarGroupsCalendarsEventsUpdateCalendarRequest {
	return ApiUsersCalendarGroupsCalendarsEventsUpdateCalendarRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		calendarGroupId: calendarGroupId,
		calendarId: calendarId,
		eventId: eventId,
	}
}

// Execute executes the request
func (a *UsersCalendarGroupApiService) UsersCalendarGroupsCalendarsEventsUpdateCalendarExecute(r ApiUsersCalendarGroupsCalendarsEventsUpdateCalendarRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPatch
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersCalendarGroupApiService.UsersCalendarGroupsCalendarsEventsUpdateCalendar")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/calendarGroups/{calendarGroup-id}/calendars/{calendar-id}/events/{event-id}/calendar"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"calendarGroup-id"+"}", _neturl.PathEscape(parameterToString(r.calendarGroupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"calendar-id"+"}", _neturl.PathEscape(parameterToString(r.calendarId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphCalendar == nil {
		return nil, reportError("microsoftGraphCalendar is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphCalendar
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUsersCalendarGroupsCalendarsEventsUpdateExtensionsRequest struct {
	ctx _context.Context
	ApiService *UsersCalendarGroupApiService
	userId string
	calendarGroupId string
	calendarId string
	eventId string
	extensionId string
	microsoftGraphExtension *MicrosoftGraphExtension
}

// New navigation property values
func (r ApiUsersCalendarGroupsCalendarsEventsUpdateExtensionsRequest) MicrosoftGraphExtension(microsoftGraphExtension MicrosoftGraphExtension) ApiUsersCalendarGroupsCalendarsEventsUpdateExtensionsRequest {
	r.microsoftGraphExtension = &microsoftGraphExtension
	return r
}

func (r ApiUsersCalendarGroupsCalendarsEventsUpdateExtensionsRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.UsersCalendarGroupsCalendarsEventsUpdateExtensionsExecute(r)
}

/*
UsersCalendarGroupsCalendarsEventsUpdateExtensions Update the navigation property extensions in users

The collection of open extensions defined for the event. Nullable.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @param calendarGroupId key: id of calendarGroup
 @param calendarId key: id of calendar
 @param eventId key: id of event
 @param extensionId key: id of extension
 @return ApiUsersCalendarGroupsCalendarsEventsUpdateExtensionsRequest
*/
func (a *UsersCalendarGroupApiService) UsersCalendarGroupsCalendarsEventsUpdateExtensions(ctx _context.Context, userId string, calendarGroupId string, calendarId string, eventId string, extensionId string) ApiUsersCalendarGroupsCalendarsEventsUpdateExtensionsRequest {
	return ApiUsersCalendarGroupsCalendarsEventsUpdateExtensionsRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		calendarGroupId: calendarGroupId,
		calendarId: calendarId,
		eventId: eventId,
		extensionId: extensionId,
	}
}

// Execute executes the request
func (a *UsersCalendarGroupApiService) UsersCalendarGroupsCalendarsEventsUpdateExtensionsExecute(r ApiUsersCalendarGroupsCalendarsEventsUpdateExtensionsRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPatch
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersCalendarGroupApiService.UsersCalendarGroupsCalendarsEventsUpdateExtensions")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/calendarGroups/{calendarGroup-id}/calendars/{calendar-id}/events/{event-id}/extensions/{extension-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"calendarGroup-id"+"}", _neturl.PathEscape(parameterToString(r.calendarGroupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"calendar-id"+"}", _neturl.PathEscape(parameterToString(r.calendarId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"extension-id"+"}", _neturl.PathEscape(parameterToString(r.extensionId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphExtension == nil {
		return nil, reportError("microsoftGraphExtension is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphExtension
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUsersCalendarGroupsCalendarsEventsUpdateInstancesRequest struct {
	ctx _context.Context
	ApiService *UsersCalendarGroupApiService
	userId string
	calendarGroupId string
	calendarId string
	eventId string
	eventId1 string
	microsoftGraphEvent *MicrosoftGraphEvent
}

// New navigation property values
func (r ApiUsersCalendarGroupsCalendarsEventsUpdateInstancesRequest) MicrosoftGraphEvent(microsoftGraphEvent MicrosoftGraphEvent) ApiUsersCalendarGroupsCalendarsEventsUpdateInstancesRequest {
	r.microsoftGraphEvent = &microsoftGraphEvent
	return r
}

func (r ApiUsersCalendarGroupsCalendarsEventsUpdateInstancesRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.UsersCalendarGroupsCalendarsEventsUpdateInstancesExecute(r)
}

/*
UsersCalendarGroupsCalendarsEventsUpdateInstances Update the navigation property instances in users

The occurrences of a recurring series, if the event is a series master. This property includes occurrences that are part of the recurrence pattern, and exceptions that have been modified, but does not include occurrences that have been cancelled from the series. Navigation property. Read-only. Nullable.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @param calendarGroupId key: id of calendarGroup
 @param calendarId key: id of calendar
 @param eventId key: id of event
 @param eventId1 key: id of event
 @return ApiUsersCalendarGroupsCalendarsEventsUpdateInstancesRequest
*/
func (a *UsersCalendarGroupApiService) UsersCalendarGroupsCalendarsEventsUpdateInstances(ctx _context.Context, userId string, calendarGroupId string, calendarId string, eventId string, eventId1 string) ApiUsersCalendarGroupsCalendarsEventsUpdateInstancesRequest {
	return ApiUsersCalendarGroupsCalendarsEventsUpdateInstancesRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		calendarGroupId: calendarGroupId,
		calendarId: calendarId,
		eventId: eventId,
		eventId1: eventId1,
	}
}

// Execute executes the request
func (a *UsersCalendarGroupApiService) UsersCalendarGroupsCalendarsEventsUpdateInstancesExecute(r ApiUsersCalendarGroupsCalendarsEventsUpdateInstancesRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPatch
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersCalendarGroupApiService.UsersCalendarGroupsCalendarsEventsUpdateInstances")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/calendarGroups/{calendarGroup-id}/calendars/{calendar-id}/events/{event-id}/instances/{event-id1}"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"calendarGroup-id"+"}", _neturl.PathEscape(parameterToString(r.calendarGroupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"calendar-id"+"}", _neturl.PathEscape(parameterToString(r.calendarId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id1"+"}", _neturl.PathEscape(parameterToString(r.eventId1, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphEvent == nil {
		return nil, reportError("microsoftGraphEvent is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphEvent
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUsersCalendarGroupsCalendarsEventsUpdateMultiValueExtendedPropertiesRequest struct {
	ctx _context.Context
	ApiService *UsersCalendarGroupApiService
	userId string
	calendarGroupId string
	calendarId string
	eventId string
	multiValueLegacyExtendedPropertyId string
	microsoftGraphMultiValueLegacyExtendedProperty *MicrosoftGraphMultiValueLegacyExtendedProperty
}

// New navigation property values
func (r ApiUsersCalendarGroupsCalendarsEventsUpdateMultiValueExtendedPropertiesRequest) MicrosoftGraphMultiValueLegacyExtendedProperty(microsoftGraphMultiValueLegacyExtendedProperty MicrosoftGraphMultiValueLegacyExtendedProperty) ApiUsersCalendarGroupsCalendarsEventsUpdateMultiValueExtendedPropertiesRequest {
	r.microsoftGraphMultiValueLegacyExtendedProperty = &microsoftGraphMultiValueLegacyExtendedProperty
	return r
}

func (r ApiUsersCalendarGroupsCalendarsEventsUpdateMultiValueExtendedPropertiesRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.UsersCalendarGroupsCalendarsEventsUpdateMultiValueExtendedPropertiesExecute(r)
}

/*
UsersCalendarGroupsCalendarsEventsUpdateMultiValueExtendedProperties Update the navigation property multiValueExtendedProperties in users

The collection of multi-value extended properties defined for the event. Read-only. Nullable.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @param calendarGroupId key: id of calendarGroup
 @param calendarId key: id of calendar
 @param eventId key: id of event
 @param multiValueLegacyExtendedPropertyId key: id of multiValueLegacyExtendedProperty
 @return ApiUsersCalendarGroupsCalendarsEventsUpdateMultiValueExtendedPropertiesRequest
*/
func (a *UsersCalendarGroupApiService) UsersCalendarGroupsCalendarsEventsUpdateMultiValueExtendedProperties(ctx _context.Context, userId string, calendarGroupId string, calendarId string, eventId string, multiValueLegacyExtendedPropertyId string) ApiUsersCalendarGroupsCalendarsEventsUpdateMultiValueExtendedPropertiesRequest {
	return ApiUsersCalendarGroupsCalendarsEventsUpdateMultiValueExtendedPropertiesRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		calendarGroupId: calendarGroupId,
		calendarId: calendarId,
		eventId: eventId,
		multiValueLegacyExtendedPropertyId: multiValueLegacyExtendedPropertyId,
	}
}

// Execute executes the request
func (a *UsersCalendarGroupApiService) UsersCalendarGroupsCalendarsEventsUpdateMultiValueExtendedPropertiesExecute(r ApiUsersCalendarGroupsCalendarsEventsUpdateMultiValueExtendedPropertiesRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPatch
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersCalendarGroupApiService.UsersCalendarGroupsCalendarsEventsUpdateMultiValueExtendedProperties")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/calendarGroups/{calendarGroup-id}/calendars/{calendar-id}/events/{event-id}/multiValueExtendedProperties/{multiValueLegacyExtendedProperty-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"calendarGroup-id"+"}", _neturl.PathEscape(parameterToString(r.calendarGroupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"calendar-id"+"}", _neturl.PathEscape(parameterToString(r.calendarId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"multiValueLegacyExtendedProperty-id"+"}", _neturl.PathEscape(parameterToString(r.multiValueLegacyExtendedPropertyId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphMultiValueLegacyExtendedProperty == nil {
		return nil, reportError("microsoftGraphMultiValueLegacyExtendedProperty is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphMultiValueLegacyExtendedProperty
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUsersCalendarGroupsCalendarsEventsUpdateSingleValueExtendedPropertiesRequest struct {
	ctx _context.Context
	ApiService *UsersCalendarGroupApiService
	userId string
	calendarGroupId string
	calendarId string
	eventId string
	singleValueLegacyExtendedPropertyId string
	microsoftGraphSingleValueLegacyExtendedProperty *MicrosoftGraphSingleValueLegacyExtendedProperty
}

// New navigation property values
func (r ApiUsersCalendarGroupsCalendarsEventsUpdateSingleValueExtendedPropertiesRequest) MicrosoftGraphSingleValueLegacyExtendedProperty(microsoftGraphSingleValueLegacyExtendedProperty MicrosoftGraphSingleValueLegacyExtendedProperty) ApiUsersCalendarGroupsCalendarsEventsUpdateSingleValueExtendedPropertiesRequest {
	r.microsoftGraphSingleValueLegacyExtendedProperty = &microsoftGraphSingleValueLegacyExtendedProperty
	return r
}

func (r ApiUsersCalendarGroupsCalendarsEventsUpdateSingleValueExtendedPropertiesRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.UsersCalendarGroupsCalendarsEventsUpdateSingleValueExtendedPropertiesExecute(r)
}

/*
UsersCalendarGroupsCalendarsEventsUpdateSingleValueExtendedProperties Update the navigation property singleValueExtendedProperties in users

The collection of single-value extended properties defined for the event. Read-only. Nullable.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @param calendarGroupId key: id of calendarGroup
 @param calendarId key: id of calendar
 @param eventId key: id of event
 @param singleValueLegacyExtendedPropertyId key: id of singleValueLegacyExtendedProperty
 @return ApiUsersCalendarGroupsCalendarsEventsUpdateSingleValueExtendedPropertiesRequest
*/
func (a *UsersCalendarGroupApiService) UsersCalendarGroupsCalendarsEventsUpdateSingleValueExtendedProperties(ctx _context.Context, userId string, calendarGroupId string, calendarId string, eventId string, singleValueLegacyExtendedPropertyId string) ApiUsersCalendarGroupsCalendarsEventsUpdateSingleValueExtendedPropertiesRequest {
	return ApiUsersCalendarGroupsCalendarsEventsUpdateSingleValueExtendedPropertiesRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		calendarGroupId: calendarGroupId,
		calendarId: calendarId,
		eventId: eventId,
		singleValueLegacyExtendedPropertyId: singleValueLegacyExtendedPropertyId,
	}
}

// Execute executes the request
func (a *UsersCalendarGroupApiService) UsersCalendarGroupsCalendarsEventsUpdateSingleValueExtendedPropertiesExecute(r ApiUsersCalendarGroupsCalendarsEventsUpdateSingleValueExtendedPropertiesRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPatch
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersCalendarGroupApiService.UsersCalendarGroupsCalendarsEventsUpdateSingleValueExtendedProperties")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/calendarGroups/{calendarGroup-id}/calendars/{calendar-id}/events/{event-id}/singleValueExtendedProperties/{singleValueLegacyExtendedProperty-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"calendarGroup-id"+"}", _neturl.PathEscape(parameterToString(r.calendarGroupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"calendar-id"+"}", _neturl.PathEscape(parameterToString(r.calendarId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"singleValueLegacyExtendedProperty-id"+"}", _neturl.PathEscape(parameterToString(r.singleValueLegacyExtendedPropertyId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphSingleValueLegacyExtendedProperty == nil {
		return nil, reportError("microsoftGraphSingleValueLegacyExtendedProperty is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphSingleValueLegacyExtendedProperty
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUsersCalendarGroupsCalendarsGetCalendarPermissionsRequest struct {
	ctx _context.Context
	ApiService *UsersCalendarGroupApiService
	userId string
	calendarGroupId string
	calendarId string
	calendarPermissionId string
	select_ *[]string
}

// Select properties to be returned
func (r ApiUsersCalendarGroupsCalendarsGetCalendarPermissionsRequest) Select_(select_ []string) ApiUsersCalendarGroupsCalendarsGetCalendarPermissionsRequest {
	r.select_ = &select_
	return r
}

func (r ApiUsersCalendarGroupsCalendarsGetCalendarPermissionsRequest) Execute() (MicrosoftGraphCalendarPermission, *_nethttp.Response, error) {
	return r.ApiService.UsersCalendarGroupsCalendarsGetCalendarPermissionsExecute(r)
}

/*
UsersCalendarGroupsCalendarsGetCalendarPermissions Get calendarPermissions from users

The permissions of the users with whom the calendar is shared.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @param calendarGroupId key: id of calendarGroup
 @param calendarId key: id of calendar
 @param calendarPermissionId key: id of calendarPermission
 @return ApiUsersCalendarGroupsCalendarsGetCalendarPermissionsRequest
*/
func (a *UsersCalendarGroupApiService) UsersCalendarGroupsCalendarsGetCalendarPermissions(ctx _context.Context, userId string, calendarGroupId string, calendarId string, calendarPermissionId string) ApiUsersCalendarGroupsCalendarsGetCalendarPermissionsRequest {
	return ApiUsersCalendarGroupsCalendarsGetCalendarPermissionsRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		calendarGroupId: calendarGroupId,
		calendarId: calendarId,
		calendarPermissionId: calendarPermissionId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphCalendarPermission
func (a *UsersCalendarGroupApiService) UsersCalendarGroupsCalendarsGetCalendarPermissionsExecute(r ApiUsersCalendarGroupsCalendarsGetCalendarPermissionsRequest) (MicrosoftGraphCalendarPermission, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphCalendarPermission
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersCalendarGroupApiService.UsersCalendarGroupsCalendarsGetCalendarPermissions")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/calendarGroups/{calendarGroup-id}/calendars/{calendar-id}/calendarPermissions/{calendarPermission-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"calendarGroup-id"+"}", _neturl.PathEscape(parameterToString(r.calendarGroupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"calendar-id"+"}", _neturl.PathEscape(parameterToString(r.calendarId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"calendarPermission-id"+"}", _neturl.PathEscape(parameterToString(r.calendarPermissionId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUsersCalendarGroupsCalendarsGetCalendarViewRequest struct {
	ctx _context.Context
	ApiService *UsersCalendarGroupApiService
	userId string
	calendarGroupId string
	calendarId string
	eventId string
	select_ *[]string
}

// Select properties to be returned
func (r ApiUsersCalendarGroupsCalendarsGetCalendarViewRequest) Select_(select_ []string) ApiUsersCalendarGroupsCalendarsGetCalendarViewRequest {
	r.select_ = &select_
	return r
}

func (r ApiUsersCalendarGroupsCalendarsGetCalendarViewRequest) Execute() (MicrosoftGraphEvent, *_nethttp.Response, error) {
	return r.ApiService.UsersCalendarGroupsCalendarsGetCalendarViewExecute(r)
}

/*
UsersCalendarGroupsCalendarsGetCalendarView Get calendarView from users

The calendar view for the calendar. Navigation property. Read-only.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @param calendarGroupId key: id of calendarGroup
 @param calendarId key: id of calendar
 @param eventId key: id of event
 @return ApiUsersCalendarGroupsCalendarsGetCalendarViewRequest
*/
func (a *UsersCalendarGroupApiService) UsersCalendarGroupsCalendarsGetCalendarView(ctx _context.Context, userId string, calendarGroupId string, calendarId string, eventId string) ApiUsersCalendarGroupsCalendarsGetCalendarViewRequest {
	return ApiUsersCalendarGroupsCalendarsGetCalendarViewRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		calendarGroupId: calendarGroupId,
		calendarId: calendarId,
		eventId: eventId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphEvent
func (a *UsersCalendarGroupApiService) UsersCalendarGroupsCalendarsGetCalendarViewExecute(r ApiUsersCalendarGroupsCalendarsGetCalendarViewRequest) (MicrosoftGraphEvent, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphEvent
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersCalendarGroupApiService.UsersCalendarGroupsCalendarsGetCalendarView")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/calendarGroups/{calendarGroup-id}/calendars/{calendar-id}/calendarView/{event-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"calendarGroup-id"+"}", _neturl.PathEscape(parameterToString(r.calendarGroupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"calendar-id"+"}", _neturl.PathEscape(parameterToString(r.calendarId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUsersCalendarGroupsCalendarsGetEventsRequest struct {
	ctx _context.Context
	ApiService *UsersCalendarGroupApiService
	userId string
	calendarGroupId string
	calendarId string
	eventId string
	select_ *[]string
}

// Select properties to be returned
func (r ApiUsersCalendarGroupsCalendarsGetEventsRequest) Select_(select_ []string) ApiUsersCalendarGroupsCalendarsGetEventsRequest {
	r.select_ = &select_
	return r
}

func (r ApiUsersCalendarGroupsCalendarsGetEventsRequest) Execute() (MicrosoftGraphEvent, *_nethttp.Response, error) {
	return r.ApiService.UsersCalendarGroupsCalendarsGetEventsExecute(r)
}

/*
UsersCalendarGroupsCalendarsGetEvents Get events from users

The events in the calendar. Navigation property. Read-only.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @param calendarGroupId key: id of calendarGroup
 @param calendarId key: id of calendar
 @param eventId key: id of event
 @return ApiUsersCalendarGroupsCalendarsGetEventsRequest
*/
func (a *UsersCalendarGroupApiService) UsersCalendarGroupsCalendarsGetEvents(ctx _context.Context, userId string, calendarGroupId string, calendarId string, eventId string) ApiUsersCalendarGroupsCalendarsGetEventsRequest {
	return ApiUsersCalendarGroupsCalendarsGetEventsRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		calendarGroupId: calendarGroupId,
		calendarId: calendarId,
		eventId: eventId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphEvent
func (a *UsersCalendarGroupApiService) UsersCalendarGroupsCalendarsGetEventsExecute(r ApiUsersCalendarGroupsCalendarsGetEventsRequest) (MicrosoftGraphEvent, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphEvent
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersCalendarGroupApiService.UsersCalendarGroupsCalendarsGetEvents")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/calendarGroups/{calendarGroup-id}/calendars/{calendar-id}/events/{event-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"calendarGroup-id"+"}", _neturl.PathEscape(parameterToString(r.calendarGroupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"calendar-id"+"}", _neturl.PathEscape(parameterToString(r.calendarId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUsersCalendarGroupsCalendarsGetMultiValueExtendedPropertiesRequest struct {
	ctx _context.Context
	ApiService *UsersCalendarGroupApiService
	userId string
	calendarGroupId string
	calendarId string
	multiValueLegacyExtendedPropertyId string
	select_ *[]string
	expand *[]string
}

// Select properties to be returned
func (r ApiUsersCalendarGroupsCalendarsGetMultiValueExtendedPropertiesRequest) Select_(select_ []string) ApiUsersCalendarGroupsCalendarsGetMultiValueExtendedPropertiesRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiUsersCalendarGroupsCalendarsGetMultiValueExtendedPropertiesRequest) Expand(expand []string) ApiUsersCalendarGroupsCalendarsGetMultiValueExtendedPropertiesRequest {
	r.expand = &expand
	return r
}

func (r ApiUsersCalendarGroupsCalendarsGetMultiValueExtendedPropertiesRequest) Execute() (MicrosoftGraphMultiValueLegacyExtendedProperty, *_nethttp.Response, error) {
	return r.ApiService.UsersCalendarGroupsCalendarsGetMultiValueExtendedPropertiesExecute(r)
}

/*
UsersCalendarGroupsCalendarsGetMultiValueExtendedProperties Get multiValueExtendedProperties from users

The collection of multi-value extended properties defined for the calendar. Read-only. Nullable.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @param calendarGroupId key: id of calendarGroup
 @param calendarId key: id of calendar
 @param multiValueLegacyExtendedPropertyId key: id of multiValueLegacyExtendedProperty
 @return ApiUsersCalendarGroupsCalendarsGetMultiValueExtendedPropertiesRequest
*/
func (a *UsersCalendarGroupApiService) UsersCalendarGroupsCalendarsGetMultiValueExtendedProperties(ctx _context.Context, userId string, calendarGroupId string, calendarId string, multiValueLegacyExtendedPropertyId string) ApiUsersCalendarGroupsCalendarsGetMultiValueExtendedPropertiesRequest {
	return ApiUsersCalendarGroupsCalendarsGetMultiValueExtendedPropertiesRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		calendarGroupId: calendarGroupId,
		calendarId: calendarId,
		multiValueLegacyExtendedPropertyId: multiValueLegacyExtendedPropertyId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphMultiValueLegacyExtendedProperty
func (a *UsersCalendarGroupApiService) UsersCalendarGroupsCalendarsGetMultiValueExtendedPropertiesExecute(r ApiUsersCalendarGroupsCalendarsGetMultiValueExtendedPropertiesRequest) (MicrosoftGraphMultiValueLegacyExtendedProperty, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphMultiValueLegacyExtendedProperty
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersCalendarGroupApiService.UsersCalendarGroupsCalendarsGetMultiValueExtendedProperties")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/calendarGroups/{calendarGroup-id}/calendars/{calendar-id}/multiValueExtendedProperties/{multiValueLegacyExtendedProperty-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"calendarGroup-id"+"}", _neturl.PathEscape(parameterToString(r.calendarGroupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"calendar-id"+"}", _neturl.PathEscape(parameterToString(r.calendarId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"multiValueLegacyExtendedProperty-id"+"}", _neturl.PathEscape(parameterToString(r.multiValueLegacyExtendedPropertyId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUsersCalendarGroupsCalendarsGetSingleValueExtendedPropertiesRequest struct {
	ctx _context.Context
	ApiService *UsersCalendarGroupApiService
	userId string
	calendarGroupId string
	calendarId string
	singleValueLegacyExtendedPropertyId string
	select_ *[]string
	expand *[]string
}

// Select properties to be returned
func (r ApiUsersCalendarGroupsCalendarsGetSingleValueExtendedPropertiesRequest) Select_(select_ []string) ApiUsersCalendarGroupsCalendarsGetSingleValueExtendedPropertiesRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiUsersCalendarGroupsCalendarsGetSingleValueExtendedPropertiesRequest) Expand(expand []string) ApiUsersCalendarGroupsCalendarsGetSingleValueExtendedPropertiesRequest {
	r.expand = &expand
	return r
}

func (r ApiUsersCalendarGroupsCalendarsGetSingleValueExtendedPropertiesRequest) Execute() (MicrosoftGraphSingleValueLegacyExtendedProperty, *_nethttp.Response, error) {
	return r.ApiService.UsersCalendarGroupsCalendarsGetSingleValueExtendedPropertiesExecute(r)
}

/*
UsersCalendarGroupsCalendarsGetSingleValueExtendedProperties Get singleValueExtendedProperties from users

The collection of single-value extended properties defined for the calendar. Read-only. Nullable.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @param calendarGroupId key: id of calendarGroup
 @param calendarId key: id of calendar
 @param singleValueLegacyExtendedPropertyId key: id of singleValueLegacyExtendedProperty
 @return ApiUsersCalendarGroupsCalendarsGetSingleValueExtendedPropertiesRequest
*/
func (a *UsersCalendarGroupApiService) UsersCalendarGroupsCalendarsGetSingleValueExtendedProperties(ctx _context.Context, userId string, calendarGroupId string, calendarId string, singleValueLegacyExtendedPropertyId string) ApiUsersCalendarGroupsCalendarsGetSingleValueExtendedPropertiesRequest {
	return ApiUsersCalendarGroupsCalendarsGetSingleValueExtendedPropertiesRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		calendarGroupId: calendarGroupId,
		calendarId: calendarId,
		singleValueLegacyExtendedPropertyId: singleValueLegacyExtendedPropertyId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphSingleValueLegacyExtendedProperty
func (a *UsersCalendarGroupApiService) UsersCalendarGroupsCalendarsGetSingleValueExtendedPropertiesExecute(r ApiUsersCalendarGroupsCalendarsGetSingleValueExtendedPropertiesRequest) (MicrosoftGraphSingleValueLegacyExtendedProperty, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphSingleValueLegacyExtendedProperty
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersCalendarGroupApiService.UsersCalendarGroupsCalendarsGetSingleValueExtendedProperties")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/calendarGroups/{calendarGroup-id}/calendars/{calendar-id}/singleValueExtendedProperties/{singleValueLegacyExtendedProperty-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"calendarGroup-id"+"}", _neturl.PathEscape(parameterToString(r.calendarGroupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"calendar-id"+"}", _neturl.PathEscape(parameterToString(r.calendarId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"singleValueLegacyExtendedProperty-id"+"}", _neturl.PathEscape(parameterToString(r.singleValueLegacyExtendedPropertyId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUsersCalendarGroupsCalendarsListCalendarPermissionsRequest struct {
	ctx _context.Context
	ApiService *UsersCalendarGroupApiService
	userId string
	calendarGroupId string
	calendarId string
	top *int32
	skip *int32
	filter *string
	count *bool
	orderby *[]string
	select_ *[]string
}

// Show only the first n items
func (r ApiUsersCalendarGroupsCalendarsListCalendarPermissionsRequest) Top(top int32) ApiUsersCalendarGroupsCalendarsListCalendarPermissionsRequest {
	r.top = &top
	return r
}
// Skip the first n items
func (r ApiUsersCalendarGroupsCalendarsListCalendarPermissionsRequest) Skip(skip int32) ApiUsersCalendarGroupsCalendarsListCalendarPermissionsRequest {
	r.skip = &skip
	return r
}
// Filter items by property values
func (r ApiUsersCalendarGroupsCalendarsListCalendarPermissionsRequest) Filter(filter string) ApiUsersCalendarGroupsCalendarsListCalendarPermissionsRequest {
	r.filter = &filter
	return r
}
// Include count of items
func (r ApiUsersCalendarGroupsCalendarsListCalendarPermissionsRequest) Count(count bool) ApiUsersCalendarGroupsCalendarsListCalendarPermissionsRequest {
	r.count = &count
	return r
}
// Order items by property values
func (r ApiUsersCalendarGroupsCalendarsListCalendarPermissionsRequest) Orderby(orderby []string) ApiUsersCalendarGroupsCalendarsListCalendarPermissionsRequest {
	r.orderby = &orderby
	return r
}
// Select properties to be returned
func (r ApiUsersCalendarGroupsCalendarsListCalendarPermissionsRequest) Select_(select_ []string) ApiUsersCalendarGroupsCalendarsListCalendarPermissionsRequest {
	r.select_ = &select_
	return r
}

func (r ApiUsersCalendarGroupsCalendarsListCalendarPermissionsRequest) Execute() (CollectionOfCalendarPermission, *_nethttp.Response, error) {
	return r.ApiService.UsersCalendarGroupsCalendarsListCalendarPermissionsExecute(r)
}

/*
UsersCalendarGroupsCalendarsListCalendarPermissions Get calendarPermissions from users

The permissions of the users with whom the calendar is shared.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @param calendarGroupId key: id of calendarGroup
 @param calendarId key: id of calendar
 @return ApiUsersCalendarGroupsCalendarsListCalendarPermissionsRequest
*/
func (a *UsersCalendarGroupApiService) UsersCalendarGroupsCalendarsListCalendarPermissions(ctx _context.Context, userId string, calendarGroupId string, calendarId string) ApiUsersCalendarGroupsCalendarsListCalendarPermissionsRequest {
	return ApiUsersCalendarGroupsCalendarsListCalendarPermissionsRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		calendarGroupId: calendarGroupId,
		calendarId: calendarId,
	}
}

// Execute executes the request
//  @return CollectionOfCalendarPermission
func (a *UsersCalendarGroupApiService) UsersCalendarGroupsCalendarsListCalendarPermissionsExecute(r ApiUsersCalendarGroupsCalendarsListCalendarPermissionsRequest) (CollectionOfCalendarPermission, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  CollectionOfCalendarPermission
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersCalendarGroupApiService.UsersCalendarGroupsCalendarsListCalendarPermissions")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/calendarGroups/{calendarGroup-id}/calendars/{calendar-id}/calendarPermissions"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"calendarGroup-id"+"}", _neturl.PathEscape(parameterToString(r.calendarGroupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"calendar-id"+"}", _neturl.PathEscape(parameterToString(r.calendarId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.top != nil {
		localVarQueryParams.Add("$top", parameterToString(*r.top, ""))
	}
	if r.skip != nil {
		localVarQueryParams.Add("$skip", parameterToString(*r.skip, ""))
	}
	if r.filter != nil {
		localVarQueryParams.Add("$filter", parameterToString(*r.filter, ""))
	}
	if r.count != nil {
		localVarQueryParams.Add("$count", parameterToString(*r.count, ""))
	}
	if r.orderby != nil {
		localVarQueryParams.Add("$orderby", parameterToString(*r.orderby, "csv"))
	}
	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUsersCalendarGroupsCalendarsListCalendarViewRequest struct {
	ctx _context.Context
	ApiService *UsersCalendarGroupApiService
	userId string
	calendarGroupId string
	calendarId string
	top *int32
	skip *int32
	filter *string
	count *bool
	orderby *[]string
	select_ *[]string
}

// Show only the first n items
func (r ApiUsersCalendarGroupsCalendarsListCalendarViewRequest) Top(top int32) ApiUsersCalendarGroupsCalendarsListCalendarViewRequest {
	r.top = &top
	return r
}
// Skip the first n items
func (r ApiUsersCalendarGroupsCalendarsListCalendarViewRequest) Skip(skip int32) ApiUsersCalendarGroupsCalendarsListCalendarViewRequest {
	r.skip = &skip
	return r
}
// Filter items by property values
func (r ApiUsersCalendarGroupsCalendarsListCalendarViewRequest) Filter(filter string) ApiUsersCalendarGroupsCalendarsListCalendarViewRequest {
	r.filter = &filter
	return r
}
// Include count of items
func (r ApiUsersCalendarGroupsCalendarsListCalendarViewRequest) Count(count bool) ApiUsersCalendarGroupsCalendarsListCalendarViewRequest {
	r.count = &count
	return r
}
// Order items by property values
func (r ApiUsersCalendarGroupsCalendarsListCalendarViewRequest) Orderby(orderby []string) ApiUsersCalendarGroupsCalendarsListCalendarViewRequest {
	r.orderby = &orderby
	return r
}
// Select properties to be returned
func (r ApiUsersCalendarGroupsCalendarsListCalendarViewRequest) Select_(select_ []string) ApiUsersCalendarGroupsCalendarsListCalendarViewRequest {
	r.select_ = &select_
	return r
}

func (r ApiUsersCalendarGroupsCalendarsListCalendarViewRequest) Execute() (CollectionOfEvent, *_nethttp.Response, error) {
	return r.ApiService.UsersCalendarGroupsCalendarsListCalendarViewExecute(r)
}

/*
UsersCalendarGroupsCalendarsListCalendarView Get calendarView from users

The calendar view for the calendar. Navigation property. Read-only.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @param calendarGroupId key: id of calendarGroup
 @param calendarId key: id of calendar
 @return ApiUsersCalendarGroupsCalendarsListCalendarViewRequest
*/
func (a *UsersCalendarGroupApiService) UsersCalendarGroupsCalendarsListCalendarView(ctx _context.Context, userId string, calendarGroupId string, calendarId string) ApiUsersCalendarGroupsCalendarsListCalendarViewRequest {
	return ApiUsersCalendarGroupsCalendarsListCalendarViewRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		calendarGroupId: calendarGroupId,
		calendarId: calendarId,
	}
}

// Execute executes the request
//  @return CollectionOfEvent
func (a *UsersCalendarGroupApiService) UsersCalendarGroupsCalendarsListCalendarViewExecute(r ApiUsersCalendarGroupsCalendarsListCalendarViewRequest) (CollectionOfEvent, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  CollectionOfEvent
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersCalendarGroupApiService.UsersCalendarGroupsCalendarsListCalendarView")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/calendarGroups/{calendarGroup-id}/calendars/{calendar-id}/calendarView"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"calendarGroup-id"+"}", _neturl.PathEscape(parameterToString(r.calendarGroupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"calendar-id"+"}", _neturl.PathEscape(parameterToString(r.calendarId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.top != nil {
		localVarQueryParams.Add("$top", parameterToString(*r.top, ""))
	}
	if r.skip != nil {
		localVarQueryParams.Add("$skip", parameterToString(*r.skip, ""))
	}
	if r.filter != nil {
		localVarQueryParams.Add("$filter", parameterToString(*r.filter, ""))
	}
	if r.count != nil {
		localVarQueryParams.Add("$count", parameterToString(*r.count, ""))
	}
	if r.orderby != nil {
		localVarQueryParams.Add("$orderby", parameterToString(*r.orderby, "csv"))
	}
	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUsersCalendarGroupsCalendarsListEventsRequest struct {
	ctx _context.Context
	ApiService *UsersCalendarGroupApiService
	userId string
	calendarGroupId string
	calendarId string
	top *int32
	skip *int32
	filter *string
	count *bool
	orderby *[]string
	select_ *[]string
}

// Show only the first n items
func (r ApiUsersCalendarGroupsCalendarsListEventsRequest) Top(top int32) ApiUsersCalendarGroupsCalendarsListEventsRequest {
	r.top = &top
	return r
}
// Skip the first n items
func (r ApiUsersCalendarGroupsCalendarsListEventsRequest) Skip(skip int32) ApiUsersCalendarGroupsCalendarsListEventsRequest {
	r.skip = &skip
	return r
}
// Filter items by property values
func (r ApiUsersCalendarGroupsCalendarsListEventsRequest) Filter(filter string) ApiUsersCalendarGroupsCalendarsListEventsRequest {
	r.filter = &filter
	return r
}
// Include count of items
func (r ApiUsersCalendarGroupsCalendarsListEventsRequest) Count(count bool) ApiUsersCalendarGroupsCalendarsListEventsRequest {
	r.count = &count
	return r
}
// Order items by property values
func (r ApiUsersCalendarGroupsCalendarsListEventsRequest) Orderby(orderby []string) ApiUsersCalendarGroupsCalendarsListEventsRequest {
	r.orderby = &orderby
	return r
}
// Select properties to be returned
func (r ApiUsersCalendarGroupsCalendarsListEventsRequest) Select_(select_ []string) ApiUsersCalendarGroupsCalendarsListEventsRequest {
	r.select_ = &select_
	return r
}

func (r ApiUsersCalendarGroupsCalendarsListEventsRequest) Execute() (CollectionOfEvent, *_nethttp.Response, error) {
	return r.ApiService.UsersCalendarGroupsCalendarsListEventsExecute(r)
}

/*
UsersCalendarGroupsCalendarsListEvents Get events from users

The events in the calendar. Navigation property. Read-only.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @param calendarGroupId key: id of calendarGroup
 @param calendarId key: id of calendar
 @return ApiUsersCalendarGroupsCalendarsListEventsRequest
*/
func (a *UsersCalendarGroupApiService) UsersCalendarGroupsCalendarsListEvents(ctx _context.Context, userId string, calendarGroupId string, calendarId string) ApiUsersCalendarGroupsCalendarsListEventsRequest {
	return ApiUsersCalendarGroupsCalendarsListEventsRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		calendarGroupId: calendarGroupId,
		calendarId: calendarId,
	}
}

// Execute executes the request
//  @return CollectionOfEvent
func (a *UsersCalendarGroupApiService) UsersCalendarGroupsCalendarsListEventsExecute(r ApiUsersCalendarGroupsCalendarsListEventsRequest) (CollectionOfEvent, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  CollectionOfEvent
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersCalendarGroupApiService.UsersCalendarGroupsCalendarsListEvents")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/calendarGroups/{calendarGroup-id}/calendars/{calendar-id}/events"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"calendarGroup-id"+"}", _neturl.PathEscape(parameterToString(r.calendarGroupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"calendar-id"+"}", _neturl.PathEscape(parameterToString(r.calendarId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.top != nil {
		localVarQueryParams.Add("$top", parameterToString(*r.top, ""))
	}
	if r.skip != nil {
		localVarQueryParams.Add("$skip", parameterToString(*r.skip, ""))
	}
	if r.filter != nil {
		localVarQueryParams.Add("$filter", parameterToString(*r.filter, ""))
	}
	if r.count != nil {
		localVarQueryParams.Add("$count", parameterToString(*r.count, ""))
	}
	if r.orderby != nil {
		localVarQueryParams.Add("$orderby", parameterToString(*r.orderby, "csv"))
	}
	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUsersCalendarGroupsCalendarsListMultiValueExtendedPropertiesRequest struct {
	ctx _context.Context
	ApiService *UsersCalendarGroupApiService
	userId string
	calendarGroupId string
	calendarId string
	top *int32
	skip *int32
	search *string
	filter *string
	count *bool
	orderby *[]string
	select_ *[]string
	expand *[]string
}

// Show only the first n items
func (r ApiUsersCalendarGroupsCalendarsListMultiValueExtendedPropertiesRequest) Top(top int32) ApiUsersCalendarGroupsCalendarsListMultiValueExtendedPropertiesRequest {
	r.top = &top
	return r
}
// Skip the first n items
func (r ApiUsersCalendarGroupsCalendarsListMultiValueExtendedPropertiesRequest) Skip(skip int32) ApiUsersCalendarGroupsCalendarsListMultiValueExtendedPropertiesRequest {
	r.skip = &skip
	return r
}
// Search items by search phrases
func (r ApiUsersCalendarGroupsCalendarsListMultiValueExtendedPropertiesRequest) Search(search string) ApiUsersCalendarGroupsCalendarsListMultiValueExtendedPropertiesRequest {
	r.search = &search
	return r
}
// Filter items by property values
func (r ApiUsersCalendarGroupsCalendarsListMultiValueExtendedPropertiesRequest) Filter(filter string) ApiUsersCalendarGroupsCalendarsListMultiValueExtendedPropertiesRequest {
	r.filter = &filter
	return r
}
// Include count of items
func (r ApiUsersCalendarGroupsCalendarsListMultiValueExtendedPropertiesRequest) Count(count bool) ApiUsersCalendarGroupsCalendarsListMultiValueExtendedPropertiesRequest {
	r.count = &count
	return r
}
// Order items by property values
func (r ApiUsersCalendarGroupsCalendarsListMultiValueExtendedPropertiesRequest) Orderby(orderby []string) ApiUsersCalendarGroupsCalendarsListMultiValueExtendedPropertiesRequest {
	r.orderby = &orderby
	return r
}
// Select properties to be returned
func (r ApiUsersCalendarGroupsCalendarsListMultiValueExtendedPropertiesRequest) Select_(select_ []string) ApiUsersCalendarGroupsCalendarsListMultiValueExtendedPropertiesRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiUsersCalendarGroupsCalendarsListMultiValueExtendedPropertiesRequest) Expand(expand []string) ApiUsersCalendarGroupsCalendarsListMultiValueExtendedPropertiesRequest {
	r.expand = &expand
	return r
}

func (r ApiUsersCalendarGroupsCalendarsListMultiValueExtendedPropertiesRequest) Execute() (CollectionOfMultiValueLegacyExtendedProperty, *_nethttp.Response, error) {
	return r.ApiService.UsersCalendarGroupsCalendarsListMultiValueExtendedPropertiesExecute(r)
}

/*
UsersCalendarGroupsCalendarsListMultiValueExtendedProperties Get multiValueExtendedProperties from users

The collection of multi-value extended properties defined for the calendar. Read-only. Nullable.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @param calendarGroupId key: id of calendarGroup
 @param calendarId key: id of calendar
 @return ApiUsersCalendarGroupsCalendarsListMultiValueExtendedPropertiesRequest
*/
func (a *UsersCalendarGroupApiService) UsersCalendarGroupsCalendarsListMultiValueExtendedProperties(ctx _context.Context, userId string, calendarGroupId string, calendarId string) ApiUsersCalendarGroupsCalendarsListMultiValueExtendedPropertiesRequest {
	return ApiUsersCalendarGroupsCalendarsListMultiValueExtendedPropertiesRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		calendarGroupId: calendarGroupId,
		calendarId: calendarId,
	}
}

// Execute executes the request
//  @return CollectionOfMultiValueLegacyExtendedProperty
func (a *UsersCalendarGroupApiService) UsersCalendarGroupsCalendarsListMultiValueExtendedPropertiesExecute(r ApiUsersCalendarGroupsCalendarsListMultiValueExtendedPropertiesRequest) (CollectionOfMultiValueLegacyExtendedProperty, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  CollectionOfMultiValueLegacyExtendedProperty
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersCalendarGroupApiService.UsersCalendarGroupsCalendarsListMultiValueExtendedProperties")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/calendarGroups/{calendarGroup-id}/calendars/{calendar-id}/multiValueExtendedProperties"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"calendarGroup-id"+"}", _neturl.PathEscape(parameterToString(r.calendarGroupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"calendar-id"+"}", _neturl.PathEscape(parameterToString(r.calendarId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.top != nil {
		localVarQueryParams.Add("$top", parameterToString(*r.top, ""))
	}
	if r.skip != nil {
		localVarQueryParams.Add("$skip", parameterToString(*r.skip, ""))
	}
	if r.search != nil {
		localVarQueryParams.Add("$search", parameterToString(*r.search, ""))
	}
	if r.filter != nil {
		localVarQueryParams.Add("$filter", parameterToString(*r.filter, ""))
	}
	if r.count != nil {
		localVarQueryParams.Add("$count", parameterToString(*r.count, ""))
	}
	if r.orderby != nil {
		localVarQueryParams.Add("$orderby", parameterToString(*r.orderby, "csv"))
	}
	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUsersCalendarGroupsCalendarsListSingleValueExtendedPropertiesRequest struct {
	ctx _context.Context
	ApiService *UsersCalendarGroupApiService
	userId string
	calendarGroupId string
	calendarId string
	top *int32
	skip *int32
	search *string
	filter *string
	count *bool
	orderby *[]string
	select_ *[]string
	expand *[]string
}

// Show only the first n items
func (r ApiUsersCalendarGroupsCalendarsListSingleValueExtendedPropertiesRequest) Top(top int32) ApiUsersCalendarGroupsCalendarsListSingleValueExtendedPropertiesRequest {
	r.top = &top
	return r
}
// Skip the first n items
func (r ApiUsersCalendarGroupsCalendarsListSingleValueExtendedPropertiesRequest) Skip(skip int32) ApiUsersCalendarGroupsCalendarsListSingleValueExtendedPropertiesRequest {
	r.skip = &skip
	return r
}
// Search items by search phrases
func (r ApiUsersCalendarGroupsCalendarsListSingleValueExtendedPropertiesRequest) Search(search string) ApiUsersCalendarGroupsCalendarsListSingleValueExtendedPropertiesRequest {
	r.search = &search
	return r
}
// Filter items by property values
func (r ApiUsersCalendarGroupsCalendarsListSingleValueExtendedPropertiesRequest) Filter(filter string) ApiUsersCalendarGroupsCalendarsListSingleValueExtendedPropertiesRequest {
	r.filter = &filter
	return r
}
// Include count of items
func (r ApiUsersCalendarGroupsCalendarsListSingleValueExtendedPropertiesRequest) Count(count bool) ApiUsersCalendarGroupsCalendarsListSingleValueExtendedPropertiesRequest {
	r.count = &count
	return r
}
// Order items by property values
func (r ApiUsersCalendarGroupsCalendarsListSingleValueExtendedPropertiesRequest) Orderby(orderby []string) ApiUsersCalendarGroupsCalendarsListSingleValueExtendedPropertiesRequest {
	r.orderby = &orderby
	return r
}
// Select properties to be returned
func (r ApiUsersCalendarGroupsCalendarsListSingleValueExtendedPropertiesRequest) Select_(select_ []string) ApiUsersCalendarGroupsCalendarsListSingleValueExtendedPropertiesRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiUsersCalendarGroupsCalendarsListSingleValueExtendedPropertiesRequest) Expand(expand []string) ApiUsersCalendarGroupsCalendarsListSingleValueExtendedPropertiesRequest {
	r.expand = &expand
	return r
}

func (r ApiUsersCalendarGroupsCalendarsListSingleValueExtendedPropertiesRequest) Execute() (CollectionOfSingleValueLegacyExtendedProperty, *_nethttp.Response, error) {
	return r.ApiService.UsersCalendarGroupsCalendarsListSingleValueExtendedPropertiesExecute(r)
}

/*
UsersCalendarGroupsCalendarsListSingleValueExtendedProperties Get singleValueExtendedProperties from users

The collection of single-value extended properties defined for the calendar. Read-only. Nullable.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @param calendarGroupId key: id of calendarGroup
 @param calendarId key: id of calendar
 @return ApiUsersCalendarGroupsCalendarsListSingleValueExtendedPropertiesRequest
*/
func (a *UsersCalendarGroupApiService) UsersCalendarGroupsCalendarsListSingleValueExtendedProperties(ctx _context.Context, userId string, calendarGroupId string, calendarId string) ApiUsersCalendarGroupsCalendarsListSingleValueExtendedPropertiesRequest {
	return ApiUsersCalendarGroupsCalendarsListSingleValueExtendedPropertiesRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		calendarGroupId: calendarGroupId,
		calendarId: calendarId,
	}
}

// Execute executes the request
//  @return CollectionOfSingleValueLegacyExtendedProperty
func (a *UsersCalendarGroupApiService) UsersCalendarGroupsCalendarsListSingleValueExtendedPropertiesExecute(r ApiUsersCalendarGroupsCalendarsListSingleValueExtendedPropertiesRequest) (CollectionOfSingleValueLegacyExtendedProperty, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  CollectionOfSingleValueLegacyExtendedProperty
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersCalendarGroupApiService.UsersCalendarGroupsCalendarsListSingleValueExtendedProperties")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/calendarGroups/{calendarGroup-id}/calendars/{calendar-id}/singleValueExtendedProperties"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"calendarGroup-id"+"}", _neturl.PathEscape(parameterToString(r.calendarGroupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"calendar-id"+"}", _neturl.PathEscape(parameterToString(r.calendarId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.top != nil {
		localVarQueryParams.Add("$top", parameterToString(*r.top, ""))
	}
	if r.skip != nil {
		localVarQueryParams.Add("$skip", parameterToString(*r.skip, ""))
	}
	if r.search != nil {
		localVarQueryParams.Add("$search", parameterToString(*r.search, ""))
	}
	if r.filter != nil {
		localVarQueryParams.Add("$filter", parameterToString(*r.filter, ""))
	}
	if r.count != nil {
		localVarQueryParams.Add("$count", parameterToString(*r.count, ""))
	}
	if r.orderby != nil {
		localVarQueryParams.Add("$orderby", parameterToString(*r.orderby, "csv"))
	}
	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUsersCalendarGroupsCalendarsUpdateCalendarPermissionsRequest struct {
	ctx _context.Context
	ApiService *UsersCalendarGroupApiService
	userId string
	calendarGroupId string
	calendarId string
	calendarPermissionId string
	microsoftGraphCalendarPermission *MicrosoftGraphCalendarPermission
}

// New navigation property values
func (r ApiUsersCalendarGroupsCalendarsUpdateCalendarPermissionsRequest) MicrosoftGraphCalendarPermission(microsoftGraphCalendarPermission MicrosoftGraphCalendarPermission) ApiUsersCalendarGroupsCalendarsUpdateCalendarPermissionsRequest {
	r.microsoftGraphCalendarPermission = &microsoftGraphCalendarPermission
	return r
}

func (r ApiUsersCalendarGroupsCalendarsUpdateCalendarPermissionsRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.UsersCalendarGroupsCalendarsUpdateCalendarPermissionsExecute(r)
}

/*
UsersCalendarGroupsCalendarsUpdateCalendarPermissions Update the navigation property calendarPermissions in users

The permissions of the users with whom the calendar is shared.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @param calendarGroupId key: id of calendarGroup
 @param calendarId key: id of calendar
 @param calendarPermissionId key: id of calendarPermission
 @return ApiUsersCalendarGroupsCalendarsUpdateCalendarPermissionsRequest
*/
func (a *UsersCalendarGroupApiService) UsersCalendarGroupsCalendarsUpdateCalendarPermissions(ctx _context.Context, userId string, calendarGroupId string, calendarId string, calendarPermissionId string) ApiUsersCalendarGroupsCalendarsUpdateCalendarPermissionsRequest {
	return ApiUsersCalendarGroupsCalendarsUpdateCalendarPermissionsRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		calendarGroupId: calendarGroupId,
		calendarId: calendarId,
		calendarPermissionId: calendarPermissionId,
	}
}

// Execute executes the request
func (a *UsersCalendarGroupApiService) UsersCalendarGroupsCalendarsUpdateCalendarPermissionsExecute(r ApiUsersCalendarGroupsCalendarsUpdateCalendarPermissionsRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPatch
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersCalendarGroupApiService.UsersCalendarGroupsCalendarsUpdateCalendarPermissions")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/calendarGroups/{calendarGroup-id}/calendars/{calendar-id}/calendarPermissions/{calendarPermission-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"calendarGroup-id"+"}", _neturl.PathEscape(parameterToString(r.calendarGroupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"calendar-id"+"}", _neturl.PathEscape(parameterToString(r.calendarId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"calendarPermission-id"+"}", _neturl.PathEscape(parameterToString(r.calendarPermissionId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphCalendarPermission == nil {
		return nil, reportError("microsoftGraphCalendarPermission is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphCalendarPermission
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUsersCalendarGroupsCalendarsUpdateCalendarViewRequest struct {
	ctx _context.Context
	ApiService *UsersCalendarGroupApiService
	userId string
	calendarGroupId string
	calendarId string
	eventId string
	microsoftGraphEvent *MicrosoftGraphEvent
}

// New navigation property values
func (r ApiUsersCalendarGroupsCalendarsUpdateCalendarViewRequest) MicrosoftGraphEvent(microsoftGraphEvent MicrosoftGraphEvent) ApiUsersCalendarGroupsCalendarsUpdateCalendarViewRequest {
	r.microsoftGraphEvent = &microsoftGraphEvent
	return r
}

func (r ApiUsersCalendarGroupsCalendarsUpdateCalendarViewRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.UsersCalendarGroupsCalendarsUpdateCalendarViewExecute(r)
}

/*
UsersCalendarGroupsCalendarsUpdateCalendarView Update the navigation property calendarView in users

The calendar view for the calendar. Navigation property. Read-only.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @param calendarGroupId key: id of calendarGroup
 @param calendarId key: id of calendar
 @param eventId key: id of event
 @return ApiUsersCalendarGroupsCalendarsUpdateCalendarViewRequest
*/
func (a *UsersCalendarGroupApiService) UsersCalendarGroupsCalendarsUpdateCalendarView(ctx _context.Context, userId string, calendarGroupId string, calendarId string, eventId string) ApiUsersCalendarGroupsCalendarsUpdateCalendarViewRequest {
	return ApiUsersCalendarGroupsCalendarsUpdateCalendarViewRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		calendarGroupId: calendarGroupId,
		calendarId: calendarId,
		eventId: eventId,
	}
}

// Execute executes the request
func (a *UsersCalendarGroupApiService) UsersCalendarGroupsCalendarsUpdateCalendarViewExecute(r ApiUsersCalendarGroupsCalendarsUpdateCalendarViewRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPatch
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersCalendarGroupApiService.UsersCalendarGroupsCalendarsUpdateCalendarView")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/calendarGroups/{calendarGroup-id}/calendars/{calendar-id}/calendarView/{event-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"calendarGroup-id"+"}", _neturl.PathEscape(parameterToString(r.calendarGroupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"calendar-id"+"}", _neturl.PathEscape(parameterToString(r.calendarId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphEvent == nil {
		return nil, reportError("microsoftGraphEvent is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphEvent
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUsersCalendarGroupsCalendarsUpdateEventsRequest struct {
	ctx _context.Context
	ApiService *UsersCalendarGroupApiService
	userId string
	calendarGroupId string
	calendarId string
	eventId string
	microsoftGraphEvent *MicrosoftGraphEvent
}

// New navigation property values
func (r ApiUsersCalendarGroupsCalendarsUpdateEventsRequest) MicrosoftGraphEvent(microsoftGraphEvent MicrosoftGraphEvent) ApiUsersCalendarGroupsCalendarsUpdateEventsRequest {
	r.microsoftGraphEvent = &microsoftGraphEvent
	return r
}

func (r ApiUsersCalendarGroupsCalendarsUpdateEventsRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.UsersCalendarGroupsCalendarsUpdateEventsExecute(r)
}

/*
UsersCalendarGroupsCalendarsUpdateEvents Update the navigation property events in users

The events in the calendar. Navigation property. Read-only.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @param calendarGroupId key: id of calendarGroup
 @param calendarId key: id of calendar
 @param eventId key: id of event
 @return ApiUsersCalendarGroupsCalendarsUpdateEventsRequest
*/
func (a *UsersCalendarGroupApiService) UsersCalendarGroupsCalendarsUpdateEvents(ctx _context.Context, userId string, calendarGroupId string, calendarId string, eventId string) ApiUsersCalendarGroupsCalendarsUpdateEventsRequest {
	return ApiUsersCalendarGroupsCalendarsUpdateEventsRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		calendarGroupId: calendarGroupId,
		calendarId: calendarId,
		eventId: eventId,
	}
}

// Execute executes the request
func (a *UsersCalendarGroupApiService) UsersCalendarGroupsCalendarsUpdateEventsExecute(r ApiUsersCalendarGroupsCalendarsUpdateEventsRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPatch
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersCalendarGroupApiService.UsersCalendarGroupsCalendarsUpdateEvents")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/calendarGroups/{calendarGroup-id}/calendars/{calendar-id}/events/{event-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"calendarGroup-id"+"}", _neturl.PathEscape(parameterToString(r.calendarGroupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"calendar-id"+"}", _neturl.PathEscape(parameterToString(r.calendarId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphEvent == nil {
		return nil, reportError("microsoftGraphEvent is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphEvent
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUsersCalendarGroupsCalendarsUpdateMultiValueExtendedPropertiesRequest struct {
	ctx _context.Context
	ApiService *UsersCalendarGroupApiService
	userId string
	calendarGroupId string
	calendarId string
	multiValueLegacyExtendedPropertyId string
	microsoftGraphMultiValueLegacyExtendedProperty *MicrosoftGraphMultiValueLegacyExtendedProperty
}

// New navigation property values
func (r ApiUsersCalendarGroupsCalendarsUpdateMultiValueExtendedPropertiesRequest) MicrosoftGraphMultiValueLegacyExtendedProperty(microsoftGraphMultiValueLegacyExtendedProperty MicrosoftGraphMultiValueLegacyExtendedProperty) ApiUsersCalendarGroupsCalendarsUpdateMultiValueExtendedPropertiesRequest {
	r.microsoftGraphMultiValueLegacyExtendedProperty = &microsoftGraphMultiValueLegacyExtendedProperty
	return r
}

func (r ApiUsersCalendarGroupsCalendarsUpdateMultiValueExtendedPropertiesRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.UsersCalendarGroupsCalendarsUpdateMultiValueExtendedPropertiesExecute(r)
}

/*
UsersCalendarGroupsCalendarsUpdateMultiValueExtendedProperties Update the navigation property multiValueExtendedProperties in users

The collection of multi-value extended properties defined for the calendar. Read-only. Nullable.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @param calendarGroupId key: id of calendarGroup
 @param calendarId key: id of calendar
 @param multiValueLegacyExtendedPropertyId key: id of multiValueLegacyExtendedProperty
 @return ApiUsersCalendarGroupsCalendarsUpdateMultiValueExtendedPropertiesRequest
*/
func (a *UsersCalendarGroupApiService) UsersCalendarGroupsCalendarsUpdateMultiValueExtendedProperties(ctx _context.Context, userId string, calendarGroupId string, calendarId string, multiValueLegacyExtendedPropertyId string) ApiUsersCalendarGroupsCalendarsUpdateMultiValueExtendedPropertiesRequest {
	return ApiUsersCalendarGroupsCalendarsUpdateMultiValueExtendedPropertiesRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		calendarGroupId: calendarGroupId,
		calendarId: calendarId,
		multiValueLegacyExtendedPropertyId: multiValueLegacyExtendedPropertyId,
	}
}

// Execute executes the request
func (a *UsersCalendarGroupApiService) UsersCalendarGroupsCalendarsUpdateMultiValueExtendedPropertiesExecute(r ApiUsersCalendarGroupsCalendarsUpdateMultiValueExtendedPropertiesRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPatch
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersCalendarGroupApiService.UsersCalendarGroupsCalendarsUpdateMultiValueExtendedProperties")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/calendarGroups/{calendarGroup-id}/calendars/{calendar-id}/multiValueExtendedProperties/{multiValueLegacyExtendedProperty-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"calendarGroup-id"+"}", _neturl.PathEscape(parameterToString(r.calendarGroupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"calendar-id"+"}", _neturl.PathEscape(parameterToString(r.calendarId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"multiValueLegacyExtendedProperty-id"+"}", _neturl.PathEscape(parameterToString(r.multiValueLegacyExtendedPropertyId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphMultiValueLegacyExtendedProperty == nil {
		return nil, reportError("microsoftGraphMultiValueLegacyExtendedProperty is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphMultiValueLegacyExtendedProperty
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUsersCalendarGroupsCalendarsUpdateSingleValueExtendedPropertiesRequest struct {
	ctx _context.Context
	ApiService *UsersCalendarGroupApiService
	userId string
	calendarGroupId string
	calendarId string
	singleValueLegacyExtendedPropertyId string
	microsoftGraphSingleValueLegacyExtendedProperty *MicrosoftGraphSingleValueLegacyExtendedProperty
}

// New navigation property values
func (r ApiUsersCalendarGroupsCalendarsUpdateSingleValueExtendedPropertiesRequest) MicrosoftGraphSingleValueLegacyExtendedProperty(microsoftGraphSingleValueLegacyExtendedProperty MicrosoftGraphSingleValueLegacyExtendedProperty) ApiUsersCalendarGroupsCalendarsUpdateSingleValueExtendedPropertiesRequest {
	r.microsoftGraphSingleValueLegacyExtendedProperty = &microsoftGraphSingleValueLegacyExtendedProperty
	return r
}

func (r ApiUsersCalendarGroupsCalendarsUpdateSingleValueExtendedPropertiesRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.UsersCalendarGroupsCalendarsUpdateSingleValueExtendedPropertiesExecute(r)
}

/*
UsersCalendarGroupsCalendarsUpdateSingleValueExtendedProperties Update the navigation property singleValueExtendedProperties in users

The collection of single-value extended properties defined for the calendar. Read-only. Nullable.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @param calendarGroupId key: id of calendarGroup
 @param calendarId key: id of calendar
 @param singleValueLegacyExtendedPropertyId key: id of singleValueLegacyExtendedProperty
 @return ApiUsersCalendarGroupsCalendarsUpdateSingleValueExtendedPropertiesRequest
*/
func (a *UsersCalendarGroupApiService) UsersCalendarGroupsCalendarsUpdateSingleValueExtendedProperties(ctx _context.Context, userId string, calendarGroupId string, calendarId string, singleValueLegacyExtendedPropertyId string) ApiUsersCalendarGroupsCalendarsUpdateSingleValueExtendedPropertiesRequest {
	return ApiUsersCalendarGroupsCalendarsUpdateSingleValueExtendedPropertiesRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		calendarGroupId: calendarGroupId,
		calendarId: calendarId,
		singleValueLegacyExtendedPropertyId: singleValueLegacyExtendedPropertyId,
	}
}

// Execute executes the request
func (a *UsersCalendarGroupApiService) UsersCalendarGroupsCalendarsUpdateSingleValueExtendedPropertiesExecute(r ApiUsersCalendarGroupsCalendarsUpdateSingleValueExtendedPropertiesRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPatch
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersCalendarGroupApiService.UsersCalendarGroupsCalendarsUpdateSingleValueExtendedProperties")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/calendarGroups/{calendarGroup-id}/calendars/{calendar-id}/singleValueExtendedProperties/{singleValueLegacyExtendedProperty-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"calendarGroup-id"+"}", _neturl.PathEscape(parameterToString(r.calendarGroupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"calendar-id"+"}", _neturl.PathEscape(parameterToString(r.calendarId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"singleValueLegacyExtendedProperty-id"+"}", _neturl.PathEscape(parameterToString(r.singleValueLegacyExtendedPropertyId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphSingleValueLegacyExtendedProperty == nil {
		return nil, reportError("microsoftGraphSingleValueLegacyExtendedProperty is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphSingleValueLegacyExtendedProperty
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUsersCalendarGroupsCreateCalendarsRequest struct {
	ctx _context.Context
	ApiService *UsersCalendarGroupApiService
	userId string
	calendarGroupId string
	microsoftGraphCalendar *MicrosoftGraphCalendar
}

// New navigation property
func (r ApiUsersCalendarGroupsCreateCalendarsRequest) MicrosoftGraphCalendar(microsoftGraphCalendar MicrosoftGraphCalendar) ApiUsersCalendarGroupsCreateCalendarsRequest {
	r.microsoftGraphCalendar = &microsoftGraphCalendar
	return r
}

func (r ApiUsersCalendarGroupsCreateCalendarsRequest) Execute() (MicrosoftGraphCalendar, *_nethttp.Response, error) {
	return r.ApiService.UsersCalendarGroupsCreateCalendarsExecute(r)
}

/*
UsersCalendarGroupsCreateCalendars Create new navigation property to calendars for users

The calendars in the calendar group. Navigation property. Read-only. Nullable.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @param calendarGroupId key: id of calendarGroup
 @return ApiUsersCalendarGroupsCreateCalendarsRequest
*/
func (a *UsersCalendarGroupApiService) UsersCalendarGroupsCreateCalendars(ctx _context.Context, userId string, calendarGroupId string) ApiUsersCalendarGroupsCreateCalendarsRequest {
	return ApiUsersCalendarGroupsCreateCalendarsRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		calendarGroupId: calendarGroupId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphCalendar
func (a *UsersCalendarGroupApiService) UsersCalendarGroupsCreateCalendarsExecute(r ApiUsersCalendarGroupsCreateCalendarsRequest) (MicrosoftGraphCalendar, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphCalendar
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersCalendarGroupApiService.UsersCalendarGroupsCreateCalendars")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/calendarGroups/{calendarGroup-id}/calendars"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"calendarGroup-id"+"}", _neturl.PathEscape(parameterToString(r.calendarGroupId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphCalendar == nil {
		return localVarReturnValue, nil, reportError("microsoftGraphCalendar is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphCalendar
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUsersCalendarGroupsDeleteCalendarsRequest struct {
	ctx _context.Context
	ApiService *UsersCalendarGroupApiService
	userId string
	calendarGroupId string
	calendarId string
	ifMatch *string
}

// ETag
func (r ApiUsersCalendarGroupsDeleteCalendarsRequest) IfMatch(ifMatch string) ApiUsersCalendarGroupsDeleteCalendarsRequest {
	r.ifMatch = &ifMatch
	return r
}

func (r ApiUsersCalendarGroupsDeleteCalendarsRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.UsersCalendarGroupsDeleteCalendarsExecute(r)
}

/*
UsersCalendarGroupsDeleteCalendars Delete navigation property calendars for users

The calendars in the calendar group. Navigation property. Read-only. Nullable.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @param calendarGroupId key: id of calendarGroup
 @param calendarId key: id of calendar
 @return ApiUsersCalendarGroupsDeleteCalendarsRequest
*/
func (a *UsersCalendarGroupApiService) UsersCalendarGroupsDeleteCalendars(ctx _context.Context, userId string, calendarGroupId string, calendarId string) ApiUsersCalendarGroupsDeleteCalendarsRequest {
	return ApiUsersCalendarGroupsDeleteCalendarsRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		calendarGroupId: calendarGroupId,
		calendarId: calendarId,
	}
}

// Execute executes the request
func (a *UsersCalendarGroupApiService) UsersCalendarGroupsDeleteCalendarsExecute(r ApiUsersCalendarGroupsDeleteCalendarsRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersCalendarGroupApiService.UsersCalendarGroupsDeleteCalendars")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/calendarGroups/{calendarGroup-id}/calendars/{calendar-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"calendarGroup-id"+"}", _neturl.PathEscape(parameterToString(r.calendarGroupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"calendar-id"+"}", _neturl.PathEscape(parameterToString(r.calendarId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ifMatch != nil {
		localVarHeaderParams["If-Match"] = parameterToString(*r.ifMatch, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUsersCalendarGroupsGetCalendarsRequest struct {
	ctx _context.Context
	ApiService *UsersCalendarGroupApiService
	userId string
	calendarGroupId string
	calendarId string
	select_ *[]string
}

// Select properties to be returned
func (r ApiUsersCalendarGroupsGetCalendarsRequest) Select_(select_ []string) ApiUsersCalendarGroupsGetCalendarsRequest {
	r.select_ = &select_
	return r
}

func (r ApiUsersCalendarGroupsGetCalendarsRequest) Execute() (MicrosoftGraphCalendar, *_nethttp.Response, error) {
	return r.ApiService.UsersCalendarGroupsGetCalendarsExecute(r)
}

/*
UsersCalendarGroupsGetCalendars Get calendars from users

The calendars in the calendar group. Navigation property. Read-only. Nullable.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @param calendarGroupId key: id of calendarGroup
 @param calendarId key: id of calendar
 @return ApiUsersCalendarGroupsGetCalendarsRequest
*/
func (a *UsersCalendarGroupApiService) UsersCalendarGroupsGetCalendars(ctx _context.Context, userId string, calendarGroupId string, calendarId string) ApiUsersCalendarGroupsGetCalendarsRequest {
	return ApiUsersCalendarGroupsGetCalendarsRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		calendarGroupId: calendarGroupId,
		calendarId: calendarId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphCalendar
func (a *UsersCalendarGroupApiService) UsersCalendarGroupsGetCalendarsExecute(r ApiUsersCalendarGroupsGetCalendarsRequest) (MicrosoftGraphCalendar, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphCalendar
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersCalendarGroupApiService.UsersCalendarGroupsGetCalendars")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/calendarGroups/{calendarGroup-id}/calendars/{calendar-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"calendarGroup-id"+"}", _neturl.PathEscape(parameterToString(r.calendarGroupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"calendar-id"+"}", _neturl.PathEscape(parameterToString(r.calendarId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUsersCalendarGroupsListCalendarsRequest struct {
	ctx _context.Context
	ApiService *UsersCalendarGroupApiService
	userId string
	calendarGroupId string
	top *int32
	skip *int32
	filter *string
	count *bool
	orderby *[]string
	select_ *[]string
}

// Show only the first n items
func (r ApiUsersCalendarGroupsListCalendarsRequest) Top(top int32) ApiUsersCalendarGroupsListCalendarsRequest {
	r.top = &top
	return r
}
// Skip the first n items
func (r ApiUsersCalendarGroupsListCalendarsRequest) Skip(skip int32) ApiUsersCalendarGroupsListCalendarsRequest {
	r.skip = &skip
	return r
}
// Filter items by property values
func (r ApiUsersCalendarGroupsListCalendarsRequest) Filter(filter string) ApiUsersCalendarGroupsListCalendarsRequest {
	r.filter = &filter
	return r
}
// Include count of items
func (r ApiUsersCalendarGroupsListCalendarsRequest) Count(count bool) ApiUsersCalendarGroupsListCalendarsRequest {
	r.count = &count
	return r
}
// Order items by property values
func (r ApiUsersCalendarGroupsListCalendarsRequest) Orderby(orderby []string) ApiUsersCalendarGroupsListCalendarsRequest {
	r.orderby = &orderby
	return r
}
// Select properties to be returned
func (r ApiUsersCalendarGroupsListCalendarsRequest) Select_(select_ []string) ApiUsersCalendarGroupsListCalendarsRequest {
	r.select_ = &select_
	return r
}

func (r ApiUsersCalendarGroupsListCalendarsRequest) Execute() (CollectionOfCalendar, *_nethttp.Response, error) {
	return r.ApiService.UsersCalendarGroupsListCalendarsExecute(r)
}

/*
UsersCalendarGroupsListCalendars Get calendars from users

The calendars in the calendar group. Navigation property. Read-only. Nullable.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @param calendarGroupId key: id of calendarGroup
 @return ApiUsersCalendarGroupsListCalendarsRequest
*/
func (a *UsersCalendarGroupApiService) UsersCalendarGroupsListCalendars(ctx _context.Context, userId string, calendarGroupId string) ApiUsersCalendarGroupsListCalendarsRequest {
	return ApiUsersCalendarGroupsListCalendarsRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		calendarGroupId: calendarGroupId,
	}
}

// Execute executes the request
//  @return CollectionOfCalendar
func (a *UsersCalendarGroupApiService) UsersCalendarGroupsListCalendarsExecute(r ApiUsersCalendarGroupsListCalendarsRequest) (CollectionOfCalendar, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  CollectionOfCalendar
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersCalendarGroupApiService.UsersCalendarGroupsListCalendars")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/calendarGroups/{calendarGroup-id}/calendars"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"calendarGroup-id"+"}", _neturl.PathEscape(parameterToString(r.calendarGroupId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.top != nil {
		localVarQueryParams.Add("$top", parameterToString(*r.top, ""))
	}
	if r.skip != nil {
		localVarQueryParams.Add("$skip", parameterToString(*r.skip, ""))
	}
	if r.filter != nil {
		localVarQueryParams.Add("$filter", parameterToString(*r.filter, ""))
	}
	if r.count != nil {
		localVarQueryParams.Add("$count", parameterToString(*r.count, ""))
	}
	if r.orderby != nil {
		localVarQueryParams.Add("$orderby", parameterToString(*r.orderby, "csv"))
	}
	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUsersCalendarGroupsUpdateCalendarsRequest struct {
	ctx _context.Context
	ApiService *UsersCalendarGroupApiService
	userId string
	calendarGroupId string
	calendarId string
	microsoftGraphCalendar *MicrosoftGraphCalendar
}

// New navigation property values
func (r ApiUsersCalendarGroupsUpdateCalendarsRequest) MicrosoftGraphCalendar(microsoftGraphCalendar MicrosoftGraphCalendar) ApiUsersCalendarGroupsUpdateCalendarsRequest {
	r.microsoftGraphCalendar = &microsoftGraphCalendar
	return r
}

func (r ApiUsersCalendarGroupsUpdateCalendarsRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.UsersCalendarGroupsUpdateCalendarsExecute(r)
}

/*
UsersCalendarGroupsUpdateCalendars Update the navigation property calendars in users

The calendars in the calendar group. Navigation property. Read-only. Nullable.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @param calendarGroupId key: id of calendarGroup
 @param calendarId key: id of calendar
 @return ApiUsersCalendarGroupsUpdateCalendarsRequest
*/
func (a *UsersCalendarGroupApiService) UsersCalendarGroupsUpdateCalendars(ctx _context.Context, userId string, calendarGroupId string, calendarId string) ApiUsersCalendarGroupsUpdateCalendarsRequest {
	return ApiUsersCalendarGroupsUpdateCalendarsRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		calendarGroupId: calendarGroupId,
		calendarId: calendarId,
	}
}

// Execute executes the request
func (a *UsersCalendarGroupApiService) UsersCalendarGroupsUpdateCalendarsExecute(r ApiUsersCalendarGroupsUpdateCalendarsRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPatch
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersCalendarGroupApiService.UsersCalendarGroupsUpdateCalendars")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/calendarGroups/{calendarGroup-id}/calendars/{calendar-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"calendarGroup-id"+"}", _neturl.PathEscape(parameterToString(r.calendarGroupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"calendar-id"+"}", _neturl.PathEscape(parameterToString(r.calendarId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphCalendar == nil {
		return nil, reportError("microsoftGraphCalendar is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphCalendar
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUsersCreateCalendarGroupsRequest struct {
	ctx _context.Context
	ApiService *UsersCalendarGroupApiService
	userId string
	microsoftGraphCalendarGroup *MicrosoftGraphCalendarGroup
}

// New navigation property
func (r ApiUsersCreateCalendarGroupsRequest) MicrosoftGraphCalendarGroup(microsoftGraphCalendarGroup MicrosoftGraphCalendarGroup) ApiUsersCreateCalendarGroupsRequest {
	r.microsoftGraphCalendarGroup = &microsoftGraphCalendarGroup
	return r
}

func (r ApiUsersCreateCalendarGroupsRequest) Execute() (MicrosoftGraphCalendarGroup, *_nethttp.Response, error) {
	return r.ApiService.UsersCreateCalendarGroupsExecute(r)
}

/*
UsersCreateCalendarGroups Create new navigation property to calendarGroups for users

The user's calendar groups. Read-only. Nullable.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @return ApiUsersCreateCalendarGroupsRequest
*/
func (a *UsersCalendarGroupApiService) UsersCreateCalendarGroups(ctx _context.Context, userId string) ApiUsersCreateCalendarGroupsRequest {
	return ApiUsersCreateCalendarGroupsRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphCalendarGroup
func (a *UsersCalendarGroupApiService) UsersCreateCalendarGroupsExecute(r ApiUsersCreateCalendarGroupsRequest) (MicrosoftGraphCalendarGroup, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphCalendarGroup
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersCalendarGroupApiService.UsersCreateCalendarGroups")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/calendarGroups"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphCalendarGroup == nil {
		return localVarReturnValue, nil, reportError("microsoftGraphCalendarGroup is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphCalendarGroup
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUsersDeleteCalendarGroupsRequest struct {
	ctx _context.Context
	ApiService *UsersCalendarGroupApiService
	userId string
	calendarGroupId string
	ifMatch *string
}

// ETag
func (r ApiUsersDeleteCalendarGroupsRequest) IfMatch(ifMatch string) ApiUsersDeleteCalendarGroupsRequest {
	r.ifMatch = &ifMatch
	return r
}

func (r ApiUsersDeleteCalendarGroupsRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.UsersDeleteCalendarGroupsExecute(r)
}

/*
UsersDeleteCalendarGroups Delete navigation property calendarGroups for users

The user's calendar groups. Read-only. Nullable.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @param calendarGroupId key: id of calendarGroup
 @return ApiUsersDeleteCalendarGroupsRequest
*/
func (a *UsersCalendarGroupApiService) UsersDeleteCalendarGroups(ctx _context.Context, userId string, calendarGroupId string) ApiUsersDeleteCalendarGroupsRequest {
	return ApiUsersDeleteCalendarGroupsRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		calendarGroupId: calendarGroupId,
	}
}

// Execute executes the request
func (a *UsersCalendarGroupApiService) UsersDeleteCalendarGroupsExecute(r ApiUsersDeleteCalendarGroupsRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersCalendarGroupApiService.UsersDeleteCalendarGroups")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/calendarGroups/{calendarGroup-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"calendarGroup-id"+"}", _neturl.PathEscape(parameterToString(r.calendarGroupId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ifMatch != nil {
		localVarHeaderParams["If-Match"] = parameterToString(*r.ifMatch, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUsersGetCalendarGroupsRequest struct {
	ctx _context.Context
	ApiService *UsersCalendarGroupApiService
	userId string
	calendarGroupId string
	select_ *[]string
}

// Select properties to be returned
func (r ApiUsersGetCalendarGroupsRequest) Select_(select_ []string) ApiUsersGetCalendarGroupsRequest {
	r.select_ = &select_
	return r
}

func (r ApiUsersGetCalendarGroupsRequest) Execute() (MicrosoftGraphCalendarGroup, *_nethttp.Response, error) {
	return r.ApiService.UsersGetCalendarGroupsExecute(r)
}

/*
UsersGetCalendarGroups Get calendarGroups from users

The user's calendar groups. Read-only. Nullable.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @param calendarGroupId key: id of calendarGroup
 @return ApiUsersGetCalendarGroupsRequest
*/
func (a *UsersCalendarGroupApiService) UsersGetCalendarGroups(ctx _context.Context, userId string, calendarGroupId string) ApiUsersGetCalendarGroupsRequest {
	return ApiUsersGetCalendarGroupsRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		calendarGroupId: calendarGroupId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphCalendarGroup
func (a *UsersCalendarGroupApiService) UsersGetCalendarGroupsExecute(r ApiUsersGetCalendarGroupsRequest) (MicrosoftGraphCalendarGroup, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphCalendarGroup
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersCalendarGroupApiService.UsersGetCalendarGroups")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/calendarGroups/{calendarGroup-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"calendarGroup-id"+"}", _neturl.PathEscape(parameterToString(r.calendarGroupId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUsersListCalendarGroupsRequest struct {
	ctx _context.Context
	ApiService *UsersCalendarGroupApiService
	userId string
	top *int32
	skip *int32
	filter *string
	count *bool
	orderby *[]string
	select_ *[]string
}

// Show only the first n items
func (r ApiUsersListCalendarGroupsRequest) Top(top int32) ApiUsersListCalendarGroupsRequest {
	r.top = &top
	return r
}
// Skip the first n items
func (r ApiUsersListCalendarGroupsRequest) Skip(skip int32) ApiUsersListCalendarGroupsRequest {
	r.skip = &skip
	return r
}
// Filter items by property values
func (r ApiUsersListCalendarGroupsRequest) Filter(filter string) ApiUsersListCalendarGroupsRequest {
	r.filter = &filter
	return r
}
// Include count of items
func (r ApiUsersListCalendarGroupsRequest) Count(count bool) ApiUsersListCalendarGroupsRequest {
	r.count = &count
	return r
}
// Order items by property values
func (r ApiUsersListCalendarGroupsRequest) Orderby(orderby []string) ApiUsersListCalendarGroupsRequest {
	r.orderby = &orderby
	return r
}
// Select properties to be returned
func (r ApiUsersListCalendarGroupsRequest) Select_(select_ []string) ApiUsersListCalendarGroupsRequest {
	r.select_ = &select_
	return r
}

func (r ApiUsersListCalendarGroupsRequest) Execute() (CollectionOfCalendarGroup, *_nethttp.Response, error) {
	return r.ApiService.UsersListCalendarGroupsExecute(r)
}

/*
UsersListCalendarGroups Get calendarGroups from users

The user's calendar groups. Read-only. Nullable.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @return ApiUsersListCalendarGroupsRequest
*/
func (a *UsersCalendarGroupApiService) UsersListCalendarGroups(ctx _context.Context, userId string) ApiUsersListCalendarGroupsRequest {
	return ApiUsersListCalendarGroupsRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
	}
}

// Execute executes the request
//  @return CollectionOfCalendarGroup
func (a *UsersCalendarGroupApiService) UsersListCalendarGroupsExecute(r ApiUsersListCalendarGroupsRequest) (CollectionOfCalendarGroup, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  CollectionOfCalendarGroup
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersCalendarGroupApiService.UsersListCalendarGroups")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/calendarGroups"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.top != nil {
		localVarQueryParams.Add("$top", parameterToString(*r.top, ""))
	}
	if r.skip != nil {
		localVarQueryParams.Add("$skip", parameterToString(*r.skip, ""))
	}
	if r.filter != nil {
		localVarQueryParams.Add("$filter", parameterToString(*r.filter, ""))
	}
	if r.count != nil {
		localVarQueryParams.Add("$count", parameterToString(*r.count, ""))
	}
	if r.orderby != nil {
		localVarQueryParams.Add("$orderby", parameterToString(*r.orderby, "csv"))
	}
	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUsersUpdateCalendarGroupsRequest struct {
	ctx _context.Context
	ApiService *UsersCalendarGroupApiService
	userId string
	calendarGroupId string
	microsoftGraphCalendarGroup *MicrosoftGraphCalendarGroup
}

// New navigation property values
func (r ApiUsersUpdateCalendarGroupsRequest) MicrosoftGraphCalendarGroup(microsoftGraphCalendarGroup MicrosoftGraphCalendarGroup) ApiUsersUpdateCalendarGroupsRequest {
	r.microsoftGraphCalendarGroup = &microsoftGraphCalendarGroup
	return r
}

func (r ApiUsersUpdateCalendarGroupsRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.UsersUpdateCalendarGroupsExecute(r)
}

/*
UsersUpdateCalendarGroups Update the navigation property calendarGroups in users

The user's calendar groups. Read-only. Nullable.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @param calendarGroupId key: id of calendarGroup
 @return ApiUsersUpdateCalendarGroupsRequest
*/
func (a *UsersCalendarGroupApiService) UsersUpdateCalendarGroups(ctx _context.Context, userId string, calendarGroupId string) ApiUsersUpdateCalendarGroupsRequest {
	return ApiUsersUpdateCalendarGroupsRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		calendarGroupId: calendarGroupId,
	}
}

// Execute executes the request
func (a *UsersCalendarGroupApiService) UsersUpdateCalendarGroupsExecute(r ApiUsersUpdateCalendarGroupsRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPatch
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersCalendarGroupApiService.UsersUpdateCalendarGroups")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/calendarGroups/{calendarGroup-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"calendarGroup-id"+"}", _neturl.PathEscape(parameterToString(r.calendarGroupId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphCalendarGroup == nil {
		return nil, reportError("microsoftGraphCalendarGroup is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphCalendarGroup
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}
